{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1MTc3ODcx", "number": 1328, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjowMjo0M1rOEgcVjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo0MDozOVrOFDkrww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAyNDU0MTU5OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/RabbitMQProducerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wNFQxNjowMjo0M1rOHNTmMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOVQwNzoyNDozMFrOHO6GRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNDYxMQ==", "bodyText": "Is context required in exit spans? I can't get the producer's instrumentation to work.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r483714611", "createdAt": "2020-09-04T16:02:43Z", "author": {"login": "hectorespert"}, "path": "apm-agent-plugins/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/RabbitMQProducerInstrumentation.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import com.rabbitmq.client.AMQP;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public class RabbitMQProducerInstrumentation extends RabbitMQBaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"basicPublish\")\n+            .and(takesArguments(6));\n+    }\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public Class<?> getAdviceClass() {\n+        return RabbitProducerAdvice.class;\n+    }\n+\n+    public static class RabbitProducerAdvice {\n+\n+        private RabbitProducerAdvice() {}\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @Nullable\n+        public static Object onBasicPublish(@Advice.Argument(0) final String exchange/*, @Advice.Argument(value = 4, readOnly = false) @Nullable AMQP.BasicProperties basicProperties*/) {\n+            if (!tracer.isRunning() || tracer.getActive() == null) {\n+                return null;\n+            }\n+\n+            final AbstractSpan<?> activeSpan = tracer.getActive();\n+            if (activeSpan == null) {\n+                return null;\n+            }\n+\n+            Span exitSpan = activeSpan.createExitSpan();\n+            if (null == exitSpan) {\n+                return null;\n+            }\n+\n+            exitSpan.withType(\"messaging\").withSubtype(\"rabbitmq\")\n+                .withAction(\"send\")\n+                .withName(\"RabbitMQ message sent to \")\n+                .appendToName(exchange);\n+\n+            // TODO: Propagate trace context\n+            //final TextHeaderSetter<HashMap<String, Object>> textHeaderSetter = new RabbitMQTextHeaderSetter();\n+            //basicProperties = propagateTraceContext(exitSpan, basicProperties, textHeaderSetter);\n+\n+            /*\n+            TODO: Transaction context\n+            exitSpan.getContext().getMessage().withQueue(exchange);\n+            exitSpan.getContext().getDestination().getService().withType(\"messaging\").withName(\"rabbitmq\")\n+                .getResource().append(\"rabbitmq/\").append(exchange);*/", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a2637c20ae73bd193d498f7a03910aa809e13d06"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDA1NTk4NQ==", "bodyText": "Without looking too much into the implementation, what do you mean you can't get it to work? What's not working?\n\nIf you use log_level=DEBUG, can you see whether the instrumentation is applied? You should see a Method match for instrumentation RabbitMQProducerInstrumentation indicating that the matchers found the method it was looking for\nCan you make sure the producer method is invoked when you expect it to be invoked in the test? If so, you can add a System.out and make sure the advice code runs when it is called as well.\nCan you see whether the trace context headers are added to the message? If not, it may be read-only at this point\nTry to print out the message headers on the receiver advice", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r484055985", "createdAt": "2020-09-06T11:10:50Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/RabbitMQProducerInstrumentation.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import com.rabbitmq.client.AMQP;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public class RabbitMQProducerInstrumentation extends RabbitMQBaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"basicPublish\")\n+            .and(takesArguments(6));\n+    }\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public Class<?> getAdviceClass() {\n+        return RabbitProducerAdvice.class;\n+    }\n+\n+    public static class RabbitProducerAdvice {\n+\n+        private RabbitProducerAdvice() {}\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @Nullable\n+        public static Object onBasicPublish(@Advice.Argument(0) final String exchange/*, @Advice.Argument(value = 4, readOnly = false) @Nullable AMQP.BasicProperties basicProperties*/) {\n+            if (!tracer.isRunning() || tracer.getActive() == null) {\n+                return null;\n+            }\n+\n+            final AbstractSpan<?> activeSpan = tracer.getActive();\n+            if (activeSpan == null) {\n+                return null;\n+            }\n+\n+            Span exitSpan = activeSpan.createExitSpan();\n+            if (null == exitSpan) {\n+                return null;\n+            }\n+\n+            exitSpan.withType(\"messaging\").withSubtype(\"rabbitmq\")\n+                .withAction(\"send\")\n+                .withName(\"RabbitMQ message sent to \")\n+                .appendToName(exchange);\n+\n+            // TODO: Propagate trace context\n+            //final TextHeaderSetter<HashMap<String, Object>> textHeaderSetter = new RabbitMQTextHeaderSetter();\n+            //basicProperties = propagateTraceContext(exitSpan, basicProperties, textHeaderSetter);\n+\n+            /*\n+            TODO: Transaction context\n+            exitSpan.getContext().getMessage().withQueue(exchange);\n+            exitSpan.getContext().getDestination().getService().withType(\"messaging\").withName(\"rabbitmq\")\n+                .getResource().append(\"rabbitmq/\").append(exchange);*/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNDYxMQ=="}, "originalCommit": {"oid": "a2637c20ae73bd193d498f7a03910aa809e13d06"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM2NjY4MQ==", "bodyText": "I've updated the RabbitMQProducerInstrumentationTest test to check if the trace context headers are added to the message. They are added but the test is failling in the recycling validation.\njava.lang.RuntimeException: Condition not fulfilled within 1000 ms\nExpected :false\nActual   :true\n<Click to see difference>\n\n\n\tat co.elastic.apm.agent.MockReporter.awaitUntilAsserted(MockReporter.java:423)\n\tat co.elastic.apm.agent.MockReporter.awaitUntilAsserted(MockReporter.java:401)\n\tat co.elastic.apm.agent.MockReporter.assertRecycledAfterDecrementingReferences(MockReporter.java:372)\n\tat co.elastic.apm.agent.AbstractInstrumentationTest.cleanUp(AbstractInstrumentationTest.java:91)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)\n\tat java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)\n\tat java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)\n\tat java.base/java.lang.reflect.Method.invoke(Method.java:566)\n\tat org.junit.runners.model.FrameworkMethod$1.runReflectiveCall(FrameworkMethod.java:59)\n\tat org.junit.internal.runners.model.ReflectiveCallable.run(ReflectiveCallable.java:12)\n\tat org.junit.runners.model.FrameworkMethod.invokeExplosively(FrameworkMethod.java:56)\n\tat org.junit.internal.runners.statements.RunAfters.invokeMethod(RunAfters.java:46)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:33)\n\tat org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\n\tat org.junit.runners.BlockJUnit4ClassRunner$1.evaluate(BlockJUnit4ClassRunner.java:100)\n\tat org.junit.runners.ParentRunner.runLeaf(ParentRunner.java:366)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:103)\n\tat org.junit.runners.BlockJUnit4ClassRunner.runChild(BlockJUnit4ClassRunner.java:63)\n\tat org.junit.runners.ParentRunner$4.run(ParentRunner.java:331)\n\tat org.junit.runners.ParentRunner$1.schedule(ParentRunner.java:79)\n\tat org.junit.runners.ParentRunner.runChildren(ParentRunner.java:329)\n\tat org.junit.runners.ParentRunner.access$100(ParentRunner.java:66)\n\tat org.junit.runners.ParentRunner$2.evaluate(ParentRunner.java:293)\n\tat org.junit.internal.runners.statements.RunBefores.evaluate(RunBefores.java:26)\n\tat org.junit.internal.runners.statements.RunAfters.evaluate(RunAfters.java:27)\n\tat org.junit.runners.ParentRunner$3.evaluate(ParentRunner.java:306)\n\tat org.junit.runners.ParentRunner.run(ParentRunner.java:413)\n\tat org.junit.runner.JUnitCore.run(JUnitCore.java:137)\n\tat com.intellij.junit4.JUnit4IdeaTestRunner.startRunnerWithArgs(JUnit4IdeaTestRunner.java:69)\n\tat com.intellij.rt.junit.IdeaTestRunner$Repeater.startRunnerWithArgs(IdeaTestRunner.java:33)\n\tat com.intellij.rt.junit.JUnitStarter.prepareStreamsAndStart(JUnitStarter.java:220)\n\tat com.intellij.rt.junit.JUnitStarter.main(JUnitStarter.java:53)\nCaused by: org.opentest4j.AssertionFailedError: [should not have any reference left, but has 2 : 'Rabbit-Test Transaction' 00-d7055f0e479e136460efa24fbccdfd1f-23255d7121bbf626-01 (23ee2ccf)] \nExpecting:\n <true>\nto be equal to:\n <false>\nbut was not.\n\tat jdk.internal.reflect.GeneratedConstructorAccessor18.newInstance(Unknown Source)\n\tat java.base/jdk.internal.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:45)\n\tat co.elastic.apm.agent.MockReporter.lambda$assertRecycledAfterDecrementingReferences$8(MockReporter.java:384)\n\tat java.base/java.util.ArrayList.forEach(ArrayList.java:1541)\n\tat java.base/java.util.Collections$SynchronizedCollection.forEach(Collections.java:2067)\n\tat java.base/java.util.Collections$UnmodifiableCollection.forEach(Collections.java:1085)\n\tat co.elastic.apm.agent.MockReporter.lambda$assertRecycledAfterDecrementingReferences$9(MockReporter.java:381)\n\tat co.elastic.apm.agent.MockReporter.awaitUntilAsserted(MockReporter.java:415)\n\t... 31 more", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r485366681", "createdAt": "2020-09-09T06:26:18Z", "author": {"login": "hectorespert"}, "path": "apm-agent-plugins/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/RabbitMQProducerInstrumentation.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import com.rabbitmq.client.AMQP;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public class RabbitMQProducerInstrumentation extends RabbitMQBaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"basicPublish\")\n+            .and(takesArguments(6));\n+    }\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public Class<?> getAdviceClass() {\n+        return RabbitProducerAdvice.class;\n+    }\n+\n+    public static class RabbitProducerAdvice {\n+\n+        private RabbitProducerAdvice() {}\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @Nullable\n+        public static Object onBasicPublish(@Advice.Argument(0) final String exchange/*, @Advice.Argument(value = 4, readOnly = false) @Nullable AMQP.BasicProperties basicProperties*/) {\n+            if (!tracer.isRunning() || tracer.getActive() == null) {\n+                return null;\n+            }\n+\n+            final AbstractSpan<?> activeSpan = tracer.getActive();\n+            if (activeSpan == null) {\n+                return null;\n+            }\n+\n+            Span exitSpan = activeSpan.createExitSpan();\n+            if (null == exitSpan) {\n+                return null;\n+            }\n+\n+            exitSpan.withType(\"messaging\").withSubtype(\"rabbitmq\")\n+                .withAction(\"send\")\n+                .withName(\"RabbitMQ message sent to \")\n+                .appendToName(exchange);\n+\n+            // TODO: Propagate trace context\n+            //final TextHeaderSetter<HashMap<String, Object>> textHeaderSetter = new RabbitMQTextHeaderSetter();\n+            //basicProperties = propagateTraceContext(exitSpan, basicProperties, textHeaderSetter);\n+\n+            /*\n+            TODO: Transaction context\n+            exitSpan.getContext().getMessage().withQueue(exchange);\n+            exitSpan.getContext().getDestination().getService().withType(\"messaging\").withName(\"rabbitmq\")\n+                .getResource().append(\"rabbitmq/\").append(exchange);*/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNDYxMQ=="}, "originalCommit": {"oid": "a2637c20ae73bd193d498f7a03910aa809e13d06"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM4Mjc1MQ==", "bodyText": "That could be because you did not call span.end() in RabbitProducerAdvice#afterBasicPublish()", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r485382751", "createdAt": "2020-09-09T07:01:33Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/RabbitMQProducerInstrumentation.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import com.rabbitmq.client.AMQP;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public class RabbitMQProducerInstrumentation extends RabbitMQBaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"basicPublish\")\n+            .and(takesArguments(6));\n+    }\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public Class<?> getAdviceClass() {\n+        return RabbitProducerAdvice.class;\n+    }\n+\n+    public static class RabbitProducerAdvice {\n+\n+        private RabbitProducerAdvice() {}\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @Nullable\n+        public static Object onBasicPublish(@Advice.Argument(0) final String exchange/*, @Advice.Argument(value = 4, readOnly = false) @Nullable AMQP.BasicProperties basicProperties*/) {\n+            if (!tracer.isRunning() || tracer.getActive() == null) {\n+                return null;\n+            }\n+\n+            final AbstractSpan<?> activeSpan = tracer.getActive();\n+            if (activeSpan == null) {\n+                return null;\n+            }\n+\n+            Span exitSpan = activeSpan.createExitSpan();\n+            if (null == exitSpan) {\n+                return null;\n+            }\n+\n+            exitSpan.withType(\"messaging\").withSubtype(\"rabbitmq\")\n+                .withAction(\"send\")\n+                .withName(\"RabbitMQ message sent to \")\n+                .appendToName(exchange);\n+\n+            // TODO: Propagate trace context\n+            //final TextHeaderSetter<HashMap<String, Object>> textHeaderSetter = new RabbitMQTextHeaderSetter();\n+            //basicProperties = propagateTraceContext(exitSpan, basicProperties, textHeaderSetter);\n+\n+            /*\n+            TODO: Transaction context\n+            exitSpan.getContext().getMessage().withQueue(exchange);\n+            exitSpan.getContext().getDestination().getService().withType(\"messaging\").withName(\"rabbitmq\")\n+                .getResource().append(\"rabbitmq/\").append(exchange);*/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNDYxMQ=="}, "originalCommit": {"oid": "a2637c20ae73bd193d498f7a03910aa809e13d06"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTM5Mzk5MQ==", "bodyText": "Yes, seems that it is the error \ud83e\udd26\nThank you for your patience", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r485393991", "createdAt": "2020-09-09T07:24:30Z", "author": {"login": "hectorespert"}, "path": "apm-agent-plugins/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/RabbitMQProducerInstrumentation.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import com.rabbitmq.client.AMQP;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.*;\n+\n+public class RabbitMQProducerInstrumentation extends RabbitMQBaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"basicPublish\")\n+            .and(takesArguments(6));\n+    }\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    @Override\n+    public Class<?> getAdviceClass() {\n+        return RabbitProducerAdvice.class;\n+    }\n+\n+    public static class RabbitProducerAdvice {\n+\n+        private RabbitProducerAdvice() {}\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @Nullable\n+        public static Object onBasicPublish(@Advice.Argument(0) final String exchange/*, @Advice.Argument(value = 4, readOnly = false) @Nullable AMQP.BasicProperties basicProperties*/) {\n+            if (!tracer.isRunning() || tracer.getActive() == null) {\n+                return null;\n+            }\n+\n+            final AbstractSpan<?> activeSpan = tracer.getActive();\n+            if (activeSpan == null) {\n+                return null;\n+            }\n+\n+            Span exitSpan = activeSpan.createExitSpan();\n+            if (null == exitSpan) {\n+                return null;\n+            }\n+\n+            exitSpan.withType(\"messaging\").withSubtype(\"rabbitmq\")\n+                .withAction(\"send\")\n+                .withName(\"RabbitMQ message sent to \")\n+                .appendToName(exchange);\n+\n+            // TODO: Propagate trace context\n+            //final TextHeaderSetter<HashMap<String, Object>> textHeaderSetter = new RabbitMQTextHeaderSetter();\n+            //basicProperties = propagateTraceContext(exitSpan, basicProperties, textHeaderSetter);\n+\n+            /*\n+            TODO: Transaction context\n+            exitSpan.getContext().getMessage().withQueue(exchange);\n+            exitSpan.getContext().getDestination().getService().withType(\"messaging\").withName(\"rabbitmq\")\n+                .getResource().append(\"rabbitmq/\").append(exchange);*/", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzcxNDYxMQ=="}, "originalCommit": {"oid": "a2637c20ae73bd193d498f7a03910aa809e13d06"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEwNDYwNjQzOnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/MockReporter.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0yOFQxMzoyNTo1NlrOHY9lxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwOTowODozM1rOHbBVgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNjk2NQ==", "bodyText": "What functionality is impacted by that? Will RabbitMQ be visible as part of the service map?\nWhat's preventing the capturing of the address? Maybe summarize the problems in a follow-up issue.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r495936965", "createdAt": "2020-09-28T13:25:56Z", "author": {"login": "felixbarny"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/MockReporter.java", "diffHunk": "@@ -92,7 +92,7 @@\n         when(apmServerClient.isAtLeast(any())).thenReturn(true);\n         dslJsonSerializer = new DslJsonSerializer(mock(StacktraceConfiguration.class), apmServerClient);\n         SPAN_TYPES_WITHOUT_ADDRESS = Set.of(\"jms\");\n-        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"));\n+        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"), \"rabbitmq\", Set.of(\"send\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4ODU4NQ==", "bodyText": "What functionality is impacted by that? Will RabbitMQ be visible as part of the service map?\n\nFor my side, I don't know if any feature is affected. I used the same solution that use the kafka plugin.\n\nWhat's preventing the capturing of the address? Maybe summarize the problems in a follow-up issue.\n\nThere isn't any attribute in the instrumented methods that allows obtain the address directly. I don't know if it can be obtained using other methods.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r497588585", "createdAt": "2020-09-30T15:10:15Z", "author": {"login": "hectorespert"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/MockReporter.java", "diffHunk": "@@ -92,7 +92,7 @@\n         when(apmServerClient.isAtLeast(any())).thenReturn(true);\n         dslJsonSerializer = new DslJsonSerializer(mock(StacktraceConfiguration.class), apmServerClient);\n         SPAN_TYPES_WITHOUT_ADDRESS = Set.of(\"jms\");\n-        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"));\n+        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"), \"rabbitmq\", Set.of(\"send\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNjk2NQ=="}, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjkwMQ==", "bodyText": "What functionality is impacted by that? Will RabbitMQ be visible as part of the service map?\n\nThe address is not required for the service map, only for the SIEM integration.\n\nThere isn't any attribute in the instrumented methods that allows obtain the address directly. I don't know if it can be obtained using other methods.\n\nIf you know the address when the channel is created, you can store it in a map (channel object ---> address) and when the method is called, get it through the @Advice.This reference in the instrumented method.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r498036901", "createdAt": "2020-10-01T07:27:34Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/MockReporter.java", "diffHunk": "@@ -92,7 +92,7 @@\n         when(apmServerClient.isAtLeast(any())).thenReturn(true);\n         dslJsonSerializer = new DslJsonSerializer(mock(StacktraceConfiguration.class), apmServerClient);\n         SPAN_TYPES_WITHOUT_ADDRESS = Set.of(\"jms\");\n-        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"));\n+        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"), \"rabbitmq\", Set.of(\"send\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNjk2NQ=="}, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0MTI1Nw==", "bodyText": "I see. Maybe one day I'll remember. Thanks for explaining again \ud83d\ude09\nSo I would say it's not too critical at the moment.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r498041257", "createdAt": "2020-10-01T07:35:58Z", "author": {"login": "felixbarny"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/MockReporter.java", "diffHunk": "@@ -92,7 +92,7 @@\n         when(apmServerClient.isAtLeast(any())).thenReturn(true);\n         dslJsonSerializer = new DslJsonSerializer(mock(StacktraceConfiguration.class), apmServerClient);\n         SPAN_TYPES_WITHOUT_ADDRESS = Set.of(\"jms\");\n-        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"));\n+        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"), \"rabbitmq\", Set.of(\"send\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNjk2NQ=="}, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA5NTQ5MA==", "bodyText": "There isn't even a need to use a map in this case as we can use Channel.getConnection(), I've implemented that in the t commit.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r498095490", "createdAt": "2020-10-01T09:08:33Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/test/java/co/elastic/apm/agent/MockReporter.java", "diffHunk": "@@ -92,7 +92,7 @@\n         when(apmServerClient.isAtLeast(any())).thenReturn(true);\n         dslJsonSerializer = new DslJsonSerializer(mock(StacktraceConfiguration.class), apmServerClient);\n         SPAN_TYPES_WITHOUT_ADDRESS = Set.of(\"jms\");\n-        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"));\n+        SPAN_ACTIONS_WITHOUT_ADDRESS = Map.of(\"kafka\", Set.of(\"poll\"), \"rabbitmq\", Set.of(\"send\"));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTkzNjk2NQ=="}, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNzkyMDg3OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wMVQwNzoyNTo1NFrOHa9tSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMFQxNToxMTo0N1rOHwhOOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjA0Mg==", "bodyText": "What does that means? How come we don't look for specific types?", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r498036042", "createdAt": "2020-10-01T07:25:54Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Consumer;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // Instrumentation applied at runtime, thus no need to check type", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA0Mjk1Mw==", "bodyText": "It's because only known types explicitly get instrumented via DynamicTransformer. See ConnectionInstrumentation.\nAlso note that the service descriptor META-INF/services/co.elastic.apm.agent.sdk.ElasticApmInstrumentation does not contain ChannelInstrumentation.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r498042953", "createdAt": "2020-10-01T07:39:17Z", "author": {"login": "felixbarny"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Consumer;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // Instrumentation applied at runtime, thus no need to check type", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjA0Mg=="}, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA2OTg4Mg==", "bodyText": "We could probably create a dedicated subclass for those \"instrumentations applied at runtime\", that would probably make things a bit more obvious instead of repeating this comment.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r498069882", "createdAt": "2020-10-01T08:26:22Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Consumer;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // Instrumentation applied at runtime, thus no need to check type", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjA0Mg=="}, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzE0NzIwOQ==", "bodyText": "I understand why Consumer instrumentation is dynamic, but why does the Channel instrumentation needs to be dynamic? Isn't there a close number of implementations (all containing the String Channel)?", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r517147209", "createdAt": "2020-11-04T07:42:16Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Consumer;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // Instrumentation applied at runtime, thus no need to check type", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjA0Mg=="}, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDYzODAwOA==", "bodyText": "has been covered in the last commit.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r520638008", "createdAt": "2020-11-10T15:11:47Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,180 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.TextHeaderSetter;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Consumer;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // Instrumentation applied at runtime, thus no need to check type", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODAzNjA0Mg=="}, "originalCommit": {"oid": "24a800d9ef5b50b1f9100a4bcd5b09d18be871b1"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzEzNjAzMjM5OnYy", "diffSide": "RIGHT", "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wN1QwODo0Mjo1N1rOHdo1gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNVQwMzo1Mzo1MFrOHhv2IA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgzOTgxMA==", "bodyText": "without this, it works only with advice that is directly within the instrumentation class, and not delegated to it's own class.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r500839810", "createdAt": "2020-10-07T08:42:57Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -683,10 +683,10 @@ public static void ensureInstrumented(Class<?> classToInstrument, Collection<Cla\n                         .with(FailSafeDeclaredMethodsCompiler.INSTANCE);\n                     AgentBuilder agentBuilder = getAgentBuilder(byteBuddy, config, logger, AgentBuilder.DescriptionStrategy.Default.HYBRID, false);\n                     for (Class<? extends ElasticApmInstrumentation> instrumentationClass : instrumentationClasses) {\n+                        ElasticApmInstrumentation apmInstrumentation = instantiate(instrumentationClass);\n                         pluginClassLoaderByAdviceClass.put(\n-                            instrumentationClass.getName(),\n+                            apmInstrumentation.getAdviceClass().getName(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e60eb00f115b810009d6d0a93ca95beaeb8a9b6"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTE0ODk2MA==", "bodyText": "Can we do this caching based on advice class names only, instead of instrumentation classes and their instantiation here? I mean that ensureInstrumented will be done directly on advice class names", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r505148960", "createdAt": "2020-10-15T03:53:50Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-core/src/main/java/co/elastic/apm/agent/bci/ElasticApmAgent.java", "diffHunk": "@@ -683,10 +683,10 @@ public static void ensureInstrumented(Class<?> classToInstrument, Collection<Cla\n                         .with(FailSafeDeclaredMethodsCompiler.INSTANCE);\n                     AgentBuilder agentBuilder = getAgentBuilder(byteBuddy, config, logger, AgentBuilder.DescriptionStrategy.Default.HYBRID, false);\n                     for (Class<? extends ElasticApmInstrumentation> instrumentationClass : instrumentationClasses) {\n+                        ElasticApmInstrumentation apmInstrumentation = instantiate(instrumentationClass);\n                         pluginClassLoaderByAdviceClass.put(\n-                            instrumentationClass.getName(),\n+                            apmInstrumentation.getAdviceClass().getName(),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDgzOTgxMA=="}, "originalCommit": {"oid": "9e60eb00f115b810009d6d0a93ca95beaeb8a9b6"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzODIxOTIyOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNDowNDo1MFrOHswMgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNDowNDo1MFrOHswMgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4OTAyNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void contextPropagationWithProperties() throws IOException, InterruptedException {\n          \n          \n            \n                public void testContextPropagationWithProperties() throws IOException, InterruptedException {", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r516689025", "createdAt": "2020-11-03T14:04:50Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.Envelope;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ChannelInstrumentationTest extends RabbitMQTest {\n+\n+    @Test\n+    public void contextPropagationWithProperties() throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94188302f9e0e399e4c88979f78dbb51f41bbec9"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzODIyMTE4OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentationTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNDowNToxNlrOHswNow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNDowNToxNlrOHswNow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY4OTMxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void contextPropagationWithoutProperties() throws IOException, InterruptedException {\n          \n          \n            \n                public void testContextPropagationWithoutProperties() throws IOException, InterruptedException {", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r516689315", "createdAt": "2020-11-03T14:05:16Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.Envelope;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ChannelInstrumentationTest extends RabbitMQTest {\n+\n+    @Test\n+    public void contextPropagationWithProperties() throws IOException, InterruptedException {\n+        testContextPropagation(emptyProperties());\n+    }\n+\n+    @Test\n+    public void contextPropagationWithoutProperties() throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94188302f9e0e399e4c88979f78dbb51f41bbec9"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIzODI2MjQxOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentationTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNDoxMzozOFrOHswmEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wM1QxNDoxMzozOFrOHswmEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjY5NTU3MQ==", "bodyText": "Verify transaction details - type, name.\nVerify context propagation:\n\nboth transactions should have the same trace ID\nreceiver side transaction's parent should be the send span\n\nYou can reuse the utility methods for such checks.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r516695571", "createdAt": "2020-11-03T14:13:38Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentationTest.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.Envelope;\n+import org.junit.jupiter.api.Test;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class ChannelInstrumentationTest extends RabbitMQTest {\n+\n+    @Test\n+    public void contextPropagationWithProperties() throws IOException, InterruptedException {\n+        testContextPropagation(emptyProperties());\n+    }\n+\n+    @Test\n+    public void contextPropagationWithoutProperties() throws IOException, InterruptedException {\n+        testContextPropagation(null);\n+    }\n+\n+    private void testContextPropagation(@Nullable AMQP.BasicProperties properties) throws IOException, InterruptedException {\n+\n+        Connection connection = createConnection();\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel);\n+        String queue = createQueue(channel, exchange);\n+\n+        CountDownLatch messageReceived = new CountDownLatch(1);\n+\n+        channel.basicConsume(queue, new DefaultConsumer(channel) {\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+                Map<String, Object> headers = properties.getHeaders();\n+                assertThat(headers).containsKey(\"elastic-apm-traceparent\");\n+                assertThat(headers).containsKey(\"traceparent\");\n+                messageReceived.countDown();\n+            }\n+        });\n+\n+        getTracer().startRootTransaction(getClass().getClassLoader())\n+            .withName(\"Rabbit-Test Transaction\")\n+            .withType(\"request\")\n+            .withResult(\"success\")\n+            .activate();\n+\n+        channel.basicPublish(exchange, ROUTING_KEY, properties, MSG);\n+\n+        getTracer().currentTransaction().deactivate().end();\n+\n+        messageReceived.await(1, TimeUnit.SECONDS);\n+\n+        // 2 transactions, 1 span expected\n+        getReporter().awaitTransactionCount(2);\n+        getReporter().awaitSpanCount(1);\n+\n+        Span span = getReporter().getSpans().get(0);\n+        checkSpan(span, exchange);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94188302f9e0e399e4c88979f78dbb51f41bbec9"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTc0MDQ3OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConnectionInstrumentation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDoxMTowOFrOHtRYeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDoxODowNVrOHzgEgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIzMjc2MQ==", "bodyText": "I am not sure I understand why this is required instead of simple type matching for Channel implementations.\nHowever, since we already have this instrumentation, let's use it to store channel destination metadata (address and port) and use it to fill the send span destination details in the basicPublish instrumentation. Looks like very little is left in order to collect this info.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r517232761", "createdAt": "2020-11-04T10:11:08Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConnectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.nameEndsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+/**\n+ * Instruments\n+ * <ul>\n+ *     <li>{@link Connection#createChannel}</li>\n+ * </ul>\n+ */\n+public class ConnectionInstrumentation extends BaseInstrumentation {\n+\n+    private static final Collection<Class<? extends ElasticApmInstrumentation>> CHANNEL_INSTRUMENTATIONS =\n+        Arrays.<Class<? extends ElasticApmInstrumentation>>asList(\n+            ChannelInstrumentation.BasicPublish.class,\n+            ChannelInstrumentation.BasicConsume.class\n+        );\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        // this fast heuristic works for all implementations within driver\n+        return nameEndsWith(\"Connection\")\n+            .and(nameStartsWith(\"com.rabbitmq.client.impl\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // fine to use super type matching thanks to restricting with pre-filter\n+        return hasSuperType(named(\"com.rabbitmq.client.Connection\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"createChannel\");\n+    }\n+\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n+    public static void onExit(@Nullable @Advice.Thrown Throwable thrown,\n+                              @Advice.Return @Nullable Channel channel) {\n+\n+        if (thrown != null || channel == null) {\n+            return;\n+        }\n+        DynamicTransformer.Accessor.get().ensureInstrumented(channel.getClass(), CHANNEL_INSTRUMENTATIONS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94188302f9e0e399e4c88979f78dbb51f41bbec9"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2NDg2NA==", "bodyText": "Or what you did - use com.rabbitmq.client.Channel#getConnection, much simpler \ud83d\ude04", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523764864", "createdAt": "2020-11-15T14:18:05Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConnectionInstrumentation.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.nameEndsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+\n+/**\n+ * Instruments\n+ * <ul>\n+ *     <li>{@link Connection#createChannel}</li>\n+ * </ul>\n+ */\n+public class ConnectionInstrumentation extends BaseInstrumentation {\n+\n+    private static final Collection<Class<? extends ElasticApmInstrumentation>> CHANNEL_INSTRUMENTATIONS =\n+        Arrays.<Class<? extends ElasticApmInstrumentation>>asList(\n+            ChannelInstrumentation.BasicPublish.class,\n+            ChannelInstrumentation.BasicConsume.class\n+        );\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        // this fast heuristic works for all implementations within driver\n+        return nameEndsWith(\"Connection\")\n+            .and(nameStartsWith(\"com.rabbitmq.client.impl\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // fine to use super type matching thanks to restricting with pre-filter\n+        return hasSuperType(named(\"com.rabbitmq.client.Connection\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"createChannel\");\n+    }\n+\n+    @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n+    public static void onExit(@Nullable @Advice.Thrown Throwable thrown,\n+                              @Advice.Return @Nullable Channel channel) {\n+\n+        if (thrown != null || channel == null) {\n+            return;\n+        }\n+        DynamicTransformer.Accessor.get().ensureInstrumented(channel.getClass(), CHANNEL_INSTRUMENTATIONS);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIzMjc2MQ=="}, "originalCommit": {"oid": "94188302f9e0e399e4c88979f78dbb51f41bbec9"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI0MTc2MzU4OnYy", "diffSide": "RIGHT", "path": "docs/supported-technologies.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDoxNjo1N1rOHtRmVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNFQxMDoxNjo1N1rOHtRmVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzIzNjMwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When the producer send message within a traced transaction, a span will be created and a transaction is created when consumes a message.\n          \n          \n            \n            When the producer sends a message within a traced transaction, a send span will be created and the transaction resulting from the message consumption will be correlated to the same trace. When a message is consumed, a transaction is created, regardless if the send action is traced.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r517236308", "createdAt": "2020-11-04T10:16:57Z", "author": {"login": "eyalkoren"}, "path": "docs/supported-technologies.asciidoc", "diffHunk": "@@ -348,6 +348,12 @@ If both producer and consumer are traced, then distributed tracing is supported,\n side will be a part of the same trace containing the producer side as well. Kafka streams are not traced.\n |1.13.0\n \n+|RabbitMQ\n+|3.x - 5.x\n+|The agent captures RabbitMQ Message sends and consumes.  \n+When the producer send message within a traced transaction, a span will be created and a transaction is created when consumes a message.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94188302f9e0e399e4c88979f78dbb51f41bbec9"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4Mzc3OTU2OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMzowMzozNVrOHzfhpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMzowMzozNVrOHzfhpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc1NTk0MA==", "bodyText": "I actually prefer the former. This name doesn't indicate it is RabbitMQ.\nMy comment about aligning names was more about the fact that the exchange/queue is missing from the receive transaction. In Kafka, I relied on the class name to indicate it is Kafka, so suggesting:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .withName(\"Channel#basicPublish to \")\n          \n          \n            \n                            .withName(\"RabbitMQ message SEND to \")", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523755940", "createdAt": "2020-11-15T13:03:35Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) final String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            final AbstractSpan<?> activeSpan = tracer.getActive();\n+            if (activeSpan == null || isExchangeIgnored(exchange)) {\n+                return null;\n+            }\n+\n+            Span exitSpan = activeSpan.createExitSpan();\n+            if (null == exitSpan) {\n+                return null;\n+            }\n+\n+            exitSpan.withType(\"messaging\")\n+                .withSubtype(\"rabbitmq\")\n+                .withAction(\"send\")\n+                .withName(\"Channel#basicPublish to \")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555c9396fa89cded0b0e195feb71f8ad382d8edc"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4Mzc4MDU0OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConsumerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMzowNDoyM1rOHzfiHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMzowNDoyM1rOHzfiHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc1NjA2MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .withName(\"Consumer#handleDelivery from \").appendToName(exchange);\n          \n          \n            \n                            .withName(\"RabbitMQ message RECEIVE from \").appendToName(exchange);", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523756061", "createdAt": "2020-11-15T13:04:23Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConsumerInstrumentation.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderGetter;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+\n+/**\n+ * Instruments\n+ * <ul>\n+ *     <li>{@link com.rabbitmq.client.Consumer#handleDelivery}</li>\n+ * </ul>\n+ */\n+public class ConsumerInstrumentation extends BaseInstrumentation {\n+\n+    public ConsumerInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // Instrumentation applied at runtime, thus no need to check type\n+        return any();\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"handleDelivery\");\n+    }\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader())\n+            .and(classLoaderCanLoadClass(\"com.rabbitmq.client.Consumer\"));\n+    }\n+\n+    @Override\n+    public Class<?> getAdviceClass() {\n+        return RabbitConsumerAdvice.class;\n+    }\n+\n+    public static class RabbitConsumerAdvice {\n+\n+        private RabbitConsumerAdvice() {\n+        }\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onHandleDelivery(@Advice.Origin Class<?> originClazz,\n+                                              @Advice.This Consumer consumer,\n+                                              @Advice.Argument(value = 1) @Nullable Envelope envelope,\n+                                              @Advice.Argument(value = 2) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning() || tracer.currentTransaction() != null) {\n+                return null;\n+            }\n+\n+            String exchange = envelope != null ? envelope.getExchange() : null;\n+            if (exchange == null) {\n+                exchange = \"unknown\";\n+            }\n+\n+            if (isExchangeIgnored(exchange)) {\n+                return null;\n+            }\n+\n+            Transaction transaction = tracer.startChildTransaction(properties, RabbitMQTextHeaderGetter.INSTANCE, originClazz.getClassLoader());\n+            if (transaction == null) {\n+                return null;\n+            }\n+\n+            transaction.withType(\"messaging\")\n+                .withName(\"Consumer#handleDelivery from \").appendToName(exchange);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555c9396fa89cded0b0e195feb71f8ad382d8edc"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4Mzc4NTYzOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConsumerInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMzoxMDoxOVrOHzfklg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMzoxMDoxOVrOHzfklg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc1NjY5NA==", "bodyText": "If tracer.currentTransaction() != null, we should probably capture this as a message receive span.\nFor example, when there is an active transaction that is synching on an async read from queue (like in send-reply scenario).\nRequires a test as well. JMS and Kafka rely on send-reply scenarios for that.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523756694", "createdAt": "2020-11-15T13:10:19Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConsumerInstrumentation.java", "diffHunk": "@@ -0,0 +1,130 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderGetter;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+\n+/**\n+ * Instruments\n+ * <ul>\n+ *     <li>{@link com.rabbitmq.client.Consumer#handleDelivery}</li>\n+ * </ul>\n+ */\n+public class ConsumerInstrumentation extends BaseInstrumentation {\n+\n+    public ConsumerInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // Instrumentation applied at runtime, thus no need to check type\n+        return any();\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"handleDelivery\");\n+    }\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader())\n+            .and(classLoaderCanLoadClass(\"com.rabbitmq.client.Consumer\"));\n+    }\n+\n+    @Override\n+    public Class<?> getAdviceClass() {\n+        return RabbitConsumerAdvice.class;\n+    }\n+\n+    public static class RabbitConsumerAdvice {\n+\n+        private RabbitConsumerAdvice() {\n+        }\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onHandleDelivery(@Advice.Origin Class<?> originClazz,\n+                                              @Advice.This Consumer consumer,\n+                                              @Advice.Argument(value = 1) @Nullable Envelope envelope,\n+                                              @Advice.Argument(value = 2) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning() || tracer.currentTransaction() != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555c9396fa89cded0b0e195feb71f8ad382d8edc"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzgxMjMyOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/BaseInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMzozODoxNVrOHzfxvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxMzozODoxNVrOHzfxvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2MDA2MA==", "bodyText": "null value for a key may also be a valuable info:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                Object value = entry.getValue();\n          \n          \n            \n                                if (value != null) {\n          \n          \n            \n                                    // headers aren't stored as String instances here\n          \n          \n            \n                                    message.addHeader(entry.getKey(), value.toString());\n          \n          \n            \n                                }\n          \n          \n            \n                                // headers aren't stored as String instances here\n          \n          \n            \n                                message.addHeader(entry.getKey(), String.valueOf(entry.getValue()));", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523760060", "createdAt": "2020-11-15T13:38:15Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/BaseInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.bci.TracerAwareInstrumentation;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.MessagingConfiguration;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Message;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n+import com.rabbitmq.client.AMQP;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+\n+public abstract class BaseInstrumentation extends TracerAwareInstrumentation {\n+\n+    private static CoreConfiguration coreConfiguration;\n+    private static MessagingConfiguration messagingConfiguration;\n+\n+    public BaseInstrumentation(ElasticApmTracer tracer) {\n+        coreConfiguration = tracer.getConfig(CoreConfiguration.class);\n+        messagingConfiguration = tracer.getConfig(MessagingConfiguration.class);\n+    }\n+\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Collections.singletonList(\"rabbitmq\");\n+    }\n+\n+    protected static boolean isExchangeIgnored(String exchange) {\n+        return WildcardMatcher.isAnyMatch(messagingConfiguration.getIgnoreMessageQueues(), exchange);\n+    }\n+\n+    private static boolean isCaptureHeaders() {\n+        return coreConfiguration.isCaptureHeaders();\n+    }\n+\n+    private static boolean captureHeaderKey(String key) {\n+        return !WildcardMatcher.isAnyMatch(coreConfiguration.getSanitizeFieldNames(), key);\n+    }\n+\n+    protected static void captureMessage(String exchange, @Nullable AMQP.BasicProperties properties, AbstractSpan<?> context) {\n+        Map<String, Object> headers = null;\n+        long age = -1L;\n+        if (null != properties) {\n+\n+            Date timestamp = properties.getTimestamp();\n+            if (timestamp != null) {\n+                long now = System.currentTimeMillis();\n+                long time = timestamp.getTime();\n+                age = time <= now ? (now - time) : 0;\n+            }\n+\n+            headers = properties.getHeaders();\n+        }\n+\n+        Message message = context.getContext().getMessage()\n+            .withQueue(exchange)\n+            .withAge(age);\n+\n+        if (isCaptureHeaders() && headers != null && headers.size() > 0) {\n+            for (Map.Entry<String, Object> entry : headers.entrySet()) {\n+                if (captureHeaderKey(entry.getKey())) {\n+                    Object value = entry.getValue();\n+                    if (value != null) {\n+                        // headers aren't stored as String instances here\n+                        message.addHeader(entry.getKey(), value.toString());\n+                    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555c9396fa89cded0b0e195feb71f8ad382d8edc"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzgzNTI4OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/RabbitMQTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDowMTozMlrOHzf81Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDowMTozMlrOHzf81Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2MjkwMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void contextPropagationWithProperties() throws IOException, InterruptedException {\n          \n          \n            \n                void contextPropagationWithoutProperties() throws IOException, InterruptedException {", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523762901", "createdAt": "2020-11-15T14:01:32Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/RabbitMQTest.java", "diffHunk": "@@ -0,0 +1,405 @@\n+package co.elastic.apm.agent.rabbitmq;\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+\n+import co.elastic.apm.agent.AbstractInstrumentationTest;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.MessagingConfiguration;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.context.Headers;\n+import co.elastic.apm.agent.impl.context.Message;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.ConnectionFactory;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.Envelope;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.containers.RabbitMQContainer;\n+import org.testcontainers.containers.output.Slf4jLogConsumer;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests the whole RabbitMQ instrumentation as a whole, both for transactions and spans\n+ */\n+public class RabbitMQTest extends AbstractInstrumentationTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RabbitMQTest.class);\n+\n+    private static final String IMAGE = \"rabbitmq:3.7-management-alpine\";\n+    private static final RabbitMQContainer container = new RabbitMQContainer(IMAGE);\n+\n+    private static final String ROUTING_KEY = \"test.key\";\n+\n+    private static final byte[] MSG = \"Testing APM!\".getBytes();\n+\n+    @Nullable\n+    private static ConnectionFactory factory;\n+\n+    @Nullable\n+    private Connection connection;\n+\n+    @BeforeAll\n+    static void before() {\n+        container.withLogConsumer(new Slf4jLogConsumer(logger))\n+            .start();\n+\n+        factory = new ConnectionFactory();\n+\n+        factory.setHost(container.getHost());\n+        factory.setPort(container.getAmqpPort());\n+        factory.setUsername(container.getAdminUsername());\n+        factory.setPassword(container.getAdminPassword());\n+    }\n+\n+    @AfterEach\n+    void cleanup() throws IOException {\n+        if (connection != null) {\n+            if (connection.isOpen()) {\n+                logger.info(\"silently closing open connection id = {}\", connection);\n+                connection.close();\n+            }\n+        }\n+    }\n+\n+    @AfterAll\n+    static void after() {\n+        container.close();\n+    }\n+\n+\n+    @Test\n+    void contextPropagationWithProperties() throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555c9396fa89cded0b0e195feb71f8ad382d8edc"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4MzgzNTQ1OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/RabbitMQTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDowMTo0M1rOHzf86Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDowMTo0M1rOHzf86Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2MjkyMQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                void contextPropagationWithoutProperties() throws IOException, InterruptedException {\n          \n          \n            \n                void contextPropagationWithProperties() throws IOException, InterruptedException {", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523762921", "createdAt": "2020-11-15T14:01:43Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/RabbitMQTest.java", "diffHunk": "@@ -0,0 +1,405 @@\n+package co.elastic.apm.agent.rabbitmq;\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+\n+import co.elastic.apm.agent.AbstractInstrumentationTest;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.MessagingConfiguration;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.context.Headers;\n+import co.elastic.apm.agent.impl.context.Message;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.ConnectionFactory;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.Envelope;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.AfterEach;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.containers.RabbitMQContainer;\n+import org.testcontainers.containers.output.Slf4jLogConsumer;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests the whole RabbitMQ instrumentation as a whole, both for transactions and spans\n+ */\n+public class RabbitMQTest extends AbstractInstrumentationTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RabbitMQTest.class);\n+\n+    private static final String IMAGE = \"rabbitmq:3.7-management-alpine\";\n+    private static final RabbitMQContainer container = new RabbitMQContainer(IMAGE);\n+\n+    private static final String ROUTING_KEY = \"test.key\";\n+\n+    private static final byte[] MSG = \"Testing APM!\".getBytes();\n+\n+    @Nullable\n+    private static ConnectionFactory factory;\n+\n+    @Nullable\n+    private Connection connection;\n+\n+    @BeforeAll\n+    static void before() {\n+        container.withLogConsumer(new Slf4jLogConsumer(logger))\n+            .start();\n+\n+        factory = new ConnectionFactory();\n+\n+        factory.setHost(container.getHost());\n+        factory.setPort(container.getAmqpPort());\n+        factory.setUsername(container.getAdminUsername());\n+        factory.setPassword(container.getAdminPassword());\n+    }\n+\n+    @AfterEach\n+    void cleanup() throws IOException {\n+        if (connection != null) {\n+            if (connection.isOpen()) {\n+                logger.info(\"silently closing open connection id = {}\", connection);\n+                connection.close();\n+            }\n+        }\n+    }\n+\n+    @AfterAll\n+    static void after() {\n+        container.close();\n+    }\n+\n+\n+    @Test\n+    void contextPropagationWithProperties() throws IOException, InterruptedException {\n+        performTest(null);\n+    }\n+\n+    @Test\n+    void contextPropagationWithoutProperties() throws IOException, InterruptedException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555c9396fa89cded0b0e195feb71f8ad382d8edc"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4Mzg2NzY0OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/BaseInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDozNTowNFrOHzgMqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDozNTowNFrOHzgMqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2Njk1NA==", "bodyText": "We should only capture headers on message read when starting a transaction.\nCapturing outgoing headers in not aligned with other messaging plugins nor HTTP client plugins.\n(Similarly if we decide to capture body in the future).", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523766954", "createdAt": "2020-11-15T14:35:04Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/BaseInstrumentation.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.bci.TracerAwareInstrumentation;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.MessagingConfiguration;\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Message;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n+import com.rabbitmq.client.AMQP;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Map;\n+\n+public abstract class BaseInstrumentation extends TracerAwareInstrumentation {\n+\n+    private static CoreConfiguration coreConfiguration;\n+    private static MessagingConfiguration messagingConfiguration;\n+\n+    public BaseInstrumentation(ElasticApmTracer tracer) {\n+        coreConfiguration = tracer.getConfig(CoreConfiguration.class);\n+        messagingConfiguration = tracer.getConfig(MessagingConfiguration.class);\n+    }\n+\n+    @Override\n+    public Collection<String> getInstrumentationGroupNames() {\n+        return Collections.singletonList(\"rabbitmq\");\n+    }\n+\n+    protected static boolean isExchangeIgnored(String exchange) {\n+        return WildcardMatcher.isAnyMatch(messagingConfiguration.getIgnoreMessageQueues(), exchange);\n+    }\n+\n+    private static boolean isCaptureHeaders() {\n+        return coreConfiguration.isCaptureHeaders();\n+    }\n+\n+    private static boolean captureHeaderKey(String key) {\n+        return !WildcardMatcher.isAnyMatch(coreConfiguration.getSanitizeFieldNames(), key);\n+    }\n+\n+    protected static void captureMessage(String exchange, @Nullable AMQP.BasicProperties properties, AbstractSpan<?> context) {\n+        Map<String, Object> headers = null;\n+        long age = -1L;\n+        if (null != properties) {\n+\n+            Date timestamp = properties.getTimestamp();\n+            if (timestamp != null) {\n+                long now = System.currentTimeMillis();\n+                long time = timestamp.getTime();\n+                age = time <= now ? (now - time) : 0;\n+            }\n+\n+            headers = properties.getHeaders();\n+        }\n+\n+        Message message = context.getContext().getMessage()\n+            .withQueue(exchange)\n+            .withAge(age);\n+\n+        if (isCaptureHeaders() && headers != null && headers.size() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555c9396fa89cded0b0e195feb71f8ad382d8edc"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI4Mzg5MTAzOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-test-5/pom.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDo1NjowOFrOHzgX-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNVQxNDo1NjowOFrOHzgX-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzc2OTg1MQ==", "bodyText": "Same version as the common module. This module seems redundant.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r523769851", "createdAt": "2020-11-15T14:56:08Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-test-5/pom.xml", "diffHunk": "@@ -0,0 +1,60 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\">\n+    <modelVersion>4.0.0</modelVersion>\n+\n+    <parent>\n+        <artifactId>apm-rabbitmq</artifactId>\n+        <groupId>co.elastic.apm</groupId>\n+        <version>1.19.1-SNAPSHOT</version>\n+    </parent>\n+\n+    <artifactId>apm-rabbitmq-test-5</artifactId>\n+    <name>${project.groupId}:${project.artifactId}</name>\n+\n+    <properties>\n+        <version.rabbitmq>5.9.0</version.rabbitmq>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "555c9396fa89cded0b0e195feb71f8ad382d8edc"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MTgyMjEyOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConsumerInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzoxMDoxNFrOIDIe5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxMzoxMDoxNFrOIDIe5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDE1NTYyMg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .withName(\"RabbitMQ message RECEIVE from \").appendToName(normalizeExchangeName(exchange));\n          \n          \n            \n                            .withName(\"RabbitMQ RECEIVE from \").appendToName(normalizeExchangeName(exchange));\n          \n      \n    \n    \n  \n\nMy fault \ud83d\ude0a , but now that we have a spec...", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540155622", "createdAt": "2020-12-10T13:10:14Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ConsumerInstrumentation.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Message;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderGetter;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.any;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+\n+/**\n+ * Instruments\n+ * <ul>\n+ *     <li>{@link com.rabbitmq.client.Consumer#handleDelivery}</li>\n+ * </ul>\n+ */\n+public class ConsumerInstrumentation extends BaseInstrumentation {\n+\n+    public ConsumerInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        // Instrumentation applied at runtime, thus no need to check type\n+        return any();\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+        return named(\"handleDelivery\");\n+    }\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader())\n+            .and(classLoaderCanLoadClass(\"com.rabbitmq.client.Consumer\"));\n+    }\n+\n+    @Override\n+    public Class<?> getAdviceClass() {\n+        return RabbitConsumerAdvice.class;\n+    }\n+\n+    public static class RabbitConsumerAdvice {\n+\n+        private RabbitConsumerAdvice() {\n+        }\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onHandleDelivery(@Advice.Origin Class<?> originClazz,\n+                                              @Advice.This Consumer consumer,\n+                                              @Advice.Argument(value = 1) @Nullable Envelope envelope,\n+                                              @Advice.Argument(value = 2) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            String exchange = envelope != null ? envelope.getExchange() : null;\n+\n+            if (null == exchange || isIgnored(exchange)) {\n+                return null;\n+            }\n+\n+            Transaction transaction = tracer.currentTransaction();\n+            if (transaction != null) {\n+                return null;\n+            }\n+\n+            transaction = tracer.startChildTransaction(properties, RabbitMQTextHeaderGetter.INSTANCE, originClazz.getClassLoader());\n+            if (transaction == null) {\n+                return null;\n+            }\n+\n+            transaction.withType(\"messaging\")\n+                .withName(\"RabbitMQ message RECEIVE from \").appendToName(normalizeExchangeName(exchange));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjYzMjkwOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTo0OToyOVrOIDQAqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTo0OToyOVrOIDQAqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3ODk1Mw==", "bodyText": "[minor] why not null for no exchange?", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540278953", "createdAt": "2020-12-10T15:49:29Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) @Nullable String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            Span exitSpan = createExitSpan(exchange);\n+            if (exitSpan == null) {\n+                // tracer disabled or ignored exchange\n+                return null;\n+            }\n+\n+            exitSpan.withAction(\"send\")\n+                .withName(\"RabbitMQ SEND to \").appendToName(normalizeExchangeName(exchange));\n+\n+            properties = propagateTraceContext(exitSpan, properties);\n+\n+            captureMessage(exchange, properties, exitSpan);\n+            captureDestination(exchange, channel, exitSpan);\n+\n+            return new Object[]{properties, exitSpan};\n+        }\n+\n+        private static AMQP.BasicProperties propagateTraceContext(Span exitSpan,\n+                                                                  @Nullable AMQP.BasicProperties originalBasicProperties) {\n+            AMQP.BasicProperties properties = originalBasicProperties;\n+            if (properties == null) {\n+                properties = new AMQP.BasicProperties();\n+            }\n+\n+            Map<String, Object> currentHeaders = properties.getHeaders();\n+            if (currentHeaders == null) {\n+                currentHeaders = new HashMap<>();\n+            }\n+\n+            HashMap<String, Object> headersWithContext = new HashMap<>(currentHeaders);\n+\n+            exitSpan.propagateTraceContext(headersWithContext, RabbitMQTextHeaderSetter.INSTANCE);\n+\n+            return properties.builder().headers(headersWithContext).build();\n+        }\n+\n+        @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class, inline = false)\n+        public static void afterBasicPublish(@Advice.Enter @Nullable Object[] enterArray,\n+                                             @Advice.Thrown @Nullable Throwable throwable) {\n+            if (enterArray != null && enterArray.length >= 2 && enterArray[1] != null) {\n+                Span span = (Span) enterArray[1];\n+                span.captureException(throwable)\n+                    .deactivate()\n+                    .end();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicGet}</li>\n+     * </ul>\n+     */\n+    public static class BasicGet extends ChannelInstrumentation {\n+\n+        public BasicGet(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicGet\")\n+                .and(takesArgument(0, String.class));\n+        }\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onEnter(@Advice.Argument(0) @Nullable String queue) {\n+\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            return createExitSpan(normalizeQueueName(queue));\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n+        public static void onExit(@Advice.This Channel channel,\n+                                  @Advice.Argument(0) String queue,\n+                                  @Advice.Enter @Nullable Object objSpan,\n+                                  @Advice.Return @Nullable GetResponse rv,\n+                                  @Advice.Thrown @Nullable Throwable thrown) {\n+\n+            if (!(objSpan instanceof Span)) {\n+                return;\n+            }\n+            Span span = (Span) objSpan;\n+\n+            if (isIgnored(queue)) {\n+                // allow to ignore on queue name when there is no answer\n+                span.requestDiscarding();\n+            }\n+\n+            span.withAction(\"poll\")\n+                .withName(\"RabbitMQ POLL from \").appendToName(normalizeQueueName(queue));\n+\n+            Envelope envelope = null;\n+            AMQP.BasicProperties properties = null;\n+\n+            if (rv != null) {\n+                envelope = rv.getEnvelope();\n+                properties = rv.getProps();\n+            }\n+\n+            String exchange = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 255}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjYzNDEwOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTo0OTo0M1rOIDQBYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNTo0OTo0M1rOIDQBYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI3OTEzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            }\n          \n          \n            \n                            }\n          \n          \n            \n                            exchange = envelope.getExchange();\n          \n      \n    \n    \n  \n\nYou never set the exchange on poll spans' destination.resource.\nFixing this does not cause any test failure, so it is not tested as well. I think it is because it is tested with empty exchange or ignore queues only. The test of polling within transaction should contain the exchange.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540279136", "createdAt": "2020-12-10T15:49:43Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) @Nullable String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            Span exitSpan = createExitSpan(exchange);\n+            if (exitSpan == null) {\n+                // tracer disabled or ignored exchange\n+                return null;\n+            }\n+\n+            exitSpan.withAction(\"send\")\n+                .withName(\"RabbitMQ SEND to \").appendToName(normalizeExchangeName(exchange));\n+\n+            properties = propagateTraceContext(exitSpan, properties);\n+\n+            captureMessage(exchange, properties, exitSpan);\n+            captureDestination(exchange, channel, exitSpan);\n+\n+            return new Object[]{properties, exitSpan};\n+        }\n+\n+        private static AMQP.BasicProperties propagateTraceContext(Span exitSpan,\n+                                                                  @Nullable AMQP.BasicProperties originalBasicProperties) {\n+            AMQP.BasicProperties properties = originalBasicProperties;\n+            if (properties == null) {\n+                properties = new AMQP.BasicProperties();\n+            }\n+\n+            Map<String, Object> currentHeaders = properties.getHeaders();\n+            if (currentHeaders == null) {\n+                currentHeaders = new HashMap<>();\n+            }\n+\n+            HashMap<String, Object> headersWithContext = new HashMap<>(currentHeaders);\n+\n+            exitSpan.propagateTraceContext(headersWithContext, RabbitMQTextHeaderSetter.INSTANCE);\n+\n+            return properties.builder().headers(headersWithContext).build();\n+        }\n+\n+        @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class, inline = false)\n+        public static void afterBasicPublish(@Advice.Enter @Nullable Object[] enterArray,\n+                                             @Advice.Thrown @Nullable Throwable throwable) {\n+            if (enterArray != null && enterArray.length >= 2 && enterArray[1] != null) {\n+                Span span = (Span) enterArray[1];\n+                span.captureException(throwable)\n+                    .deactivate()\n+                    .end();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicGet}</li>\n+     * </ul>\n+     */\n+    public static class BasicGet extends ChannelInstrumentation {\n+\n+        public BasicGet(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicGet\")\n+                .and(takesArgument(0, String.class));\n+        }\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onEnter(@Advice.Argument(0) @Nullable String queue) {\n+\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            return createExitSpan(normalizeQueueName(queue));\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n+        public static void onExit(@Advice.This Channel channel,\n+                                  @Advice.Argument(0) String queue,\n+                                  @Advice.Enter @Nullable Object objSpan,\n+                                  @Advice.Return @Nullable GetResponse rv,\n+                                  @Advice.Thrown @Nullable Throwable thrown) {\n+\n+            if (!(objSpan instanceof Span)) {\n+                return;\n+            }\n+            Span span = (Span) objSpan;\n+\n+            if (isIgnored(queue)) {\n+                // allow to ignore on queue name when there is no answer\n+                span.requestDiscarding();\n+            }\n+\n+            span.withAction(\"poll\")\n+                .withName(\"RabbitMQ POLL from \").appendToName(normalizeQueueName(queue));\n+\n+            Envelope envelope = null;\n+            AMQP.BasicProperties properties = null;\n+\n+            if (rv != null) {\n+                envelope = rv.getEnvelope();\n+                properties = rv.getProps();\n+            }\n+\n+            String exchange = \"\";\n+\n+            if (null != envelope) {\n+                // since exchange name is only known when receiving the message, we might have to discard it\n+                if (isIgnored(envelope.getExchange())) {\n+                    span.requestDiscarding();\n+                }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 261}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjY5MTk2OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/RabbitMQTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjowMDo1MFrOIDQkXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxMDozMDo1MFrOIGD7YA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4ODA5NA==", "bodyText": "Should contain the exchange in the resource name", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540288094", "createdAt": "2020-12-10T16:00:50Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/RabbitMQTest.java", "diffHunk": "@@ -0,0 +1,672 @@\n+package co.elastic.apm.agent.rabbitmq;\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+\n+import co.elastic.apm.agent.AbstractInstrumentationTest;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.MessagingConfiguration;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.context.Headers;\n+import co.elastic.apm.agent.impl.context.Message;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Id;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.ConnectionFactory;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.Envelope;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.containers.RabbitMQContainer;\n+import org.testcontainers.containers.output.Slf4jLogConsumer;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.BiConsumer;\n+import java.util.function.Supplier;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests the whole RabbitMQ instrumentation as a whole, both for transactions and spans\n+ */\n+public class RabbitMQTest extends AbstractInstrumentationTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RabbitMQTest.class);\n+\n+    private static final String IMAGE = \"rabbitmq:3.7-management-alpine\";\n+    private static final RabbitMQContainer container = new RabbitMQContainer(IMAGE);\n+\n+    private static final String ROUTING_KEY = \"test.key\";\n+\n+    private static final byte[] MSG = \"Testing APM!\".getBytes();\n+\n+    private static ConnectionFactory factory;\n+\n+    private static Connection connection;\n+\n+    @BeforeAll\n+    static void before() {\n+        container.withLogConsumer(new Slf4jLogConsumer(logger))\n+            .start();\n+\n+        factory = new ConnectionFactory();\n+\n+        factory.setHost(container.getHost());\n+        factory.setPort(container.getAmqpPort());\n+        factory.setUsername(container.getAdminUsername());\n+        factory.setPassword(container.getAdminPassword());\n+\n+        try {\n+            connection = factory.newConnection();\n+            Objects.requireNonNull(connection);\n+            logger.info(\"created connection id = {}\", connection);\n+        } catch (IOException | TimeoutException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+\n+    @AfterAll\n+    static void after() throws IOException {\n+        container.close();\n+\n+        if (connection.isOpen()) {\n+            logger.info(\"silently closing open connection id = {}\", connection);\n+            connection.close();\n+        }\n+    }\n+\n+\n+    @Test\n+    void contextPropagationWithoutProperties() throws IOException, InterruptedException {\n+        performTest(null);\n+    }\n+\n+    @Test\n+    void contextPropagationWithProperties() throws IOException, InterruptedException {\n+        performTest(emptyProperties());\n+    }\n+\n+    @Test\n+    void bodyCaptureNotSupported() throws IOException, InterruptedException {\n+        // body capture is not supported because at the RabbitMQ driver level\n+        // the message is provided as a byte array.\n+        CoreConfiguration config = AbstractInstrumentationTest.config.getConfig(CoreConfiguration.class);\n+        when(config.getCaptureBody()).thenReturn(CoreConfiguration.EventType.ALL);\n+\n+        performTest(\n+            emptyProperties(),\n+            false,\n+            randString(\"exchange\"),\n+            (mt, ms) -> {\n+\n+                checkMessageBodyNotCaptured(mt);\n+                checkMessageBodyNotCaptured(ms);\n+            });\n+    }\n+\n+    @Test\n+    void headersCaptureEnabledByDefault() throws IOException, InterruptedException {\n+        Map<String, String> headers = Map.of(\"message-header\", \"header value\");\n+        Map<String, String> headersWithNullValue = new HashMap<>(headers);\n+        headersWithNullValue.put(\"null-header\", null);\n+        testHeadersCapture(headersWithNullValue,\n+            Map.of(\n+                \"message-header\", \"header value\",\n+                \"null-header\", \"null\"),\n+            true);\n+    }\n+\n+    @Test\n+    void headersCaptureDisabled() throws IOException, InterruptedException {\n+        CoreConfiguration coreConfiguration = config.getConfig(CoreConfiguration.class);\n+        when(coreConfiguration.isCaptureHeaders()).thenReturn(false);\n+\n+        testHeadersCapture(Map.of(\"message-header\", \"header value\"), Map.of(), false);\n+    }\n+\n+    @Test\n+    void headersCaptureSanitize() throws IOException, InterruptedException {\n+        CoreConfiguration coreConfiguration = config.getConfig(CoreConfiguration.class);\n+        when(coreConfiguration.getSanitizeFieldNames()).thenReturn(List.of(WildcardMatcher.valueOf(\"secret*\")));\n+\n+        testHeadersCapture(\n+            Map.of(\n+                \"other-header\", \"other-value\",\n+                \"secret-token\", \"secret-value\"),\n+            Map.of(\n+                \"other-header\", \"other-value\"\n+            ), true);\n+    }\n+\n+    private void testHeadersCapture(Map<String, String> headersMap, Map<String, String> expectedHeaders, boolean expectTracingHeaders) throws IOException, InterruptedException {\n+        performTest(\n+            propertiesMap(headersMap),\n+            false,\n+            randString(\"exchange\"),\n+            (mt, ms) -> {\n+                assertThat(ms.getHeaders())\n+                    .describedAs(\"spans should not capture outgoing message headers\")\n+                    .isEmpty();\n+\n+                // only transaction should have headers\n+                checkHeaders(mt, expectedHeaders);\n+                checkDistributedTracingHeaders(mt, expectTracingHeaders);\n+            });\n+    }\n+\n+    @Test\n+    void ignoreExchangeName() throws IOException, InterruptedException {\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-*\")));\n+\n+        performTest(emptyProperties(), true, randString(\"ignored\"), (mt, ms) -> {\n+        });\n+    }\n+\n+    private void performTest(@Nullable AMQP.BasicProperties properties) throws IOException, InterruptedException {\n+        performTest(properties, false, randString(\"exchange\"), (mt, ms) -> {\n+        });\n+    }\n+\n+    private void performTest(@Nullable AMQP.BasicProperties properties,\n+                             boolean shouldIgnore,\n+                             String channelName,\n+                             BiConsumer<Message, Message> messageCheck) throws IOException, InterruptedException {\n+\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, channelName);\n+        String queue = createQueue(channel, exchange);\n+\n+        CountDownLatch messageReceived = new CountDownLatch(1);\n+\n+        channel.basicConsume(queue, new DefaultConsumer(channel) {\n+            // using an anonymous class to ensure class matching is properly applied\n+\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+                assertThat(properties).isNotNull();\n+                Map<String, Object> headers = properties.getHeaders();\n+\n+                if (shouldIgnore) {\n+                    assertThat(headers).doesNotContainKeys(DISTRIBUTED_TRACING_HEADERS);\n+                } else {\n+                    assertThat(headers).containsKeys(DISTRIBUTED_TRACING_HEADERS);\n+                }\n+\n+                messageReceived.countDown();\n+            }\n+        });\n+\n+        Transaction rootTransaction = startRootTransaction();\n+\n+        channel.basicPublish(exchange, ROUTING_KEY, properties, MSG);\n+\n+        endRootTransaction(rootTransaction);\n+\n+        messageReceived.await(1, TimeUnit.SECONDS);\n+\n+        if (shouldIgnore) {\n+            getReporter().awaitTransactionCount(1);\n+            assertThat(getReporter().getFirstTransaction())\n+                .describedAs(\"only the test root transaction is expected\")\n+                .isSameAs(rootTransaction);\n+\n+            getReporter()\n+                .awaitUntilAsserted(1_000, () -> assertThat(getReporter().getNumReportedTransactions())\n+                    .describedAs(\"no other transaction should be reported\")\n+                    .isEqualTo(1));\n+\n+            getReporter().assertNoSpan(1_000);\n+            return;\n+        }\n+\n+\n+        // 2 transactions, 1 span expected\n+        getReporter().awaitTransactionCount(2);\n+        getReporter().awaitSpanCount(1);\n+\n+        Transaction childTransaction = getNonRootTransaction(rootTransaction, getReporter().getTransactions());\n+\n+        checkTransaction(childTransaction, exchange);\n+\n+        Span span = getReporter().getSpans().get(0);\n+        checkSendSpan(span, exchange);\n+\n+        // span should be child of the first transaction\n+        checkParentChild(rootTransaction, span);\n+        // second transaction should be the child of span\n+        checkParentChild(span, childTransaction);\n+\n+        // common assertions on span & transaction message\n+        Message spanMessage = span.getContext().getMessage();\n+        Message transactionMessage = childTransaction.getContext().getMessage();\n+\n+\n+        // test-specific assertions on captured message\n+        messageCheck.accept(transactionMessage, spanMessage);\n+\n+    }\n+\n+    @Test\n+    void testPollingWithinTransaction() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        String queueName = randString(\"queue-\");\n+\n+        pollingTest(true, false, () -> declareAndBindQueue(queueName, exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.awaitSpanCount(1);\n+\n+        Span pollingSpan = reporter.getFirstSpan();\n+        checkPollSpan(pollingSpan, queueName);\n+    }\n+\n+    @Test\n+    void testPollingOutsideTransaction() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        pollingTest(false, false, () -> declareAndBindQueue(\"queue\", exchange, channel), exchange);\n+\n+        reporter.assertNoTransaction(100);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    @Test\n+    void testPollingIgnoreQueueName() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-qu*\")));\n+\n+        pollingTest(true, false, () -> declareAndBindQueue(\"ignored-queue\", exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    @Test\n+    void testPollingIgnoreExchangeName() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"ignored-exchange\");\n+\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-ex*\")));\n+\n+        pollingTest(true, true, () -> declareAndBindQueue(\"queue\", exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    private String declareAndBindQueue(String queue, String exchange, Channel channel) {\n+        try {\n+            channel.queueDeclare(queue, false, false, false, null);\n+            channel.queueBind(queue, exchange, ROUTING_KEY);\n+            return queue;\n+        } catch (IOException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void pollingTest(boolean withinTransaction, boolean withResult, Supplier<String> createQueue, String exchange) throws IOException {\n+        Channel channel = connection.createChannel();\n+\n+        String queue = createQueue.get();\n+\n+        if (withResult) {\n+            channel.basicPublish(exchange, ROUTING_KEY, emptyProperties(), MSG);\n+        }\n+\n+        Transaction rootTransaction = null;\n+        if (withinTransaction) {\n+            rootTransaction = startRootTransaction();\n+        }\n+\n+        channel.basicGet(queue, true);\n+\n+        if (withinTransaction) {\n+            endRootTransaction(rootTransaction);\n+        }\n+    }\n+\n+    @Test\n+    void testRpcCall() throws IOException, InterruptedException {\n+        // with an RPC call, the message consumer might be executed within the caller thread\n+        // as a result, if there is an active transaction we should create a span for the message processing\n+\n+        Channel channel = connection.createChannel();\n+\n+        // using an empty name for exchange allows to use the default exchange\n+        // which has the property to send message to any queue by name using routing key\n+        final String exchange = \"\";\n+\n+        channel.basicQos(1);\n+\n+        String rpcQueueName = randString(\"rpc_queue\");\n+        channel.queueDeclare(rpcQueueName, false, false, false, null);\n+        // because we use a random queue, we don't have to purge it\n+        // if it was persistent, any previous message should be discarded with a call to 'queuePurge'\n+\n+        // RPC server implementation\n+        String serverConsumerTag = channel.basicConsume(rpcQueueName, false, new DefaultConsumer(channel) {\n+\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+\n+                AMQP.BasicProperties replyProperties = new AMQP.BasicProperties\n+                    .Builder()\n+                    .correlationId(properties.getCorrelationId())\n+                    .build();\n+\n+                String reply = \"reply from RPC server: \" + new String(body);\n+                channel.basicPublish(exchange, properties.getReplyTo(), replyProperties, reply.getBytes());\n+                channel.basicAck(envelope.getDeliveryTag(), false);\n+            }\n+        });\n+\n+        final String correlationId = UUID.randomUUID().toString();\n+\n+        String replyQueueName = channel.queueDeclare().getQueue();\n+        AMQP.BasicProperties properties = new AMQP.BasicProperties\n+            .Builder()\n+            .correlationId(correlationId)\n+            .replyTo(replyQueueName)\n+            .build();\n+\n+\n+        Transaction rootTransaction = startRootTransaction();\n+\n+        channel.basicPublish(exchange, rpcQueueName, properties, MSG);\n+\n+        ArrayBlockingQueue<String> rpcResult = new ArrayBlockingQueue<>(1);\n+\n+        // here we could have used the DeliverCallback functional interface added in rabbitmq 5.x driver\n+        // however, internally it only delegates to a regular Consumer\n+        String clientConsumerTag = channel.basicConsume(replyQueueName, true, new DefaultConsumer(channel) {\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+                if (correlationId.equals(properties.getCorrelationId())) {\n+                    rpcResult.offer(new String(body));\n+                }\n+            }\n+        });\n+\n+        assertThat(rpcResult.take()).isEqualTo(\"reply from RPC server: Testing APM!\");\n+\n+        endRootTransaction(rootTransaction);\n+\n+        // we need to cancel consumers after usage\n+        channel.basicCancel(clientConsumerTag);\n+        channel.basicCancel(serverConsumerTag);\n+\n+\n+        // we should have captured the following:\n+        // 3 transactions:\n+        // - root transaction\n+        // - transaction for the server-side of the RPC call (processing request)\n+        // - transaction for the client-side of the RPC call (processing response)\n+        // 2 spans:\n+        // - span for sending the RPC request message in the root transaction\n+        // - span for sending the RPC response message in server-side processing\n+\n+        getReporter().awaitTransactionCount(3);\n+        getReporter().awaitSpanCount(2);\n+\n+        // start with the spans as we can identify them using the root transaction\n+        // parent/child relationships are used to find who is who as we don't have other fields like name\n+        // to distinguish them\n+\n+        Span clientRequestRpc = null;\n+        Span serverReplyRpc = null;\n+        for (Span s : getReporter().getSpans()) {\n+            Id spanParentId = s.getTraceContext().getParentId();\n+            if (rootTransaction.getTraceContext().getId().equals(spanParentId)) {\n+                // client request is child of root transaction\n+                assertThat(clientRequestRpc).isNull();\n+                clientRequestRpc = s;\n+            } else {\n+                assertThat(serverReplyRpc).isNull();\n+                serverReplyRpc = s;\n+            }\n+        }\n+        assertThat(clientRequestRpc).isNotNull();\n+        assertThat(serverReplyRpc).isNotNull();\n+\n+        Transaction serverSideRpc = null;\n+        Transaction clientSideRpc = null;\n+        for (Transaction t : getReporter().getTransactions()) {\n+            if (t != rootTransaction) {\n+                Id transactionParentId = t.getTraceContext().getParentId();\n+                if (clientRequestRpc.getTraceContext().getId().equals(transactionParentId)) {\n+                    assertThat(serverSideRpc).isNull();\n+                    serverSideRpc = t;\n+                } else {\n+                    assertThat(clientSideRpc).isNull();\n+                    clientSideRpc = t;\n+                }\n+            }\n+        }\n+        assertThat(serverSideRpc).isNotNull();\n+        assertThat(clientSideRpc).isNotNull();\n+\n+        checkSendSpan(clientRequestRpc, exchange);\n+        checkParentChild(rootTransaction, clientRequestRpc);\n+\n+        checkTransaction(serverSideRpc, exchange);\n+        assertThat(serverSideRpc.getNameAsString()).isEqualTo(\"RabbitMQ message RECEIVE from <default>\");\n+        checkParentChild(clientRequestRpc, serverSideRpc);\n+\n+        checkSendSpan(serverReplyRpc, exchange);\n+        checkParentChild(serverSideRpc, serverReplyRpc);\n+\n+        checkTransaction(clientSideRpc, exchange);\n+        checkParentChild(serverReplyRpc, clientSideRpc);\n+\n+    }\n+\n+    private void endRootTransaction(Transaction rootTransaction) {\n+        rootTransaction.deactivate().end();\n+    }\n+\n+    private Transaction startRootTransaction() {\n+        return getTracer().startRootTransaction(getClass().getClassLoader())\n+            .withName(\"Rabbit-Test Root Transaction\")\n+            .withType(\"request\")\n+            .withResult(\"success\")\n+            .activate();\n+    }\n+\n+    private static Transaction getNonRootTransaction(Transaction rootTransaction, List<Transaction> transactions) {\n+        Transaction childTransaction = null;\n+        for (Transaction t : transactions) {\n+            if (t != rootTransaction) {\n+                assertThat(childTransaction).isNull();\n+                childTransaction = t;\n+            }\n+        }\n+        assertThat(childTransaction).isNotNull();\n+        return childTransaction;\n+    }\n+\n+    private String createQueue(Channel channel, String exchange) throws IOException {\n+        String queueName = channel.queueDeclare().getQueue();\n+        channel.queueBind(queueName, exchange, ROUTING_KEY);\n+        return queueName;\n+    }\n+\n+    private String createExchange(Channel channel, String exchangeName) throws IOException {\n+        channel.exchangeDeclare(exchangeName, \"direct\", false);\n+        return exchangeName;\n+    }\n+\n+    private static String randString(String prefix) {\n+        return String.format(\"%s-%08x\", prefix, System.currentTimeMillis());\n+    }\n+\n+    private AMQP.BasicProperties propertiesMap(Map<String, String> map) {\n+        // doing a dumb copy to convert Map<String,String> to Map<String,Object>\n+        Map<String, Object> objectMap = new HashMap<>();\n+        for (Map.Entry<String, String> entry : map.entrySet()) {\n+            objectMap.put(entry.getKey(), entry.getValue());\n+        }\n+        return new AMQP.BasicProperties.Builder()\n+            .headers(objectMap)\n+            .build();\n+    }\n+\n+    private AMQP.BasicProperties emptyProperties() {\n+        return new AMQP.BasicProperties.Builder().headers(new HashMap<>()).build();\n+    }\n+\n+    private static void checkParentChild(AbstractSpan<?> parent, AbstractSpan<?> child) {\n+        assertThat(child.getTraceContext().getParentId())\n+            .describedAs(\"child (%s) should be a child of (%s)\", child, parent)\n+            .isEqualTo(parent.getTraceContext().getId());\n+\n+        assertThat(child.getTraceContext().getTraceId())\n+            .describedAs(\"child (%s) should have same trace ID as parent (%s)\", child, parent)\n+            .isEqualTo(parent.getTraceContext().getTraceId());\n+    }\n+\n+    private static void checkTransaction(Transaction transaction, String exchange) {\n+        assertThat(transaction.getType()).isEqualTo(\"messaging\");\n+        assertThat(transaction.getNameAsString())\n+            .isEqualTo(\"RabbitMQ message RECEIVE from %s\", exchange.isEmpty() ? \"<default>\" : exchange);\n+        assertThat(transaction.getFrameworkName()).isEqualTo(\"RabbitMQ\");\n+\n+        checkMessage(transaction.getContext().getMessage(), exchange);\n+    }\n+\n+    private static void checkMessage(Message message, String queueName) {\n+        assertThat(message.getQueueName()).isEqualTo(queueName);\n+\n+        // RabbitMQ does not provide timestamp by default\n+        assertThat(message.getAge()).isLessThan(0);\n+    }\n+\n+\n+    private static void checkMessageBodyNotCaptured(Message message) {\n+        assertThat(message.getBodyForRead()).describedAs(\"body capture isn't supported\").isNull();\n+    }\n+\n+    private static final String[] DISTRIBUTED_TRACING_HEADERS = {\n+        \"elastic-apm-traceparent\",\n+        \"tracestate\",\n+        \"traceparent\"\n+    };\n+\n+    private static void checkDistributedTracingHeaders(Message message, boolean expectTracingHeaders) {\n+        HashMap<String, String> headersMap = getHeadersMap(message);\n+        if (expectTracingHeaders) {\n+            assertThat(headersMap)\n+                .describedAs(\"distributed tracing headers should be captured\")\n+                .containsKeys(DISTRIBUTED_TRACING_HEADERS);\n+        } else {\n+            assertThat(headersMap)\n+                .describedAs(\"distributed tracing headers aren't expected\")\n+                .doesNotContainKeys(DISTRIBUTED_TRACING_HEADERS);\n+        }\n+    }\n+\n+    private static void checkHeaders(Message message, Map<String, String> expectedHeaders) {\n+        HashMap<String, String> headersMap = getHeadersMap(message);\n+        for (String key : DISTRIBUTED_TRACING_HEADERS) {\n+            headersMap.remove(key);\n+        }\n+        assertThat(headersMap)\n+            .describedAs(\"should contain entries of %s\", expectedHeaders)\n+            .containsAllEntriesOf(expectedHeaders);\n+    }\n+\n+    private static HashMap<String, String> getHeadersMap(Message message) {\n+        Headers headers = message.getHeaders();\n+        HashMap<String, String> headersMap = new HashMap<>();\n+        headers.forEach(h -> headersMap.put(h.getKey(), h.getValue().toString()));\n+        return headersMap;\n+    }\n+\n+    private static void checkSendSpan(Span span, String exchange) {\n+        String expectedResource = exchange.isEmpty() ? \"rabbitmq\" : String.format(\"rabbitmq/%s\", exchange);\n+        checkSpanCommon(span,\n+            \"send\",\n+            String.format(\"RabbitMQ SEND to %s\", exchange.isEmpty() ? \"<default>\" : exchange),\n+            exchange,\n+            expectedResource);\n+\n+    }\n+\n+    private static void checkPollSpan(Span span, String queue){\n+        checkSpanCommon(span,\n+            \"poll\",\n+            String.format(\"RabbitMQ POLL from %s\", queue),\n+            queue,\n+            \"rabbitmq\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 648}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyMTE5NA==", "bodyText": "For polling, the exchange name is only known when there is a message, thus that would use two different names for the cases with/without a response, whereas it's the same polling operation. Also, I found it was more consistent with the \"use the queue name when available, exchange name otherwise\".", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r543221194", "createdAt": "2020-12-15T10:23:12Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/RabbitMQTest.java", "diffHunk": "@@ -0,0 +1,672 @@\n+package co.elastic.apm.agent.rabbitmq;\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+\n+import co.elastic.apm.agent.AbstractInstrumentationTest;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.MessagingConfiguration;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.context.Headers;\n+import co.elastic.apm.agent.impl.context.Message;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Id;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.ConnectionFactory;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.Envelope;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.containers.RabbitMQContainer;\n+import org.testcontainers.containers.output.Slf4jLogConsumer;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.BiConsumer;\n+import java.util.function.Supplier;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests the whole RabbitMQ instrumentation as a whole, both for transactions and spans\n+ */\n+public class RabbitMQTest extends AbstractInstrumentationTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RabbitMQTest.class);\n+\n+    private static final String IMAGE = \"rabbitmq:3.7-management-alpine\";\n+    private static final RabbitMQContainer container = new RabbitMQContainer(IMAGE);\n+\n+    private static final String ROUTING_KEY = \"test.key\";\n+\n+    private static final byte[] MSG = \"Testing APM!\".getBytes();\n+\n+    private static ConnectionFactory factory;\n+\n+    private static Connection connection;\n+\n+    @BeforeAll\n+    static void before() {\n+        container.withLogConsumer(new Slf4jLogConsumer(logger))\n+            .start();\n+\n+        factory = new ConnectionFactory();\n+\n+        factory.setHost(container.getHost());\n+        factory.setPort(container.getAmqpPort());\n+        factory.setUsername(container.getAdminUsername());\n+        factory.setPassword(container.getAdminPassword());\n+\n+        try {\n+            connection = factory.newConnection();\n+            Objects.requireNonNull(connection);\n+            logger.info(\"created connection id = {}\", connection);\n+        } catch (IOException | TimeoutException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+\n+    @AfterAll\n+    static void after() throws IOException {\n+        container.close();\n+\n+        if (connection.isOpen()) {\n+            logger.info(\"silently closing open connection id = {}\", connection);\n+            connection.close();\n+        }\n+    }\n+\n+\n+    @Test\n+    void contextPropagationWithoutProperties() throws IOException, InterruptedException {\n+        performTest(null);\n+    }\n+\n+    @Test\n+    void contextPropagationWithProperties() throws IOException, InterruptedException {\n+        performTest(emptyProperties());\n+    }\n+\n+    @Test\n+    void bodyCaptureNotSupported() throws IOException, InterruptedException {\n+        // body capture is not supported because at the RabbitMQ driver level\n+        // the message is provided as a byte array.\n+        CoreConfiguration config = AbstractInstrumentationTest.config.getConfig(CoreConfiguration.class);\n+        when(config.getCaptureBody()).thenReturn(CoreConfiguration.EventType.ALL);\n+\n+        performTest(\n+            emptyProperties(),\n+            false,\n+            randString(\"exchange\"),\n+            (mt, ms) -> {\n+\n+                checkMessageBodyNotCaptured(mt);\n+                checkMessageBodyNotCaptured(ms);\n+            });\n+    }\n+\n+    @Test\n+    void headersCaptureEnabledByDefault() throws IOException, InterruptedException {\n+        Map<String, String> headers = Map.of(\"message-header\", \"header value\");\n+        Map<String, String> headersWithNullValue = new HashMap<>(headers);\n+        headersWithNullValue.put(\"null-header\", null);\n+        testHeadersCapture(headersWithNullValue,\n+            Map.of(\n+                \"message-header\", \"header value\",\n+                \"null-header\", \"null\"),\n+            true);\n+    }\n+\n+    @Test\n+    void headersCaptureDisabled() throws IOException, InterruptedException {\n+        CoreConfiguration coreConfiguration = config.getConfig(CoreConfiguration.class);\n+        when(coreConfiguration.isCaptureHeaders()).thenReturn(false);\n+\n+        testHeadersCapture(Map.of(\"message-header\", \"header value\"), Map.of(), false);\n+    }\n+\n+    @Test\n+    void headersCaptureSanitize() throws IOException, InterruptedException {\n+        CoreConfiguration coreConfiguration = config.getConfig(CoreConfiguration.class);\n+        when(coreConfiguration.getSanitizeFieldNames()).thenReturn(List.of(WildcardMatcher.valueOf(\"secret*\")));\n+\n+        testHeadersCapture(\n+            Map.of(\n+                \"other-header\", \"other-value\",\n+                \"secret-token\", \"secret-value\"),\n+            Map.of(\n+                \"other-header\", \"other-value\"\n+            ), true);\n+    }\n+\n+    private void testHeadersCapture(Map<String, String> headersMap, Map<String, String> expectedHeaders, boolean expectTracingHeaders) throws IOException, InterruptedException {\n+        performTest(\n+            propertiesMap(headersMap),\n+            false,\n+            randString(\"exchange\"),\n+            (mt, ms) -> {\n+                assertThat(ms.getHeaders())\n+                    .describedAs(\"spans should not capture outgoing message headers\")\n+                    .isEmpty();\n+\n+                // only transaction should have headers\n+                checkHeaders(mt, expectedHeaders);\n+                checkDistributedTracingHeaders(mt, expectTracingHeaders);\n+            });\n+    }\n+\n+    @Test\n+    void ignoreExchangeName() throws IOException, InterruptedException {\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-*\")));\n+\n+        performTest(emptyProperties(), true, randString(\"ignored\"), (mt, ms) -> {\n+        });\n+    }\n+\n+    private void performTest(@Nullable AMQP.BasicProperties properties) throws IOException, InterruptedException {\n+        performTest(properties, false, randString(\"exchange\"), (mt, ms) -> {\n+        });\n+    }\n+\n+    private void performTest(@Nullable AMQP.BasicProperties properties,\n+                             boolean shouldIgnore,\n+                             String channelName,\n+                             BiConsumer<Message, Message> messageCheck) throws IOException, InterruptedException {\n+\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, channelName);\n+        String queue = createQueue(channel, exchange);\n+\n+        CountDownLatch messageReceived = new CountDownLatch(1);\n+\n+        channel.basicConsume(queue, new DefaultConsumer(channel) {\n+            // using an anonymous class to ensure class matching is properly applied\n+\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+                assertThat(properties).isNotNull();\n+                Map<String, Object> headers = properties.getHeaders();\n+\n+                if (shouldIgnore) {\n+                    assertThat(headers).doesNotContainKeys(DISTRIBUTED_TRACING_HEADERS);\n+                } else {\n+                    assertThat(headers).containsKeys(DISTRIBUTED_TRACING_HEADERS);\n+                }\n+\n+                messageReceived.countDown();\n+            }\n+        });\n+\n+        Transaction rootTransaction = startRootTransaction();\n+\n+        channel.basicPublish(exchange, ROUTING_KEY, properties, MSG);\n+\n+        endRootTransaction(rootTransaction);\n+\n+        messageReceived.await(1, TimeUnit.SECONDS);\n+\n+        if (shouldIgnore) {\n+            getReporter().awaitTransactionCount(1);\n+            assertThat(getReporter().getFirstTransaction())\n+                .describedAs(\"only the test root transaction is expected\")\n+                .isSameAs(rootTransaction);\n+\n+            getReporter()\n+                .awaitUntilAsserted(1_000, () -> assertThat(getReporter().getNumReportedTransactions())\n+                    .describedAs(\"no other transaction should be reported\")\n+                    .isEqualTo(1));\n+\n+            getReporter().assertNoSpan(1_000);\n+            return;\n+        }\n+\n+\n+        // 2 transactions, 1 span expected\n+        getReporter().awaitTransactionCount(2);\n+        getReporter().awaitSpanCount(1);\n+\n+        Transaction childTransaction = getNonRootTransaction(rootTransaction, getReporter().getTransactions());\n+\n+        checkTransaction(childTransaction, exchange);\n+\n+        Span span = getReporter().getSpans().get(0);\n+        checkSendSpan(span, exchange);\n+\n+        // span should be child of the first transaction\n+        checkParentChild(rootTransaction, span);\n+        // second transaction should be the child of span\n+        checkParentChild(span, childTransaction);\n+\n+        // common assertions on span & transaction message\n+        Message spanMessage = span.getContext().getMessage();\n+        Message transactionMessage = childTransaction.getContext().getMessage();\n+\n+\n+        // test-specific assertions on captured message\n+        messageCheck.accept(transactionMessage, spanMessage);\n+\n+    }\n+\n+    @Test\n+    void testPollingWithinTransaction() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        String queueName = randString(\"queue-\");\n+\n+        pollingTest(true, false, () -> declareAndBindQueue(queueName, exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.awaitSpanCount(1);\n+\n+        Span pollingSpan = reporter.getFirstSpan();\n+        checkPollSpan(pollingSpan, queueName);\n+    }\n+\n+    @Test\n+    void testPollingOutsideTransaction() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        pollingTest(false, false, () -> declareAndBindQueue(\"queue\", exchange, channel), exchange);\n+\n+        reporter.assertNoTransaction(100);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    @Test\n+    void testPollingIgnoreQueueName() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-qu*\")));\n+\n+        pollingTest(true, false, () -> declareAndBindQueue(\"ignored-queue\", exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    @Test\n+    void testPollingIgnoreExchangeName() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"ignored-exchange\");\n+\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-ex*\")));\n+\n+        pollingTest(true, true, () -> declareAndBindQueue(\"queue\", exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    private String declareAndBindQueue(String queue, String exchange, Channel channel) {\n+        try {\n+            channel.queueDeclare(queue, false, false, false, null);\n+            channel.queueBind(queue, exchange, ROUTING_KEY);\n+            return queue;\n+        } catch (IOException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void pollingTest(boolean withinTransaction, boolean withResult, Supplier<String> createQueue, String exchange) throws IOException {\n+        Channel channel = connection.createChannel();\n+\n+        String queue = createQueue.get();\n+\n+        if (withResult) {\n+            channel.basicPublish(exchange, ROUTING_KEY, emptyProperties(), MSG);\n+        }\n+\n+        Transaction rootTransaction = null;\n+        if (withinTransaction) {\n+            rootTransaction = startRootTransaction();\n+        }\n+\n+        channel.basicGet(queue, true);\n+\n+        if (withinTransaction) {\n+            endRootTransaction(rootTransaction);\n+        }\n+    }\n+\n+    @Test\n+    void testRpcCall() throws IOException, InterruptedException {\n+        // with an RPC call, the message consumer might be executed within the caller thread\n+        // as a result, if there is an active transaction we should create a span for the message processing\n+\n+        Channel channel = connection.createChannel();\n+\n+        // using an empty name for exchange allows to use the default exchange\n+        // which has the property to send message to any queue by name using routing key\n+        final String exchange = \"\";\n+\n+        channel.basicQos(1);\n+\n+        String rpcQueueName = randString(\"rpc_queue\");\n+        channel.queueDeclare(rpcQueueName, false, false, false, null);\n+        // because we use a random queue, we don't have to purge it\n+        // if it was persistent, any previous message should be discarded with a call to 'queuePurge'\n+\n+        // RPC server implementation\n+        String serverConsumerTag = channel.basicConsume(rpcQueueName, false, new DefaultConsumer(channel) {\n+\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+\n+                AMQP.BasicProperties replyProperties = new AMQP.BasicProperties\n+                    .Builder()\n+                    .correlationId(properties.getCorrelationId())\n+                    .build();\n+\n+                String reply = \"reply from RPC server: \" + new String(body);\n+                channel.basicPublish(exchange, properties.getReplyTo(), replyProperties, reply.getBytes());\n+                channel.basicAck(envelope.getDeliveryTag(), false);\n+            }\n+        });\n+\n+        final String correlationId = UUID.randomUUID().toString();\n+\n+        String replyQueueName = channel.queueDeclare().getQueue();\n+        AMQP.BasicProperties properties = new AMQP.BasicProperties\n+            .Builder()\n+            .correlationId(correlationId)\n+            .replyTo(replyQueueName)\n+            .build();\n+\n+\n+        Transaction rootTransaction = startRootTransaction();\n+\n+        channel.basicPublish(exchange, rpcQueueName, properties, MSG);\n+\n+        ArrayBlockingQueue<String> rpcResult = new ArrayBlockingQueue<>(1);\n+\n+        // here we could have used the DeliverCallback functional interface added in rabbitmq 5.x driver\n+        // however, internally it only delegates to a regular Consumer\n+        String clientConsumerTag = channel.basicConsume(replyQueueName, true, new DefaultConsumer(channel) {\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+                if (correlationId.equals(properties.getCorrelationId())) {\n+                    rpcResult.offer(new String(body));\n+                }\n+            }\n+        });\n+\n+        assertThat(rpcResult.take()).isEqualTo(\"reply from RPC server: Testing APM!\");\n+\n+        endRootTransaction(rootTransaction);\n+\n+        // we need to cancel consumers after usage\n+        channel.basicCancel(clientConsumerTag);\n+        channel.basicCancel(serverConsumerTag);\n+\n+\n+        // we should have captured the following:\n+        // 3 transactions:\n+        // - root transaction\n+        // - transaction for the server-side of the RPC call (processing request)\n+        // - transaction for the client-side of the RPC call (processing response)\n+        // 2 spans:\n+        // - span for sending the RPC request message in the root transaction\n+        // - span for sending the RPC response message in server-side processing\n+\n+        getReporter().awaitTransactionCount(3);\n+        getReporter().awaitSpanCount(2);\n+\n+        // start with the spans as we can identify them using the root transaction\n+        // parent/child relationships are used to find who is who as we don't have other fields like name\n+        // to distinguish them\n+\n+        Span clientRequestRpc = null;\n+        Span serverReplyRpc = null;\n+        for (Span s : getReporter().getSpans()) {\n+            Id spanParentId = s.getTraceContext().getParentId();\n+            if (rootTransaction.getTraceContext().getId().equals(spanParentId)) {\n+                // client request is child of root transaction\n+                assertThat(clientRequestRpc).isNull();\n+                clientRequestRpc = s;\n+            } else {\n+                assertThat(serverReplyRpc).isNull();\n+                serverReplyRpc = s;\n+            }\n+        }\n+        assertThat(clientRequestRpc).isNotNull();\n+        assertThat(serverReplyRpc).isNotNull();\n+\n+        Transaction serverSideRpc = null;\n+        Transaction clientSideRpc = null;\n+        for (Transaction t : getReporter().getTransactions()) {\n+            if (t != rootTransaction) {\n+                Id transactionParentId = t.getTraceContext().getParentId();\n+                if (clientRequestRpc.getTraceContext().getId().equals(transactionParentId)) {\n+                    assertThat(serverSideRpc).isNull();\n+                    serverSideRpc = t;\n+                } else {\n+                    assertThat(clientSideRpc).isNull();\n+                    clientSideRpc = t;\n+                }\n+            }\n+        }\n+        assertThat(serverSideRpc).isNotNull();\n+        assertThat(clientSideRpc).isNotNull();\n+\n+        checkSendSpan(clientRequestRpc, exchange);\n+        checkParentChild(rootTransaction, clientRequestRpc);\n+\n+        checkTransaction(serverSideRpc, exchange);\n+        assertThat(serverSideRpc.getNameAsString()).isEqualTo(\"RabbitMQ message RECEIVE from <default>\");\n+        checkParentChild(clientRequestRpc, serverSideRpc);\n+\n+        checkSendSpan(serverReplyRpc, exchange);\n+        checkParentChild(serverSideRpc, serverReplyRpc);\n+\n+        checkTransaction(clientSideRpc, exchange);\n+        checkParentChild(serverReplyRpc, clientSideRpc);\n+\n+    }\n+\n+    private void endRootTransaction(Transaction rootTransaction) {\n+        rootTransaction.deactivate().end();\n+    }\n+\n+    private Transaction startRootTransaction() {\n+        return getTracer().startRootTransaction(getClass().getClassLoader())\n+            .withName(\"Rabbit-Test Root Transaction\")\n+            .withType(\"request\")\n+            .withResult(\"success\")\n+            .activate();\n+    }\n+\n+    private static Transaction getNonRootTransaction(Transaction rootTransaction, List<Transaction> transactions) {\n+        Transaction childTransaction = null;\n+        for (Transaction t : transactions) {\n+            if (t != rootTransaction) {\n+                assertThat(childTransaction).isNull();\n+                childTransaction = t;\n+            }\n+        }\n+        assertThat(childTransaction).isNotNull();\n+        return childTransaction;\n+    }\n+\n+    private String createQueue(Channel channel, String exchange) throws IOException {\n+        String queueName = channel.queueDeclare().getQueue();\n+        channel.queueBind(queueName, exchange, ROUTING_KEY);\n+        return queueName;\n+    }\n+\n+    private String createExchange(Channel channel, String exchangeName) throws IOException {\n+        channel.exchangeDeclare(exchangeName, \"direct\", false);\n+        return exchangeName;\n+    }\n+\n+    private static String randString(String prefix) {\n+        return String.format(\"%s-%08x\", prefix, System.currentTimeMillis());\n+    }\n+\n+    private AMQP.BasicProperties propertiesMap(Map<String, String> map) {\n+        // doing a dumb copy to convert Map<String,String> to Map<String,Object>\n+        Map<String, Object> objectMap = new HashMap<>();\n+        for (Map.Entry<String, String> entry : map.entrySet()) {\n+            objectMap.put(entry.getKey(), entry.getValue());\n+        }\n+        return new AMQP.BasicProperties.Builder()\n+            .headers(objectMap)\n+            .build();\n+    }\n+\n+    private AMQP.BasicProperties emptyProperties() {\n+        return new AMQP.BasicProperties.Builder().headers(new HashMap<>()).build();\n+    }\n+\n+    private static void checkParentChild(AbstractSpan<?> parent, AbstractSpan<?> child) {\n+        assertThat(child.getTraceContext().getParentId())\n+            .describedAs(\"child (%s) should be a child of (%s)\", child, parent)\n+            .isEqualTo(parent.getTraceContext().getId());\n+\n+        assertThat(child.getTraceContext().getTraceId())\n+            .describedAs(\"child (%s) should have same trace ID as parent (%s)\", child, parent)\n+            .isEqualTo(parent.getTraceContext().getTraceId());\n+    }\n+\n+    private static void checkTransaction(Transaction transaction, String exchange) {\n+        assertThat(transaction.getType()).isEqualTo(\"messaging\");\n+        assertThat(transaction.getNameAsString())\n+            .isEqualTo(\"RabbitMQ message RECEIVE from %s\", exchange.isEmpty() ? \"<default>\" : exchange);\n+        assertThat(transaction.getFrameworkName()).isEqualTo(\"RabbitMQ\");\n+\n+        checkMessage(transaction.getContext().getMessage(), exchange);\n+    }\n+\n+    private static void checkMessage(Message message, String queueName) {\n+        assertThat(message.getQueueName()).isEqualTo(queueName);\n+\n+        // RabbitMQ does not provide timestamp by default\n+        assertThat(message.getAge()).isLessThan(0);\n+    }\n+\n+\n+    private static void checkMessageBodyNotCaptured(Message message) {\n+        assertThat(message.getBodyForRead()).describedAs(\"body capture isn't supported\").isNull();\n+    }\n+\n+    private static final String[] DISTRIBUTED_TRACING_HEADERS = {\n+        \"elastic-apm-traceparent\",\n+        \"tracestate\",\n+        \"traceparent\"\n+    };\n+\n+    private static void checkDistributedTracingHeaders(Message message, boolean expectTracingHeaders) {\n+        HashMap<String, String> headersMap = getHeadersMap(message);\n+        if (expectTracingHeaders) {\n+            assertThat(headersMap)\n+                .describedAs(\"distributed tracing headers should be captured\")\n+                .containsKeys(DISTRIBUTED_TRACING_HEADERS);\n+        } else {\n+            assertThat(headersMap)\n+                .describedAs(\"distributed tracing headers aren't expected\")\n+                .doesNotContainKeys(DISTRIBUTED_TRACING_HEADERS);\n+        }\n+    }\n+\n+    private static void checkHeaders(Message message, Map<String, String> expectedHeaders) {\n+        HashMap<String, String> headersMap = getHeadersMap(message);\n+        for (String key : DISTRIBUTED_TRACING_HEADERS) {\n+            headersMap.remove(key);\n+        }\n+        assertThat(headersMap)\n+            .describedAs(\"should contain entries of %s\", expectedHeaders)\n+            .containsAllEntriesOf(expectedHeaders);\n+    }\n+\n+    private static HashMap<String, String> getHeadersMap(Message message) {\n+        Headers headers = message.getHeaders();\n+        HashMap<String, String> headersMap = new HashMap<>();\n+        headers.forEach(h -> headersMap.put(h.getKey(), h.getValue().toString()));\n+        return headersMap;\n+    }\n+\n+    private static void checkSendSpan(Span span, String exchange) {\n+        String expectedResource = exchange.isEmpty() ? \"rabbitmq\" : String.format(\"rabbitmq/%s\", exchange);\n+        checkSpanCommon(span,\n+            \"send\",\n+            String.format(\"RabbitMQ SEND to %s\", exchange.isEmpty() ? \"<default>\" : exchange),\n+            exchange,\n+            expectedResource);\n+\n+    }\n+\n+    private static void checkPollSpan(Span span, String queue){\n+        checkSpanCommon(span,\n+            \"poll\",\n+            String.format(\"RabbitMQ POLL from %s\", queue),\n+            queue,\n+            \"rabbitmq\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4ODA5NA=="}, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 648}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyNjcyMA==", "bodyText": "My bad, I read it too quickly, here it's about the resource name, not the span name. Thus we should have:\n\nrabbitmq for polling when there is no message\nrabbitmq/${exchange} for polling when there is a message\n\nWe do not include queue name in resource name due to potentially high cardinality.\nAlso, that means that a successful message is being captured with queue name, and exchange name is visible in resource name, which could help to configure filtering using either queue name and exchange name.", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r543226720", "createdAt": "2020-12-15T10:30:50Z", "author": {"login": "SylvainJuge"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/test/java/co/elastic/apm/agent/rabbitmq/RabbitMQTest.java", "diffHunk": "@@ -0,0 +1,672 @@\n+package co.elastic.apm.agent.rabbitmq;\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+\n+import co.elastic.apm.agent.AbstractInstrumentationTest;\n+import co.elastic.apm.agent.configuration.CoreConfiguration;\n+import co.elastic.apm.agent.configuration.MessagingConfiguration;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.context.Headers;\n+import co.elastic.apm.agent.impl.context.Message;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Id;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.impl.transaction.Transaction;\n+import co.elastic.apm.agent.matcher.WildcardMatcher;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.ConnectionFactory;\n+import com.rabbitmq.client.DefaultConsumer;\n+import com.rabbitmq.client.Envelope;\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.BeforeAll;\n+import org.junit.jupiter.api.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.testcontainers.containers.RabbitMQContainer;\n+import org.testcontainers.containers.output.Slf4jLogConsumer;\n+\n+import javax.annotation.Nullable;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n+import java.util.function.BiConsumer;\n+import java.util.function.Supplier;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Mockito.when;\n+\n+/**\n+ * Tests the whole RabbitMQ instrumentation as a whole, both for transactions and spans\n+ */\n+public class RabbitMQTest extends AbstractInstrumentationTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(RabbitMQTest.class);\n+\n+    private static final String IMAGE = \"rabbitmq:3.7-management-alpine\";\n+    private static final RabbitMQContainer container = new RabbitMQContainer(IMAGE);\n+\n+    private static final String ROUTING_KEY = \"test.key\";\n+\n+    private static final byte[] MSG = \"Testing APM!\".getBytes();\n+\n+    private static ConnectionFactory factory;\n+\n+    private static Connection connection;\n+\n+    @BeforeAll\n+    static void before() {\n+        container.withLogConsumer(new Slf4jLogConsumer(logger))\n+            .start();\n+\n+        factory = new ConnectionFactory();\n+\n+        factory.setHost(container.getHost());\n+        factory.setPort(container.getAmqpPort());\n+        factory.setUsername(container.getAdminUsername());\n+        factory.setPassword(container.getAdminPassword());\n+\n+        try {\n+            connection = factory.newConnection();\n+            Objects.requireNonNull(connection);\n+            logger.info(\"created connection id = {}\", connection);\n+        } catch (IOException | TimeoutException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+\n+    @AfterAll\n+    static void after() throws IOException {\n+        container.close();\n+\n+        if (connection.isOpen()) {\n+            logger.info(\"silently closing open connection id = {}\", connection);\n+            connection.close();\n+        }\n+    }\n+\n+\n+    @Test\n+    void contextPropagationWithoutProperties() throws IOException, InterruptedException {\n+        performTest(null);\n+    }\n+\n+    @Test\n+    void contextPropagationWithProperties() throws IOException, InterruptedException {\n+        performTest(emptyProperties());\n+    }\n+\n+    @Test\n+    void bodyCaptureNotSupported() throws IOException, InterruptedException {\n+        // body capture is not supported because at the RabbitMQ driver level\n+        // the message is provided as a byte array.\n+        CoreConfiguration config = AbstractInstrumentationTest.config.getConfig(CoreConfiguration.class);\n+        when(config.getCaptureBody()).thenReturn(CoreConfiguration.EventType.ALL);\n+\n+        performTest(\n+            emptyProperties(),\n+            false,\n+            randString(\"exchange\"),\n+            (mt, ms) -> {\n+\n+                checkMessageBodyNotCaptured(mt);\n+                checkMessageBodyNotCaptured(ms);\n+            });\n+    }\n+\n+    @Test\n+    void headersCaptureEnabledByDefault() throws IOException, InterruptedException {\n+        Map<String, String> headers = Map.of(\"message-header\", \"header value\");\n+        Map<String, String> headersWithNullValue = new HashMap<>(headers);\n+        headersWithNullValue.put(\"null-header\", null);\n+        testHeadersCapture(headersWithNullValue,\n+            Map.of(\n+                \"message-header\", \"header value\",\n+                \"null-header\", \"null\"),\n+            true);\n+    }\n+\n+    @Test\n+    void headersCaptureDisabled() throws IOException, InterruptedException {\n+        CoreConfiguration coreConfiguration = config.getConfig(CoreConfiguration.class);\n+        when(coreConfiguration.isCaptureHeaders()).thenReturn(false);\n+\n+        testHeadersCapture(Map.of(\"message-header\", \"header value\"), Map.of(), false);\n+    }\n+\n+    @Test\n+    void headersCaptureSanitize() throws IOException, InterruptedException {\n+        CoreConfiguration coreConfiguration = config.getConfig(CoreConfiguration.class);\n+        when(coreConfiguration.getSanitizeFieldNames()).thenReturn(List.of(WildcardMatcher.valueOf(\"secret*\")));\n+\n+        testHeadersCapture(\n+            Map.of(\n+                \"other-header\", \"other-value\",\n+                \"secret-token\", \"secret-value\"),\n+            Map.of(\n+                \"other-header\", \"other-value\"\n+            ), true);\n+    }\n+\n+    private void testHeadersCapture(Map<String, String> headersMap, Map<String, String> expectedHeaders, boolean expectTracingHeaders) throws IOException, InterruptedException {\n+        performTest(\n+            propertiesMap(headersMap),\n+            false,\n+            randString(\"exchange\"),\n+            (mt, ms) -> {\n+                assertThat(ms.getHeaders())\n+                    .describedAs(\"spans should not capture outgoing message headers\")\n+                    .isEmpty();\n+\n+                // only transaction should have headers\n+                checkHeaders(mt, expectedHeaders);\n+                checkDistributedTracingHeaders(mt, expectTracingHeaders);\n+            });\n+    }\n+\n+    @Test\n+    void ignoreExchangeName() throws IOException, InterruptedException {\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-*\")));\n+\n+        performTest(emptyProperties(), true, randString(\"ignored\"), (mt, ms) -> {\n+        });\n+    }\n+\n+    private void performTest(@Nullable AMQP.BasicProperties properties) throws IOException, InterruptedException {\n+        performTest(properties, false, randString(\"exchange\"), (mt, ms) -> {\n+        });\n+    }\n+\n+    private void performTest(@Nullable AMQP.BasicProperties properties,\n+                             boolean shouldIgnore,\n+                             String channelName,\n+                             BiConsumer<Message, Message> messageCheck) throws IOException, InterruptedException {\n+\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, channelName);\n+        String queue = createQueue(channel, exchange);\n+\n+        CountDownLatch messageReceived = new CountDownLatch(1);\n+\n+        channel.basicConsume(queue, new DefaultConsumer(channel) {\n+            // using an anonymous class to ensure class matching is properly applied\n+\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+                assertThat(properties).isNotNull();\n+                Map<String, Object> headers = properties.getHeaders();\n+\n+                if (shouldIgnore) {\n+                    assertThat(headers).doesNotContainKeys(DISTRIBUTED_TRACING_HEADERS);\n+                } else {\n+                    assertThat(headers).containsKeys(DISTRIBUTED_TRACING_HEADERS);\n+                }\n+\n+                messageReceived.countDown();\n+            }\n+        });\n+\n+        Transaction rootTransaction = startRootTransaction();\n+\n+        channel.basicPublish(exchange, ROUTING_KEY, properties, MSG);\n+\n+        endRootTransaction(rootTransaction);\n+\n+        messageReceived.await(1, TimeUnit.SECONDS);\n+\n+        if (shouldIgnore) {\n+            getReporter().awaitTransactionCount(1);\n+            assertThat(getReporter().getFirstTransaction())\n+                .describedAs(\"only the test root transaction is expected\")\n+                .isSameAs(rootTransaction);\n+\n+            getReporter()\n+                .awaitUntilAsserted(1_000, () -> assertThat(getReporter().getNumReportedTransactions())\n+                    .describedAs(\"no other transaction should be reported\")\n+                    .isEqualTo(1));\n+\n+            getReporter().assertNoSpan(1_000);\n+            return;\n+        }\n+\n+\n+        // 2 transactions, 1 span expected\n+        getReporter().awaitTransactionCount(2);\n+        getReporter().awaitSpanCount(1);\n+\n+        Transaction childTransaction = getNonRootTransaction(rootTransaction, getReporter().getTransactions());\n+\n+        checkTransaction(childTransaction, exchange);\n+\n+        Span span = getReporter().getSpans().get(0);\n+        checkSendSpan(span, exchange);\n+\n+        // span should be child of the first transaction\n+        checkParentChild(rootTransaction, span);\n+        // second transaction should be the child of span\n+        checkParentChild(span, childTransaction);\n+\n+        // common assertions on span & transaction message\n+        Message spanMessage = span.getContext().getMessage();\n+        Message transactionMessage = childTransaction.getContext().getMessage();\n+\n+\n+        // test-specific assertions on captured message\n+        messageCheck.accept(transactionMessage, spanMessage);\n+\n+    }\n+\n+    @Test\n+    void testPollingWithinTransaction() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        String queueName = randString(\"queue-\");\n+\n+        pollingTest(true, false, () -> declareAndBindQueue(queueName, exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.awaitSpanCount(1);\n+\n+        Span pollingSpan = reporter.getFirstSpan();\n+        checkPollSpan(pollingSpan, queueName);\n+    }\n+\n+    @Test\n+    void testPollingOutsideTransaction() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        pollingTest(false, false, () -> declareAndBindQueue(\"queue\", exchange, channel), exchange);\n+\n+        reporter.assertNoTransaction(100);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    @Test\n+    void testPollingIgnoreQueueName() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"exchange\");\n+\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-qu*\")));\n+\n+        pollingTest(true, false, () -> declareAndBindQueue(\"ignored-queue\", exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    @Test\n+    void testPollingIgnoreExchangeName() throws IOException {\n+        Channel channel = connection.createChannel();\n+        String exchange = createExchange(channel, \"ignored-exchange\");\n+\n+        MessagingConfiguration messagingConfiguration = config.getConfig(MessagingConfiguration.class);\n+        when(messagingConfiguration.getIgnoreMessageQueues()).thenReturn(List.of(WildcardMatcher.valueOf(\"ignored-ex*\")));\n+\n+        pollingTest(true, true, () -> declareAndBindQueue(\"queue\", exchange, channel), exchange);\n+\n+        reporter.awaitTransactionCount(1);\n+        reporter.assertNoSpan(100);\n+    }\n+\n+    private String declareAndBindQueue(String queue, String exchange, Channel channel) {\n+        try {\n+            channel.queueDeclare(queue, false, false, false, null);\n+            channel.queueBind(queue, exchange, ROUTING_KEY);\n+            return queue;\n+        } catch (IOException e) {\n+            throw new IllegalStateException(e);\n+        }\n+    }\n+\n+    private void pollingTest(boolean withinTransaction, boolean withResult, Supplier<String> createQueue, String exchange) throws IOException {\n+        Channel channel = connection.createChannel();\n+\n+        String queue = createQueue.get();\n+\n+        if (withResult) {\n+            channel.basicPublish(exchange, ROUTING_KEY, emptyProperties(), MSG);\n+        }\n+\n+        Transaction rootTransaction = null;\n+        if (withinTransaction) {\n+            rootTransaction = startRootTransaction();\n+        }\n+\n+        channel.basicGet(queue, true);\n+\n+        if (withinTransaction) {\n+            endRootTransaction(rootTransaction);\n+        }\n+    }\n+\n+    @Test\n+    void testRpcCall() throws IOException, InterruptedException {\n+        // with an RPC call, the message consumer might be executed within the caller thread\n+        // as a result, if there is an active transaction we should create a span for the message processing\n+\n+        Channel channel = connection.createChannel();\n+\n+        // using an empty name for exchange allows to use the default exchange\n+        // which has the property to send message to any queue by name using routing key\n+        final String exchange = \"\";\n+\n+        channel.basicQos(1);\n+\n+        String rpcQueueName = randString(\"rpc_queue\");\n+        channel.queueDeclare(rpcQueueName, false, false, false, null);\n+        // because we use a random queue, we don't have to purge it\n+        // if it was persistent, any previous message should be discarded with a call to 'queuePurge'\n+\n+        // RPC server implementation\n+        String serverConsumerTag = channel.basicConsume(rpcQueueName, false, new DefaultConsumer(channel) {\n+\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+\n+                AMQP.BasicProperties replyProperties = new AMQP.BasicProperties\n+                    .Builder()\n+                    .correlationId(properties.getCorrelationId())\n+                    .build();\n+\n+                String reply = \"reply from RPC server: \" + new String(body);\n+                channel.basicPublish(exchange, properties.getReplyTo(), replyProperties, reply.getBytes());\n+                channel.basicAck(envelope.getDeliveryTag(), false);\n+            }\n+        });\n+\n+        final String correlationId = UUID.randomUUID().toString();\n+\n+        String replyQueueName = channel.queueDeclare().getQueue();\n+        AMQP.BasicProperties properties = new AMQP.BasicProperties\n+            .Builder()\n+            .correlationId(correlationId)\n+            .replyTo(replyQueueName)\n+            .build();\n+\n+\n+        Transaction rootTransaction = startRootTransaction();\n+\n+        channel.basicPublish(exchange, rpcQueueName, properties, MSG);\n+\n+        ArrayBlockingQueue<String> rpcResult = new ArrayBlockingQueue<>(1);\n+\n+        // here we could have used the DeliverCallback functional interface added in rabbitmq 5.x driver\n+        // however, internally it only delegates to a regular Consumer\n+        String clientConsumerTag = channel.basicConsume(replyQueueName, true, new DefaultConsumer(channel) {\n+            @Override\n+            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {\n+                if (correlationId.equals(properties.getCorrelationId())) {\n+                    rpcResult.offer(new String(body));\n+                }\n+            }\n+        });\n+\n+        assertThat(rpcResult.take()).isEqualTo(\"reply from RPC server: Testing APM!\");\n+\n+        endRootTransaction(rootTransaction);\n+\n+        // we need to cancel consumers after usage\n+        channel.basicCancel(clientConsumerTag);\n+        channel.basicCancel(serverConsumerTag);\n+\n+\n+        // we should have captured the following:\n+        // 3 transactions:\n+        // - root transaction\n+        // - transaction for the server-side of the RPC call (processing request)\n+        // - transaction for the client-side of the RPC call (processing response)\n+        // 2 spans:\n+        // - span for sending the RPC request message in the root transaction\n+        // - span for sending the RPC response message in server-side processing\n+\n+        getReporter().awaitTransactionCount(3);\n+        getReporter().awaitSpanCount(2);\n+\n+        // start with the spans as we can identify them using the root transaction\n+        // parent/child relationships are used to find who is who as we don't have other fields like name\n+        // to distinguish them\n+\n+        Span clientRequestRpc = null;\n+        Span serverReplyRpc = null;\n+        for (Span s : getReporter().getSpans()) {\n+            Id spanParentId = s.getTraceContext().getParentId();\n+            if (rootTransaction.getTraceContext().getId().equals(spanParentId)) {\n+                // client request is child of root transaction\n+                assertThat(clientRequestRpc).isNull();\n+                clientRequestRpc = s;\n+            } else {\n+                assertThat(serverReplyRpc).isNull();\n+                serverReplyRpc = s;\n+            }\n+        }\n+        assertThat(clientRequestRpc).isNotNull();\n+        assertThat(serverReplyRpc).isNotNull();\n+\n+        Transaction serverSideRpc = null;\n+        Transaction clientSideRpc = null;\n+        for (Transaction t : getReporter().getTransactions()) {\n+            if (t != rootTransaction) {\n+                Id transactionParentId = t.getTraceContext().getParentId();\n+                if (clientRequestRpc.getTraceContext().getId().equals(transactionParentId)) {\n+                    assertThat(serverSideRpc).isNull();\n+                    serverSideRpc = t;\n+                } else {\n+                    assertThat(clientSideRpc).isNull();\n+                    clientSideRpc = t;\n+                }\n+            }\n+        }\n+        assertThat(serverSideRpc).isNotNull();\n+        assertThat(clientSideRpc).isNotNull();\n+\n+        checkSendSpan(clientRequestRpc, exchange);\n+        checkParentChild(rootTransaction, clientRequestRpc);\n+\n+        checkTransaction(serverSideRpc, exchange);\n+        assertThat(serverSideRpc.getNameAsString()).isEqualTo(\"RabbitMQ message RECEIVE from <default>\");\n+        checkParentChild(clientRequestRpc, serverSideRpc);\n+\n+        checkSendSpan(serverReplyRpc, exchange);\n+        checkParentChild(serverSideRpc, serverReplyRpc);\n+\n+        checkTransaction(clientSideRpc, exchange);\n+        checkParentChild(serverReplyRpc, clientSideRpc);\n+\n+    }\n+\n+    private void endRootTransaction(Transaction rootTransaction) {\n+        rootTransaction.deactivate().end();\n+    }\n+\n+    private Transaction startRootTransaction() {\n+        return getTracer().startRootTransaction(getClass().getClassLoader())\n+            .withName(\"Rabbit-Test Root Transaction\")\n+            .withType(\"request\")\n+            .withResult(\"success\")\n+            .activate();\n+    }\n+\n+    private static Transaction getNonRootTransaction(Transaction rootTransaction, List<Transaction> transactions) {\n+        Transaction childTransaction = null;\n+        for (Transaction t : transactions) {\n+            if (t != rootTransaction) {\n+                assertThat(childTransaction).isNull();\n+                childTransaction = t;\n+            }\n+        }\n+        assertThat(childTransaction).isNotNull();\n+        return childTransaction;\n+    }\n+\n+    private String createQueue(Channel channel, String exchange) throws IOException {\n+        String queueName = channel.queueDeclare().getQueue();\n+        channel.queueBind(queueName, exchange, ROUTING_KEY);\n+        return queueName;\n+    }\n+\n+    private String createExchange(Channel channel, String exchangeName) throws IOException {\n+        channel.exchangeDeclare(exchangeName, \"direct\", false);\n+        return exchangeName;\n+    }\n+\n+    private static String randString(String prefix) {\n+        return String.format(\"%s-%08x\", prefix, System.currentTimeMillis());\n+    }\n+\n+    private AMQP.BasicProperties propertiesMap(Map<String, String> map) {\n+        // doing a dumb copy to convert Map<String,String> to Map<String,Object>\n+        Map<String, Object> objectMap = new HashMap<>();\n+        for (Map.Entry<String, String> entry : map.entrySet()) {\n+            objectMap.put(entry.getKey(), entry.getValue());\n+        }\n+        return new AMQP.BasicProperties.Builder()\n+            .headers(objectMap)\n+            .build();\n+    }\n+\n+    private AMQP.BasicProperties emptyProperties() {\n+        return new AMQP.BasicProperties.Builder().headers(new HashMap<>()).build();\n+    }\n+\n+    private static void checkParentChild(AbstractSpan<?> parent, AbstractSpan<?> child) {\n+        assertThat(child.getTraceContext().getParentId())\n+            .describedAs(\"child (%s) should be a child of (%s)\", child, parent)\n+            .isEqualTo(parent.getTraceContext().getId());\n+\n+        assertThat(child.getTraceContext().getTraceId())\n+            .describedAs(\"child (%s) should have same trace ID as parent (%s)\", child, parent)\n+            .isEqualTo(parent.getTraceContext().getTraceId());\n+    }\n+\n+    private static void checkTransaction(Transaction transaction, String exchange) {\n+        assertThat(transaction.getType()).isEqualTo(\"messaging\");\n+        assertThat(transaction.getNameAsString())\n+            .isEqualTo(\"RabbitMQ message RECEIVE from %s\", exchange.isEmpty() ? \"<default>\" : exchange);\n+        assertThat(transaction.getFrameworkName()).isEqualTo(\"RabbitMQ\");\n+\n+        checkMessage(transaction.getContext().getMessage(), exchange);\n+    }\n+\n+    private static void checkMessage(Message message, String queueName) {\n+        assertThat(message.getQueueName()).isEqualTo(queueName);\n+\n+        // RabbitMQ does not provide timestamp by default\n+        assertThat(message.getAge()).isLessThan(0);\n+    }\n+\n+\n+    private static void checkMessageBodyNotCaptured(Message message) {\n+        assertThat(message.getBodyForRead()).describedAs(\"body capture isn't supported\").isNull();\n+    }\n+\n+    private static final String[] DISTRIBUTED_TRACING_HEADERS = {\n+        \"elastic-apm-traceparent\",\n+        \"tracestate\",\n+        \"traceparent\"\n+    };\n+\n+    private static void checkDistributedTracingHeaders(Message message, boolean expectTracingHeaders) {\n+        HashMap<String, String> headersMap = getHeadersMap(message);\n+        if (expectTracingHeaders) {\n+            assertThat(headersMap)\n+                .describedAs(\"distributed tracing headers should be captured\")\n+                .containsKeys(DISTRIBUTED_TRACING_HEADERS);\n+        } else {\n+            assertThat(headersMap)\n+                .describedAs(\"distributed tracing headers aren't expected\")\n+                .doesNotContainKeys(DISTRIBUTED_TRACING_HEADERS);\n+        }\n+    }\n+\n+    private static void checkHeaders(Message message, Map<String, String> expectedHeaders) {\n+        HashMap<String, String> headersMap = getHeadersMap(message);\n+        for (String key : DISTRIBUTED_TRACING_HEADERS) {\n+            headersMap.remove(key);\n+        }\n+        assertThat(headersMap)\n+            .describedAs(\"should contain entries of %s\", expectedHeaders)\n+            .containsAllEntriesOf(expectedHeaders);\n+    }\n+\n+    private static HashMap<String, String> getHeadersMap(Message message) {\n+        Headers headers = message.getHeaders();\n+        HashMap<String, String> headersMap = new HashMap<>();\n+        headers.forEach(h -> headersMap.put(h.getKey(), h.getValue().toString()));\n+        return headersMap;\n+    }\n+\n+    private static void checkSendSpan(Span span, String exchange) {\n+        String expectedResource = exchange.isEmpty() ? \"rabbitmq\" : String.format(\"rabbitmq/%s\", exchange);\n+        checkSpanCommon(span,\n+            \"send\",\n+            String.format(\"RabbitMQ SEND to %s\", exchange.isEmpty() ? \"<default>\" : exchange),\n+            exchange,\n+            expectedResource);\n+\n+    }\n+\n+    private static void checkPollSpan(Span span, String queue){\n+        checkSpanCommon(span,\n+            \"poll\",\n+            String.format(\"RabbitMQ POLL from %s\", queue),\n+            queue,\n+            \"rabbitmq\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDI4ODA5NA=="}, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 648}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjgwMjkzOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjoyMTo1NVrOIDRm4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjoyMTo1NVrOIDRm4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMwNTEyMg==", "bodyText": "[minor]\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            // tracer disabled or ignored exchange\n          \n          \n            \n                            // tracer disabled or ignored exchange or this is nested within another exit span", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540305122", "createdAt": "2020-12-10T16:21:55Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) @Nullable String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            Span exitSpan = createExitSpan(exchange);\n+            if (exitSpan == null) {\n+                // tracer disabled or ignored exchange", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjgyNjkzOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjoyNjowNVrOIDR14g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjoyNjowNVrOIDR14g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMwODk2Mg==", "bodyText": "[minor]\nIf currentHeaders == null, create only one instead of two", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540308962", "createdAt": "2020-12-10T16:26:05Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) @Nullable String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            Span exitSpan = createExitSpan(exchange);\n+            if (exitSpan == null) {\n+                // tracer disabled or ignored exchange\n+                return null;\n+            }\n+\n+            exitSpan.withAction(\"send\")\n+                .withName(\"RabbitMQ SEND to \").appendToName(normalizeExchangeName(exchange));\n+\n+            properties = propagateTraceContext(exitSpan, properties);\n+\n+            captureMessage(exchange, properties, exitSpan);\n+            captureDestination(exchange, channel, exitSpan);\n+\n+            return new Object[]{properties, exitSpan};\n+        }\n+\n+        private static AMQP.BasicProperties propagateTraceContext(Span exitSpan,\n+                                                                  @Nullable AMQP.BasicProperties originalBasicProperties) {\n+            AMQP.BasicProperties properties = originalBasicProperties;\n+            if (properties == null) {\n+                properties = new AMQP.BasicProperties();\n+            }\n+\n+            Map<String, Object> currentHeaders = properties.getHeaders();\n+            if (currentHeaders == null) {\n+                currentHeaders = new HashMap<>();\n+            }\n+\n+            HashMap<String, Object> headersWithContext = new HashMap<>(currentHeaders);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Mjg2NTI4OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozMzowOFrOIDSNyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozMzowOFrOIDSNyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMxNTA4MA==", "bodyText": "[minor]\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static Span createExitSpan(@Nullable String exchangeOrQueue) {\n          \n          \n            \n                private static Span createAndActivateExitSpan(@Nullable String exchangeOrQueue) {", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540315080", "createdAt": "2020-12-10T16:33:08Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) @Nullable String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            Span exitSpan = createExitSpan(exchange);\n+            if (exitSpan == null) {\n+                // tracer disabled or ignored exchange\n+                return null;\n+            }\n+\n+            exitSpan.withAction(\"send\")\n+                .withName(\"RabbitMQ SEND to \").appendToName(normalizeExchangeName(exchange));\n+\n+            properties = propagateTraceContext(exitSpan, properties);\n+\n+            captureMessage(exchange, properties, exitSpan);\n+            captureDestination(exchange, channel, exitSpan);\n+\n+            return new Object[]{properties, exitSpan};\n+        }\n+\n+        private static AMQP.BasicProperties propagateTraceContext(Span exitSpan,\n+                                                                  @Nullable AMQP.BasicProperties originalBasicProperties) {\n+            AMQP.BasicProperties properties = originalBasicProperties;\n+            if (properties == null) {\n+                properties = new AMQP.BasicProperties();\n+            }\n+\n+            Map<String, Object> currentHeaders = properties.getHeaders();\n+            if (currentHeaders == null) {\n+                currentHeaders = new HashMap<>();\n+            }\n+\n+            HashMap<String, Object> headersWithContext = new HashMap<>(currentHeaders);\n+\n+            exitSpan.propagateTraceContext(headersWithContext, RabbitMQTextHeaderSetter.INSTANCE);\n+\n+            return properties.builder().headers(headersWithContext).build();\n+        }\n+\n+        @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class, inline = false)\n+        public static void afterBasicPublish(@Advice.Enter @Nullable Object[] enterArray,\n+                                             @Advice.Thrown @Nullable Throwable throwable) {\n+            if (enterArray != null && enterArray.length >= 2 && enterArray[1] != null) {\n+                Span span = (Span) enterArray[1];\n+                span.captureException(throwable)\n+                    .deactivate()\n+                    .end();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicGet}</li>\n+     * </ul>\n+     */\n+    public static class BasicGet extends ChannelInstrumentation {\n+\n+        public BasicGet(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicGet\")\n+                .and(takesArgument(0, String.class));\n+        }\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onEnter(@Advice.Argument(0) @Nullable String queue) {\n+\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            return createExitSpan(normalizeQueueName(queue));\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n+        public static void onExit(@Advice.This Channel channel,\n+                                  @Advice.Argument(0) String queue,\n+                                  @Advice.Enter @Nullable Object objSpan,\n+                                  @Advice.Return @Nullable GetResponse rv,\n+                                  @Advice.Thrown @Nullable Throwable thrown) {\n+\n+            if (!(objSpan instanceof Span)) {\n+                return;\n+            }\n+            Span span = (Span) objSpan;\n+\n+            if (isIgnored(queue)) {\n+                // allow to ignore on queue name when there is no answer\n+                span.requestDiscarding();\n+            }\n+\n+            span.withAction(\"poll\")\n+                .withName(\"RabbitMQ POLL from \").appendToName(normalizeQueueName(queue));\n+\n+            Envelope envelope = null;\n+            AMQP.BasicProperties properties = null;\n+\n+            if (rv != null) {\n+                envelope = rv.getEnvelope();\n+                properties = rv.getProps();\n+            }\n+\n+            String exchange = \"\";\n+\n+            if (null != envelope) {\n+                // since exchange name is only known when receiving the message, we might have to discard it\n+                if (isIgnored(envelope.getExchange())) {\n+                    span.requestDiscarding();\n+                }\n+            }\n+            captureMessage(queue, properties, span);\n+            captureDestination(exchange, channel, span);\n+\n+            span.captureException(thrown)\n+                .deactivate()\n+                .end();\n+        }\n+    }\n+\n+    /**\n+     * Creates a messaging exit span\n+     *\n+     * @param exchangeOrQueue exchange or queue name\n+     * @return exit span if applicable, {@literal null} otherwise\n+     */\n+    @Nullable\n+    private static Span createExitSpan(@Nullable String exchangeOrQueue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 279}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Mjg4MzkzOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozNjoyNFrOIDSZyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozNjoyNFrOIDSZyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMxODE1NQ==", "bodyText": "Include default as well", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540318155", "createdAt": "2020-12-10T16:36:24Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) @Nullable String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            Span exitSpan = createExitSpan(exchange);\n+            if (exitSpan == null) {\n+                // tracer disabled or ignored exchange\n+                return null;\n+            }\n+\n+            exitSpan.withAction(\"send\")\n+                .withName(\"RabbitMQ SEND to \").appendToName(normalizeExchangeName(exchange));\n+\n+            properties = propagateTraceContext(exitSpan, properties);\n+\n+            captureMessage(exchange, properties, exitSpan);\n+            captureDestination(exchange, channel, exitSpan);\n+\n+            return new Object[]{properties, exitSpan};\n+        }\n+\n+        private static AMQP.BasicProperties propagateTraceContext(Span exitSpan,\n+                                                                  @Nullable AMQP.BasicProperties originalBasicProperties) {\n+            AMQP.BasicProperties properties = originalBasicProperties;\n+            if (properties == null) {\n+                properties = new AMQP.BasicProperties();\n+            }\n+\n+            Map<String, Object> currentHeaders = properties.getHeaders();\n+            if (currentHeaders == null) {\n+                currentHeaders = new HashMap<>();\n+            }\n+\n+            HashMap<String, Object> headersWithContext = new HashMap<>(currentHeaders);\n+\n+            exitSpan.propagateTraceContext(headersWithContext, RabbitMQTextHeaderSetter.INSTANCE);\n+\n+            return properties.builder().headers(headersWithContext).build();\n+        }\n+\n+        @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class, inline = false)\n+        public static void afterBasicPublish(@Advice.Enter @Nullable Object[] enterArray,\n+                                             @Advice.Thrown @Nullable Throwable throwable) {\n+            if (enterArray != null && enterArray.length >= 2 && enterArray[1] != null) {\n+                Span span = (Span) enterArray[1];\n+                span.captureException(throwable)\n+                    .deactivate()\n+                    .end();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicGet}</li>\n+     * </ul>\n+     */\n+    public static class BasicGet extends ChannelInstrumentation {\n+\n+        public BasicGet(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicGet\")\n+                .and(takesArgument(0, String.class));\n+        }\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onEnter(@Advice.Argument(0) @Nullable String queue) {\n+\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            return createExitSpan(normalizeQueueName(queue));\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n+        public static void onExit(@Advice.This Channel channel,\n+                                  @Advice.Argument(0) String queue,\n+                                  @Advice.Enter @Nullable Object objSpan,\n+                                  @Advice.Return @Nullable GetResponse rv,\n+                                  @Advice.Thrown @Nullable Throwable thrown) {\n+\n+            if (!(objSpan instanceof Span)) {\n+                return;\n+            }\n+            Span span = (Span) objSpan;\n+\n+            if (isIgnored(queue)) {\n+                // allow to ignore on queue name when there is no answer\n+                span.requestDiscarding();\n+            }\n+\n+            span.withAction(\"poll\")\n+                .withName(\"RabbitMQ POLL from \").appendToName(normalizeQueueName(queue));\n+\n+            Envelope envelope = null;\n+            AMQP.BasicProperties properties = null;\n+\n+            if (rv != null) {\n+                envelope = rv.getEnvelope();\n+                properties = rv.getProps();\n+            }\n+\n+            String exchange = \"\";\n+\n+            if (null != envelope) {\n+                // since exchange name is only known when receiving the message, we might have to discard it\n+                if (isIgnored(envelope.getExchange())) {\n+                    span.requestDiscarding();\n+                }\n+            }\n+            captureMessage(queue, properties, span);\n+            captureDestination(exchange, channel, span);\n+\n+            span.captureException(thrown)\n+                .deactivate()\n+                .end();\n+        }\n+    }\n+\n+    /**\n+     * Creates a messaging exit span\n+     *\n+     * @param exchangeOrQueue exchange or queue name\n+     * @return exit span if applicable, {@literal null} otherwise\n+     */\n+    @Nullable\n+    private static Span createExitSpan(@Nullable String exchangeOrQueue) {\n+        AbstractSpan<?> context = tracer.getActive();\n+        if (exchangeOrQueue == null || context == null || isIgnored(exchangeOrQueue)) {\n+            return null;\n+        }\n+        Span exitSpan = context.createExitSpan();\n+        if (exitSpan == null) {\n+            return null;\n+        }\n+\n+        return exitSpan.activate()\n+            .withType(\"messaging\")\n+            .withSubtype(\"rabbitmq\");\n+    }\n+\n+    private static void captureDestination(String exchange, Channel channel, Span span) {\n+        Destination destination = span.getContext().getDestination();\n+\n+        Destination.Service service = destination.getService();\n+        service.withType(\"messaging\")\n+            .withName(\"rabbitmq\")\n+            .withResource(\"rabbitmq\");\n+\n+        if (!exchange.isEmpty()) {\n+            // include non-default exchange name in resource", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 303}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Mjg4NzI2OnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozNjo1NFrOIDSbwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozNjo1NFrOIDSbwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMxODY1Nw==", "bodyText": "Use the normalized exchange name", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540318657", "createdAt": "2020-12-10T16:36:54Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) @Nullable String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            Span exitSpan = createExitSpan(exchange);\n+            if (exitSpan == null) {\n+                // tracer disabled or ignored exchange\n+                return null;\n+            }\n+\n+            exitSpan.withAction(\"send\")\n+                .withName(\"RabbitMQ SEND to \").appendToName(normalizeExchangeName(exchange));\n+\n+            properties = propagateTraceContext(exitSpan, properties);\n+\n+            captureMessage(exchange, properties, exitSpan);\n+            captureDestination(exchange, channel, exitSpan);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 162}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5Mjg4OTUwOnYy", "diffSide": "RIGHT", "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozNzoxM1rOIDSdHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozNzoxM1rOIDSdHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMxOTAwNw==", "bodyText": "Use the normalized exchange name", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540319007", "createdAt": "2020-12-10T16:37:13Z", "author": {"login": "eyalkoren"}, "path": "apm-agent-plugins/apm-rabbitmq/apm-rabbitmq-plugin/src/main/java/co/elastic/apm/agent/rabbitmq/ChannelInstrumentation.java", "diffHunk": "@@ -0,0 +1,311 @@\n+/*-\n+ * #%L\n+ * Elastic APM Java agent\n+ * %%\n+ * Copyright (C) 2018 - 2020 Elastic and contributors\n+ * %%\n+ * Licensed to Elasticsearch B.V. under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch B.V. licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *   http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ * #L%\n+ */\n+package co.elastic.apm.agent.rabbitmq;\n+\n+import co.elastic.apm.agent.impl.ElasticApmTracer;\n+import co.elastic.apm.agent.impl.context.Destination;\n+import co.elastic.apm.agent.impl.transaction.AbstractSpan;\n+import co.elastic.apm.agent.impl.transaction.Span;\n+import co.elastic.apm.agent.rabbitmq.header.RabbitMQTextHeaderSetter;\n+import co.elastic.apm.agent.sdk.DynamicTransformer;\n+import co.elastic.apm.agent.sdk.ElasticApmInstrumentation;\n+import co.elastic.apm.agent.sdk.advice.AssignTo;\n+import com.rabbitmq.client.AMQP;\n+import com.rabbitmq.client.Channel;\n+import com.rabbitmq.client.Connection;\n+import com.rabbitmq.client.Consumer;\n+import com.rabbitmq.client.Envelope;\n+import com.rabbitmq.client.GetResponse;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.description.NamedElement;\n+import net.bytebuddy.description.method.MethodDescription;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.matcher.ElementMatcher;\n+\n+import javax.annotation.Nullable;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static co.elastic.apm.agent.bci.bytebuddy.CustomElementMatchers.classLoaderCanLoadClass;\n+import static net.bytebuddy.matcher.ElementMatchers.hasSuperType;\n+import static net.bytebuddy.matcher.ElementMatchers.isBootstrapClassLoader;\n+import static net.bytebuddy.matcher.ElementMatchers.nameContains;\n+import static net.bytebuddy.matcher.ElementMatchers.nameStartsWith;\n+import static net.bytebuddy.matcher.ElementMatchers.named;\n+import static net.bytebuddy.matcher.ElementMatchers.not;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArgument;\n+import static net.bytebuddy.matcher.ElementMatchers.takesArguments;\n+\n+/**\n+ * Instruments implementations of {@link com.rabbitmq.client.Channel}\n+ */\n+public abstract class ChannelInstrumentation extends BaseInstrumentation {\n+\n+    public ChannelInstrumentation(ElasticApmTracer tracer) {\n+        super(tracer);\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super NamedElement> getTypeMatcherPreFilter() {\n+        return nameStartsWith(\"com.rabbitmq.client\")\n+            .and(nameContains(\"Channel\"));\n+    }\n+\n+    @Override\n+    public ElementMatcher<? super TypeDescription> getTypeMatcher() {\n+        return hasSuperType(named(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+\n+    @Override\n+    public ElementMatcher.Junction<ClassLoader> getClassLoaderMatcher() {\n+        return not(isBootstrapClassLoader()).and(classLoaderCanLoadClass(\"com.rabbitmq.client.Channel\"));\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicConsume} to ensure instrumentation of {@link com.rabbitmq.client.Consumer} implementation</li>\n+     * </ul>\n+     */\n+    public static class BasicConsume extends ChannelInstrumentation {\n+\n+        public static final Collection<Class<? extends ElasticApmInstrumentation>> CONSUMER_INSTRUMENTATION =\n+            Collections.<Class<? extends ElasticApmInstrumentation>>singleton(ConsumerInstrumentation.class);\n+\n+        public BasicConsume(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicConsume\")\n+                .and(takesArguments(7))\n+                .and(takesArgument(6, named(\"com.rabbitmq.client.Consumer\")));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static void onEnter(@Advice.This Channel channel,\n+                                   @Advice.Argument(6) @Nullable Consumer consumer) {\n+            if (consumer == null) {\n+                return;\n+            }\n+\n+            DynamicTransformer.Accessor.get().ensureInstrumented(consumer.getClass(), CONSUMER_INSTRUMENTATION);\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicPublish}</li>\n+     * </ul>\n+     */\n+    public static class BasicPublish extends ChannelInstrumentation {\n+\n+        public BasicPublish(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicPublish\")\n+                .and(takesArguments(6));\n+        }\n+\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        @AssignTo(arguments = @AssignTo.Argument(index = 0, value = 4))\n+        @Nullable\n+        public static Object[] onBasicPublish(@Advice.This Channel channel,\n+                                              @Advice.Argument(0) @Nullable String exchange,\n+                                              @Advice.Argument(4) @Nullable AMQP.BasicProperties properties) {\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            Span exitSpan = createExitSpan(exchange);\n+            if (exitSpan == null) {\n+                // tracer disabled or ignored exchange\n+                return null;\n+            }\n+\n+            exitSpan.withAction(\"send\")\n+                .withName(\"RabbitMQ SEND to \").appendToName(normalizeExchangeName(exchange));\n+\n+            properties = propagateTraceContext(exitSpan, properties);\n+\n+            captureMessage(exchange, properties, exitSpan);\n+            captureDestination(exchange, channel, exitSpan);\n+\n+            return new Object[]{properties, exitSpan};\n+        }\n+\n+        private static AMQP.BasicProperties propagateTraceContext(Span exitSpan,\n+                                                                  @Nullable AMQP.BasicProperties originalBasicProperties) {\n+            AMQP.BasicProperties properties = originalBasicProperties;\n+            if (properties == null) {\n+                properties = new AMQP.BasicProperties();\n+            }\n+\n+            Map<String, Object> currentHeaders = properties.getHeaders();\n+            if (currentHeaders == null) {\n+                currentHeaders = new HashMap<>();\n+            }\n+\n+            HashMap<String, Object> headersWithContext = new HashMap<>(currentHeaders);\n+\n+            exitSpan.propagateTraceContext(headersWithContext, RabbitMQTextHeaderSetter.INSTANCE);\n+\n+            return properties.builder().headers(headersWithContext).build();\n+        }\n+\n+        @Advice.OnMethodExit(onThrowable = Throwable.class, suppress = Throwable.class, inline = false)\n+        public static void afterBasicPublish(@Advice.Enter @Nullable Object[] enterArray,\n+                                             @Advice.Thrown @Nullable Throwable throwable) {\n+            if (enterArray != null && enterArray.length >= 2 && enterArray[1] != null) {\n+                Span span = (Span) enterArray[1];\n+                span.captureException(throwable)\n+                    .deactivate()\n+                    .end();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Instruments\n+     * <ul>\n+     *     <li>{@link com.rabbitmq.client.Channel#basicGet}</li>\n+     * </ul>\n+     */\n+    public static class BasicGet extends ChannelInstrumentation {\n+\n+        public BasicGet(ElasticApmTracer tracer) {\n+            super(tracer);\n+        }\n+\n+        @Override\n+        public ElementMatcher<? super MethodDescription> getMethodMatcher() {\n+            return named(\"basicGet\")\n+                .and(takesArgument(0, String.class));\n+        }\n+\n+        @Nullable\n+        @Advice.OnMethodEnter(suppress = Throwable.class, inline = false)\n+        public static Object onEnter(@Advice.Argument(0) @Nullable String queue) {\n+\n+            if (!tracer.isRunning()) {\n+                return null;\n+            }\n+\n+            return createExitSpan(normalizeQueueName(queue));\n+        }\n+\n+        @Advice.OnMethodExit(suppress = Throwable.class, onThrowable = Throwable.class, inline = false)\n+        public static void onExit(@Advice.This Channel channel,\n+                                  @Advice.Argument(0) String queue,\n+                                  @Advice.Enter @Nullable Object objSpan,\n+                                  @Advice.Return @Nullable GetResponse rv,\n+                                  @Advice.Thrown @Nullable Throwable thrown) {\n+\n+            if (!(objSpan instanceof Span)) {\n+                return;\n+            }\n+            Span span = (Span) objSpan;\n+\n+            if (isIgnored(queue)) {\n+                // allow to ignore on queue name when there is no answer\n+                span.requestDiscarding();\n+            }\n+\n+            span.withAction(\"poll\")\n+                .withName(\"RabbitMQ POLL from \").appendToName(normalizeQueueName(queue));\n+\n+            Envelope envelope = null;\n+            AMQP.BasicProperties properties = null;\n+\n+            if (rv != null) {\n+                envelope = rv.getEnvelope();\n+                properties = rv.getProps();\n+            }\n+\n+            String exchange = \"\";\n+\n+            if (null != envelope) {\n+                // since exchange name is only known when receiving the message, we might have to discard it\n+                if (isIgnored(envelope.getExchange())) {\n+                    span.requestDiscarding();\n+                }\n+            }\n+            captureMessage(queue, properties, span);\n+            captureDestination(exchange, channel, span);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 264}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjkwNjY4OnYy", "diffSide": "RIGHT", "path": "docs/supported-technologies.asciidoc", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozOTo1NFrOIDSoHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjozOTo1NFrOIDSoHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMyMTgyMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            |1.19.1\n          \n          \n            \n            |1.20.0", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540321823", "createdAt": "2020-12-10T16:39:54Z", "author": {"login": "eyalkoren"}, "path": "docs/supported-technologies.asciidoc", "diffHunk": "@@ -356,8 +356,22 @@ If both producer and consumer are traced, then distributed tracing is supported,\n side will be a part of the same trace containing the producer side as well. Kafka streams are not traced.\n |1.13.0\n \n+|RabbitMQ\n+|3.x - 5.x\n+|The agent captures RabbitMQ Message sends, consumption and polling.\n+When the producer sends a message within a traced transaction, a send span will be created and the transaction resulting\n+from the message consumption will be correlated to the same trace.\n+When a message is consumed, a transaction is created, regardless if the send action is traced.\n+When a message is polled, a span is created for the polling operation and optionally have message fields if a message\n+has been returned.\n+|1.19.1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5MjkxMDc1OnYy", "diffSide": "RIGHT", "path": "docs/supported-technologies.asciidoc", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo0MDozOVrOIDSqyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQxNjo0MDozOVrOIDSqyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDMyMjUwNw==", "bodyText": "Always with the exchange, normalized when it is the default", "url": "https://github.com/elastic/apm-agent-java/pull/1328#discussion_r540322507", "createdAt": "2020-12-10T16:40:39Z", "author": {"login": "eyalkoren"}, "path": "docs/supported-technologies.asciidoc", "diffHunk": "@@ -356,8 +356,22 @@ If both producer and consumer are traced, then distributed tracing is supported,\n side will be a part of the same trace containing the producer side as well. Kafka streams are not traced.\n |1.13.0\n \n+|RabbitMQ\n+|3.x - 5.x\n+|The agent captures RabbitMQ Message sends, consumption and polling.\n+When the producer sends a message within a traced transaction, a send span will be created and the transaction resulting\n+from the message consumption will be correlated to the same trace.\n+When a message is consumed, a transaction is created, regardless if the send action is traced.\n+When a message is polled, a span is created for the polling operation and optionally have message fields if a message\n+has been returned.\n+|1.19.1\n+\n |===\n \n+For RabbitMQ:\n+\n+- `context.message.queue.name` field will contain queue name when using polling, exchange name otherwise.\n+- `context.message.destination.resource` field will contain `rabbitmq` for the default exchange and `rabbitmq/XXX` for named exchanges", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ebeb047dae016bf8319b83e549404cb4d5b6552"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 205, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}