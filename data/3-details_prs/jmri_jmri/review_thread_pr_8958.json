{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxOTY1ODcz", "number": 8958, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNDoyMzowOFrOEbOH2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNDoyNToyMVrOEbOIjA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTc4Mzk0OnYy", "diffSide": "RIGHT", "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNDoyMzowOFrOHFFjQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNTowMDo0MlrOHFFv9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NTg3NA==", "bodyText": "(Not a request for change, I'm just curious) Why do you handle NEGATIVE_INFINITY and POSITIVE_INFINITY with a IllegalArgumentException, and outside min-max with a JmriException?  The JmriException appears in the signature and has to be caught in any case.", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475095874", "createdAt": "2020-08-22T14:23:08Z", "author": {"login": "bobjacobsen"}, "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package jmri.implementation;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckReturnValue;\n+import jmri.JmriException;\n+import jmri.NamedBean;\n+import jmri.AnalogIO;\n+\n+/**\n+ * Base implementation of the AnalogIO interface.\n+ *\n+ * @author Daniel Bergqvist Copyright (c) 2018\n+ */\n+public abstract class AbstractAnalogIO extends AbstractNamedBean implements AnalogIO {\n+\n+    private double _commandedValue = 0.0;\n+    private double _knownValue = 0.0;\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name\n+     *\n+     * @param systemName AnalogIO system name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName) {\n+        super(systemName);\n+    }\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name and user name\n+     *\n+     * @param systemName AnalogIO system name\n+     * @param userName   AnalogIO user name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName, @CheckForNull String userName) {\n+        super(systemName, userName);\n+    }\n+\n+    /**\n+     * Sends the string to the layout.\n+     * The string [u]must not[/u] be longer than the value of getMaximumLength()\n+     * unless that value is zero. Some microcomputers have little memory and\n+     * it's very important that this method is never called with too long strings.\n+     *\n+     * @param value the desired string value\n+     * @throws jmri.JmriException general error when setting the value fails\n+     */\n+    abstract protected void sendValueToLayout(double value) throws JmriException;\n+\n+    /**\n+     * Set the string of this AnalogIO.Called from the implementation class\n+     * when the layout updates this AnalogIO.\n+     * \n+     * @param newValue the new value\n+     */\n+    protected void setValue(double newValue) {\n+        Object _old = this._knownValue;\n+        this._knownValue = newValue;\n+        firePropertyChange(\"State\", _old, _knownValue); //NOI18N\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setCommandedAnalogValue(double value) throws JmriException {\n+        if (value == Double.NEGATIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is negative infinity\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5ODgzNg==", "bodyText": "Good point. There is a difference between the two cases. NEGATIVE_INFINITY, POSITIVE_INFINITY and NaN is always illegal, and if it happens, it's a software error.\nBut a value outside min and max may or may not be valid depending on cutOutOfBoundsValues(). So for one device, a value too small or too big could be valid, and for another device it could be invalid. A good example for StringIO devices is that a filename for a MP3 player that gets truncated is invalid, but a string to be displayed on a small screen is valid. It's no problem if you don't see the entire string on the screen, but if the filename is truncated, the MP3 player will look for a different file.\nA possible example for AnalogIO could be that a position for a servo is invalid outside min and max, but the intensity of a light could be safe to truncate.", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475098836", "createdAt": "2020-08-22T14:57:28Z", "author": {"login": "danielb987"}, "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package jmri.implementation;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckReturnValue;\n+import jmri.JmriException;\n+import jmri.NamedBean;\n+import jmri.AnalogIO;\n+\n+/**\n+ * Base implementation of the AnalogIO interface.\n+ *\n+ * @author Daniel Bergqvist Copyright (c) 2018\n+ */\n+public abstract class AbstractAnalogIO extends AbstractNamedBean implements AnalogIO {\n+\n+    private double _commandedValue = 0.0;\n+    private double _knownValue = 0.0;\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name\n+     *\n+     * @param systemName AnalogIO system name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName) {\n+        super(systemName);\n+    }\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name and user name\n+     *\n+     * @param systemName AnalogIO system name\n+     * @param userName   AnalogIO user name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName, @CheckForNull String userName) {\n+        super(systemName, userName);\n+    }\n+\n+    /**\n+     * Sends the string to the layout.\n+     * The string [u]must not[/u] be longer than the value of getMaximumLength()\n+     * unless that value is zero. Some microcomputers have little memory and\n+     * it's very important that this method is never called with too long strings.\n+     *\n+     * @param value the desired string value\n+     * @throws jmri.JmriException general error when setting the value fails\n+     */\n+    abstract protected void sendValueToLayout(double value) throws JmriException;\n+\n+    /**\n+     * Set the string of this AnalogIO.Called from the implementation class\n+     * when the layout updates this AnalogIO.\n+     * \n+     * @param newValue the new value\n+     */\n+    protected void setValue(double newValue) {\n+        Object _old = this._knownValue;\n+        this._knownValue = newValue;\n+        firePropertyChange(\"State\", _old, _knownValue); //NOI18N\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setCommandedAnalogValue(double value) throws JmriException {\n+        if (value == Double.NEGATIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is negative infinity\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NTg3NA=="}, "originalCommit": {"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5OTEyNQ==", "bodyText": "If you look at the JavaDoc for AnalogIO, it clearly tells that NEGATIVE_INFINITY, POSITIVE_INFINITY and NaN will throw an IllegalArgumentException.\nhttps://github.com/JMRI/JMRI/blob/master/java/src/jmri/AnalogIO.java#L50", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475099125", "createdAt": "2020-08-22T15:00:42Z", "author": {"login": "danielb987"}, "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package jmri.implementation;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckReturnValue;\n+import jmri.JmriException;\n+import jmri.NamedBean;\n+import jmri.AnalogIO;\n+\n+/**\n+ * Base implementation of the AnalogIO interface.\n+ *\n+ * @author Daniel Bergqvist Copyright (c) 2018\n+ */\n+public abstract class AbstractAnalogIO extends AbstractNamedBean implements AnalogIO {\n+\n+    private double _commandedValue = 0.0;\n+    private double _knownValue = 0.0;\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name\n+     *\n+     * @param systemName AnalogIO system name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName) {\n+        super(systemName);\n+    }\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name and user name\n+     *\n+     * @param systemName AnalogIO system name\n+     * @param userName   AnalogIO user name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName, @CheckForNull String userName) {\n+        super(systemName, userName);\n+    }\n+\n+    /**\n+     * Sends the string to the layout.\n+     * The string [u]must not[/u] be longer than the value of getMaximumLength()\n+     * unless that value is zero. Some microcomputers have little memory and\n+     * it's very important that this method is never called with too long strings.\n+     *\n+     * @param value the desired string value\n+     * @throws jmri.JmriException general error when setting the value fails\n+     */\n+    abstract protected void sendValueToLayout(double value) throws JmriException;\n+\n+    /**\n+     * Set the string of this AnalogIO.Called from the implementation class\n+     * when the layout updates this AnalogIO.\n+     * \n+     * @param newValue the new value\n+     */\n+    protected void setValue(double newValue) {\n+        Object _old = this._knownValue;\n+        this._knownValue = newValue;\n+        firePropertyChange(\"State\", _old, _knownValue); //NOI18N\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setCommandedAnalogValue(double value) throws JmriException {\n+        if (value == Double.NEGATIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is negative infinity\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NTg3NA=="}, "originalCommit": {"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTc4NTcyOnYy", "diffSide": "RIGHT", "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNDoyNToyMVrOHFFkCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNDoyNToyMVrOHFFkCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NjA3NQ==", "bodyText": "(Again, not a request for change). Particularly for scripting, have getState() and setState() work can be very helpful; Python programmers tend to expect it.  Would it make sense to add a getState(double ..)?  And have getState return the (nearest?) int value?", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475096075", "createdAt": "2020-08-22T14:25:21Z", "author": {"login": "bobjacobsen"}, "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package jmri.implementation;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckReturnValue;\n+import jmri.JmriException;\n+import jmri.NamedBean;\n+import jmri.AnalogIO;\n+\n+/**\n+ * Base implementation of the AnalogIO interface.\n+ *\n+ * @author Daniel Bergqvist Copyright (c) 2018\n+ */\n+public abstract class AbstractAnalogIO extends AbstractNamedBean implements AnalogIO {\n+\n+    private double _commandedValue = 0.0;\n+    private double _knownValue = 0.0;\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name\n+     *\n+     * @param systemName AnalogIO system name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName) {\n+        super(systemName);\n+    }\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name and user name\n+     *\n+     * @param systemName AnalogIO system name\n+     * @param userName   AnalogIO user name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName, @CheckForNull String userName) {\n+        super(systemName, userName);\n+    }\n+\n+    /**\n+     * Sends the string to the layout.\n+     * The string [u]must not[/u] be longer than the value of getMaximumLength()\n+     * unless that value is zero. Some microcomputers have little memory and\n+     * it's very important that this method is never called with too long strings.\n+     *\n+     * @param value the desired string value\n+     * @throws jmri.JmriException general error when setting the value fails\n+     */\n+    abstract protected void sendValueToLayout(double value) throws JmriException;\n+\n+    /**\n+     * Set the string of this AnalogIO.Called from the implementation class\n+     * when the layout updates this AnalogIO.\n+     * \n+     * @param newValue the new value\n+     */\n+    protected void setValue(double newValue) {\n+        Object _old = this._knownValue;\n+        this._knownValue = newValue;\n+        firePropertyChange(\"State\", _old, _knownValue); //NOI18N\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setCommandedAnalogValue(double value) throws JmriException {\n+        if (value == Double.NEGATIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is negative infinity\");\n+        }\n+        if (value == Double.POSITIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is positive infinity\");\n+        }\n+        if (Double.isNaN(value)) {\n+            throw new IllegalArgumentException(\"value is not-a-number\");\n+        }\n+        \n+        double min = getMin();\n+        double max = getMax();\n+        \n+        if (value < min) {\n+            if (cutOutOfBoundsValues()) value = min;\n+            else throw new JmriException(\"value out of bounds\");\n+        }\n+        if (value > max) {\n+            if (cutOutOfBoundsValues()) value = max;\n+            else throw new JmriException(\"value out of bounds\");\n+        }\n+        _commandedValue = value;\n+        sendValueToLayout(_commandedValue);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    @Nonnull\n+    public double getCommandedAnalogValue() {\n+        return _commandedValue;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getKnownAnalogValue() {\n+        return _knownValue;\n+    }\n+\n+    /**\n+     * Cut out of bounds values instead of throwing an exception?\n+     * For example, if the AnalogIO is a display, it could be desired to\n+     * accept too long strings.\n+     * On the other hand, if the AnalogIO is used to send a command, a too\n+     * long string is an error.\n+     *\n+     * @return true if long strings should be cut\n+     */\n+    abstract protected boolean cutOutOfBoundsValues();\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getState() {\n+        // A AnalogIO doesn't have a state\n+        return NamedBean.UNKNOWN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setState(int newState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd"}, "originalPosition": 123}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4469, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}