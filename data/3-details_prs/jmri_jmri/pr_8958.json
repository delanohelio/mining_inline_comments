{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDcxOTY1ODcz", "number": 8958, "title": "Add AnalogIOManager and StringIOManager", "bodyText": "Replaces #8641 and #8645.", "createdAt": "2020-08-22T09:39:13Z", "url": "https://github.com/JMRI/JMRI/pull/8958", "merged": true, "mergeCommit": {"oid": "f1bd6cc7f1f335d5d9b9cc3ecea720347ecf4715"}, "closed": true, "closedAt": "2020-08-23T14:42:24Z", "author": {"login": "danielb987"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdBVQT_gH2gAyNDcxOTY1ODczOmFlZmE2ODUyN2FhNmIxOTQ2YjQ4NjExODFmYzZhYjA5YjAzYjU4YmQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdBnuLpAFqTQ3Mjk4MjM4MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd", "author": {"user": {"login": "danielb987", "name": "Daniel"}}, "url": "https://github.com/JMRI/JMRI/commit/aefa68527aa6b1946b4861181fc6ab09b03b58bd", "committedDate": "2020-08-22T08:36:59Z", "message": "Add AnalogIOManager and StringIOManager"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTI5NzQ3", "url": "https://github.com/JMRI/JMRI/pull/8958#pullrequestreview-472929747", "createdAt": "2020-08-22T14:23:07Z", "commit": {"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd"}, "state": "DISMISSED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNDoyMzowOFrOHFFjQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNDoyNToyMVrOHFFkCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NTg3NA==", "bodyText": "(Not a request for change, I'm just curious) Why do you handle NEGATIVE_INFINITY and POSITIVE_INFINITY with a IllegalArgumentException, and outside min-max with a JmriException?  The JmriException appears in the signature and has to be caught in any case.", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475095874", "createdAt": "2020-08-22T14:23:08Z", "author": {"login": "bobjacobsen"}, "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package jmri.implementation;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckReturnValue;\n+import jmri.JmriException;\n+import jmri.NamedBean;\n+import jmri.AnalogIO;\n+\n+/**\n+ * Base implementation of the AnalogIO interface.\n+ *\n+ * @author Daniel Bergqvist Copyright (c) 2018\n+ */\n+public abstract class AbstractAnalogIO extends AbstractNamedBean implements AnalogIO {\n+\n+    private double _commandedValue = 0.0;\n+    private double _knownValue = 0.0;\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name\n+     *\n+     * @param systemName AnalogIO system name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName) {\n+        super(systemName);\n+    }\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name and user name\n+     *\n+     * @param systemName AnalogIO system name\n+     * @param userName   AnalogIO user name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName, @CheckForNull String userName) {\n+        super(systemName, userName);\n+    }\n+\n+    /**\n+     * Sends the string to the layout.\n+     * The string [u]must not[/u] be longer than the value of getMaximumLength()\n+     * unless that value is zero. Some microcomputers have little memory and\n+     * it's very important that this method is never called with too long strings.\n+     *\n+     * @param value the desired string value\n+     * @throws jmri.JmriException general error when setting the value fails\n+     */\n+    abstract protected void sendValueToLayout(double value) throws JmriException;\n+\n+    /**\n+     * Set the string of this AnalogIO.Called from the implementation class\n+     * when the layout updates this AnalogIO.\n+     * \n+     * @param newValue the new value\n+     */\n+    protected void setValue(double newValue) {\n+        Object _old = this._knownValue;\n+        this._knownValue = newValue;\n+        firePropertyChange(\"State\", _old, _knownValue); //NOI18N\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setCommandedAnalogValue(double value) throws JmriException {\n+        if (value == Double.NEGATIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is negative infinity\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA5NjA3NQ==", "bodyText": "(Again, not a request for change). Particularly for scripting, have getState() and setState() work can be very helpful; Python programmers tend to expect it.  Would it make sense to add a getState(double ..)?  And have getState return the (nearest?) int value?", "url": "https://github.com/JMRI/JMRI/pull/8958#discussion_r475096075", "createdAt": "2020-08-22T14:25:21Z", "author": {"login": "bobjacobsen"}, "path": "java/src/jmri/implementation/AbstractAnalogIO.java", "diffHunk": "@@ -0,0 +1,145 @@\n+package jmri.implementation;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nonnull;\n+import javax.annotation.CheckReturnValue;\n+import jmri.JmriException;\n+import jmri.NamedBean;\n+import jmri.AnalogIO;\n+\n+/**\n+ * Base implementation of the AnalogIO interface.\n+ *\n+ * @author Daniel Bergqvist Copyright (c) 2018\n+ */\n+public abstract class AbstractAnalogIO extends AbstractNamedBean implements AnalogIO {\n+\n+    private double _commandedValue = 0.0;\n+    private double _knownValue = 0.0;\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name\n+     *\n+     * @param systemName AnalogIO system name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName) {\n+        super(systemName);\n+    }\n+\n+    /**\n+     * Abstract constructor for new AnalogIO with system name and user name\n+     *\n+     * @param systemName AnalogIO system name\n+     * @param userName   AnalogIO user name\n+     */\n+    public AbstractAnalogIO(@Nonnull String systemName, @CheckForNull String userName) {\n+        super(systemName, userName);\n+    }\n+\n+    /**\n+     * Sends the string to the layout.\n+     * The string [u]must not[/u] be longer than the value of getMaximumLength()\n+     * unless that value is zero. Some microcomputers have little memory and\n+     * it's very important that this method is never called with too long strings.\n+     *\n+     * @param value the desired string value\n+     * @throws jmri.JmriException general error when setting the value fails\n+     */\n+    abstract protected void sendValueToLayout(double value) throws JmriException;\n+\n+    /**\n+     * Set the string of this AnalogIO.Called from the implementation class\n+     * when the layout updates this AnalogIO.\n+     * \n+     * @param newValue the new value\n+     */\n+    protected void setValue(double newValue) {\n+        Object _old = this._knownValue;\n+        this._knownValue = newValue;\n+        firePropertyChange(\"State\", _old, _knownValue); //NOI18N\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setCommandedAnalogValue(double value) throws JmriException {\n+        if (value == Double.NEGATIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is negative infinity\");\n+        }\n+        if (value == Double.POSITIVE_INFINITY) {\n+            throw new IllegalArgumentException(\"value is positive infinity\");\n+        }\n+        if (Double.isNaN(value)) {\n+            throw new IllegalArgumentException(\"value is not-a-number\");\n+        }\n+        \n+        double min = getMin();\n+        double max = getMax();\n+        \n+        if (value < min) {\n+            if (cutOutOfBoundsValues()) value = min;\n+            else throw new JmriException(\"value out of bounds\");\n+        }\n+        if (value > max) {\n+            if (cutOutOfBoundsValues()) value = max;\n+            else throw new JmriException(\"value out of bounds\");\n+        }\n+        _commandedValue = value;\n+        sendValueToLayout(_commandedValue);\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    @Nonnull\n+    public double getCommandedAnalogValue() {\n+        return _commandedValue;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public double getKnownAnalogValue() {\n+        return _knownValue;\n+    }\n+\n+    /**\n+     * Cut out of bounds values instead of throwing an exception?\n+     * For example, if the AnalogIO is a display, it could be desired to\n+     * accept too long strings.\n+     * On the other hand, if the AnalogIO is used to send a command, a too\n+     * long string is an error.\n+     *\n+     * @return true if long strings should be cut\n+     */\n+    abstract protected boolean cutOutOfBoundsValues();\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public int getState() {\n+        // A AnalogIO doesn't have a state\n+        return NamedBean.UNKNOWN;\n+    }\n+\n+    /** {@inheritDoc} */\n+    @Override\n+    public void setState(int newState) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aefa68527aa6b1946b4861181fc6ab09b03b58bd"}, "originalPosition": 123}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a9e5f867014e639fdafaf93ab2aed5f7c88d44f", "author": {"user": {"login": "danielb987", "name": "Daniel"}}, "url": "https://github.com/JMRI/JMRI/commit/8a9e5f867014e639fdafaf93ab2aed5f7c88d44f", "committedDate": "2020-08-22T21:53:43Z", "message": "Add feedback mode. Add setState(double)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7b3b4fe46a0cd20181364e59a581260db5659e4c", "author": {"user": {"login": "danielb987", "name": "Daniel"}}, "url": "https://github.com/JMRI/JMRI/commit/7b3b4fe46a0cd20181364e59a581260db5659e4c", "committedDate": "2020-08-22T23:57:19Z", "message": "Fix error in test. Remove FeedbackMode"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTgyMzgx", "url": "https://github.com/JMRI/JMRI/pull/8958#pullrequestreview-472982381", "createdAt": "2020-08-23T06:07:54Z", "commit": {"oid": "7b3b4fe46a0cd20181364e59a581260db5659e4c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3994, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}