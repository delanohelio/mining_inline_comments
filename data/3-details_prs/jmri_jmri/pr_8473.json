{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNDE4NjA5", "number": 8473, "title": "Cleanup of duplicate / inefficient code working with XNetReply feedback.", "bodyText": "During work on NanoX support, when I went through XNetTurnout code, it seemed that there are identical branches duplicated. Also digging bits by their value, or odd/even numbers seems inappropriate for \"layout object\" level: could be better encapsulated in XpressNet protocol classes.\nAnd indeed, XNetSensor and XNetFeedbackMessageCache also contains similar code replicas.\nI played a \"what-if\" game so I can reduce the logic code before major refactoring in NanoX specific code. I've decided to contribute that back.\nThe core idea is to abstract a FeedbackItem that describes a single turnout feedback, or a feedback module's nibble. XNetReply then can search for FeedbackItems. That way, XNetTurnout or XNetSensor can:\n\ndetermine if there is a relevant feedback\nnot worry about odd/even numbers\n\nThe code is somewhat cleaner afterwards. No semantic changes done\nOther changes\n\nFeedback message cache\n\nreplaced unnecessary double-indexing by linearizing address+nibble.\nremoved catch (NullPointerException) that potential masks code erros\nfixed bug: cache only worked with 1st item in a multi-item feedback broadcast\n\n\nXNetReply\n\nreduced complex if-else-if-else with complex bitwise operations\n\n\nXNetTurnout\n\nremoved usage of j.u.concurrent classes: they are meant for high-contention environments, and synchronization here is external (in Turnout object) anyway\nremoved redundant nested synchronized()\nsimplified queue operations, removed unnecessary interrupt handling", "createdAt": "2020-05-02T08:29:02Z", "url": "https://github.com/JMRI/JMRI/pull/8473", "merged": true, "mergeCommit": {"oid": "138bd54cf1a429fcdc41419c84fc6ce873257e37"}, "closed": true, "closedAt": "2020-05-06T15:04:54Z", "author": {"login": "svatoun"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcdR8W-AH2gAyNDEyNDE4NjA5Ojk4MDg0MWMwZTRiMTUzMjkzNDk3ZTRlOWQyNTQ0NGZmZWJhZmQ5NTM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceauEuABqjMzMDYwMzQ4Mzc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "980841c0e4b153293497e4e9d25444ffebafd953", "author": {"user": {"login": "svatoun", "name": "Svata Dedic"}}, "url": "https://github.com/JMRI/JMRI/commit/980841c0e4b153293497e4e9d25444ffebafd953", "committedDate": "2020-05-02T08:24:12Z", "message": "Cleanup of duplicate / inefficient code working with XNetReply feedback."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTM3OTMy", "url": "https://github.com/JMRI/JMRI/pull/8473#pullrequestreview-404537932", "createdAt": "2020-05-02T15:40:34Z", "commit": {"oid": "980841c0e4b153293497e4e9d25444ffebafd953"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxNTo0MDozNFrOGPkFIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxNTo0NDo0NlrOGPkHNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3Mjk2Mw==", "bodyText": "Why a Deque here?  we really only need a Queue.  Seems like extra overhead.", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418972963", "createdAt": "2020-05-02T15:40:34Z", "author": {"login": "pabender"}, "path": "java/src/jmri/jmrix/lenz/XNetTurnout.java", "diffHunk": "@@ -132,7 +134,7 @@ public XNetTurnout(String prefix, int pNumber, XNetTrafficController controller)\n         _prefix = prefix;\n         mNumber = pNumber;\n \n-        requestList = new LinkedBlockingQueue<>();\n+        requestList = new ArrayDeque<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980841c0e4b153293497e4e9d25444ffebafd953"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzQyMw==", "bodyText": "Removing this may be problematic.\nThe feedback has to be able to trigger an off message.\nI will need to verify this works with real hardware.", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418973423", "createdAt": "2020-05-02T15:44:17Z", "author": {"login": "pabender"}, "path": "java/src/jmri/jmrix/lenz/XNetTurnout.java", "diffHunk": "@@ -385,35 +383,23 @@ private synchronized void handleDirectModeFeedback(XNetReply l) {\n             l.resetUnsolicited();\n         }\n         if (getCommandedState() != getKnownState() || internalState == COMMANDSENT) {\n-            if (l.isFeedbackBroadcastMessage()) {\n-                int numDataBytes = l.getElement(0) & 0x0f;\n-                for (int i = 1; i < numDataBytes; i += 2) {\n-                    int messageType = l.getFeedbackMessageType(i);\n-                    if (messageType == 0 || messageType == 1) {\n-                        if ((mNumber % 2 != 0\n-                                && (l.getTurnoutMsgAddr(i) == mNumber))\n-                                || (((mNumber % 2) == 0)\n-                                && (l.getTurnoutMsgAddr(i) == mNumber - 1))) {\n-                            // This message includes feedback for this turnout\n-                            log.debug(\"Turnout {} DIRECT feedback mode - directed reply received.\", mNumber);\n-                            // set the reply as being solicited\n-                            if (l.isUnsolicited()) {\n-                                l.resetUnsolicited();\n-                            }\n-                            sendOffMessage();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980841c0e4b153293497e4e9d25444ffebafd953"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODk3MzQ5NA==", "bodyText": "Removing this may be problematic.\nThe feedback has to be able to trigger an off message.\nI will need to verify this works with real hardware.", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r418973494", "createdAt": "2020-05-02T15:44:46Z", "author": {"login": "pabender"}, "path": "java/src/jmri/jmrix/lenz/XNetTurnout.java", "diffHunk": "@@ -435,41 +421,26 @@ private synchronized void handleMonitoringModeFeedback(XNetReply l) {\n          */\n         log.debug(\"Handle Message for turnout {} in MONITORING feedback mode \", mNumber);\n         if (internalState == IDLE || internalState == STATUSREQUESTSENT) {\n-            if (l.isFeedbackBroadcastMessage()) {\n-                // This is a feedback message, we need to check and see if it\n-                // indicates this turnout is to change state or if it is for\n-                // another turnout.\n-                int numDataBytes = l.getElement(0) & 0x0f;\n-                for (int i = 1; i < numDataBytes; i += 2) {\n-                    if (parseFeedbackMessage(l, i) != -1) {\n-                        log.debug(\"Turnout {} MONITORING feedback mode - state change from feedback.\", mNumber);\n-                        break;\n-                    }\n-                }\n+            if (l.onTurnoutFeedback(mNumber, this::parseFeedbackMessage)) {\n+                log.debug(\"Turnout {} MONITORING feedback mode - state change from feedback.\", mNumber);\n             }\n         } else if (getCommandedState() != getKnownState()\n                 || internalState == COMMANDSENT) {\n-            if (l.isFeedbackBroadcastMessage()) {\n-                int numDataBytes = l.getElement(0) & 0x0f;\n-                for (int i = 1; i < numDataBytes; i += 2) {\n-                    int messageType = l.getFeedbackMessageType(i);\n-                    if (messageType == 0 || messageType == 1) {\n-                        // In Monitoring mode, treat both turnouts with feedback\n-                        // and turnouts without feedback as turnouts without\n-                        // feedback.  i.e. just interpret the feedback\n-                        // message, don't check to see if the motion is complete\n-                        if (parseFeedbackMessage(l, i) != -1) {\n-                            // We need to tell the turnout to shut off the output.\n-                            log.debug(\"Turnout {} MONITORING feedback mode - state change from feedback, CommandedState != KnownState.\", mNumber);\n-                            sendOffMessage();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "980841c0e4b153293497e4e9d25444ffebafd953"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTQxNjU1", "url": "https://github.com/JMRI/JMRI/pull/8473#pullrequestreview-404541655", "createdAt": "2020-05-02T16:31:56Z", "commit": {"oid": "980841c0e4b153293497e4e9d25444ffebafd953"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "86dc156a5c34e18d24614ad8031acd6b6b9430cc", "author": {"user": {"login": "svatoun", "name": "Svata Dedic"}}, "url": "https://github.com/JMRI/JMRI/commit/86dc156a5c34e18d24614ad8031acd6b6b9430cc", "committedDate": "2020-05-02T17:18:36Z", "message": "Use simpler collection, just Queue is needed."}, "afterCommit": {"oid": "211379d6f4fc3664330485e53a6b779f0cc9d204", "author": {"user": {"login": "svatoun", "name": "Svata Dedic"}}, "url": "https://github.com/JMRI/JMRI/commit/211379d6f4fc3664330485e53a6b779f0cc9d204", "committedDate": "2020-05-02T18:09:42Z", "message": "Use simpler collection, just Queue is needed."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTc2MjIw", "url": "https://github.com/JMRI/JMRI/pull/8473#pullrequestreview-404576220", "createdAt": "2020-05-03T02:33:31Z", "commit": {"oid": "211379d6f4fc3664330485e53a6b779f0cc9d204"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QwMjozMzozMVrOGPn9XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QwMjozMzozMVrOGPn9XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAzNjUwOQ==", "bodyText": "We don't use the @Nullable annotation, see https://www.jmri.org/help/en/html/doc/Technical/SpotBugs.shtml", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r419036509", "createdAt": "2020-05-03T02:33:31Z", "author": {"login": "bobjacobsen"}, "path": "java/src/jmri/jmrix/lenz/FeedbackItem.java", "diffHunk": "@@ -0,0 +1,168 @@\n+package jmri.jmrix.lenz;\n+\n+import javax.annotation.CheckForNull;\n+import javax.annotation.Nullable;\n+import jmri.Turnout;\n+\n+/**\n+ * Represents a single response from the XpressNet.\n+ *\n+ * @author svatopluk.dedic@gmail.com Copyright (C) 2020\n+ *\n+ */\n+public class FeedbackItem {\n+    private final int number;\n+    private final int data;\n+    private final XNetReply reply;\n+\n+    protected FeedbackItem(XNetReply reply, int number, int data) {\n+        this.number = number;\n+        this.data = data;\n+        this.reply = reply;\n+    }\n+    \n+    /**\n+     * Determines if the feedback was solicited.\n+     * @return {@code true}, if feedback was solicited.\n+     */\n+    public boolean isUnsolicited() {\n+        return reply.isUnsolicited();\n+    }\n+\n+    /**\n+     * Resets the unsolicited flag in the reply.\n+     * @see XNetReply#resetUnsolicited()\n+     */\n+    public void resetUnsolicited() {\n+        reply.resetUnsolicited();\n+    }\n+    \n+    /**\n+     * Returns the (base) address of the item.\n+     * For turnouts, return the reported address. For encoders,\n+     * return the address of the first contained sensor\n+     * @return the address.\n+     */\n+    public int getAddress() {\n+        return number;\n+    }\n+\n+    /**\n+     * Determines if the feedback is for the given Turnout address\n+     * @param address address to check\n+     * @return {@code true}, if the item applies to the address.\n+     */\n+    public boolean matchesAddress(int address) {\n+        if (isAccessory()) {\n+            return number == address;\n+        } else {\n+            return ((address - 1) & ~0x03) + 1 == number;\n+        }\n+    }\n+\n+    /**\n+     * Determines if the turnout motion has completed. Requires decoder/switch\n+     * feedback to be processed by the command station; always {@code false} if not connected.\n+     * @return {@code true} if the motion is complete.\n+     */\n+    public boolean isMotionComplete() {\n+        return (data & 0x80) == 0;\n+    }\n+\n+    /**\n+     * Returns the feedback type.\n+     * <ul>\n+     * <li> 0: Turnout without feedback\n+     * <li> 1: Turnout with feedback\n+     * <li> 2: Feedback encoder\n+     * <li> 3: reserved, invalid\n+     * </ul>\n+     * @return feedback type.\n+     */\n+    public int getType() {\n+        return (data & 0b0110_0000) >> 5;\n+    }\n+\n+    /**\n+     * Translates raw value in {@link #getAccessoryStatus} into Turnout's CLOSED/THROWN\n+     * values\n+     * @return {@link Turnout#CLOSED}, {@link Turnout#THROWN} or -1 for inconsistent.s\n+     */\n+    public int getTurnoutStatus() {\n+        int t = getType();\n+        if (t > 1) {\n+            return -1;\n+        }\n+        switch (getAccessoryStatus()) {\n+            case 0x01: return Turnout.CLOSED;\n+            case 0x02: return Turnout.THROWN;\n+            default: // fall through\n+        }\n+        return -1;\n+    }\n+    \n+    /**\n+     * Returns true, if the feedback is from feedback encoder.\n+     * @return {@code true} for encoder feedback.\n+     */\n+    public boolean isEncoder() {\n+        return getType() == 2;\n+    }\n+    \n+    /**\n+     * Returns true, if the feedback is from turnout (accessory).\n+     * @return {@code true} for turnout feedback.\n+     */\n+    public boolean isAccessory() {\n+        return getType() < 2;\n+    }\n+\n+    /**\n+     * Gives status value as specified in XPressNet.\n+     * <ul>\n+     * <li> 0x00: turnout was not operated\n+     * <li> 0x01: last command was \"0\", turnout left, CLOSED.\n+     * <li> 0x02: last command was \"1\", turnout right, THROWN.\n+     * <li> 0x03: reserved, invalid\n+     * </ul>\n+     * The method returns 0x03, if the feedback is not for accessory.\n+     * @return accessory state.\n+     */\n+    public int getAccessoryStatus() {\n+        if (!isAccessory()) {\n+            return 0x03;    // invalid\n+        }\n+        return (number & 0x01) != 0 ? (data & 0b0011) : (data & 0b1100) >> 2;\n+    }\n+\n+    /**\n+     * Returns encoder feedback for the given sensor. The function return {@code null}\n+     * if the sensor number is not within this FeedbackItem range, or the item does\n+     * not represent an encoder feedback.\n+     * @param sensorNumber sensor number, starting with 1.\n+     * @return The sensor's reported bit value (true/false) or {@code null}, if \n+     * no encoder feedback for the sensor is found. \n+     */\n+    @CheckForNull\n+    public Boolean getEncoderStatus(int sensorNumber) {\n+        if (!matchesAddress(number) || isAccessory()) {\n+            return null;\n+        } else {\n+            return (data & (1 << ((sensorNumber -1) % 4))) > 0;\n+        }\n+    }\n+\n+    /**\n+     * Returns a FeedbackItem instance for the other accessory address reported in the\n+     * item. Returns {@code null} for non-accessory feedbacks.\n+     * @return instance for the paired accessory, or {@code null}.\n+     */\n+    @Nullable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "211379d6f4fc3664330485e53a6b779f0cc9d204"}, "originalPosition": 160}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTc2NDg3", "url": "https://github.com/JMRI/JMRI/pull/8473#pullrequestreview-404576487", "createdAt": "2020-05-03T02:40:16Z", "commit": {"oid": "211379d6f4fc3664330485e53a6b779f0cc9d204"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QwMjo0MDoxNlrOGPn_iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QwMjo0MDoxNlrOGPn_iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTAzNzA2NA==", "bodyText": "Not sure what it means to assertNonNull on a Boolean. Is that really what was intended? (Several places)", "url": "https://github.com/JMRI/JMRI/pull/8473#discussion_r419037064", "createdAt": "2020-05-03T02:40:16Z", "author": {"login": "bobjacobsen"}, "path": "java/test/jmri/jmrix/lenz/XNetReplyTest.java", "diffHunk": "@@ -1387,7 +1395,288 @@ public void testToMonitorStringInvalidFeedbackReply(){\n         XNetReply r = new XNetReply(\"42 FF FF 42\");\n         Assert.assertEquals(\"Monitor String\",\"Feedback Response: 255 255\",r.toMonitorString());\n     }\n-\n+    \n+    /**\n+     * Checks that the number of feedback items are correctly returned.\n+     */\n+    @Test\n+    public void testFeedbackItemsCount() {\n+        XNetReply r = new XNetReply(\"42 05 48 0f\");\n+        assertEquals(\"Feedback has single item\", 1, r.getFeedbackMessageItems());\n+        r = new XNetReply(\"46 05 48 06 48 07 48 0f\");\n+        assertEquals(\"Feedback has 3 items\", 3, r.getFeedbackMessageItems());\n+        r = new XNetReply(\"E3 32 00 04 C5\");\n+        assertEquals(0, r.getFeedbackMessageItems());\n+    }\n+    \n+    /**\n+     * Checks that all information is consistent from the Feedback item, \n+     * and are consistent with data served from XNetReply.\n+     * \n+     * @param reply the original reply\n+     * @param startByte start byte where the Feedback item came from\n+     * @param address the expected address\n+     * @param aStatus the expected status\n+     * @param tType the expected feedback type\n+     * @param fItem the expected feedback address \n+     */\n+    private void assertTurnoutFeedbackData(XNetReply reply, int startByte, int address, \n+            int aStatus, int tType, FeedbackItem fItem) {\n+        \n+        // general accessory feedback constraints\n+        assertFalse(\"Must not be encoder\", fItem.isEncoder());\n+        assertNull(\"Encoder functions disabled\", fItem.getEncoderStatus(address));\n+        assertTrue(\"Must be accessory\", fItem.isAccessory());\n+        \n+        // info consistent with the reply's original accessors\n+        assertEquals(\"Motion same as reply\", reply.isFeedbackMotionComplete(startByte), fItem.isMotionComplete());\n+        if ((address & 0x01) == 1) {\n+            assertTrue(\"Accepts reply's odd address\", fItem.matchesAddress(reply.getTurnoutMsgAddr(startByte)));\n+            assertEquals(address, reply.getTurnoutMsgAddr(startByte));\n+        } else {\n+            assertTrue(\"Accepts reply's even address\", fItem.matchesAddress(reply.getTurnoutMsgAddr(startByte) + 1));\n+            assertEquals(address, reply.getTurnoutMsgAddr(startByte) + 1);\n+        }\n+        assertEquals(\"Solicited same as reply\", reply.isUnsolicited(), fItem.isUnsolicited());\n+        \n+        assertEquals(\"Invalid feedback type\", tType, fItem.getType());\n+        assertEquals(\"Raw accessory status\", aStatus, fItem.getAccessoryStatus());\n+\n+        int lowAddress = (address & 0x01) > 0 ? address - 1 : address - 2;\n+        int pairAddress = (address & 0x01) > 0 ? address + 1 : address - 1;\n+        int highAddress = (address & 0x01) > 0 ? address + 2 : address + 1;\n+        \n+        assertTrue(\"Must accept own address\", fItem.matchesAddress(address));\n+        assertFalse(\"Must not accept other pair's address\", fItem.matchesAddress(pairAddress));\n+        assertFalse(\"Must not accept other addresses\", fItem.matchesAddress(lowAddress));\n+        assertFalse(\"Must not accept other addresses\", fItem.matchesAddress(highAddress));\n+\n+        int tStatus;\n+        switch (aStatus) {\n+            case 0x00: tStatus = -1; break; // not operated; shouldn't be UNKNOWN ?\n+            case 0x01: tStatus = Turnout.CLOSED; break;\n+            case 0x02: tStatus = Turnout.THROWN; break;\n+            case 0x03: tStatus = -1; break; // invalid; shouldn't be INCONSISTENT ?\n+            default:\n+                throw new IllegalArgumentException();\n+        }\n+        assertEquals(\"Turnout status\", tStatus, fItem.getTurnoutStatus());\n+        \n+        // check the paired item:\n+        FeedbackItem paired = fItem.pairedAccessoryItem();\n+        assertNotNull(\"Accessory fedbacks are always in pairs\", paired);\n+        assertFalse(\"Must not be encoder\", paired.isEncoder());\n+        assertTrue(\"Must be accessory\", paired.isAccessory());\n+        assertEquals(\"Invalid feedback type\", tType, paired.getType());\n+        assertEquals(\"Solicited same as reply\", reply.isUnsolicited(), paired.isUnsolicited());\n+        assertFalse(\"Must not accept pair's address\", paired.matchesAddress(address));\n+    }\n+    \n+    /**\n+     * Checks that information can be read from single-item feedback and\n+     * the reply are consistent.\n+     */\n+    @Test\n+    public void testSingleFeedbackTurnoutItem() {\n+        // 5 * 4, lower nibble = 21 (N/A) +22 (T)\n+        // movement NOT complete; turnout WITH feedback.\n+        XNetReply r = new XNetReply(\"42 05 28 0f\");\n+        Optional<FeedbackItem> selected = r.selectTurnoutFeedback(20);\n+        assertFalse(\"Incorrect turnout number\", selected.isPresent());\n+        selected = r.selectTurnoutFeedback(23);\n+        assertFalse(\"Incorrect turnout number\", selected.isPresent());\n+        \n+        selected = r.selectTurnoutFeedback(21);\n+        assertTrue(selected.isPresent());\n+        \n+        FeedbackItem oddItem = selected.get();\n+\n+        assertTrue(\"Motion completed\", oddItem.isMotionComplete());\n+        assertTrue(\"Initially unsolicited\", oddItem.isUnsolicited());\n+        assertTurnoutFeedbackData(r, 1, 21, 0, 1, oddItem);\n+        \n+        selected = r.selectTurnoutFeedback(22);\n+        assertTrue(selected.isPresent());\n+        \n+        FeedbackItem evenItem = selected.get();\n+        assertTurnoutFeedbackData(r, 1, 22, 2, 1, evenItem);\n+        \n+        // make solicited:\n+        oddItem.resetUnsolicited();\n+        assertFalse(r.isUnsolicited());\n+        \n+        // 5 * 4, upper nibble = 23 (C) + 24 (T)\n+        // movement IS complete; turnout WITHOUT feedback.\n+        r = new XNetReply(\"42 05 95 0f\");\n+        selected = r.selectTurnoutFeedback(23);\n+        assertTrue(selected.isPresent());\n+        \n+        oddItem = selected.get();\n+        assertFalse(\"Motion incomplete\", oddItem.isMotionComplete());\n+        assertTurnoutFeedbackData(r, 1, 23, 1, 0, oddItem);\n+        \n+        selected = r.selectTurnoutFeedback(24);\n+        assertTrue(selected.isPresent());\n+        evenItem = selected.get();\n+        assertTurnoutFeedbackData(r, 1, 24, 1, 0, evenItem);\n+    }\n+    \n+    /**\n+     * Checks that feedback module item gives invalid / erroneous / null\n+     * information when used as accessory.\n+     */\n+    @Test\n+    public void testOtherRepliesAsAccessoryFeedback() {\n+        XNetReply r = new XNetReply(\"42 05 58 0f\");\n+        // test directly the item\n+        FeedbackItem item = new FeedbackItem(r, 45, 0x58);\n+        assertEquals(45, item.getAddress());\n+        for (int a = 45; a < 45 + 4; a++) {\n+            assertTrue(item.matchesAddress(a));\n+            // last bit is set, all others are false.\n+            assertEquals(\"Bit state for sensor \" + a, a == 48, item.getEncoderStatus(a));\n+        }\n+        // does not match accessory for 0x05, 0x58\n+        assertFalse(item.matchesAddress(21));\n+        assertEquals(3, item.getAccessoryStatus());\n+        assertNull(item.pairedAccessoryItem());\n+\n+        // check that no turnout feedback can be selected\n+        for (int i = 1 ; i < 1024; i++) {\n+            assertFalse(r.selectTurnoutFeedback(i).isPresent());\n+        }\n+        \n+        // no accessory feedback present\n+        r = new XNetReply(\"E3 40 C1 04 61\");\n+        for (int i = 1 ; i < 1024; i++) {\n+            assertFalse(r.selectTurnoutFeedback(i).isPresent());\n+        }\n+    }\n+    \n+    /**\n+     * Checks that encoder feedback will return null for turnout\n+     * feedbacks.\n+     */\n+    @Test\n+    public void testOtherRepliesAsEncoder() {\n+        XNetReply r = new XNetReply(\"42 05 28 0f\");\n+        for (int i = 1 ; i < 1024; i++) {\n+            assertNull(r.selectModuleFeedback(i));\n+        }\n+        r = new XNetReply(\"E3 40 C1 04 61\");\n+        for (int i = 1 ; i < 1024; i++) {\n+            assertNull(r.selectModuleFeedback(i));\n+        }\n+\n+    }\n+\n+    \n+    /**\n+     * Checks that select will filter out accessories with an incorrect state.\n+     */\n+    @Test\n+    public void testInvalidAccessoryStateFiltered() {\n+        XNetReply r = new XNetReply(\"42 05 2B 0f\");\n+        Optional<FeedbackItem> opt = r.selectTurnoutFeedback(21);\n+        assertFalse(opt.isPresent());\n+        assertEquals(-1, r.getTurnoutStatus(1));\n+        \n+        opt = r.selectTurnoutFeedback(22);\n+        assertTrue(opt.isPresent());\n+        assertEquals(Turnout.THROWN, opt.get().getTurnoutStatus());\n+        assertEquals(r.getTurnoutStatus(0), opt.get().getTurnoutStatus());\n+    }\n+    \n+    @Test\n+    public void testSingleEncoderModuleFeedback() {\n+        // feedback 5 * 8  + 4 (upper nibble) (+1) = 45\n+        XNetReply r = new XNetReply(\"42 05 58 0f\");\n+        \n+        assertNull(r.selectModuleFeedback(44));\n+        \n+        for (int i = 45; i < 45 + 4; i++) {\n+            Boolean b = r.selectModuleFeedback(i);\n+            assertNotNull(b);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "211379d6f4fc3664330485e53a6b779f0cc9d204"}, "originalPosition": 220}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a048134c694d7eab45c8efe7705daab920027d62", "author": {"user": {"login": "svatoun", "name": "Svata Dedic"}}, "url": "https://github.com/JMRI/JMRI/commit/a048134c694d7eab45c8efe7705daab920027d62", "committedDate": "2020-05-05T21:11:04Z", "message": "Use simpler collection, just Queue is needed."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "211379d6f4fc3664330485e53a6b779f0cc9d204", "author": {"user": {"login": "svatoun", "name": "Svata Dedic"}}, "url": "https://github.com/JMRI/JMRI/commit/211379d6f4fc3664330485e53a6b779f0cc9d204", "committedDate": "2020-05-02T18:09:42Z", "message": "Use simpler collection, just Queue is needed."}, "afterCommit": {"oid": "a048134c694d7eab45c8efe7705daab920027d62", "author": {"user": {"login": "svatoun", "name": "Svata Dedic"}}, "url": "https://github.com/JMRI/JMRI/commit/a048134c694d7eab45c8efe7705daab920027d62", "committedDate": "2020-05-05T21:11:04Z", "message": "Use simpler collection, just Queue is needed."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4112, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}