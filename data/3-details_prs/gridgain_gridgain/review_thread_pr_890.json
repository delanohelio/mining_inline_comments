{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY5MjM5NTQy", "number": 890, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMzozNzo1NFrODoiVSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzo1MTowMVrODr4A-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODMyMTM5OnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/configuration/PlatformNearCacheConfiguration.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQyMzozNzo1NFrOF3JV3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwODo1OToyN1rOF4lSfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2OTA1NQ==", "bodyText": "From my understanding, it allows native cache configuration from the Java part, but do we really need this feature?", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r393369055", "createdAt": "2020-03-16T23:37:54Z", "author": {"login": "ashapkin"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/PlatformNearCacheConfiguration.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.configuration;\n+\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Platform near cache configuration.\n+ * <p>\n+ * Additional near caching mechanism on platform side (.NET).\n+ */\n+public class PlatformNearCacheConfiguration implements Serializable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1OTIwOQ==", "bodyText": "Why not? To me it looks like a good idea to allow user to configure this from xml.", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394059209", "createdAt": "2020-03-18T01:30:27Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/PlatformNearCacheConfiguration.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.configuration;\n+\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Platform near cache configuration.\n+ * <p>\n+ * Additional near caching mechanism on platform side (.NET).\n+ */\n+public class PlatformNearCacheConfiguration implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2OTA1NQ=="}, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg3NTUxOQ==", "bodyText": "Agree with @isapego . Another thing is that we can't (trivially) avoid this, because configuration needs to be sent across entire cluster, so this has to be a part of CacheConfiguration.\nRelevant dev list thread: http://apache-ignite-developers.2346864.n4.nabble.com/NET-Near-Cache-new-flag-in-NearCacheConfiguration-java-td45961.html", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394875519", "createdAt": "2020-03-19T08:59:27Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/PlatformNearCacheConfiguration.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.configuration;\n+\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Platform near cache configuration.\n+ * <p>\n+ * Additional near caching mechanism on platform side (.NET).\n+ */\n+public class PlatformNearCacheConfiguration implements Serializable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM2OTA1NQ=="}, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODQxMjI1OnYy", "diffSide": "RIGHT", "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCache.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDozMjoxOVrOF3KMMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOToxMToyMlrOF4lrHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4Mjk2MQ==", "bodyText": "You mentioned no-boxing approach, am I missing something?\nCan't we introduce another generic interface INearCache<T, V>?", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r393382961", "createdAt": "2020-03-17T00:32:19Z", "author": {"login": "ashapkin"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCache.cs", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace Apache.Ignite.Core.Impl.Cache.Near\n+{\n+    using System;\n+    using System.Collections.Concurrent;\n+    using System.Collections.Generic;\n+    using System.Diagnostics;\n+    using Apache.Ignite.Core.Cache;\n+    using Apache.Ignite.Core.Cache.Affinity;\n+    using Apache.Ignite.Core.Impl.Binary;\n+    using Apache.Ignite.Core.Impl.Binary.IO;\n+\n+    /// <summary>\n+    /// Holds near cache data for a given cache, serves one or more <see cref=\"CacheImpl{TK,TV}\"/> instances.\n+    /// </summary>\n+    internal sealed class NearCache<TK, TV> : INearCache\n+    {\n+        /** Affinity. */\n+        private readonly CacheAffinityImpl _affinity;\n+        \n+        /** Keep binary flag. */\n+        private readonly bool _keepBinary;\n+\n+        /** Topology version func. Returns boxed <see cref=\"AffinityTopologyVersion\"/>.\n+         * Boxed copy is passed directly to <see cref=\"NearCacheEntry{T}\"/>, avoiding extra allocations.\n+         * This way for every unique <see cref=\"AffinityTopologyVersion\"/> we only have one boxed copy,\n+         * and we can update <see cref=\"NearCacheEntry{T}.Version\"/> atomically without locks. */\n+        private readonly Func<object> _affinityTopologyVersionFunc;\n+\n+        /** Underlying map. */\n+        private readonly ConcurrentDictionary<TK, NearCacheEntry<TV>> _map = \n+            new ConcurrentDictionary<TK, NearCacheEntry<TV>>();\n+\n+        /** Stopped flag. */\n+        private volatile bool _stopped;\n+\n+        /// <summary>\n+        /// Initializes a new instance of the <see cref=\"NearCache{TK, TV}\"/> class.\n+        /// Called via reflection from <see cref=\"NearCacheManager.CreateNearCache\"/>. \n+        /// </summary>\n+        public NearCache(Func<object> affinityTopologyVersionFunc, CacheAffinityImpl affinity, bool keepBinary)\n+        {\n+            _affinityTopologyVersionFunc = affinityTopologyVersionFunc;\n+            _affinity = affinity;\n+            _keepBinary = keepBinary;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public bool IsStopped\n+        {\n+            get { return _stopped; }\n+        }\n+\n+        public bool TryGetValue<TKey, TVal>(TKey key, out TVal val)\n+        {\n+            if (_stopped)\n+            {\n+                val = default(TVal);\n+                return false;\n+            }\n+\n+            NearCacheEntry<TV> entry;\n+            var key0 = (TK) (object) key;\n+            \n+            if (_map.TryGetValue(key0, out entry))\n+            {\n+                if (IsValid(entry))\n+                {\n+                    val = (TVal) (object) entry.Value;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4MTgyMg==", "bodyText": "Yes, I mentioned no-boxing approach regarding _map when proper types are specified in PlatformNearCacheConfiguration.\nThis line is just a cast from TV to TVal, which can't be done any other way. Previously we used TypeCaster class to avoid boxing in such cases (see usages), and it was proved to be better on .NET 4. However, this is no longer the case on .NET Core:\nRuntime=.NET Core 3.1  \n\n|     Method |      Mean |     Error |    StdDev | Gen 0 | Gen 1 | Gen 2 | Allocated |\n|----------- |----------:|----------:|----------:|------:|------:|------:|----------:|\n| TypeCaster | 1.5402 ns | 0.0138 ns | 0.0122 ns |     - |     - |     - |         - |\n| ObjectCast | 0.0284 ns | 0.0098 ns | 0.0087 ns |     - |     - |     - |         - |\n\n(source: https://github.com/ptupitsyn/IgniteNetBenchmarks/blob/master/CasterBenchmark.cs)\nAs you can see, such a cast is optimized by JIT, there are zero allocations, and it is faster than TypeCaster.\n(There is a ticket to get rid of TypeCaster: https://issues.apache.org/jira/browse/IGNITE-12699)", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394881822", "createdAt": "2020-03-19T09:11:22Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCache.cs", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace Apache.Ignite.Core.Impl.Cache.Near\n+{\n+    using System;\n+    using System.Collections.Concurrent;\n+    using System.Collections.Generic;\n+    using System.Diagnostics;\n+    using Apache.Ignite.Core.Cache;\n+    using Apache.Ignite.Core.Cache.Affinity;\n+    using Apache.Ignite.Core.Impl.Binary;\n+    using Apache.Ignite.Core.Impl.Binary.IO;\n+\n+    /// <summary>\n+    /// Holds near cache data for a given cache, serves one or more <see cref=\"CacheImpl{TK,TV}\"/> instances.\n+    /// </summary>\n+    internal sealed class NearCache<TK, TV> : INearCache\n+    {\n+        /** Affinity. */\n+        private readonly CacheAffinityImpl _affinity;\n+        \n+        /** Keep binary flag. */\n+        private readonly bool _keepBinary;\n+\n+        /** Topology version func. Returns boxed <see cref=\"AffinityTopologyVersion\"/>.\n+         * Boxed copy is passed directly to <see cref=\"NearCacheEntry{T}\"/>, avoiding extra allocations.\n+         * This way for every unique <see cref=\"AffinityTopologyVersion\"/> we only have one boxed copy,\n+         * and we can update <see cref=\"NearCacheEntry{T}.Version\"/> atomically without locks. */\n+        private readonly Func<object> _affinityTopologyVersionFunc;\n+\n+        /** Underlying map. */\n+        private readonly ConcurrentDictionary<TK, NearCacheEntry<TV>> _map = \n+            new ConcurrentDictionary<TK, NearCacheEntry<TV>>();\n+\n+        /** Stopped flag. */\n+        private volatile bool _stopped;\n+\n+        /// <summary>\n+        /// Initializes a new instance of the <see cref=\"NearCache{TK, TV}\"/> class.\n+        /// Called via reflection from <see cref=\"NearCacheManager.CreateNearCache\"/>. \n+        /// </summary>\n+        public NearCache(Func<object> affinityTopologyVersionFunc, CacheAffinityImpl affinity, bool keepBinary)\n+        {\n+            _affinityTopologyVersionFunc = affinityTopologyVersionFunc;\n+            _affinity = affinity;\n+            _keepBinary = keepBinary;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public bool IsStopped\n+        {\n+            get { return _stopped; }\n+        }\n+\n+        public bool TryGetValue<TKey, TVal>(TKey key, out TVal val)\n+        {\n+            if (_stopped)\n+            {\n+                val = default(TVal);\n+                return false;\n+            }\n+\n+            NearCacheEntry<TV> entry;\n+            var key0 = (TK) (object) key;\n+            \n+            if (_map.TryGetValue(key0, out entry))\n+            {\n+                if (IsValid(entry))\n+                {\n+                    val = (TVal) (object) entry.Value;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4Mjk2MQ=="}, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODQ0MjM2OnYy", "diffSide": "RIGHT", "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCache.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMDo1MTowOFrOF3Keyg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOToxODoxNFrOF4l6dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4NzcyMg==", "bodyText": "Sry for possible question duplicate, can't we set a callback for this affinity changes directly from the Java side? Or this will downgrade the performance?", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r393387722", "createdAt": "2020-03-17T00:51:08Z", "author": {"login": "ashapkin"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCache.cs", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace Apache.Ignite.Core.Impl.Cache.Near\n+{\n+    using System;\n+    using System.Collections.Concurrent;\n+    using System.Collections.Generic;\n+    using System.Diagnostics;\n+    using Apache.Ignite.Core.Cache;\n+    using Apache.Ignite.Core.Cache.Affinity;\n+    using Apache.Ignite.Core.Impl.Binary;\n+    using Apache.Ignite.Core.Impl.Binary.IO;\n+\n+    /// <summary>\n+    /// Holds near cache data for a given cache, serves one or more <see cref=\"CacheImpl{TK,TV}\"/> instances.\n+    /// </summary>\n+    internal sealed class NearCache<TK, TV> : INearCache\n+    {\n+        /** Affinity. */\n+        private readonly CacheAffinityImpl _affinity;\n+        \n+        /** Keep binary flag. */\n+        private readonly bool _keepBinary;\n+\n+        /** Topology version func. Returns boxed <see cref=\"AffinityTopologyVersion\"/>.\n+         * Boxed copy is passed directly to <see cref=\"NearCacheEntry{T}\"/>, avoiding extra allocations.\n+         * This way for every unique <see cref=\"AffinityTopologyVersion\"/> we only have one boxed copy,\n+         * and we can update <see cref=\"NearCacheEntry{T}.Version\"/> atomically without locks. */\n+        private readonly Func<object> _affinityTopologyVersionFunc;\n+\n+        /** Underlying map. */\n+        private readonly ConcurrentDictionary<TK, NearCacheEntry<TV>> _map = \n+            new ConcurrentDictionary<TK, NearCacheEntry<TV>>();\n+\n+        /** Stopped flag. */\n+        private volatile bool _stopped;\n+\n+        /// <summary>\n+        /// Initializes a new instance of the <see cref=\"NearCache{TK, TV}\"/> class.\n+        /// Called via reflection from <see cref=\"NearCacheManager.CreateNearCache\"/>. \n+        /// </summary>\n+        public NearCache(Func<object> affinityTopologyVersionFunc, CacheAffinityImpl affinity, bool keepBinary)\n+        {\n+            _affinityTopologyVersionFunc = affinityTopologyVersionFunc;\n+            _affinity = affinity;\n+            _keepBinary = keepBinary;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public bool IsStopped\n+        {\n+            get { return _stopped; }\n+        }\n+\n+        public bool TryGetValue<TKey, TVal>(TKey key, out TVal val)\n+        {\n+            if (_stopped)\n+            {\n+                val = default(TVal);\n+                return false;\n+            }\n+\n+            NearCacheEntry<TV> entry;\n+            var key0 = (TK) (object) key;\n+            \n+            if (_map.TryGetValue(key0, out entry))\n+            {\n+                if (IsValid(entry))\n+                {\n+                    val = (TVal) (object) entry.Value;\n+                    return true;\n+                }\n+\n+                // Remove invalid entry to free up memory.\n+                // NOTE: We may end up removing a good entry that was inserted concurrently,\n+                // but this does not violate correctness, only causes a potential near cache miss.\n+                _map.TryRemove(key0, out entry);\n+            }\n+\n+            val = default(TVal);\n+            return false;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public int GetSize()\n+        {\n+            if (_stopped)\n+            {\n+                return 0;\n+            }\n+\n+            var count = 0;\n+            \n+            foreach (var e in _map)\n+            {\n+                if (IsValid(e.Value))\n+                {\n+                    count++;\n+                }\n+            }\n+\n+            return count;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void Update(IBinaryStream stream, Marshaller marshaller)\n+        {\n+            Debug.Assert(stream != null);\n+            Debug.Assert(marshaller != null);\n+\n+            if (_stopped)\n+            {\n+                return;\n+            }\n+\n+            var mode = _keepBinary ? BinaryMode.ForceBinary : BinaryMode.Deserialize;\n+            var reader = marshaller.StartUnmarshal(stream, mode);\n+\n+            var key = reader.ReadObject<TK>();\n+            var hasVal = stream.ReadBool();\n+\n+            if (hasVal)\n+            {\n+                var val = reader.ReadObject<TV>();\n+                var part = stream.ReadInt();\n+                var ver = new AffinityTopologyVersion(stream.ReadLong(), stream.ReadInt());\n+\n+                _map[key] = new NearCacheEntry<TV>(val, GetBoxedAffinityTopologyVersion(ver), part);\n+            }\n+            else\n+            {\n+                NearCacheEntry<TV> unused;\n+                _map.TryRemove(key, out unused);\n+            }\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void UpdateFromThreadLocal(int partition, AffinityTopologyVersion affinityTopologyVersion)\n+        {\n+            if (_stopped)\n+            {\n+                return;\n+            }\n+\n+            var pair = (KeyValuePair<TK, TV>) NearCacheManager.ThreadLocalPair.Value;\n+\n+            _map[pair.Key] = new NearCacheEntry<TV>(\n+                pair.Value,\n+                GetBoxedAffinityTopologyVersion(affinityTopologyVersion),\n+                partition);\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void Stop()\n+        {\n+            _stopped = true;\n+            Clear();\n+        }\n+        \n+        /** <inheritdoc /> */\n+        public void Clear()\n+        {\n+            _map.Clear();\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void SetThreadLocalPair<TKey, TVal>(TKey key, TVal val)\n+        {\n+            NearCacheManager.ThreadLocalPair.Value = new KeyValuePair<TK, TV>((TK) (object) key, (TV) (object) val);\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void ResetThreadLocalPair()\n+        {\n+            NearCacheManager.ThreadLocalPair.Value = null;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public IEnumerable<ICacheEntry<TKey, TVal>> GetEntries<TKey, TVal>()\n+        {\n+            if (_stopped)\n+            {\n+                yield break;\n+            }\n+\n+            foreach (var entry in _map)\n+            {\n+                yield return new CacheEntry<TKey, TVal>((TKey) (object) entry.Key, (TVal) (object) entry.Value.Value);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Checks whether specified cache entry is still valid, based on Affinity Topology Version.\n+        /// When primary node changes for a key, GridNearCacheEntry stops receiving updates for that key,\n+        /// because reader (\"subscription\") on new primary is not yet established.\n+        /// <para />\n+        /// This method is similar to GridNearCacheEntry.valid(). \n+        /// </summary>\n+        /// <param name=\"entry\">Entry to validate.</param>\n+        /// <typeparam name=\"TVal\">Value type.</typeparam>\n+        /// <returns>True if entry is valid and can be returned to the user; false otherwise.</returns>\n+        private bool IsValid<TVal>(NearCacheEntry<TVal> entry)\n+        {\n+            // See comments on _affinityTopologyVersionFunc about boxed copy approach. \n+            var currentVerBoxed = _affinityTopologyVersionFunc();\n+            var entryVerBoxed = entry.Version;\n+            \n+            Debug.Assert(currentVerBoxed != null);\n+            \n+            if (ReferenceEquals(currentVerBoxed, entryVerBoxed))\n+            {\n+                // Happy path: true on stable topology.\n+                return true;\n+            }\n+\n+            if (entryVerBoxed == null)\n+            {\n+                return false;\n+            }\n+\n+            var entryVer = (AffinityTopologyVersion) entryVerBoxed;\n+            var currentVer = (AffinityTopologyVersion) currentVerBoxed;\n+\n+            if (entryVer >= currentVer)\n+            {\n+                return true;\n+            }\n+\n+            var part = entry.Partition;\n+            var valid = _affinity.IsAssignmentValid(entryVer, part);\n+\n+            // Update version or mark as invalid (null).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4NTc1MA==", "bodyText": "Unfortunately, we can't. Because nothing is invoked on Java side in this case. What happens is:\n\nAffinity topology version changes (node enters or leaves, etc)\nGridNearCacheEntry becomes effectively invalid, because updates are no longer received (primary node changed for the key).\nData becomes stale, but nothing is being done until user requests this entry\nWhen user calls cache.Get, GridNearCacheEntry.valid() is called, invalid entry is detected, etc\n\nSo we have to have the same valid() check on .NET side to avoid calling Java on every Get", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394885750", "createdAt": "2020-03-19T09:18:14Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCache.cs", "diffHunk": "@@ -0,0 +1,261 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace Apache.Ignite.Core.Impl.Cache.Near\n+{\n+    using System;\n+    using System.Collections.Concurrent;\n+    using System.Collections.Generic;\n+    using System.Diagnostics;\n+    using Apache.Ignite.Core.Cache;\n+    using Apache.Ignite.Core.Cache.Affinity;\n+    using Apache.Ignite.Core.Impl.Binary;\n+    using Apache.Ignite.Core.Impl.Binary.IO;\n+\n+    /// <summary>\n+    /// Holds near cache data for a given cache, serves one or more <see cref=\"CacheImpl{TK,TV}\"/> instances.\n+    /// </summary>\n+    internal sealed class NearCache<TK, TV> : INearCache\n+    {\n+        /** Affinity. */\n+        private readonly CacheAffinityImpl _affinity;\n+        \n+        /** Keep binary flag. */\n+        private readonly bool _keepBinary;\n+\n+        /** Topology version func. Returns boxed <see cref=\"AffinityTopologyVersion\"/>.\n+         * Boxed copy is passed directly to <see cref=\"NearCacheEntry{T}\"/>, avoiding extra allocations.\n+         * This way for every unique <see cref=\"AffinityTopologyVersion\"/> we only have one boxed copy,\n+         * and we can update <see cref=\"NearCacheEntry{T}.Version\"/> atomically without locks. */\n+        private readonly Func<object> _affinityTopologyVersionFunc;\n+\n+        /** Underlying map. */\n+        private readonly ConcurrentDictionary<TK, NearCacheEntry<TV>> _map = \n+            new ConcurrentDictionary<TK, NearCacheEntry<TV>>();\n+\n+        /** Stopped flag. */\n+        private volatile bool _stopped;\n+\n+        /// <summary>\n+        /// Initializes a new instance of the <see cref=\"NearCache{TK, TV}\"/> class.\n+        /// Called via reflection from <see cref=\"NearCacheManager.CreateNearCache\"/>. \n+        /// </summary>\n+        public NearCache(Func<object> affinityTopologyVersionFunc, CacheAffinityImpl affinity, bool keepBinary)\n+        {\n+            _affinityTopologyVersionFunc = affinityTopologyVersionFunc;\n+            _affinity = affinity;\n+            _keepBinary = keepBinary;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public bool IsStopped\n+        {\n+            get { return _stopped; }\n+        }\n+\n+        public bool TryGetValue<TKey, TVal>(TKey key, out TVal val)\n+        {\n+            if (_stopped)\n+            {\n+                val = default(TVal);\n+                return false;\n+            }\n+\n+            NearCacheEntry<TV> entry;\n+            var key0 = (TK) (object) key;\n+            \n+            if (_map.TryGetValue(key0, out entry))\n+            {\n+                if (IsValid(entry))\n+                {\n+                    val = (TVal) (object) entry.Value;\n+                    return true;\n+                }\n+\n+                // Remove invalid entry to free up memory.\n+                // NOTE: We may end up removing a good entry that was inserted concurrently,\n+                // but this does not violate correctness, only causes a potential near cache miss.\n+                _map.TryRemove(key0, out entry);\n+            }\n+\n+            val = default(TVal);\n+            return false;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public int GetSize()\n+        {\n+            if (_stopped)\n+            {\n+                return 0;\n+            }\n+\n+            var count = 0;\n+            \n+            foreach (var e in _map)\n+            {\n+                if (IsValid(e.Value))\n+                {\n+                    count++;\n+                }\n+            }\n+\n+            return count;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void Update(IBinaryStream stream, Marshaller marshaller)\n+        {\n+            Debug.Assert(stream != null);\n+            Debug.Assert(marshaller != null);\n+\n+            if (_stopped)\n+            {\n+                return;\n+            }\n+\n+            var mode = _keepBinary ? BinaryMode.ForceBinary : BinaryMode.Deserialize;\n+            var reader = marshaller.StartUnmarshal(stream, mode);\n+\n+            var key = reader.ReadObject<TK>();\n+            var hasVal = stream.ReadBool();\n+\n+            if (hasVal)\n+            {\n+                var val = reader.ReadObject<TV>();\n+                var part = stream.ReadInt();\n+                var ver = new AffinityTopologyVersion(stream.ReadLong(), stream.ReadInt());\n+\n+                _map[key] = new NearCacheEntry<TV>(val, GetBoxedAffinityTopologyVersion(ver), part);\n+            }\n+            else\n+            {\n+                NearCacheEntry<TV> unused;\n+                _map.TryRemove(key, out unused);\n+            }\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void UpdateFromThreadLocal(int partition, AffinityTopologyVersion affinityTopologyVersion)\n+        {\n+            if (_stopped)\n+            {\n+                return;\n+            }\n+\n+            var pair = (KeyValuePair<TK, TV>) NearCacheManager.ThreadLocalPair.Value;\n+\n+            _map[pair.Key] = new NearCacheEntry<TV>(\n+                pair.Value,\n+                GetBoxedAffinityTopologyVersion(affinityTopologyVersion),\n+                partition);\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void Stop()\n+        {\n+            _stopped = true;\n+            Clear();\n+        }\n+        \n+        /** <inheritdoc /> */\n+        public void Clear()\n+        {\n+            _map.Clear();\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void SetThreadLocalPair<TKey, TVal>(TKey key, TVal val)\n+        {\n+            NearCacheManager.ThreadLocalPair.Value = new KeyValuePair<TK, TV>((TK) (object) key, (TV) (object) val);\n+        }\n+\n+        /** <inheritdoc /> */\n+        public void ResetThreadLocalPair()\n+        {\n+            NearCacheManager.ThreadLocalPair.Value = null;\n+        }\n+\n+        /** <inheritdoc /> */\n+        public IEnumerable<ICacheEntry<TKey, TVal>> GetEntries<TKey, TVal>()\n+        {\n+            if (_stopped)\n+            {\n+                yield break;\n+            }\n+\n+            foreach (var entry in _map)\n+            {\n+                yield return new CacheEntry<TKey, TVal>((TKey) (object) entry.Key, (TVal) (object) entry.Value.Value);\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Checks whether specified cache entry is still valid, based on Affinity Topology Version.\n+        /// When primary node changes for a key, GridNearCacheEntry stops receiving updates for that key,\n+        /// because reader (\"subscription\") on new primary is not yet established.\n+        /// <para />\n+        /// This method is similar to GridNearCacheEntry.valid(). \n+        /// </summary>\n+        /// <param name=\"entry\">Entry to validate.</param>\n+        /// <typeparam name=\"TVal\">Value type.</typeparam>\n+        /// <returns>True if entry is valid and can be returned to the user; false otherwise.</returns>\n+        private bool IsValid<TVal>(NearCacheEntry<TVal> entry)\n+        {\n+            // See comments on _affinityTopologyVersionFunc about boxed copy approach. \n+            var currentVerBoxed = _affinityTopologyVersionFunc();\n+            var entryVerBoxed = entry.Version;\n+            \n+            Debug.Assert(currentVerBoxed != null);\n+            \n+            if (ReferenceEquals(currentVerBoxed, entryVerBoxed))\n+            {\n+                // Happy path: true on stable topology.\n+                return true;\n+            }\n+\n+            if (entryVerBoxed == null)\n+            {\n+                return false;\n+            }\n+\n+            var entryVer = (AffinityTopologyVersion) entryVerBoxed;\n+            var currentVer = (AffinityTopologyVersion) currentVerBoxed;\n+\n+            if (entryVer >= currentVer)\n+            {\n+                return true;\n+            }\n+\n+            var part = entry.Partition;\n+            var valid = _affinity.IsAssignmentValid(entryVer, part);\n+\n+            // Update version or mark as invalid (null).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM4NzcyMg=="}, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODQ3ODYyOnYy", "diffSide": "RIGHT", "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCacheManager.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMToxNDo0OFrOF3K02Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOToyMTowNFrOF4mAvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM5MzM2OQ==", "bodyText": "FYI: Could hit performance, customers could use a thick client for health checking instead of a thin one", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r393393369", "createdAt": "2020-03-17T01:14:48Z", "author": {"login": "ashapkin"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCacheManager.cs", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace Apache.Ignite.Core.Impl.Cache.Near\n+{\n+    using System;\n+    using System.Diagnostics;\n+    using System.Threading;\n+    using Apache.Ignite.Core.Cache.Affinity;\n+    using Apache.Ignite.Core.Cache.Configuration;\n+    using Apache.Ignite.Core.Impl.Binary;\n+    using Apache.Ignite.Core.Impl.Binary.IO;\n+    using Apache.Ignite.Core.Impl.Common;\n+\n+    /// <summary>\n+    /// Manages <see cref=\"NearCache{TK,TV}\"/> instances.\n+    /// Multiple <see cref=\"CacheImpl{TK,TV}\"/> instances can exist for a given cache, and all of them share the same\n+    /// <see cref=\"NearCache{TK,TV}\"/> instance.\n+    /// </summary>\n+    [DebuggerDisplay(\"NearCacheManager [IgniteInstanceName={_ignite.GetIgnite().Name}]\")]\n+    internal class NearCacheManager\n+    {\n+        /// <summary>\n+        /// Holds thread-local key/val pair to be used for updating Near Cache .\n+        /// </summary>\n+        internal static readonly ThreadLocal<object> ThreadLocalPair = new ThreadLocal<object>();\n+        \n+        /// <summary>\n+        /// Near caches per cache id.\n+        /// Multiple <see cref=\"CacheImpl{TK,TV}\"/> instances can point to the same Ignite cache,\n+        /// and share one <see cref=\"NearCache{TK,TV}\"/> instance. \n+        /// </summary> \n+        private readonly CopyOnWriteConcurrentDictionary<int, INearCache> _nearCaches\n+            = new CopyOnWriteConcurrentDictionary<int, INearCache>();\n+\n+        /// <summary>\n+        /// Ignite.\n+        /// </summary>\n+        private readonly IIgniteInternal _ignite;\n+\n+        /// <summary>\n+        /// Current topology version. Store as object for atomic updates.\n+        /// </summary>\n+        private volatile object _affinityTopologyVersion;\n+        \n+        /// <summary>\n+        /// Initializes a new instance of the <see cref=\"NearCacheManager\"/> class. \n+        /// </summary>\n+        /// <param name=\"ignite\">Ignite.</param>\n+        public NearCacheManager(IIgniteInternal ignite)\n+        {\n+            Debug.Assert(ignite != null);\n+\n+            _ignite = ignite;\n+            _ignite.GetIgnite().ClientDisconnected += OnClientDisconnected;\n+        }\n+\n+        /// <summary>\n+        /// Gets or creates the near cache.\n+        /// </summary>\n+        public INearCache GetOrCreateNearCache(CacheConfiguration cacheConfiguration)\n+        {\n+            Debug.Assert(cacheConfiguration != null);\n+\n+            var cacheId = BinaryUtils.GetCacheId(cacheConfiguration.Name);\n+            \n+            return _nearCaches.GetOrAdd(cacheId, _ => CreateNearCache(cacheConfiguration));\n+        }\n+\n+        /// <summary>\n+        /// Gets near cache when it exists.\n+        /// </summary>\n+        public INearCache TryGetNearCache(int cacheId)\n+        {\n+            INearCache nearCache;\n+            return _nearCaches.TryGetValue(cacheId, out nearCache) ? nearCache : null;\n+        }\n+        \n+        /// <summary>\n+        /// Reads cache entry from a stream and updates the near cache.\n+        /// </summary>\n+        public void Update(int cacheId, IBinaryStream stream, Marshaller marshaller)\n+        {\n+            var nearCache = _nearCaches.GetOrAdd(cacheId, \n+                _ => CreateNearCache(_ignite.GetCacheConfiguration(cacheId)));\n+            \n+            nearCache.Update(stream, marshaller);\n+        }\n+\n+        /// <summary>\n+        /// Updates near cache from <see cref=\"ThreadLocalPair\"/>.\n+        /// </summary>\n+        public void UpdateFromThreadLocal(int cacheId, int partition, AffinityTopologyVersion affinityTopologyVersion)\n+        {\n+            var nearCache = _nearCaches.GetOrAdd(cacheId, \n+                _ => CreateNearCache(_ignite.GetCacheConfiguration(cacheId)));\n+            \n+            nearCache.UpdateFromThreadLocal(partition, affinityTopologyVersion);\n+        }\n+\n+        /// <summary>\n+        /// Stops near cache.\n+        /// </summary>\n+        public void Stop(int cacheId)\n+        {\n+            INearCache cache;\n+            if (_nearCaches.Remove(cacheId, out cache))\n+            {\n+                cache.Stop();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Called when topology version changes.\n+        /// </summary>\n+        public void OnAffinityTopologyVersionChanged(AffinityTopologyVersion affinityTopologyVersion)\n+        {\n+            _affinityTopologyVersion = affinityTopologyVersion;\n+        }\n+        \n+        /// <summary>\n+        /// Creates near cache.\n+        /// </summary>\n+        private INearCache CreateNearCache(CacheConfiguration cacheConfiguration)\n+        {\n+            var nearCfg = cacheConfiguration.PlatformNearConfiguration;\n+            Debug.Assert(nearCfg != null);\n+            \n+            Func<object> affinityTopologyVersionFunc = () => _affinityTopologyVersion;\n+            var affinity = _ignite.GetAffinity(cacheConfiguration.Name);\n+            var keepBinary = nearCfg.KeepBinary;\n+\n+            TypeResolver resolver = null;\n+            Func<string, Type> resolve = n =>\n+            {\n+                if (n == null)\n+                {\n+                    return typeof(object);\n+                }\n+\n+                if (resolver == null)\n+                {\n+                    resolver = new TypeResolver();\n+                }\n+\n+                var resolved = resolver.ResolveType(n);\n+\n+                if (resolved == null)\n+                {\n+                    throw new InvalidOperationException(string.Format(\"Failed to resolve type: '{0}'\", n));\n+                }\n+\n+                return resolved;\n+            };\n+\n+            var keyType = resolve(nearCfg.KeyTypeName);\n+            var valType = resolve(nearCfg.ValueTypeName);\n+\n+            var cacheType = typeof(NearCache<,>).MakeGenericType(keyType, valType);\n+            var nearCache = Activator.CreateInstance(\n+                cacheType, \n+                affinityTopologyVersionFunc, \n+                affinity,\n+                keepBinary);\n+            \n+            return (INearCache) nearCache;\n+        }\n+        \n+        /// <summary>\n+        /// Handles client disconnect.\n+        /// </summary>\n+        private void OnClientDisconnected(object sender, EventArgs e)\n+        {\n+            foreach (var cache in _nearCaches)\n+            {\n+                cache.Value.Clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4NzM1Nw==", "bodyText": "I think that compared to the whole \"thick client connect/disconnect\" procedure, this call is very cheap.", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394887357", "createdAt": "2020-03-19T09:21:04Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/Near/NearCacheManager.cs", "diffHunk": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+namespace Apache.Ignite.Core.Impl.Cache.Near\n+{\n+    using System;\n+    using System.Diagnostics;\n+    using System.Threading;\n+    using Apache.Ignite.Core.Cache.Affinity;\n+    using Apache.Ignite.Core.Cache.Configuration;\n+    using Apache.Ignite.Core.Impl.Binary;\n+    using Apache.Ignite.Core.Impl.Binary.IO;\n+    using Apache.Ignite.Core.Impl.Common;\n+\n+    /// <summary>\n+    /// Manages <see cref=\"NearCache{TK,TV}\"/> instances.\n+    /// Multiple <see cref=\"CacheImpl{TK,TV}\"/> instances can exist for a given cache, and all of them share the same\n+    /// <see cref=\"NearCache{TK,TV}\"/> instance.\n+    /// </summary>\n+    [DebuggerDisplay(\"NearCacheManager [IgniteInstanceName={_ignite.GetIgnite().Name}]\")]\n+    internal class NearCacheManager\n+    {\n+        /// <summary>\n+        /// Holds thread-local key/val pair to be used for updating Near Cache .\n+        /// </summary>\n+        internal static readonly ThreadLocal<object> ThreadLocalPair = new ThreadLocal<object>();\n+        \n+        /// <summary>\n+        /// Near caches per cache id.\n+        /// Multiple <see cref=\"CacheImpl{TK,TV}\"/> instances can point to the same Ignite cache,\n+        /// and share one <see cref=\"NearCache{TK,TV}\"/> instance. \n+        /// </summary> \n+        private readonly CopyOnWriteConcurrentDictionary<int, INearCache> _nearCaches\n+            = new CopyOnWriteConcurrentDictionary<int, INearCache>();\n+\n+        /// <summary>\n+        /// Ignite.\n+        /// </summary>\n+        private readonly IIgniteInternal _ignite;\n+\n+        /// <summary>\n+        /// Current topology version. Store as object for atomic updates.\n+        /// </summary>\n+        private volatile object _affinityTopologyVersion;\n+        \n+        /// <summary>\n+        /// Initializes a new instance of the <see cref=\"NearCacheManager\"/> class. \n+        /// </summary>\n+        /// <param name=\"ignite\">Ignite.</param>\n+        public NearCacheManager(IIgniteInternal ignite)\n+        {\n+            Debug.Assert(ignite != null);\n+\n+            _ignite = ignite;\n+            _ignite.GetIgnite().ClientDisconnected += OnClientDisconnected;\n+        }\n+\n+        /// <summary>\n+        /// Gets or creates the near cache.\n+        /// </summary>\n+        public INearCache GetOrCreateNearCache(CacheConfiguration cacheConfiguration)\n+        {\n+            Debug.Assert(cacheConfiguration != null);\n+\n+            var cacheId = BinaryUtils.GetCacheId(cacheConfiguration.Name);\n+            \n+            return _nearCaches.GetOrAdd(cacheId, _ => CreateNearCache(cacheConfiguration));\n+        }\n+\n+        /// <summary>\n+        /// Gets near cache when it exists.\n+        /// </summary>\n+        public INearCache TryGetNearCache(int cacheId)\n+        {\n+            INearCache nearCache;\n+            return _nearCaches.TryGetValue(cacheId, out nearCache) ? nearCache : null;\n+        }\n+        \n+        /// <summary>\n+        /// Reads cache entry from a stream and updates the near cache.\n+        /// </summary>\n+        public void Update(int cacheId, IBinaryStream stream, Marshaller marshaller)\n+        {\n+            var nearCache = _nearCaches.GetOrAdd(cacheId, \n+                _ => CreateNearCache(_ignite.GetCacheConfiguration(cacheId)));\n+            \n+            nearCache.Update(stream, marshaller);\n+        }\n+\n+        /// <summary>\n+        /// Updates near cache from <see cref=\"ThreadLocalPair\"/>.\n+        /// </summary>\n+        public void UpdateFromThreadLocal(int cacheId, int partition, AffinityTopologyVersion affinityTopologyVersion)\n+        {\n+            var nearCache = _nearCaches.GetOrAdd(cacheId, \n+                _ => CreateNearCache(_ignite.GetCacheConfiguration(cacheId)));\n+            \n+            nearCache.UpdateFromThreadLocal(partition, affinityTopologyVersion);\n+        }\n+\n+        /// <summary>\n+        /// Stops near cache.\n+        /// </summary>\n+        public void Stop(int cacheId)\n+        {\n+            INearCache cache;\n+            if (_nearCaches.Remove(cacheId, out cache))\n+            {\n+                cache.Stop();\n+            }\n+        }\n+\n+        /// <summary>\n+        /// Called when topology version changes.\n+        /// </summary>\n+        public void OnAffinityTopologyVersionChanged(AffinityTopologyVersion affinityTopologyVersion)\n+        {\n+            _affinityTopologyVersion = affinityTopologyVersion;\n+        }\n+        \n+        /// <summary>\n+        /// Creates near cache.\n+        /// </summary>\n+        private INearCache CreateNearCache(CacheConfiguration cacheConfiguration)\n+        {\n+            var nearCfg = cacheConfiguration.PlatformNearConfiguration;\n+            Debug.Assert(nearCfg != null);\n+            \n+            Func<object> affinityTopologyVersionFunc = () => _affinityTopologyVersion;\n+            var affinity = _ignite.GetAffinity(cacheConfiguration.Name);\n+            var keepBinary = nearCfg.KeepBinary;\n+\n+            TypeResolver resolver = null;\n+            Func<string, Type> resolve = n =>\n+            {\n+                if (n == null)\n+                {\n+                    return typeof(object);\n+                }\n+\n+                if (resolver == null)\n+                {\n+                    resolver = new TypeResolver();\n+                }\n+\n+                var resolved = resolver.ResolveType(n);\n+\n+                if (resolved == null)\n+                {\n+                    throw new InvalidOperationException(string.Format(\"Failed to resolve type: '{0}'\", n));\n+                }\n+\n+                return resolved;\n+            };\n+\n+            var keyType = resolve(nearCfg.KeyTypeName);\n+            var valType = resolve(nearCfg.ValueTypeName);\n+\n+            var cacheType = typeof(NearCache<,>).MakeGenericType(keyType, valType);\n+            var nearCache = Activator.CreateInstance(\n+                cacheType, \n+                affinityTopologyVersionFunc, \n+                affinity,\n+                keepBinary);\n+            \n+            return (INearCache) nearCache;\n+        }\n+        \n+        /// <summary>\n+        /// Handles client disconnect.\n+        /// </summary>\n+        private void OnClientDisconnected(object sender, EventArgs e)\n+        {\n+            foreach (var cache in _nearCaches)\n+            {\n+                cache.Value.Clear();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM5MzM2OQ=="}, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODUwNjkxOnYy", "diffSide": "RIGHT", "path": "modules/platforms/dotnet/Apache.Ignite.Core/Cache/Configuration/CacheConfiguration.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMTozNDoxNlrOF3LGRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOToyMjoxMFrOF4mDPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM5NzgyOQ==", "bodyText": "For some reason, this config seems to not having effect when creating cache with Ignite.CreateCache(cfg), but it works on Ignite.CreateCache(cfg, nearCfg).", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r393397829", "createdAt": "2020-03-17T01:34:16Z", "author": {"login": "ashapkin"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Cache/Configuration/CacheConfiguration.cs", "diffHunk": "@@ -448,6 +453,16 @@ internal void Write(BinaryWriter writer, ClientProtocolVersion srvVer)\n             ExpiryPolicySerializer.WritePolicyFactory(writer, ExpiryPolicyFactory);\n \n             writer.WriteCollectionRaw(KeyConfiguration);\n+            \n+            if (PlatformNearConfiguration != null)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4Nzk5Ng==", "bodyText": "@ashapkin can you please provide a full reproducer?", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394887996", "createdAt": "2020-03-19T09:22:10Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Cache/Configuration/CacheConfiguration.cs", "diffHunk": "@@ -448,6 +453,16 @@ internal void Write(BinaryWriter writer, ClientProtocolVersion srvVer)\n             ExpiryPolicySerializer.WritePolicyFactory(writer, ExpiryPolicyFactory);\n \n             writer.WriteCollectionRaw(KeyConfiguration);\n+            \n+            if (PlatformNearConfiguration != null)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM5NzgyOQ=="}, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzODUxNDg4OnYy", "diffSide": "RIGHT", "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/CacheImpl.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xN1QwMTozOToyOVrOF3LLKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOToyMTozNlrOF4mB7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM5OTA4MA==", "bodyText": "It feels that Peek.All should work as \"all available\" instead of throwing an explicit exception.\nPlease, check tests, we could convert this into a warning temporary.", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r393399080", "createdAt": "2020-03-17T01:39:29Z", "author": {"login": "ashapkin"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/CacheImpl.cs", "diffHunk": "@@ -949,6 +1243,45 @@ private Task<long> SizeAsync0(int? part, params CachePeekMode[] modes)\n             });\n         }\n \n+        /// <summary>\n+        /// Encodes peek modes, includes native near check.\n+        /// </summary>\n+        private int EncodePeekModes(bool loc, int? part, CachePeekMode[] modes, out bool onlyNativeNear, out int size)\n+        {\n+            size = 0;\n+            onlyNativeNear = false;\n+            \n+            bool hasPlatformNear;\n+            var modes0 = IgniteUtils.EncodePeekModes(modes, out hasPlatformNear);\n+\n+            if (hasPlatformNear)\n+            {\n+                if (!loc)\n+                {\n+                    throw new InvalidOperationException(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 572}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg4NzY2MQ==", "bodyText": "Agree, fixed. No exceptions now.", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394887661", "createdAt": "2020-03-19T09:21:36Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Cache/CacheImpl.cs", "diffHunk": "@@ -949,6 +1243,45 @@ private Task<long> SizeAsync0(int? part, params CachePeekMode[] modes)\n             });\n         }\n \n+        /// <summary>\n+        /// Encodes peek modes, includes native near check.\n+        /// </summary>\n+        private int EncodePeekModes(bool loc, int? part, CachePeekMode[] modes, out bool onlyNativeNear, out int size)\n+        {\n+            size = 0;\n+            onlyNativeNear = false;\n+            \n+            bool hasPlatformNear;\n+            var modes0 = IgniteUtils.EncodePeekModes(modes, out hasPlatformNear);\n+\n+            if (hasPlatformNear)\n+            {\n+                if (!loc)\n+                {\n+                    throw new InvalidOperationException(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM5OTA4MA=="}, "originalCommit": {"oid": "598a37a869de64b5183e3dcd5c6ed39c3b09a43c"}, "originalPosition": 572}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjU2OTQzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/configuration/PlatformNearCacheConfiguration.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMTozMTo1M1rOF3zfGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMTozMTo1M1rOF3zfGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1OTU0NA==", "bodyText": "By the way, is it possible to get this info from cache configuration in some cases?", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394059544", "createdAt": "2020-03-18T01:31:53Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/configuration/PlatformNearCacheConfiguration.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.ignite.configuration;\n+\n+import org.apache.ignite.internal.util.typedef.internal.S;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Platform near cache configuration.\n+ * <p>\n+ * Additional near caching mechanism on platform side (.NET).\n+ */\n+public class PlatformNearCacheConfiguration implements Serializable {\n+    /** */\n+    private static final long serialVersionUID = 0L;\n+\n+    /** Key type name. */\n+    private String keyTypeName;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e74369732817fd074a8e4231cf4f0238491df750"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjU3MTMyOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/GridDhtCacheEntry.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMTozMjo1OFrOF3zgKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQwOTozMTo0OVrOF4mZbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1OTgxOQ==", "bodyText": "Was it originally a bug?", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394059819", "createdAt": "2020-03-18T01:32:58Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/GridDhtCacheEntry.java", "diffHunk": "@@ -165,6 +165,8 @@ public GridDhtCacheEntry(\n \n     /** {@inheritDoc} */\n     @Override public void onMarkedObsolete() {\n+        super.onMarkedObsolete();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e74369732817fd074a8e4231cf4f0238491df750"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5MzY3OQ==", "bodyText": "Unnecessary change, reverted.", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394893679", "createdAt": "2020-03-19T09:31:49Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/cache/distributed/dht/GridDhtCacheEntry.java", "diffHunk": "@@ -165,6 +165,8 @@ public GridDhtCacheEntry(\n \n     /** {@inheritDoc} */\n     @Override public void onMarkedObsolete() {\n+        super.onMarkedObsolete();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA1OTgxOQ=="}, "originalCommit": {"oid": "e74369732817fd074a8e4231cf4f0238491df750"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjU3MjkzOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/platform/PlatformContextImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMTozNDoxMVrOF3zhPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQxOTo0MDozNlrOF49szQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA2MDA5NQ==", "bodyText": "Do we use TLS here to avoid redundant copies on put from platform side? Looks a bit complicated.", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394060095", "createdAt": "2020-03-18T01:34:11Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/platform/PlatformContextImpl.java", "diffHunk": "@@ -80,10 +83,13 @@\n  * Implementation of platform context.\n  */\n @SuppressWarnings(\"TypeMayBeWeakened\")\n-public class PlatformContextImpl implements PlatformContext {\n+public class PlatformContextImpl implements PlatformContext, PartitionsExchangeAware {\n     /** Supported event types. */\n     private static final Set<Integer> evtTyps;\n \n+    /** Whether to use thread-local data to update platform near cache. */\n+    private static final ThreadLocal<Boolean> nearUpdateUseThreadLocal = new ThreadLocal<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e74369732817fd074a8e4231cf4f0238491df750"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDg5MTQyOA==", "bodyText": "Yes, when .NET performs Put, we already have a value on .NET side, no need to send it back through the callback.\nBefore this TLS optimization we had a 50% perf drop on Put when Platform Near is enabled. After TLS optimization the drop is about 7%. I think this added complexity is worth it.", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394891428", "createdAt": "2020-03-19T09:28:05Z", "author": {"login": "ptupitsyn"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/platform/PlatformContextImpl.java", "diffHunk": "@@ -80,10 +83,13 @@\n  * Implementation of platform context.\n  */\n @SuppressWarnings(\"TypeMayBeWeakened\")\n-public class PlatformContextImpl implements PlatformContext {\n+public class PlatformContextImpl implements PlatformContext, PartitionsExchangeAware {\n     /** Supported event types. */\n     private static final Set<Integer> evtTyps;\n \n+    /** Whether to use thread-local data to update platform near cache. */\n+    private static final ThreadLocal<Boolean> nearUpdateUseThreadLocal = new ThreadLocal<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA2MDA5NQ=="}, "originalCommit": {"oid": "e74369732817fd074a8e4231cf4f0238491df750"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTI3NTQ2OQ==", "bodyText": "Cool", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r395275469", "createdAt": "2020-03-19T19:40:36Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/platform/PlatformContextImpl.java", "diffHunk": "@@ -80,10 +83,13 @@\n  * Implementation of platform context.\n  */\n @SuppressWarnings(\"TypeMayBeWeakened\")\n-public class PlatformContextImpl implements PlatformContext {\n+public class PlatformContextImpl implements PlatformContext, PartitionsExchangeAware {\n     /** Supported event types. */\n     private static final Set<Integer> evtTyps;\n \n+    /** Whether to use thread-local data to update platform near cache. */\n+    private static final ThreadLocal<Boolean> nearUpdateUseThreadLocal = new ThreadLocal<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA2MDA5NQ=="}, "originalCommit": {"oid": "e74369732817fd074a8e4231cf4f0238491df750"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ0MjU3NzAwOnYy", "diffSide": "RIGHT", "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/platform/PlatformProcessor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMTozNzowMFrOF3zjug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOFQwMTozNzowMFrOF3zjug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NDA2MDczMA==", "bodyText": "I don't think this is a good name for this method as it does not say anything for person reading the code. I actually had to go to implementation of context() method in PlatformNoopProcessor to understand it's meaning. Maybe hasPlatformRuntime() or isPlatformNode() would fit better here?", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r394060730", "createdAt": "2020-03-18T01:37:00Z", "author": {"login": "isapego"}, "path": "modules/core/src/main/java/org/apache/ignite/internal/processors/platform/PlatformProcessor.java", "diffHunk": "@@ -47,6 +48,13 @@\n      */\n     public PlatformContext context();\n \n+    /**\n+     * Returns a value indicating whether {@link #context()} is available.\n+     *\n+     * @return value indicating whether {@link #context()} is available.\n+     */\n+    public boolean hasContext();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e74369732817fd074a8e4231cf4f0238491df750"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzMzMTE1OnYy", "diffSide": "RIGHT", "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Common/CopyOnWriteConcurrentDictionary.cs", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQyMzo1MTowMVrOF8eggA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNzozNjoyOFrOF8l8lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1ODcyMA==", "bodyText": "Probably, it makes sense to make this check prior to copying dictionary, as object already locked and can not change. It can save a lot of CPU time in negative scenario.", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r398958720", "createdAt": "2020-03-26T23:51:01Z", "author": {"login": "isapego"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Common/CopyOnWriteConcurrentDictionary.cs", "diffHunk": "@@ -89,6 +89,30 @@ public void Set(TKey key, TValue value)\n                 _dict = dict0;\n             }\n         }\n+\n+        /// <summary>\n+        /// Removes the value with the specified key.\n+        /// </summary>\n+        /// <param name=\"key\">The key.</param>\n+        /// <param name=\"val\">Removed value, if any.</param>\n+        public bool Remove(TKey key, out TValue val)\n+        {\n+            lock (this)\n+            {\n+                var dict0 = new Dictionary<TKey, TValue>(_dict);\n+\n+                if (!dict0.TryGetValue(key, out val))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ac831d21b05cb51c03e068fe4717aa20457bec95"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA4MDU5Nw==", "bodyText": "Good catch, fixed", "url": "https://github.com/gridgain/gridgain/pull/890#discussion_r399080597", "createdAt": "2020-03-27T07:36:28Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/dotnet/Apache.Ignite.Core/Impl/Common/CopyOnWriteConcurrentDictionary.cs", "diffHunk": "@@ -89,6 +89,30 @@ public void Set(TKey key, TValue value)\n                 _dict = dict0;\n             }\n         }\n+\n+        /// <summary>\n+        /// Removes the value with the specified key.\n+        /// </summary>\n+        /// <param name=\"key\">The key.</param>\n+        /// <param name=\"val\">Removed value, if any.</param>\n+        public bool Remove(TKey key, out TValue val)\n+        {\n+            lock (this)\n+            {\n+                var dict0 = new Dictionary<TKey, TValue>(_dict);\n+\n+                if (!dict0.TryGetValue(key, out val))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODk1ODcyMA=="}, "originalCommit": {"oid": "ac831d21b05cb51c03e068fe4717aa20457bec95"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3171, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}