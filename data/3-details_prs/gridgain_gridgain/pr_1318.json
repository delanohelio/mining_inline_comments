{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0Nzc4OTEz", "number": 1318, "title": "GG-30206: Enabled CPP Cluster API", "bodyText": "", "createdAt": "2020-07-21T22:27:08Z", "url": "https://github.com/gridgain/gridgain/pull/1318", "merged": true, "mergeCommit": {"oid": "8ad4bcde18c07758f14e5953d873fb609446dbf9"}, "closed": true, "closedAt": "2020-07-22T23:03:38Z", "author": {"login": "isapego"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3YnLhAFqTQ1MzE5MDMzOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc3h0YgAH2gAyNDU0Nzc4OTEzOjFhYTIzMjg4YWE0YWEzMzRkY2M4OTUwNTNjNDJhOTNjMWY2NWY0ZGY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzMTkwMzM4", "url": "https://github.com/gridgain/gridgain/pull/1318#pullrequestreview-453190338", "createdAt": "2020-07-22T10:27:04Z", "commit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDoyNzowNFrOG1cbAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDo1MjoxN1rOG1dM1w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5MzM3OA==", "bodyText": "Can you please explain this loop logic? Our BinaryObject format does not require looping like this, looks confusing.", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458693378", "createdAt": "2020-07-22T10:27:04Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "diffHunk": "@@ -40,6 +40,20 @@ namespace ignite\n             {\n                 if (idRslvr)\n                     this->idRslvr = idRslvr->Clone();\n+\n+                while (true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5NDk0NQ==", "bodyText": "OP_ prefix is not consistent", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458694945", "createdAt": "2020-07-22T10:30:09Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/core/include/ignite/impl/compute/compute_impl.h", "diffHunk": "@@ -48,11 +48,13 @@ namespace ignite\n                 {\n                     enum Type\n                     {\n-                        AFFINITY = 1,\n-\n                         BROADCAST = 2,\n \n                         UNICAST = 5,\n+\n+                        OP_AFFINITY_CALL = 13,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwMzMyNQ==", "bodyText": "Combine with the condition below to make it if-else. The logic is confusing with the last error: is Job is not registred for handle even possible?", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458703325", "createdAt": "2020-07-22T10:46:38Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "diffHunk": "@@ -659,18 +685,13 @@ namespace ignite\n             // Cancel flag\n             reader.ReadBool();\n \n-            SharedPointer<compute::ComputeJobHolder> job0 =\n-                StaticPointerCast<compute::ComputeJobHolder>(registry.Get(jobHandle));\n-\n-            compute::ComputeJobHolder* job = job0.Get();\n-\n             SharedPointer<compute::ComputeTaskHolder> task0 =\n                 StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(taskHandle));\n \n             compute::ComputeTaskHolder* task = task0.Get();\n \n-            if (task && job)\n-                return task->JobResultRemote(*job, reader);\n+            if (task)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNDA3Mg==", "bodyText": "Should we reduce in case of error?", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458704072", "createdAt": "2020-07-22T10:48:12Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "diffHunk": "@@ -789,6 +810,103 @@ namespace ignite\n             return res ? 1 : 0;\n         }\n \n+        int64_t IgniteEnvironment::OnFutureResult(int64_t handle, SharedPointer<InteropMemory>& mem)\n+        {\n+            InteropInputStream inStream(mem.Get());\n+            BinaryReaderImpl reader(&inStream);\n+\n+            SharedPointer<compute::ComputeTaskHolder> task0 =\n+                StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(handle));\n+\n+            registry.Release(handle);\n+\n+            compute::ComputeTaskHolder* task = task0.Get();\n+\n+            task->JobResultSuccess(reader);\n+            task->Reduce();\n+\n+            return 1;\n+        }\n+\n+        int64_t IgniteEnvironment::OnFutureError(int64_t handle, SharedPointer<InteropMemory>& mem)\n+        {\n+            InteropInputStream inStream(mem.Get());\n+            BinaryReaderImpl reader(&inStream);\n+            BinaryRawReader rawReader(&reader);\n+\n+            rawReader.ReadString();\n+            rawReader.ReadString();\n+\n+            std::string errStr = rawReader.ReadString();\n+\n+            IgniteError err(IgniteError::IGNITE_ERR_GENERIC, errStr.c_str());\n+\n+            SharedPointer<compute::ComputeTaskHolder> task0 =\n+                StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(handle));\n+\n+            registry.Release(handle);\n+\n+            compute::ComputeTaskHolder* task = task0.Get();\n+\n+            task->JobResultError(err);\n+            task->Reduce();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTM1MQ==", "bodyText": "splitted -> split", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458705351", "createdAt": "2020-07-22T10:50:41Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTY0NA==", "bodyText": "\"Broadcast compute jobs\"", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458705644", "createdAt": "2020-07-22T10:51:13Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjAxNw==", "bodyText": "\"Waiting for the compute jobs to complete\".\nBy the way, this is not clear: C++ Compute API is synchronous, so we don't have to wait, as I understand.", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458706017", "createdAt": "2020-07-22T10:52:02Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.\n+        client.GetCompute(group1).Broadcast(PrintMsg(\"DemoAttribute=Value0\"));\n+        client.GetCompute(group2).Broadcast(PrintMsg(\"DemoAttribute=Value1\"));\n+\n+        // Waiting the compute jobs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjEzNQ==", "bodyText": "Why stop client first?", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458706135", "createdAt": "2020-07-22T10:52:17Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.\n+        client.GetCompute(group1).Broadcast(PrintMsg(\"DemoAttribute=Value0\"));\n+        client.GetCompute(group2).Broadcast(PrintMsg(\"DemoAttribute=Value1\"));\n+\n+        // Waiting the compute jobs.\n+        std::cout << std::endl;\n+        std::cout << \">>> Waiting all compute jobs done, before shutting down the cluster, press 'Enter to continue ...\" << std::endl;\n+        std::cout << std::endl;\n+        std::cin.get();\n+\n+        // Stop client node first.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 140}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3389cd00319c2d8de208917dcaf72dd77d6f81ef", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/3389cd00319c2d8de208917dcaf72dd77d6f81ef", "committedDate": "2020-07-22T14:41:05Z", "message": "GG-30206: Enabled CPP Cluster API\n\nThis reverts commit 84a18f567fc5504b017f394eab50003fa1cea91f."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3504fb835f0a8610c95cc36aa6b61fb939274432", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/3504fb835f0a8610c95cc36aa6b61fb939274432", "committedDate": "2020-07-22T14:41:05Z", "message": "GG-30206: Fixed affinity calls/runs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1fe067a2c47be6682514a0a32e21c0fef0968bda", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/1fe067a2c47be6682514a0a32e21c0fef0968bda", "committedDate": "2020-07-22T14:41:05Z", "message": "GG-30206: Fixed flaky tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8808869a35799017e22028c7399b161fbdc0fecc", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/8808869a35799017e22028c7399b161fbdc0fecc", "committedDate": "2020-07-22T14:41:05Z", "message": "GG-30206: Fixed memory leak"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a47c80982763fd8edce705ed398d4c0a5ead91b", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/5a47c80982763fd8edce705ed398d4c0a5ead91b", "committedDate": "2020-07-22T14:41:05Z", "message": "GG-30206: Review-related fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "committedDate": "2020-07-22T14:41:05Z", "message": "GG-30206: Minor fix"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b2a358b98103db642ddb84e14bd38aac8d56889", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/6b2a358b98103db642ddb84e14bd38aac8d56889", "committedDate": "2020-07-22T14:38:01Z", "message": "GG-30206: Minor fix"}, "afterCommit": {"oid": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/15c0c869059aea0cfc6e5144cd566dab8fc99e3e", "committedDate": "2020-07-22T14:41:05Z", "message": "GG-30206: Minor fix"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUzNTIzODQz", "url": "https://github.com/gridgain/gridgain/pull/1318#pullrequestreview-453523843", "createdAt": "2020-07-22T17:15:25Z", "commit": {"oid": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzoxNToyNlrOG1sTww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzoxNToyNlrOG1sTww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MzY2Nw==", "bodyText": "What if this condition is false? Is it a valid case or should we throw an error?", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458953667", "createdAt": "2020-07-22T17:15:26Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "diffHunk": "@@ -36,10 +36,23 @@ namespace ignite\n                 mem(&mem),\n                 start(start),\n                 idRslvr(0),\n-                metaMgr(metaMgr)\n+                metaMgr(metaMgr),\n+                binary(false)\n             {\n                 if (idRslvr)\n                     this->idRslvr = idRslvr->Clone();\n+\n+                int8_t hdr = BinaryUtils::ReadInt8(mem, this->start);\n+\n+                if (hdr == IGNITE_TYPE_BINARY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e"}, "originalPosition": 13}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6e36ee5ba0cde6ade77e29e3b6b91b01022e370", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/d6e36ee5ba0cde6ade77e29e3b6b91b01022e370", "committedDate": "2020-07-22T19:17:53Z", "message": "GG-30206: Added check for BinaryObjectImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1aa23288aa4aa334dcc895053c42a93c1f65f4df", "author": {"user": {"login": "isapego", "name": "Igor Sapego"}}, "url": "https://github.com/gridgain/gridgain/commit/1aa23288aa4aa334dcc895053c42a93c1f65f4df", "committedDate": "2020-07-22T21:36:00Z", "message": "GG-30206: Fixed container"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 39, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}