{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0Nzc4OTEz", "number": 1318, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDoyNzowNFrOEQ_I8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzoxNToyNlrOERJFwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjQ3MTU0OnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDoyNzowNFrOG1cbAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTowMjozNVrOG1dgNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5MzM3OA==", "bodyText": "Can you please explain this loop logic? Our BinaryObject format does not require looping like this, looks confusing.", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458693378", "createdAt": "2020-07-22T10:27:04Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "diffHunk": "@@ -40,6 +40,20 @@ namespace ignite\n             {\n                 if (idRslvr)\n                     this->idRslvr = idRslvr->Clone();\n+\n+                while (true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxMTA5NQ==", "bodyText": "You are right. Will remove", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458711095", "createdAt": "2020-07-22T11:02:35Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "diffHunk": "@@ -40,6 +40,20 @@ namespace ignite\n             {\n                 if (idRslvr)\n                     this->idRslvr = idRslvr->Clone();\n+\n+                while (true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5MzM3OA=="}, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjQ4MTQ1OnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/core/include/ignite/impl/compute/compute_impl.h", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDozMDowOVrOG1chIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTowNToyNlrOG1dlvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5NDk0NQ==", "bodyText": "OP_ prefix is not consistent", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458694945", "createdAt": "2020-07-22T10:30:09Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/core/include/ignite/impl/compute/compute_impl.h", "diffHunk": "@@ -48,11 +48,13 @@ namespace ignite\n                 {\n                     enum Type\n                     {\n-                        AFFINITY = 1,\n-\n                         BROADCAST = 2,\n \n                         UNICAST = 5,\n+\n+                        OP_AFFINITY_CALL = 13,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxMjUxMQ==", "bodyText": "Agree. Fixed", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458712511", "createdAt": "2020-07-22T11:05:26Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/core/include/ignite/impl/compute/compute_impl.h", "diffHunk": "@@ -48,11 +48,13 @@ namespace ignite\n                 {\n                     enum Type\n                     {\n-                        AFFINITY = 1,\n-\n                         BROADCAST = 2,\n \n                         UNICAST = 5,\n+\n+                        OP_AFFINITY_CALL = 13,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODY5NDk0NQ=="}, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjUzMzczOnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDo0NjozOFrOG1dB3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToxNDozN1rOG1d3TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwMzMyNQ==", "bodyText": "Combine with the condition below to make it if-else. The logic is confusing with the last error: is Job is not registred for handle even possible?", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458703325", "createdAt": "2020-07-22T10:46:38Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "diffHunk": "@@ -659,18 +685,13 @@ namespace ignite\n             // Cancel flag\n             reader.ReadBool();\n \n-            SharedPointer<compute::ComputeJobHolder> job0 =\n-                StaticPointerCast<compute::ComputeJobHolder>(registry.Get(jobHandle));\n-\n-            compute::ComputeJobHolder* job = job0.Get();\n-\n             SharedPointer<compute::ComputeTaskHolder> task0 =\n                 StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(taskHandle));\n \n             compute::ComputeTaskHolder* task = task0.Get();\n \n-            if (task && job)\n-                return task->JobResultRemote(*job, reader);\n+            if (task)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxNzAwNA==", "bodyText": "Agree, fixed. On normal conditions, it should not happen, I believe.", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458717004", "createdAt": "2020-07-22T11:14:37Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "diffHunk": "@@ -659,18 +685,13 @@ namespace ignite\n             // Cancel flag\n             reader.ReadBool();\n \n-            SharedPointer<compute::ComputeJobHolder> job0 =\n-                StaticPointerCast<compute::ComputeJobHolder>(registry.Get(jobHandle));\n-\n-            compute::ComputeJobHolder* job = job0.Get();\n-\n             SharedPointer<compute::ComputeTaskHolder> task0 =\n                 StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(taskHandle));\n \n             compute::ComputeTaskHolder* task = task0.Get();\n \n-            if (task && job)\n-                return task->JobResultRemote(*job, reader);\n+            if (task)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwMzMyNQ=="}, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjUzODM3OnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDo0ODoxMlrOG1dEyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToxNjozNlrOG1d7Hg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNDA3Mg==", "bodyText": "Should we reduce in case of error?", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458704072", "createdAt": "2020-07-22T10:48:12Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "diffHunk": "@@ -789,6 +810,103 @@ namespace ignite\n             return res ? 1 : 0;\n         }\n \n+        int64_t IgniteEnvironment::OnFutureResult(int64_t handle, SharedPointer<InteropMemory>& mem)\n+        {\n+            InteropInputStream inStream(mem.Get());\n+            BinaryReaderImpl reader(&inStream);\n+\n+            SharedPointer<compute::ComputeTaskHolder> task0 =\n+                StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(handle));\n+\n+            registry.Release(handle);\n+\n+            compute::ComputeTaskHolder* task = task0.Get();\n+\n+            task->JobResultSuccess(reader);\n+            task->Reduce();\n+\n+            return 1;\n+        }\n+\n+        int64_t IgniteEnvironment::OnFutureError(int64_t handle, SharedPointer<InteropMemory>& mem)\n+        {\n+            InteropInputStream inStream(mem.Get());\n+            BinaryReaderImpl reader(&inStream);\n+            BinaryRawReader rawReader(&reader);\n+\n+            rawReader.ReadString();\n+            rawReader.ReadString();\n+\n+            std::string errStr = rawReader.ReadString();\n+\n+            IgniteError err(IgniteError::IGNITE_ERR_GENERIC, errStr.c_str());\n+\n+            SharedPointer<compute::ComputeTaskHolder> task0 =\n+                StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(handle));\n+\n+            registry.Release(handle);\n+\n+            compute::ComputeTaskHolder* task = task0.Get();\n+\n+            task->JobResultError(err);\n+            task->Reduce();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 249}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxNzk4Mg==", "bodyText": "Yeah, in this case reduce will only notify future that result is available, even if it's an error.", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458717982", "createdAt": "2020-07-22T11:16:36Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/core/src/impl/ignite_environment.cpp", "diffHunk": "@@ -789,6 +810,103 @@ namespace ignite\n             return res ? 1 : 0;\n         }\n \n+        int64_t IgniteEnvironment::OnFutureResult(int64_t handle, SharedPointer<InteropMemory>& mem)\n+        {\n+            InteropInputStream inStream(mem.Get());\n+            BinaryReaderImpl reader(&inStream);\n+\n+            SharedPointer<compute::ComputeTaskHolder> task0 =\n+                StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(handle));\n+\n+            registry.Release(handle);\n+\n+            compute::ComputeTaskHolder* task = task0.Get();\n+\n+            task->JobResultSuccess(reader);\n+            task->Reduce();\n+\n+            return 1;\n+        }\n+\n+        int64_t IgniteEnvironment::OnFutureError(int64_t handle, SharedPointer<InteropMemory>& mem)\n+        {\n+            InteropInputStream inStream(mem.Get());\n+            BinaryReaderImpl reader(&inStream);\n+            BinaryRawReader rawReader(&reader);\n+\n+            rawReader.ReadString();\n+            rawReader.ReadString();\n+\n+            std::string errStr = rawReader.ReadString();\n+\n+            IgniteError err(IgniteError::IGNITE_ERR_GENERIC, errStr.c_str());\n+\n+            SharedPointer<compute::ComputeTaskHolder> task0 =\n+                StaticPointerCast<compute::ComputeTaskHolder>(registry.Get(handle));\n+\n+            registry.Release(handle);\n+\n+            compute::ComputeTaskHolder* task = task0.Get();\n+\n+            task->JobResultError(err);\n+            task->Reduce();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNDA3Mg=="}, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 249}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjU0NjMyOnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDo1MDo0MVrOG1dJxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToxNzoyOFrOG1d8qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTM1MQ==", "bodyText": "splitted -> split", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458705351", "createdAt": "2020-07-22T10:50:41Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxODM3OQ==", "bodyText": "Good catch", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458718379", "createdAt": "2020-07-22T11:17:28Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTM1MQ=="}, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjU0ODI1OnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDo1MToxM1rOG1dK7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMToxOToxNVrOG1d_zg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTY0NA==", "bodyText": "\"Broadcast compute jobs\"", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458705644", "createdAt": "2020-07-22T10:51:13Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxOTE4Mg==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458719182", "createdAt": "2020-07-22T11:19:15Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNTY0NA=="}, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjU1MDcxOnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDo1MjowMlrOG1dMYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNDozMzozMVrOG1lS5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjAxNw==", "bodyText": "\"Waiting for the compute jobs to complete\".\nBy the way, this is not clear: C++ Compute API is synchronous, so we don't have to wait, as I understand.", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458706017", "createdAt": "2020-07-22T10:52:02Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.\n+        client.GetCompute(group1).Broadcast(PrintMsg(\"DemoAttribute=Value0\"));\n+        client.GetCompute(group2).Broadcast(PrintMsg(\"DemoAttribute=Value1\"));\n+\n+        // Waiting the compute jobs.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODgzODc1Ng==", "bodyText": "This is not completely true. We do have sync and async Compute API in C++. But in this case sync version is used, so you are right, this is not necessary, but it helps to see result of the example for a user. I think, only a message should be fixed.", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458838756", "createdAt": "2020-07-22T14:33:31Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.\n+        client.GetCompute(group1).Broadcast(PrintMsg(\"DemoAttribute=Value0\"));\n+        client.GetCompute(group2).Broadcast(PrintMsg(\"DemoAttribute=Value1\"));\n+\n+        // Waiting the compute jobs.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjAxNw=="}, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjU1MTM3OnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMDo1MjoxN1rOG1dM1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTo0ODoyM1rOG1e3bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjEzNQ==", "bodyText": "Why stop client first?", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458706135", "createdAt": "2020-07-22T10:52:17Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.\n+        client.GetCompute(group1).Broadcast(PrintMsg(\"DemoAttribute=Value0\"));\n+        client.GetCompute(group2).Broadcast(PrintMsg(\"DemoAttribute=Value1\"));\n+\n+        // Waiting the compute jobs.\n+        std::cout << std::endl;\n+        std::cout << \">>> Waiting all compute jobs done, before shutting down the cluster, press 'Enter to continue ...\" << std::endl;\n+        std::cout << std::endl;\n+        std::cin.get();\n+\n+        // Stop client node first.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczMzQyMQ==", "bodyText": "Because client prints exception when loses connection to all server nodes in cluster. Just to make output more clear and less scary for a user.", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458733421", "createdAt": "2020-07-22T11:48:23Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/examples/cluster-compute-example/src/cluster_compute_example.cpp", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Copyright 2019 GridGain Systems, Inc. and Contributors.\n+ *\n+ * Licensed under the GridGain Community Edition License (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     https://www.gridgain.com/products/software/community-edition/gridgain-community-edition-license\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+#include <stdint.h>\n+#include <iostream>\n+#include <sstream>\n+\n+#include <ignite/ignition.h>\n+#include <ignite/compute/compute.h>\n+#include <ignite/cluster/cluster_group.h>\n+\n+using namespace ignite;\n+using namespace compute;\n+using namespace cluster;\n+\n+/*\n+ * Function class.\n+ */\n+class PrintMsg : public ComputeFunc<void>\n+{\n+    friend struct ignite::binary::BinaryType<PrintMsg>;\n+public:\n+    /*\n+     * Default constructor.\n+     */\n+    PrintMsg() :\n+        msg(\"default\")\n+    {\n+        // No-op.\n+    }\n+\n+    /*\n+     * Constructor.\n+     *\n+     * @param text Text.\n+     */\n+    PrintMsg(std::string msg) :\n+        msg(msg)\n+    {\n+        // No-op.\n+    }\n+\n+    /**\n+     * Callback.\n+     * Just print the message.\n+     *\n+     */\n+    virtual void Call()\n+    {\n+        std::cout << \"# MESSAGE => \" <<  msg << std::endl;\n+    }\n+\n+private:\n+    /** Message text. */\n+    std::string msg;\n+};\n+\n+namespace ignite\n+{\n+    namespace binary\n+    {\n+        template<>\n+        struct BinaryType<PrintMsg>: BinaryTypeDefaultAll<PrintMsg>\n+        {\n+            static void GetTypeName(std::string& dst)\n+            {\n+                dst = \"Func\";\n+            }\n+\n+            static void Write(BinaryWriter& writer, const PrintMsg& obj)\n+            {\n+                writer.RawWriter().WriteString(obj.msg);\n+            }\n+\n+            static void Read(BinaryReader& reader, PrintMsg& dst)\n+            {\n+                dst.msg = reader.RawReader().ReadString();\n+            }\n+        };\n+    }\n+}\n+\n+int main()\n+{\n+    IgniteConfiguration cfgs[4];\n+\n+    cfgs[0].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example1.xml\";\n+    cfgs[1].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[2].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example2.xml\";\n+    cfgs[3].springCfgPath = \"platforms/cpp/examples/cluster-compute-example/config/cluster-compute-example-client.xml\";\n+\n+    try\n+    {\n+        // Start server nodes.\n+        Ignite node1 = Ignition::Start(cfgs[0], \"DemoAttributeValue0\");\n+        Ignite node2 = Ignition::Start(cfgs[1], \"DemoAttributeValue1I0\");\n+        Ignite node3 = Ignition::Start(cfgs[2], \"DemoAttributeValue1I1\");\n+\n+        // Start client node.\n+        Ignite client = Ignition::Start(cfgs[3], \"Client\");\n+\n+        std::cout << std::endl;\n+        std::cout << \">>> Cluster compute example started.\" << std::endl;\n+        std::cout << std::endl;\n+\n+        // Get binding instances and register our classes as a compute functions.\n+        node1.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node2.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        node3.GetBinding().RegisterComputeFunc<PrintMsg>();\n+        client.GetBinding().RegisterComputeFunc<PrintMsg>();\n+\n+        // Create cluster groups splitted up by demo attribute value.\n+        ClusterGroup localGroup = client.GetCluster().AsClusterGroup();\n+        ClusterGroup group1 = localGroup.ForAttribute(\"DemoAttribute\", \"Value0\");\n+        ClusterGroup group2 = localGroup.ForAttribute(\"DemoAttribute\", \"Value1\");\n+\n+        // Making calls.\n+        client.GetCompute(group1).Broadcast(PrintMsg(\"DemoAttribute=Value0\"));\n+        client.GetCompute(group2).Broadcast(PrintMsg(\"DemoAttribute=Value1\"));\n+\n+        // Waiting the compute jobs.\n+        std::cout << std::endl;\n+        std::cout << \">>> Waiting all compute jobs done, before shutting down the cluster, press 'Enter to continue ...\" << std::endl;\n+        std::cout << std::endl;\n+        std::cin.get();\n+\n+        // Stop client node first.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcwNjEzNQ=="}, "originalCommit": {"oid": "ed9a2a8b2c5ef63322e6af1235156d82faf9863b"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2NDEwMTc3OnYy", "diffSide": "RIGHT", "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxNzoxNToyNlrOG1sTww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxOTowMTo1OVrOG1wL3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MzY2Nw==", "bodyText": "What if this condition is false? Is it a valid case or should we throw an error?", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r458953667", "createdAt": "2020-07-22T17:15:26Z", "author": {"login": "ptupitsyn"}, "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "diffHunk": "@@ -36,10 +36,23 @@ namespace ignite\n                 mem(&mem),\n                 start(start),\n                 idRslvr(0),\n-                metaMgr(metaMgr)\n+                metaMgr(metaMgr),\n+                binary(false)\n             {\n                 if (idRslvr)\n                     this->idRslvr = idRslvr->Clone();\n+\n+                int8_t hdr = BinaryUtils::ReadInt8(mem, this->start);\n+\n+                if (hdr == IGNITE_TYPE_BINARY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTAxNzE4Mg==", "bodyText": "It's OK, the class works on normal objects (hdr = 103) too. Maybe we should throw in other cases though. It's only internal class for now, so no other cases are expected. Will add a check", "url": "https://github.com/gridgain/gridgain/pull/1318#discussion_r459017182", "createdAt": "2020-07-22T19:01:59Z", "author": {"login": "isapego"}, "path": "modules/platforms/cpp/binary/src/impl/binary/binary_object_impl.cpp", "diffHunk": "@@ -36,10 +36,23 @@ namespace ignite\n                 mem(&mem),\n                 start(start),\n                 idRslvr(0),\n-                metaMgr(metaMgr)\n+                metaMgr(metaMgr),\n+                binary(false)\n             {\n                 if (idRslvr)\n                     this->idRslvr = idRslvr->Clone();\n+\n+                int8_t hdr = BinaryUtils::ReadInt8(mem, this->start);\n+\n+                if (hdr == IGNITE_TYPE_BINARY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk1MzY2Nw=="}, "originalCommit": {"oid": "15c0c869059aea0cfc6e5144cd566dab8fc99e3e"}, "originalPosition": 13}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3297, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}