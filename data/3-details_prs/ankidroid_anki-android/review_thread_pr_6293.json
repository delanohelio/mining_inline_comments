{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzOTk3NjMw", "number": 6293, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzozMzoyM1rOEANBzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNDoyNzo0NVrOEBHG9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY4NjQ4OTA5OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/build.gradle", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxNzozMzoyM1rOGbVtTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QxODoyMDoyN1rOGbXkfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyMDM5Ng==", "bodyText": "Fascinating bug thread(s) there. For me I had to read those in order to answer the question I had, so I'd like the comment to distill it and answer the question directly, also the real tracking issue is different\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                //apparently required for testing fragments :/\n          \n          \n            \n                //https://issuetracker.google.com/issues/122321150\n          \n          \n            \n                // debugImplementation required vs testImplementation: https://issuetracker.google.com/issues/128612536\n          \n      \n    \n    \n  \n\nFinally, I actually use standard lint rule packs in other languages and it's not a big deal but I wonder about your 'comment slashes with no space after' style - it's visually jarring to me and linted out via my standard packages. Is this important to you? If not, I humbly submit I prefer '// then comment' :-)", "url": "https://github.com/ankidroid/Anki-Android/pull/6293#discussion_r431320396", "createdAt": "2020-05-27T17:33:23Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/build.gradle", "diffHunk": "@@ -168,6 +168,9 @@ dependencies {\n     testImplementation \"org.robolectric:robolectric:4.3.1\"\n     testImplementation 'androidx.test:core:1.2.0'\n     testImplementation 'androidx.test.ext:junit:1.1.1'\n+    //apparently required for testing fragments :/\n+    //https://issuetracker.google.com/issues/122321150", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf82c88fff9ae2a11a0ca164017fba06269e53b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMzNjI3Ng==", "bodyText": "The horrors of being a self-taught programmer. Just wait until you catch me using Allman-style braces \ud83d\ude09\nCan we start up a wiki page or issue about these nits? Better to encode these into autolint settings, rather than add PR comments.", "url": "https://github.com/ankidroid/Anki-Android/pull/6293#discussion_r431336276", "createdAt": "2020-05-27T17:56:00Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/build.gradle", "diffHunk": "@@ -168,6 +168,9 @@ dependencies {\n     testImplementation \"org.robolectric:robolectric:4.3.1\"\n     testImplementation 'androidx.test:core:1.2.0'\n     testImplementation 'androidx.test.ext:junit:1.1.1'\n+    //apparently required for testing fragments :/\n+    //https://issuetracker.google.com/issues/122321150", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyMDM5Ng=="}, "originalCommit": {"oid": "5cf82c88fff9ae2a11a0ca164017fba06269e53b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MDQwMA==", "bodyText": "Yes we can (go for it hahaha) - honestly it should all be in codacy, driven by a checkstyle or pmd xml that Android Studio reads. I think there actually is a coding standards document even? In the codebase?", "url": "https://github.com/ankidroid/Anki-Android/pull/6293#discussion_r431340400", "createdAt": "2020-05-27T18:01:38Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/build.gradle", "diffHunk": "@@ -168,6 +168,9 @@ dependencies {\n     testImplementation \"org.robolectric:robolectric:4.3.1\"\n     testImplementation 'androidx.test:core:1.2.0'\n     testImplementation 'androidx.test.ext:junit:1.1.1'\n+    //apparently required for testing fragments :/\n+    //https://issuetracker.google.com/issues/122321150", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyMDM5Ng=="}, "originalCommit": {"oid": "5cf82c88fff9ae2a11a0ca164017fba06269e53b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM0MzU5MQ==", "bodyText": "https://github.com/ankidroid/Anki-Android/blob/master/docs/code_conventions/AnkiDroid_code_conventions.html ... I missed that.", "url": "https://github.com/ankidroid/Anki-Android/pull/6293#discussion_r431343591", "createdAt": "2020-05-27T18:07:27Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/build.gradle", "diffHunk": "@@ -168,6 +168,9 @@ dependencies {\n     testImplementation \"org.robolectric:robolectric:4.3.1\"\n     testImplementation 'androidx.test:core:1.2.0'\n     testImplementation 'androidx.test.ext:junit:1.1.1'\n+    //apparently required for testing fragments :/\n+    //https://issuetracker.google.com/issues/122321150", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyMDM5Ng=="}, "originalCommit": {"oid": "5cf82c88fff9ae2a11a0ca164017fba06269e53b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTM1MDkxMQ==", "bodyText": "... we should probably have an Anki deck for this", "url": "https://github.com/ankidroid/Anki-Android/pull/6293#discussion_r431350911", "createdAt": "2020-05-27T18:20:27Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/build.gradle", "diffHunk": "@@ -168,6 +168,9 @@ dependencies {\n     testImplementation \"org.robolectric:robolectric:4.3.1\"\n     testImplementation 'androidx.test:core:1.2.0'\n     testImplementation 'androidx.test.ext:junit:1.1.1'\n+    //apparently required for testing fragments :/\n+    //https://issuetracker.google.com/issues/122321150", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTMyMDM5Ng=="}, "originalCommit": {"oid": "5cf82c88fff9ae2a11a0ca164017fba06269e53b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjAwNDk4OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/androidTest/java/androidx/test/internal/runner/MultiDexClassPathScanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNDoyNzo0NFrOGcyzqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNDoyNzo0NFrOGcyzqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0NTczNg==", "bodyText": "Issue found: Avoid throwing raw exception types.", "url": "https://github.com/ankidroid/Anki-Android/pull/6293#discussion_r432845736", "createdAt": "2020-05-30T14:27:44Z", "author": {"login": "timrae"}, "path": "AnkiDroid/src/androidTest/java/androidx/test/internal/runner/MultiDexClassPathScanner.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ Copyright (c) 2020 David Allison <davidallisongithub@gmail.com>\n+\n+ This program is free software; you can redistribute it and/or modify it under\n+ the terms of the GNU General Public License as published by the Free Software\n+ Foundation; either version 3 of the License, or (at your option) any later\n+ version.\n+\n+ This program is distributed in the hope that it will be useful, but WITHOUT ANY\n+ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ PARTICULAR PURPOSE. See the GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License along with\n+ this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package androidx.test.internal.runner;\n+\n+import android.content.Context;\n+import android.os.Build;\n+\n+import com.ichi2.libanki.Utils;\n+\n+import org.jf.dexlib2.DexFileFactory;\n+import org.jf.dexlib2.dexbacked.DexBackedDexFile;\n+import org.jf.dexlib2.iface.ClassDef;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.VisibleForTesting;\n+import timber.log.Timber;\n+\n+/**\n+ * This class exists as I could get MultiDex working, but ClassPathScanner uses new DexFile(),\n+ * which only loads the classes from classes.dex in Android < 21. MultiDex.install() fixes the class loader,\n+ * but since we don't return all the class names from the dex, we don't see these as potential test classes to filter.\n+ **/\n+class MultiDexClassPathScanner extends ClassPathScanner {\n+    private final List<String> classPathEntries;\n+    private final Context targetContext;\n+\n+    public MultiDexClassPathScanner(List<String> classPath, Context targetContext) {\n+        super(classPath);\n+        //There's no accessor in the base class.\n+        this.classPathEntries = classPath;\n+        //We need context to get a temporary folder to store our extracted dex files.\n+        this.targetContext = targetContext;\n+    }\n+\n+    @Override\n+    @VisibleForTesting\n+    //dalvik.system.DexFile\n+    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"})\n+    Enumeration<String> getDexEntries(dalvik.system.DexFile dexFile) {\n+        List<String> ret = new ArrayList<>();\n+        String absolutePath = targetContext.getCacheDir().getAbsolutePath();\n+\n+        for (String classPath : classPathEntries) {\n+            for (String dexPath: extractDexFilesFromApk(classPath, absolutePath)) {\n+                List<String> classes = extractClassesFromDexPath(dexPath);\n+                ret.addAll(classes);\n+            }\n+        }\n+\n+        return Collections.enumeration(ret);\n+    }\n+\n+\n+    private List<String> extractClassesFromDexPath(String dexPath) {\n+        List<String> ret = new ArrayList<>();\n+        try {\n+            DexBackedDexFile dex = DexFileFactory.loadDexFile(dexPath, Build.VERSION.SDK_INT);\n+            for (ClassDef classDef: dex.getClasses()) {\n+                String typeName = extractTypeNameFromDef(classDef);\n+                ret.add(typeName);\n+            }\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e.getLocalizedMessage(), e);\n+        }\n+        return ret;\n+    }\n+\n+\n+    /**\n+     * @param classDef The class definition to extract the name from\n+     * @return A classname in the form: java.util.scanner\n+     */\n+    @NonNull\n+    private String extractTypeNameFromDef(ClassDef classDef) {\n+        String type = classDef.getType();\n+        //classes are inconsistently named: https://stackoverflow.com/a/11350724\n+        //Assumed structure: Ljava/lang/String;\n+        if (!type.startsWith(\"L\") || !type.endsWith(\";\")) {\n+            throw new IllegalArgumentException(\"Unhandled class type: \" + type);\n+        }\n+        type = type.substring(1, type.length() - 1); //trim suffix and prefix\n+        type = type.replace('/', '.');\n+        return type;\n+    }\n+\n+\n+    private List<String> extractDexFilesFromApk(String path, String targetDirectory) {\n+        //Modified from Utils.unzipFiles\n+        ZipFile zip;\n+        try {\n+            zip = new ZipFile(new File(path), ZipFile.OPEN_READ);\n+        } catch (IOException e) {\n+            throw new RuntimeException(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d8436d14c6308adb813a6d792d054576e44873c"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NjAwNTAzOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/androidTest/java/androidx/test/internal/runner/MultiDexClassPathScanner.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNDoyNzo0NVrOGcyzrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0zMFQxNDoyNzo0NVrOGcyzrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjg0NTc0MQ==", "bodyText": "Issue found: Avoid throwing raw exception types.", "url": "https://github.com/ankidroid/Anki-Android/pull/6293#discussion_r432845741", "createdAt": "2020-05-30T14:27:45Z", "author": {"login": "timrae"}, "path": "AnkiDroid/src/androidTest/java/androidx/test/internal/runner/MultiDexClassPathScanner.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ Copyright (c) 2020 David Allison <davidallisongithub@gmail.com>\n+\n+ This program is free software; you can redistribute it and/or modify it under\n+ the terms of the GNU General Public License as published by the Free Software\n+ Foundation; either version 3 of the License, or (at your option) any later\n+ version.\n+\n+ This program is distributed in the hope that it will be useful, but WITHOUT ANY\n+ WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n+ PARTICULAR PURPOSE. See the GNU General Public License for more details.\n+\n+ You should have received a copy of the GNU General Public License along with\n+ this program.  If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package androidx.test.internal.runner;\n+\n+import android.content.Context;\n+import android.os.Build;\n+\n+import com.ichi2.libanki.Utils;\n+\n+import org.jf.dexlib2.DexFileFactory;\n+import org.jf.dexlib2.dexbacked.DexBackedDexFile;\n+import org.jf.dexlib2.iface.ClassDef;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Enumeration;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.zip.ZipEntry;\n+import java.util.zip.ZipFile;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.VisibleForTesting;\n+import timber.log.Timber;\n+\n+/**\n+ * This class exists as I could get MultiDex working, but ClassPathScanner uses new DexFile(),\n+ * which only loads the classes from classes.dex in Android < 21. MultiDex.install() fixes the class loader,\n+ * but since we don't return all the class names from the dex, we don't see these as potential test classes to filter.\n+ **/\n+class MultiDexClassPathScanner extends ClassPathScanner {\n+    private final List<String> classPathEntries;\n+    private final Context targetContext;\n+\n+    public MultiDexClassPathScanner(List<String> classPath, Context targetContext) {\n+        super(classPath);\n+        //There's no accessor in the base class.\n+        this.classPathEntries = classPath;\n+        //We need context to get a temporary folder to store our extracted dex files.\n+        this.targetContext = targetContext;\n+    }\n+\n+    @Override\n+    @VisibleForTesting\n+    //dalvik.system.DexFile\n+    @SuppressWarnings( {\"deprecation\", \"RedundantSuppression\"})\n+    Enumeration<String> getDexEntries(dalvik.system.DexFile dexFile) {\n+        List<String> ret = new ArrayList<>();\n+        String absolutePath = targetContext.getCacheDir().getAbsolutePath();\n+\n+        for (String classPath : classPathEntries) {\n+            for (String dexPath: extractDexFilesFromApk(classPath, absolutePath)) {\n+                List<String> classes = extractClassesFromDexPath(dexPath);\n+                ret.addAll(classes);\n+            }\n+        }\n+\n+        return Collections.enumeration(ret);\n+    }\n+\n+\n+    private List<String> extractClassesFromDexPath(String dexPath) {\n+        List<String> ret = new ArrayList<>();\n+        try {\n+            DexBackedDexFile dex = DexFileFactory.loadDexFile(dexPath, Build.VERSION.SDK_INT);\n+            for (ClassDef classDef: dex.getClasses()) {\n+                String typeName = extractTypeNameFromDef(classDef);\n+                ret.add(typeName);\n+            }\n+\n+        } catch (IOException e) {\n+            throw new RuntimeException(e.getLocalizedMessage(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0d8436d14c6308adb813a6d792d054576e44873c"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 307, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}