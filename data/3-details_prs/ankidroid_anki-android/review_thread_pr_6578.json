{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMTUwNzIw", "number": 6578, "reviewThreads": {"totalCount": 29, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo0NjoyM1rOEX9QAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToyMzoyMlrOEb-6jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTU2MjI3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo0NjoyM1rOHACCqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo0MzoxNlrOHAY3CA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA==", "bodyText": "Could you extract this condition (instanceof) to a member on AbstractDeckTreeNode with a reasonable name", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469795498", "createdAt": "2020-08-13T08:46:23Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,7 +2107,21 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_ instanceof DeckDueTreeNode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NjgyMw==", "bodyText": "I don't feel the copy/pasting works well here.\nCombine the two into (deckDueTreeNode_.shouldOpenReviewerOnSelection())", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469796823", "createdAt": "2020-08-13T08:48:33Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,7 +2107,21 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_ instanceof DeckDueTreeNode)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2OTM1Mg==", "bodyText": "I'm not convinced it makes the code easier to read, because anyway I'm going to use a cast; so instanceOf makes sens here.\nI am pretty sure I had a good reason not to factorize, but I can't recall it", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470169352", "createdAt": "2020-08-13T18:43:16Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,7 +2107,21 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_ instanceof DeckDueTreeNode)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTU3NTQ1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo0OTo1MVrOHACK9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDozNDozMVrOHAcqgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzYyMg==", "bodyText": "@Nullable - and ensure that there are no lint warnings", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469797622", "createdAt": "2020-08-13T08:49:51Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -319,15 +329,23 @@ public int findDeckPosition(long did) {\n     }\n \n \n-    public int getEta() {\n-        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});\n+    public Integer getEta() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMTY4MA==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470231680", "createdAt": "2020-08-13T20:34:31Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -319,15 +329,23 @@ public int findDeckPosition(long did) {\n     }\n \n \n-    public int getEta() {\n-        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});\n+    public Integer getEta() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzYyMg=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTU3NjA3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo0OTo1N1rOHACLRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDozNDozNlrOHAcqtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzcwMQ==", "bodyText": "Ditto", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469797701", "createdAt": "2020-08-13T08:49:57Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -319,15 +329,23 @@ public int findDeckPosition(long did) {\n     }\n \n \n-    public int getEta() {\n-        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});\n+    public Integer getEta() {\n+        if (numbersComputed) {\n+            return mCol.getSched().eta(new int[] {mNew, mLrn, mRev});\n+        } else {\n+            return null;\n+        }\n     }\n \n-    public int getDue() {\n-        return mNew + mLrn + mRev;\n+    public Integer getDue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMTczMw==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470231733", "createdAt": "2020-08-13T20:34:36Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -319,15 +329,23 @@ public int findDeckPosition(long did) {\n     }\n \n \n-    public int getEta() {\n-        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});\n+    public Integer getEta() {\n+        if (numbersComputed) {\n+            return mCol.getSched().eta(new int[] {mNew, mLrn, mRev});\n+        } else {\n+            return null;\n+        }\n     }\n \n-    public int getDue() {\n-        return mNew + mLrn + mRev;\n+    public Integer getDue() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzcwMQ=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTU4NTIyOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1MjoxNVrOHACQ9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxOTo1MzozOFrOHAbUFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw==", "bodyText": "For discussion:\ninstanceof is typically seen as a code smell: https://softwareengineering.stackexchange.com/questions/394856/instanceof-code-smell\nConsider removing this instanceof, and returning 0 (or null, or Optional.none()) from getNewCount on unprocessed nodes", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469799157", "createdAt": "2020-08-13T08:52:15Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +294,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {\n-                mNew += node.getNewCount();\n-                mLrn += node.getLrnCount();\n-                mRev += node.getRevCount();\n+                if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3NTM5Ng==", "bodyText": "I'm really surprised. Because my first implementation returned 0 when no number were known and you told me to avoid to do that.\nAgreed, I displayed the 0's to the user, which was not a good idea. Having a method returning an arbitrary value seems less a problem. But still, I don't like the idea of returning a wrong value. Nor checking every returned value when it's easy to know in advance whether we will get relevant values", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470175396", "createdAt": "2020-08-13T18:53:59Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +294,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {\n-                mNew += node.getNewCount();\n-                mLrn += node.getLrnCount();\n-                mRev += node.getRevCount();\n+                if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwNTgwMA==", "bodyText": "I should note that, if at some point we merge #6573 then the top level will also be a tree node, and so we won't need to consider it as a special case in deck adapter. I still believe it would made the code cleaner, but that would not improve computation time so it's not my priority", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470205800", "createdAt": "2020-08-13T19:46:09Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +294,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {\n-                mNew += node.getNewCount();\n-                mLrn += node.getLrnCount();\n-                mRev += node.getRevCount();\n+                if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwOTU1OQ==", "bodyText": "Actually displaying 0 is a bad idea, returning 0 could be fine as long as there's other state to say \"don't display this\". There's also the consideration that you don't need to recurse if values are unavailable.", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470209559", "createdAt": "2020-08-13T19:53:38Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +294,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {\n-                mNew += node.getNewCount();\n-                mLrn += node.getLrnCount();\n-                mRev += node.getRevCount();\n+                if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTU4OTcwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1MzozMlrOHACTug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo1MDo1N1rOHAZHzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTg2Ng==", "bodyText": "How are partial values guarded against? If some subdecks have counts, and others haven't been processed, is this displayed, should it be, and does it mattter?", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469799866", "createdAt": "2020-08-13T08:53:32Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -267,8 +274,8 @@ private void setDeckExpander(ImageButton expander, ImageButton indent, DeckDueTr\n     }\n \n \n-    private void processNodes(List<DeckDueTreeNode> nodes) {\n-        for (DeckDueTreeNode node : nodes) {\n+    private void processNodes(List<AbstractDeckTreeNode> nodes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MzY0NA==", "bodyText": "I protected it as well as I could given java type. That is, DeckDueTreeNode is an AbstracDeckTreeNode<DeckDueTreeNode> which means that each children of DeckDueTreeNode are DeckDueTreeNode and similarly for DeckTreeNode.\nI agree that this is far from perfect and we could do error really easily, the typing is a small protection here.", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470173644", "createdAt": "2020-08-13T18:50:57Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -267,8 +274,8 @@ private void setDeckExpander(ImageButton expander, ImageButton indent, DeckDueTr\n     }\n \n \n-    private void processNodes(List<DeckDueTreeNode> nodes) {\n-        for (DeckDueTreeNode node : nodes) {\n+    private void processNodes(List<AbstractDeckTreeNode> nodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTg2Ng=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTU5MTgxOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1NDowOFrOHACVIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo0ODoxM1rOHAZCAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDIyNA==", "bodyText": "node.shouldDisplayCounts, and avoid the instanceof", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800224", "createdAt": "2020-08-13T08:54:08Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -213,12 +217,15 @@ public void onBindViewHolder(ViewHolder holder, int position) {\n         }\n \n         // Set the card counts and their colors\n-        holder.deckNew.setText(String.valueOf(node.getNewCount()));\n-        holder.deckNew.setTextColor((node.getNewCount() == 0) ? mZeroCountColor : mNewCountColor);\n-        holder.deckLearn.setText(String.valueOf(node.getLrnCount()));\n-        holder.deckLearn.setTextColor((node.getLrnCount() == 0) ? mZeroCountColor : mLearnCountColor);\n-        holder.deckRev.setText(String.valueOf(node.getRevCount()));\n-        holder.deckRev.setTextColor((node.getRevCount() == 0) ? mZeroCountColor : mReviewCountColor);\n+        if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MjE2Mw==", "bodyText": "As above, since I need a cast anyway, I'm confused by the fact that you want to remove an instanceOf", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470172163", "createdAt": "2020-08-13T18:48:13Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -213,12 +217,15 @@ public void onBindViewHolder(ViewHolder holder, int position) {\n         }\n \n         // Set the card counts and their colors\n-        holder.deckNew.setText(String.valueOf(node.getNewCount()));\n-        holder.deckNew.setTextColor((node.getNewCount() == 0) ? mZeroCountColor : mNewCountColor);\n-        holder.deckLearn.setText(String.valueOf(node.getLrnCount()));\n-        holder.deckLearn.setTextColor((node.getLrnCount() == 0) ? mZeroCountColor : mLearnCountColor);\n-        holder.deckRev.setText(String.valueOf(node.getRevCount()));\n-        holder.deckRev.setTextColor((node.getRevCount() == 0) ? mZeroCountColor : mReviewCountColor);\n+        if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDIyNA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTU5MzczOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1NDozNlrOHACWRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo0Njo0OVrOHAY_Dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDUxOQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean numbersComputed;\n          \n          \n            \n                private boolean mNumbersComputed;", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800519", "createdAt": "2020-08-13T08:54:36Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -71,6 +73,7 @@\n     private int mNew;\n     private int mLrn;\n     private int mRev;\n+    private boolean numbersComputed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MTQwNg==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470171406", "createdAt": "2020-08-13T18:46:49Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -71,6 +73,7 @@\n     private int mNew;\n     private int mLrn;\n     private int mRev;\n+    private boolean numbersComputed;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDUxOQ=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTU5NjI2OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1NToxMlrOHACXuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo0NToyM1rOHAY74A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDg5MQ==", "bodyText": "maybe rename to LOAD_DECK_QUICK", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800891", "createdAt": "2020-08-13T08:55:12Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2211,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MDU5Mg==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470170592", "createdAt": "2020-08-13T18:45:23Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2211,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDg5MQ=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYwMDU1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1NjoyMVrOHACaZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1NjoyMVrOHACaZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMTU3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");\n          \n          \n            \n                        Timber.w(e, \"doInBackgroundLoadDeckCounts - error\");", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469801574", "createdAt": "2020-08-13T08:56:21Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -593,6 +597,20 @@ private TaskData doInBackgroundAnswerCard(TaskData param) {\n     }\n \n \n+    private TaskData doInBackgroundLoadDeck() {\n+        Timber.d(\"doInBackgroundLoadDeckCounts\");\n+        Collection col = CollectionHelper.getInstance().getCol(mContext);\n+        try {\n+            // Get due tree\n+            Object[] o = new Object[] {col.getSched().quickDeckDueTree()};\n+            return new TaskData(o);\n+        } catch (RuntimeException e) {\n+            Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYwMzQ5OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1NzowNlrOHACcPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1NzowNlrOHACcPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjA0Nw==", "bodyText": "\ud83d\udc4d null is handled correctly", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802047", "createdAt": "2020-08-13T08:57:06Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -593,6 +597,20 @@ private TaskData doInBackgroundAnswerCard(TaskData param) {\n     }\n \n \n+    private TaskData doInBackgroundLoadDeck() {\n+        Timber.d(\"doInBackgroundLoadDeckCounts\");\n+        Collection col = CollectionHelper.getInstance().getCol(mContext);\n+        try {\n+            // Get due tree\n+            Object[] o = new Object[] {col.getSched().quickDeckDueTree()};\n+            return new TaskData(o);\n+        } catch (RuntimeException e) {\n+            Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYwNTg1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1Nzo0M1rOHACdvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo1OTo0NVrOHAZhYg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjQyOQ==", "bodyText": "can be simplified by an Integer.compareTo(x, y)", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802429", "createdAt": "2020-08-13T08:57:43Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MDE5NA==", "bodyText": "Done in https://github.com/ankidroid/Anki-Android/pull/6890/files", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470180194", "createdAt": "2020-08-13T18:59:45Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjQyOQ=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYwODUwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1ODoyOVrOHACfag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDozMTo1OFrOHAclrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA==", "bodyText": "Needs better internationalisation", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802858", "createdAt": "2020-08-13T08:58:29Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MDcyOQ==", "bodyText": "I should note that this is only used in Timber. Timber prints recursively the deck and its subdeck, and so I wanted to have a general method to get the timbered line for this specific deck without dealing with recursion.\nSo in this case, I don't believe we actually want to internationalize. Instead we want to write in comment what I just wrote", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470180729", "createdAt": "2020-08-13T19:00:46Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIwODQ3NQ==", "bodyText": "Yeah - that's fine - a comment that it's only used in Timber would be useful", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470208475", "createdAt": "2020-08-13T19:51:34Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzMDQ0Nw==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470230447", "createdAt": "2020-08-13T20:31:58Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYxMjMyOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo1OTozNVrOHACh3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxOTowMzoyNFrOHAZpgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzQ4Nw==", "bodyText": "This throws when mChildren is null", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469803487", "createdAt": "2020-08-13T08:59:35Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MjI3Mw==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470182273", "createdAt": "2020-08-13T19:03:24Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzQ4Nw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYxNDUxOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMDoxMFrOHACjPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxOTowNzoyMlrOHAZxdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzgzNw==", "bodyText": "I think this needs a null check on mChildren. mChildren is null and tree is non-null would crash", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469803837", "createdAt": "2020-08-13T09:00:10Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4NDMwOA==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470184308", "createdAt": "2020-08-13T19:07:22Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzgzNw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYxNzQxOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMDo1N1rOHAClBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxOTowNTo0OFrOHAZuXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDI5NA==", "bodyText": "No null checks for object", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469804294", "createdAt": "2020-08-13T09:00:57Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MzUxNw==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470183517", "createdAt": "2020-08-13T19:05:48Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDI5NA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 160}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzNTYyMDcyOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMTo1NFrOHACnIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxOTowODowMVrOHAZysg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDgzMw==", "bodyText": "Revert this file - spacing changes", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469804833", "createdAt": "2020-08-13T09:01:54Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -128,9 +128,9 @@ private void markNextCardAsGood(Sched sched) {\n \n     @NonNull\n     private DeckDueTreeNode getCountsForDid(double didToFind) {\n-        List<DeckDueTreeNode> tree = getCol().getSched().deckDueTree();\n+        List<DeckDueTreeNode> tree =  getCol().getSched().deckDueTree();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4NDYyNg==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470184626", "createdAt": "2020-08-13T19:08:01Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -128,9 +128,9 @@ private void markNextCardAsGood(Sched sched) {\n \n     @NonNull\n     private DeckDueTreeNode getCountsForDid(double didToFind) {\n-        List<DeckDueTreeNode> tree = getCol().getSched().deckDueTree();\n+        List<DeckDueTreeNode> tree =  getCol().getSched().deckDueTree();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDgzMw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODQwNzgwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0MjoyN1rOHAc7NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMToxMDoxNFrOHAdzEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNTk1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!(deckDueTreeNode_.shouldDisplayCounts())) {\n          \n          \n            \n                    if (!deckDueTreeNode_.shouldDisplayCounts()) {", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470235957", "createdAt": "2020-08-13T20:42:27Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,17 +2118,19 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_.shouldDisplayCounts())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MDI1OA==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470250258", "createdAt": "2020-08-13T21:10:14Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,17 +2118,19 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_.shouldDisplayCounts())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNTk1Nw=="}, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODQxNjI4OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0NDozOFrOHAdAAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowNjoxOVrOHAfUog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzE4NQ==", "bodyText": "Nicer already!\nCould be even nicer if you performed (!shouldDisplayCounts() || .hasNoPendingReps())", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470237185", "createdAt": "2020-08-13T20:44:38Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,17 +2118,19 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_.shouldDisplayCounts())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3NTIzNA==", "bodyText": "Ok", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470275234", "createdAt": "2020-08-13T22:06:19Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,17 +2118,19 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_.shouldDisplayCounts())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzE4NQ=="}, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODQxODE1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0NTowMFrOHAdBBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMToxMTowMVrOHAd0iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzQ0NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;\n          \n          \n            \n                    CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470237445", "createdAt": "2020-08-13T20:45:00Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2210,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI1MDYzMg==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470250632", "createdAt": "2020-08-13T21:11:01Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2210,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzQ0NQ=="}, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODQyMjMzOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0NjowN1rOHAdDZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0NjowN1rOHAdDZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODA1Mw==", "bodyText": "Would be better to use polymorphism here so we don't need to cast. I know there's a discussion below.", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470238053", "createdAt": "2020-08-13T20:46:07Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -213,12 +219,15 @@ public void onBindViewHolder(ViewHolder holder, int position) {\n         }\n \n         // Set the card counts and their colors\n-        holder.deckNew.setText(String.valueOf(node.getNewCount()));\n-        holder.deckNew.setTextColor((node.getNewCount() == 0) ? mZeroCountColor : mNewCountColor);\n-        holder.deckLearn.setText(String.valueOf(node.getLrnCount()));\n-        holder.deckLearn.setTextColor((node.getLrnCount() == 0) ? mZeroCountColor : mLearnCountColor);\n-        holder.deckRev.setText(String.valueOf(node.getRevCount()));\n-        holder.deckRev.setTextColor((node.getRevCount() == 0) ? mZeroCountColor : mReviewCountColor);\n+        if (node.shouldDisplayCounts()) {\n+            DeckDueTreeNode node_ = (DeckDueTreeNode) node;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODQyNjU1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0NzowOVrOHAdFtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMjowMTo1OFrOHAfOPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODY0Nw==", "bodyText": "It would be better to stop processing straight away if shouldDisplayCounts is false - it means that children also have no counts.\nMaybe alias the name to canCalculateCounts for better semantic meaning here", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470238647", "createdAt": "2020-08-13T20:47:09Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +296,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDI3MzU5Nw==", "bodyText": "processNodes is in charge of transforming the tree of deck into the list shown in DeckPicker. I believe that you do not want to stop the process even if there is no count.", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470273597", "createdAt": "2020-08-13T22:01:58Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +296,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODY0Nw=="}, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODQzMDE3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0ODoxNVrOHAdH7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0ODoxNVrOHAdH7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzOTIxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int childrenHash;\n          \n          \n            \n                    int childrenHash = mChildren == null ? 0 : mChildren.hashCode();", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470239215", "createdAt": "2020-08-13T20:48:15Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 144}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkzODQzMjY1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/DeckDueTreeNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0ODo0OVrOHAdJPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0ODo0OVrOHAdJPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzOTU1MQ==", "bodyText": "ditto", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470239551", "createdAt": "2020-08-13T20:48:49Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/DeckDueTreeNode.java", "diffHunk": "@@ -182,7 +82,13 @@ public void setChildren(@NonNull List<DeckDueTreeNode> children, boolean addRev)\n \n     @Override\n     public int hashCode() {\n-        int childrenHash = mChildren.hashCode();\n+        int childrenHash;\n+        @Nullable List<DeckDueTreeNode> children = getChildren();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mzc5MzgxOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQyMToyNDo0MFrOHBNt2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQyMjowNToyNlrOHBN5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzNTM1Mg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void shouldOpenReviewerOnSelection(boolean dontSkipStudyOptions) {\n          \n          \n            \n                private void openReviewerOrStudyOptions(boolean dontSkipStudyOptions) {\n          \n      \n    \n    \n  \n\nJust a name suggestion so it is aligned with what is actually happening in this commit", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r471035352", "createdAt": "2020-08-15T21:24:40Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2090,6 +2090,17 @@ private void openStudyOptions(boolean withDeckOptions) {\n         }\n     }\n \n+    private void shouldOpenReviewerOnSelection(boolean dontSkipStudyOptions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ed51e5756e17ae88c37943fca8ef57e1dc4b03b"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzODI2NQ==", "bodyText": "Fine by me", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r471038265", "createdAt": "2020-08-15T22:05:26Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2090,6 +2090,17 @@ private void openStudyOptions(boolean withDeckOptions) {\n         }\n     }\n \n+    private void shouldOpenReviewerOnSelection(boolean dontSkipStudyOptions) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzNTM1Mg=="}, "originalCommit": {"oid": "1ed51e5756e17ae88c37943fca8ef57e1dc4b03b"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Nzc1MDM3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToxNjozNFrOHGPQSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToxNjozNFrOHGPQSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzQzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return;", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476303433", "createdAt": "2020-08-25T09:16:34Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2138,6 +2142,17 @@ private void openStudyOptions(boolean withDeckOptions) {\n         }\n     }\n \n+    private void openReviewerOrStudyOptions(boolean dontSkipStudyOptions) {\n+        if (mFragmented || dontSkipStudyOptions) {\n+            // Go to StudyOptions screen when tablet or deck counts area was clicked\n+            openStudyOptions(false);\n+        } else {\n+            // Otherwise jump straight to the reviewer\n+            openReviewer();\n+        }\n+        return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Nzc1Mzg1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToxNzozMFrOHGPSbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMzo1NDo1MVrOHGysiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzk4MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;\n          \n          \n            \n                    CollectionTask.TASK_TYPE taskType = quick ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476303980", "createdAt": "2020-08-25T09:17:30Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2279,8 +2290,13 @@ public void actualOnPostExecute(@NonNull DeckPicker deckPicker, TaskData result)\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n         TaskListener listener = updateDeckListListener();\n-        CollectionTask task = CollectionTask.launchCollectionTask(LOAD_DECK_COUNTS, listener);\n+        CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg4NDEwNw==", "bodyText": "I didn't even know it works without parenthesis. I thought it was like if, with mandatory parenthesis", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476884107", "createdAt": "2020-08-25T23:54:51Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2279,8 +2290,13 @@ public void actualOnPostExecute(@NonNull DeckPicker deckPicker, TaskData result)\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n         TaskListener listener = updateDeckListListener();\n-        CollectionTask task = CollectionTask.launchCollectionTask(LOAD_DECK_COUNTS, listener);\n+        CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzk4MA=="}, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Nzc2MzM2OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToxOTo0MVrOHGPX-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMzo1NjoyMVrOHGyyzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNTQwMA==", "bodyText": "addRev is unused", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476305400", "createdAt": "2020-08-25T09:19:41Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg4NTcwOA==", "bodyText": "It is used in the child. And I need to have the same method in parent and child if I want overridding to work", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476885708", "createdAt": "2020-08-25T23:56:21Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNTQwMA=="}, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 138}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Nzc2ODAwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToyMDo0MlrOHGPakg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQyMzo1ODo1NlrOHGy9_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNjA2Ng==", "bodyText": "May be able to use Comparable<AbstractDeckTreeNode<T>> to improve the signature of compare()", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476306066", "createdAt": "2020-08-25T09:20:42Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg4ODU3Mw==", "bodyText": "Nice", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476888573", "createdAt": "2020-08-25T23:58:56Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNjA2Ng=="}, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3Nzc3ODA3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToyMzoyMlrOHGPg2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNlQwMDoyMDoyOVrOHG0Cmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNzY3Mw==", "bodyText": "Questionable - might be best to extract to return a new (nullable) instance of a DeckCounts class so people don't misuse the API.\nImplementer's choice here", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476307673", "createdAt": "2020-08-25T09:23:22Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren == null ? 0 : mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == null || !(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&\n+            (mChildren == null && tree.mChildren == null) || // Would be the case if both are null, or the same pointer\n+            (mChildren != null && mChildren.equals(tree.mChildren))\n+            ;\n+    }\n+\n+    public Collection getCol() {\n+        return mCol;\n+    }\n+\n+    public boolean shouldDisplayCounts() {\n+        return false;\n+    }\n+\n+    /* Number of new cards to see today known to be in this deck and its descendants. The number to show to user*/\n+    public int getNewCount() {\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Njg5MTYxMQ==", "bodyText": "I don't see how returning null instead of throwing ensures it's used correctly. On the contrary, with throwing, as soon as the program is tested on a phone/emulator, it'll fail if it is used incorrectly.\nI don't expect any solution to be perfect, I'm happy with this version.", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476891611", "createdAt": "2020-08-26T00:01:51Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren == null ? 0 : mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == null || !(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&\n+            (mChildren == null && tree.mChildren == null) || // Would be the case if both are null, or the same pointer\n+            (mChildren != null && mChildren.equals(tree.mChildren))\n+            ;\n+    }\n+\n+    public Collection getCol() {\n+        return mCol;\n+    }\n+\n+    public boolean shouldDisplayCounts() {\n+        return false;\n+    }\n+\n+    /* Number of new cards to see today known to be in this deck and its descendants. The number to show to user*/\n+    public int getNewCount() {\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNzY3Mw=="}, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjkwNjEzOQ==", "bodyText": "There's currently an implicit dependency between getNewCount and shouldDisplayCounts.\nReturning an object removes that dependency (shouldDisplayCounts is equivalent to object == null), if the returned signature is @Nullable, then the caller will get a compiler warning if they're doing something wrong (trying to get counts before checking whether counts are supported).", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476906139", "createdAt": "2020-08-26T00:20:29Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren == null ? 0 : mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == null || !(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&\n+            (mChildren == null && tree.mChildren == null) || // Would be the case if both are null, or the same pointer\n+            (mChildren != null && mChildren.equals(tree.mChildren))\n+            ;\n+    }\n+\n+    public Collection getCol() {\n+        return mCol;\n+    }\n+\n+    public boolean shouldDisplayCounts() {\n+        return false;\n+    }\n+\n+    /* Number of new cards to see today known to be in this deck and its descendants. The number to show to user*/\n+    public int getNewCount() {\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNzY3Mw=="}, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 176}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 51, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}