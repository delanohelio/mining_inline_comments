{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4ODkzMjY0", "number": 6543, "title": "Add Crop functionality", "bodyText": "Pull Request template\nPurpose / Description\nThere was no way to crop images previously, but cameras especially are generating very large images these days\nThis allows the advanced editor's image field component to crop images, and prompts users to do so for photos or if the image is large\nThis is entirely based on the work from @NightXlt - everything about how to do the Intent correctly, to the URI / File path conversion is their work\nI took the PR contents of #5301 and re-factored them to fit better with the work done since @NightXlt originally submitted the work, then I tested, tested, and tested some more with little fixes related to preview handling and button visibility added in.\nFinally, I deconstructed the work into chunks as small as I could so review would be easier.\nPlease understand the commit separation was done after the fact and there may be a couple cross-dependencies still present in the commit. The separate commits are for easier review but I make no guarantee they will function separately, testing has only been performed with the complete work\nFixes\nFixes #2554\nObsoletes #5301\nApproach\nThe basic idea is to\n\nhandle the path internally with a path backup\nadd the general ability to create temporary files\nadd the general ability to generate URIs for our cache files\nadd the general ability to translate between URIs and Paths\nask the system to crop when we want, with a URI to a new internal file for the result\n\nHow Has This Been Tested?\nAPI16, 18, 24, 29, 30 emulators\nThe scenarios I ran are:\n\nadd note, paperclip, add image, gallery, verify preview, choose crop, do the crop, verify preview, save, note editor preview\nsame as above but camera\nsave note, view note verify images\n\nNote that after adding images but before you save the note, the field has data and the paperclip menu behaves differently than if you were editing a note and it had data because the paperclip menu listener hasn't re-been rebound. This is an existing bug and not addressed here\nSame as above but with an existing note with image data:\n\nedit note (with image data), paperclip (opens advanced image editor w/preview), crop, do crop+return, verify image, save, preview from note editor, verify image, return and save note, view note and verify images\n\nLearning (optional, can help others)\nOf interest from this PR:\nAttempting to implement an \"EDIT\" intent vs stricly crop is better but fails in mysterious ways, especially with API30\nAPI30 in general may require more testing\nOf interest that existed prior to the PR and still exist:\nThe advanced editor is rough to deal with, it's pretty fluffy with regard to number of objects and how control passes around\nThe paperclip menu behaves inconsistently right now based on whether the note had data in the field to start or was empty. If empty to start it will show a popup menu, if it had data to start it sends you right to the advanced editor.\nThe advanced editor doesn't handle the case of multiple things in the same a field very well.\nThe advanced editor doesn't handle the case of editing a multimedia field very well (it just keeps appending the edits) but at least with preview from note editor this is easy to fix\nChecklist\nPlease, go through these checks before submitting the PR.\n\n You have not changed whitespace unnecessarily (it makes diffs hard to read)\n You have a descriptive commit message with a short title (first line, max 50 chars).\n Your code follows the style of the project (e.g. never omit braces in if statements)\n You have commented your code, particularly in hard-to-understand areas\n You have performed a self-review of your own code", "createdAt": "2020-06-24T00:34:04Z", "url": "https://github.com/ankidroid/Anki-Android/pull/6543", "merged": true, "mergeCommit": {"oid": "c7f466554110db49ca633812e79ff0fd684296cc"}, "closed": true, "closedAt": "2020-06-28T17:29:02Z", "author": {"login": "mikehardy"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcuPHSWABqjM0NzUzMTQ0MTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcvvGZhgH2gAyNDM4ODkzMjY0OjJkYTA0MWYyMzZlMjkzOGQwYjllZGJhYmUxNGY0MTM0NTM5MWQ0ZjQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3e5fc9f2cbb59110028fe9c2f052b8b8b5ddd050", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/3e5fc9f2cbb59110028fe9c2f052b8b8b5ddd050", "committedDate": "2020-06-24T00:00:01Z", "message": "Prompt user to crop on image edit return if images is large"}, "afterCommit": {"oid": "2d87143d313abe52b7efff2cf73c31a4a8ab9cba", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/2d87143d313abe52b7efff2cf73c31a4a8ab9cba", "committedDate": "2020-06-24T00:42:07Z", "message": "Prompt user to crop on image edit return if images is large"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d87143d313abe52b7efff2cf73c31a4a8ab9cba", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/2d87143d313abe52b7efff2cf73c31a4a8ab9cba", "committedDate": "2020-06-24T00:42:07Z", "message": "Prompt user to crop on image edit return if images is large"}, "afterCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a4500eda080fb2956f8c0f17b3548d863496ad22", "committedDate": "2020-06-24T00:47:23Z", "message": "Prompt user to crop on image edit return if images is large"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MjU3Mzg2", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#pullrequestreview-436257386", "createdAt": "2020-06-24T01:06:00Z", "commit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMTowNjowMFrOGn_hkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMjoxMDowMFrOGoAglQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4ODQzNA==", "bodyText": "Could you add a comment/reword with the units? Presumably Bytes", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444588434", "createdAt": "2020-06-24T01:06:00Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -65,6 +70,8 @@\n     private static final int REQUEST_AUDIO_PERMISSION = 0;\n     private static final int REQUEST_CAMERA_PERMISSION = 1;\n \n+    public static final int sImageLimit = 1024 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4OTk4Ng==", "bodyText": "translatable=\"false\" ?", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444589986", "createdAt": "2020-06-24T01:12:17Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/res/values/16-multimedia-editor.xml", "diffHunk": "@@ -112,4 +112,11 @@\n \n \t<!-- Network failure -->\n \t<string name=\"network_no_connection\">No connection</string>\n+\n+    <!-- Crop function-->\n+    <string name=\"crop_image\" translatable=\"false\">Do you want to crop this image?</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MDIzNg==", "bodyText": "Maybe go with Formatter.formatShortFileSize.\nYou could bring the format string inside the resource.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444590236", "createdAt": "2020-06-24T01:13:12Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -379,6 +383,30 @@ public void handleFieldChanged(IField newField) {\n         recreateEditingUi(ChangeUIRequest.fieldChange(newField));\n     }\n \n+    public void showLargeFileCropDialog(float length) {\n+        BasicImageFieldController imageFieldController = (BasicImageFieldController) mFieldController;\n+        File file = new File(mField.getImagePath());\n+        Uri uri = FileProvider.getUriForFile(this, this.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        DecimalFormat decimalFormat = new DecimalFormat(\".00\");\n+        String size = decimalFormat.format(length);\n+        String content = getString(R.string.save_dialog_content, size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MjExMg==", "bodyText": "Could a sample path be provided here? Probably on me to better understand filepaths.xml", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444592112", "createdAt": "2020-06-24T01:20:48Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -71,16 +78,22 @@\n     @VisibleForTesting\n     static final int ACTIVITY_SELECT_IMAGE = 1;\n     private static final int ACTIVITY_TAKE_PICTURE = 2;\n+    private static final int ACTIVITY_CROP_PICTURE = 3;\n     private static final int IMAGE_SAVE_MAX_WIDTH = 1920;\n \n     private ImageView mImagePreview;\n     private TextView mImageFileSize;\n     private TextView mImageFileSizeWarning;\n \n-    private String mTempCameraImagePath;\n+    private @Nullable String mImagePath;\n+    private @Nullable Uri mImageUri;\n+    private @Nullable String mPreviousImagePath; // save the latest path to prevent from cropping or taking photo action canceled\n+    private @Nullable Uri mPreviousImageUri;\n+    private @Nullable String mAnkiCacheDirectory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MzI2Nw==", "bodyText": "(optional) surprised there's not an override for showThemedToast which expects a @StringRes", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444593267", "createdAt": "2020-06-24T01:25:29Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 471}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5NDIwNA==", "bodyText": "Interesting... looks like it'll also have application in the import screen. Any reference for how this code came to fruition?\nLooks like: https://stackoverflow.com/a/44172185/13121290\nI suspect this may be device manufacturer specific.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444594204", "createdAt": "2020-06-24T01:29:21Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODU3Mw==", "bodyText": "Has this path been exercised on a later API? I know there were changes to the way file:// data could be accessed", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444598573", "createdAt": "2020-06-24T01:46:12Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODgxNw==", "bodyText": "should be in a finally block", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444598817", "createdAt": "2020-06-24T01:47:18Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();\n+        }\n+\n+        return imagePath;\n     }\n \n+\n+    /**\n+     * Get image path based on uri and selection args\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable String getImagePathFromContentResolver(Context context, Uri uri, String selection) {\n+        Timber.d(\"getImagePathFromContentResolver() %s\", uri);\n+        String[] filePathColumn = { MediaStore.MediaColumns.DATA };\n+        Cursor cursor = context.getContentResolver().query(uri, filePathColumn, selection, null, null);\n+\n+        if (cursor == null) {\n+            Timber.w(\"getImagePathFromUri() cursor was null\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        if (!cursor.moveToFirst()) {\n+            //TODO: #5909, it would be best to instrument this to see if we can fix the failure\n+            Timber.w(\"getImagePathFromUri() cursor had no data\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\n+        String path = cursor.getString(columnIndex);\n+        cursor.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYwMzk4NQ==", "bodyText": "can clipData be used here?", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444603985", "createdAt": "2020-06-24T02:07:34Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 469}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYwNDU2NQ==", "bodyText": "Would be nice to comment a sample path here.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444604565", "createdAt": "2020-06-24T02:10:00Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/res/xml/filepaths.xml", "diffHunk": "@@ -2,4 +2,5 @@\n <paths>\n     <external-cache-path path=\"export/\" name=\"export-directory\" />\n     <cache-path path=\"/\" name=\"cache-directory\" />\n+    <external-path path=\".\" name=\"photos\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2MzAxNTE2", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#pullrequestreview-436301516", "createdAt": "2020-06-24T03:36:02Z", "commit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a4500eda080fb2956f8c0f17b3548d863496ad22", "committedDate": "2020-06-24T00:47:23Z", "message": "Prompt user to crop on image edit return if images is large"}, "afterCommit": {"oid": "a0c9f2a00b90e39687703e955c2124842494b689", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a0c9f2a00b90e39687703e955c2124842494b689", "committedDate": "2020-06-26T03:46:16Z", "message": "Image crop feedback: JPG compress, \"No\" in dialogs, add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34982097c48c1c78d495e058cb169534cab124ff", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/34982097c48c1c78d495e058cb169534cab124ff", "committedDate": "2020-06-26T21:57:50Z", "message": "NF: remove API15 remnants now that minSdkVersion is 16"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22521e3f79e00bdb4c2755912d4f6eee85216f54", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/22521e3f79e00bdb4c2755912d4f6eee85216f54", "committedDate": "2020-06-26T21:57:50Z", "message": "NF: extract saveAndExit from MultimediaEditFieldActivity"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "409ee8012cb35157df857665cee68a0bdd97281c", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/409ee8012cb35157df857665cee68a0bdd97281c", "committedDate": "2020-06-26T21:57:50Z", "message": "NF: path variables, extract createNewFile/handleTakePictureResult\n\nalso improve error handling in rotateAndCompress\nstart setting up for handling crop results"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44426e5001ae0cfa20115b377212a372bdfff2bf", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/44426e5001ae0cfa20115b377212a372bdfff2bf", "committedDate": "2020-06-26T21:57:51Z", "message": "Extract file path / URI conversions, make work across all APIs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc4d457e79762ecbe80cce638c596408a91ad4c7", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/bc4d457e79762ecbe80cce638c596408a91ad4c7", "committedDate": "2020-06-26T21:57:51Z", "message": "Add ability to crop image on user request and camera result return"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b2dd84d49e03e6edc4424cbb330a411da991a937", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/b2dd84d49e03e6edc4424cbb330a411da991a937", "committedDate": "2020-06-26T21:57:52Z", "message": "Prompt user to crop on image edit return if images is large"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e11ce6afbada4f07cbeed00235d080c11a620371", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/e11ce6afbada4f07cbeed00235d080c11a620371", "committedDate": "2020-06-26T21:57:52Z", "message": "Image crop feedback: JPG compress, \"No\" in dialogs, add comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f9c811ca8687f2ea8a608230deb6faca05db196", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/1f9c811ca8687f2ea8a608230deb6faca05db196", "committedDate": "2020-06-27T04:11:05Z", "message": "Only consider RESULT_OK as a positive image edit result"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0791bf786653f93450af4728d2ef7fc956b04f8", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a0791bf786653f93450af4728d2ef7fc956b04f8", "committedDate": "2020-06-27T04:11:49Z", "message": "Add Activity restart support to multimedia edit, implement for Image"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a0c9f2a00b90e39687703e955c2124842494b689", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a0c9f2a00b90e39687703e955c2124842494b689", "committedDate": "2020-06-26T03:46:16Z", "message": "Image crop feedback: JPG compress, \"No\" in dialogs, add comments"}, "afterCommit": {"oid": "a0791bf786653f93450af4728d2ef7fc956b04f8", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a0791bf786653f93450af4728d2ef7fc956b04f8", "committedDate": "2020-06-27T04:11:49Z", "message": "Add Activity restart support to multimedia edit, implement for Image"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d847f1b4dac8947bb28378d9bd3686f2853bcbe", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/2d847f1b4dac8947bb28378d9bd3686f2853bcbe", "committedDate": "2020-06-27T23:38:17Z", "message": "Refactor crop dialog so one definition is reusable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3586444b0632e039325f261270de690794016b33", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/3586444b0632e039325f261270de690794016b33", "committedDate": "2020-06-27T23:57:49Z", "message": "NF: add annotations from super to subclass compat copy methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1978f47b29bb15d74ba04bd944abfa743b1c0a61", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/1978f47b29bb15d74ba04bd944abfa743b1c0a61", "committedDate": "2020-06-28T00:00:16Z", "message": "Improve messaging on unexpected crop results"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7500e85287bfc50f9181db4dc4998e00e3bbc611", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7500e85287bfc50f9181db4dc4998e00e3bbc611", "committedDate": "2020-06-28T00:09:51Z", "message": "Improve image editor file handling\n\npreviously we would lose track of previous images and not\nclean up after ourselves, plus the temporary images were not\nsegregated from other things"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba7feb4559cba01c503549c8c5cab84f2160e9ae", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/ba7feb4559cba01c503549c8c5cab84f2160e9ae", "committedDate": "2020-06-28T00:11:20Z", "message": "Improve error-handling in image edit on activity starts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8756fd41ee44b8572d81e1c85851ae9519047619", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/8756fd41ee44b8572d81e1c85851ae9519047619", "committedDate": "2020-06-28T00:13:00Z", "message": "Image edit can internalize ephemeral files now\n\nOn picking a file now we get the display name and path from\nthe content resolver\n\nWe use the display name in order to generate an appropriate internal\nfile name, then we internalize the content resolver contents"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b146e9ec31a35849bee24dd88f2f70c4728a2997", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/b146e9ec31a35849bee24dd88f2f70c4728a2997", "committedDate": "2020-06-28T00:27:59Z", "message": "Fix incorrect change to URI generation on API<N"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1c87a6518a88cb3a42f530f57d60a3afad63294", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/c1c87a6518a88cb3a42f530f57d60a3afad63294", "committedDate": "2020-06-28T00:45:13Z", "message": "Use FileProvider-correct test for image test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/408192ff445fa2f08a0019df11a2fa7cfd820eac", "committedDate": "2020-06-28T01:02:14Z", "message": "Fully restore previous image on unsuccessful image edit\n\nthis prevents the original image from being cleaned up now that\nwe work harder on cleaning up old images"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4NzM2NTE5", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#pullrequestreview-438736519", "createdAt": "2020-06-28T02:03:05Z", "commit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjowMzowNlrOGp5o8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjozMzo1MlrOGp5wtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTE3MA==", "bodyText": "Consider promoting to Timber.i", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589170", "createdAt": "2020-06-28T02:03:06Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -80,9 +88,13 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n+        Bundle controllerBundle = null;\n         if (savedInstanceState != null) {\n+            Timber.d(\"onCreate - saved bundle exists\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTM1Mg==", "bodyText": "Likely as the functionality isn't implemented in the controllers", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589352", "createdAt": "2020-06-28T02:05:33Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -379,22 +393,49 @@ public void handleFieldChanged(IField newField) {\n         recreateEditingUi(ChangeUIRequest.fieldChange(newField));\n     }\n \n+    public void showLargeFileCropDialog(float length) {\n+        BasicImageFieldController imageFieldController = (BasicImageFieldController) mFieldController;\n+        DecimalFormat decimalFormat = new DecimalFormat(\".00\");\n+        String size = decimalFormat.format(length);\n+        String content = getString(R.string.save_dialog_content, size);\n+        imageFieldController.showCropDialog(content, (dialog, which) -> saveAndExit());\n+    }\n+\n+\n+    private void saveAndExit() {\n+        Intent resultData = new Intent();\n+        resultData.putExtra(EXTRA_RESULT_FIELD, mField);\n+        resultData.putExtra(EXTRA_RESULT_FIELD_INDEX, mFieldIndex);\n+        setResult(RESULT_OK, resultData);\n+        finishWithoutAnimation();\n+    }\n \n     @Override\n     protected void onDestroy() {\n-        super.onDestroy();\n-\n         if (mFieldController != null) {\n             mFieldController.onDestroy();\n         }\n-\n+        super.onDestroy();\n     }\n \n \n     @Override\n     protected void onSaveInstanceState(Bundle outState) {\n-        super.onSaveInstanceState(outState);\n+        Timber.d(\"onSaveInstanceState - saving state\");\n+\n+        // This is used to tell the whole activity to shut down if it is restored from Activity restart.\n+        // Why? I am not really sure. Perhaps to avoid terrible bugs due to not implementing things correctly?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTUwOA==", "bodyText": "Could you mention the method which is problematic", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589508", "createdAt": "2020-06-28T02:07:50Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -91,16 +108,65 @@ private int getMaxImageSize() {\n         return (int) Math.min(height * 0.4, width * 0.6);\n     }\n \n-    // The NewApi deprecation should be removed with API21. UnsupportedChromeOsCameraSystemFeature can be fixed in API16\n-    @SuppressLint( {\"UnsupportedChromeOsCameraSystemFeature\", \"NewApi\"})\n+    public void loadInstanceState(Bundle savedInstanceState) {\n+        if (savedInstanceState == null) {\n+            Timber.d(\"loadInstanceState but null so nothing to load\");\n+            return;\n+        }\n+\n+        Timber.d(\"loadInstanceState loading saved state...\");\n+        mImagePath = savedInstanceState.getString(\"mImagePath\");\n+        mImageUri = savedInstanceState.getParcelable(\"mImageUri\");\n+        mPreviousImagePath = savedInstanceState.getString(\"mPreviousImagePath\");\n+        mPreviousImageUri = savedInstanceState.getParcelable(\"mPreviousImageUri\");\n+    }\n+\n+    public Bundle saveInstanceState() {\n+        Timber.d(\"saveInstanceState\");\n+        Bundle savedInstanceState = new Bundle();\n+        savedInstanceState.putString(\"mImagePath\", mImagePath);\n+        savedInstanceState.putParcelable(\"mImageUri\", mImageUri);\n+        savedInstanceState.putString(\"mPreviousImagePath\", mPreviousImagePath);\n+        savedInstanceState.putParcelable(\"mPreviousImageUri\", mPreviousImageUri);\n+        return savedInstanceState;\n+    }\n+\n+    // The NewApi deprecation should be removed with API21\n+    @SuppressLint(\"NewApi\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTYyNQ==", "bodyText": "Is this automatically cased by the UI library?", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589625", "createdAt": "2020-06-28T02:09:34Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/res/values/03-dialogs.xml", "diffHunk": "@@ -104,6 +104,7 @@\n \n     <string name=\"dialog_cancel\">Cancel</string>\n     <string name=\"dialog_ok\">OK</string>\n+    <string name=\"dialog_no\">No</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MDU4NQ==", "bodyText": "Use >= here. The pattern is to continually add 1 for different user-defined results.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446590585", "createdAt": "2020-06-28T02:24:39Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -289,6 +289,11 @@ public void onActivityResult(int requestCode, int resultCode, Intent data) {\n                 default:\n                     break;\n             }\n+\n+            // Some apps send this back with app-specific data, direct the user to another app\n+            if (resultCode == Activity.RESULT_FIRST_USER) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1978f47b29bb15d74ba04bd944abfa743b1c0a61"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTA3NQ==", "bodyText": "(Optional): Might be worth turning the return value into a class. Each time I see the array access, I presume there's a potential indexing bug", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446591075", "createdAt": "2020-06-28T02:32:20Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -590,64 +646,76 @@ private Uri getUriForFile(File file) {\n             return null;\n         }\n         mImageUri = uri;\n-        mImagePath = getImagePathFromUri(context, uri);\n+        mImagePath = getImageInfoFromUri(context, uri)[0];\n         mField.setImagePath(mImagePath);\n         mField.setHasTemporaryMedia(false);\n         return mImageUri;\n     }\n \n \n-    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+    /**\n+     * Get image information based on uri and selection args\n+     *\n+     * @return string[] 0: file path (null if does not exist), 1: display name (null if does not exist)\n+     */\n+    private String[] getImageInfoFromUri(Context context, Uri uri) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8756fd41ee44b8572d81e1c85851ae9519047619"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTE1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            imageInfo= getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n          \n          \n            \n                            imageInfo = getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446591157", "createdAt": "2020-06-28T02:33:52Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -590,64 +646,76 @@ private Uri getUriForFile(File file) {\n             return null;\n         }\n         mImageUri = uri;\n-        mImagePath = getImagePathFromUri(context, uri);\n+        mImagePath = getImageInfoFromUri(context, uri)[0];\n         mField.setImagePath(mImagePath);\n         mField.setHasTemporaryMedia(false);\n         return mImageUri;\n     }\n \n \n-    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+    /**\n+     * Get image information based on uri and selection args\n+     *\n+     * @return string[] 0: file path (null if does not exist), 1: display name (null if does not exist)\n+     */\n+    private String[] getImageInfoFromUri(Context context, Uri uri) {\n         Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n-        String imagePath = null;\n+        String[] imageInfo = { null, null };\n         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n             String docId = DocumentsContract.getDocumentId(uri);\n             if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n                 String id = docId.split(\":\")[1];\n                 String selection = MediaStore.Images.Media._ID + \"=\" + id;\n-                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+                imageInfo= getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8756fd41ee44b8572d81e1c85851ae9519047619"}, "originalPosition": 138}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f253f18c726bd0d009558747e0d292d2a4323b90", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/f253f18c726bd0d009558747e0d292d2a4323b90", "committedDate": "2020-06-28T15:30:54Z", "message": "NF: image editor re-categorize logging, clean imports, remove @Suppress"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "30fa233aef475ef80b82de17bcab5926323bb001", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/30fa233aef475ef80b82de17bcab5926323bb001", "committedDate": "2020-06-28T15:31:46Z", "message": "Image controller should treat all errors >= 1 as non-success"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e1f5eaaa5211ff9cb4ffe69d8b262135da34686", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/2e1f5eaaa5211ff9cb4ffe69d8b262135da34686", "committedDate": "2020-06-28T15:33:02Z", "message": "URI path/name resolution typed more strongly\n\nArrays are convenient for the same reason they are dangerous, using\na Pair in place makes it impossible to have anything other than 2\nelements, which was the prior intention"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0281280786fb83f738fd8b06913377c2153a4237", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/0281280786fb83f738fd8b06913377c2153a4237", "committedDate": "2020-06-28T16:32:14Z", "message": "NF: extract image revert handling (save, revert, delete) methods"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4746f0e3db5b1f3f7b260a62e7abdfeeb9fcadb", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a4746f0e3db5b1f3f7b260a62e7abdfeeb9fcadb", "committedDate": "2020-06-28T16:32:48Z", "message": "Image picker should be restricted to images only"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2da041f236e2938d0b9edbabe14f41345391d4f4", "author": {"user": {"login": "mikehardy", "name": "Mike Hardy"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/2da041f236e2938d0b9edbabe14f41345391d4f4", "committedDate": "2020-06-28T16:33:03Z", "message": "Image rotate and compress detects bad images, callers handle it\n\nThis is where the Bitmap.decode happens, so it can provide useful signal\nin case something about the image crop or camera selection resulted in\na bad image\n\ncombined with image picker clamped to actual images, we should only\nallow valid images to pass through the controller to NoteEditor for save now"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3005, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}