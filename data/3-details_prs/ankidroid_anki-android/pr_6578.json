{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQxMTUwNzIw", "number": 6578, "title": "Load deck tree before number on start", "bodyText": "As David requested some time ago, I use the type system to determines whether deck nodes have numbers or not. I first compute deck nodes without numbers in order to be quick, and then with numbers.\nThis lead to  almost immediately instead of waiting 10 seconds to get all numbers.\nIt has been tested on my phone for months now", "createdAt": "2020-06-29T01:38:15Z", "url": "https://github.com/ankidroid/Anki-Android/pull/6578", "merged": true, "mergeCommit": {"oid": "94b732e7fcf77fc30b2046c8da71d725f438cfda"}, "closed": true, "closedAt": "2020-08-26T19:49:08Z", "author": {"login": "Arthur-Milchior"}, "timelineItems": {"totalCount": 34, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcv3JgUgBqjM0OTA5MzcwNDE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdCxQvXgFqTQ3NTgwODIzMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d335fe63fd42dcc2f70e8448d538177b612e1ef4", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/d335fe63fd42dcc2f70e8448d538177b612e1ef4", "committedDate": "2020-06-29T01:34:34Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "73531c07b3f1f9b6e2517c906e407ed6d2d1af5f", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/73531c07b3f1f9b6e2517c906e407ed6d2d1af5f", "committedDate": "2020-06-29T01:55:23Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8974280f0dcd1e20a3f983a2cb8dc62ee2afa311", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/8974280f0dcd1e20a3f983a2cb8dc62ee2afa311", "committedDate": "2020-06-29T12:51:08Z", "message": "Merge branch 'master' into DeckDueTreeSplited"}, "afterCommit": {"oid": "d3b7558b9756b551e7e107cb300db40617a123ab", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/d3b7558b9756b551e7e107cb300db40617a123ab", "committedDate": "2020-06-29T12:54:42Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d3b7558b9756b551e7e107cb300db40617a123ab", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/d3b7558b9756b551e7e107cb300db40617a123ab", "committedDate": "2020-06-29T12:54:42Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "ab61cf3927308a27c01181f744272e87b9c331dd", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/ab61cf3927308a27c01181f744272e87b9c331dd", "committedDate": "2020-06-30T00:35:58Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab61cf3927308a27c01181f744272e87b9c331dd", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/ab61cf3927308a27c01181f744272e87b9c331dd", "committedDate": "2020-06-30T00:35:58Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "cbac69058afa4d9fd232b69ff6820dddaff7c42d", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/cbac69058afa4d9fd232b69ff6820dddaff7c42d", "committedDate": "2020-06-30T20:16:45Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cbac69058afa4d9fd232b69ff6820dddaff7c42d", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/cbac69058afa4d9fd232b69ff6820dddaff7c42d", "committedDate": "2020-06-30T20:16:45Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "f003472f6ad7a799bddbb3bf91b8fa1baf524924", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/f003472f6ad7a799bddbb3bf91b8fa1baf524924", "committedDate": "2020-07-04T17:20:21Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f003472f6ad7a799bddbb3bf91b8fa1baf524924", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/f003472f6ad7a799bddbb3bf91b8fa1baf524924", "committedDate": "2020-07-04T17:20:21Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "49e3c91dd6beb7a8aba1cc0460afa1e843f475df", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/49e3c91dd6beb7a8aba1cc0460afa1e843f475df", "committedDate": "2020-07-04T20:25:14Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "49e3c91dd6beb7a8aba1cc0460afa1e843f475df", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/49e3c91dd6beb7a8aba1cc0460afa1e843f475df", "committedDate": "2020-07-04T20:25:14Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "376fa96d71164326ee8869fa39e315eec3acdaa2", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/376fa96d71164326ee8869fa39e315eec3acdaa2", "committedDate": "2020-07-05T15:18:22Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "376fa96d71164326ee8869fa39e315eec3acdaa2", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/376fa96d71164326ee8869fa39e315eec3acdaa2", "committedDate": "2020-07-05T15:18:22Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "cef56d7752deb3eb3a6e5fdaf0aea3e86f6885a0", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/cef56d7752deb3eb3a6e5fdaf0aea3e86f6885a0", "committedDate": "2020-07-05T23:45:15Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "cef56d7752deb3eb3a6e5fdaf0aea3e86f6885a0", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/cef56d7752deb3eb3a6e5fdaf0aea3e86f6885a0", "committedDate": "2020-07-05T23:45:15Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "0a8ebc951e02eafdaca66ea9139055c8475c4680", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/0a8ebc951e02eafdaca66ea9139055c8475c4680", "committedDate": "2020-07-24T19:50:54Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0a8ebc951e02eafdaca66ea9139055c8475c4680", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/0a8ebc951e02eafdaca66ea9139055c8475c4680", "committedDate": "2020-07-24T19:50:54Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "2c368c7e1cd0bbbe995c7869109f47072446701a", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/2c368c7e1cd0bbbe995c7869109f47072446701a", "committedDate": "2020-08-05T12:36:07Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2c368c7e1cd0bbbe995c7869109f47072446701a", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/2c368c7e1cd0bbbe995c7869109f47072446701a", "committedDate": "2020-08-05T12:36:07Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "6f916914173e629a37299d29e203a08eab5156a0", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/6f916914173e629a37299d29e203a08eab5156a0", "committedDate": "2020-08-05T16:58:31Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6f916914173e629a37299d29e203a08eab5156a0", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/6f916914173e629a37299d29e203a08eab5156a0", "committedDate": "2020-08-05T16:58:31Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "224113b9e55ed62f1c80b687f022ad8ed03bba5e", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/224113b9e55ed62f1c80b687f022ad8ed03bba5e", "committedDate": "2020-08-07T21:26:33Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "224113b9e55ed62f1c80b687f022ad8ed03bba5e", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/224113b9e55ed62f1c80b687f022ad8ed03bba5e", "committedDate": "2020-08-07T21:26:33Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "4c4d8c5fd78bd7fed0212f8b1ef52dcfbb605f37", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/4c4d8c5fd78bd7fed0212f8b1ef52dcfbb605f37", "committedDate": "2020-08-08T19:13:15Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4c4d8c5fd78bd7fed0212f8b1ef52dcfbb605f37", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/4c4d8c5fd78bd7fed0212f8b1ef52dcfbb605f37", "committedDate": "2020-08-08T19:13:15Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/038c805d7ad27694a95f54c0e28d6ec2ca44312a", "committedDate": "2020-08-13T00:40:58Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2NTYzNDc4", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#pullrequestreview-466563478", "createdAt": "2020-08-13T08:46:23Z", "commit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwODo0NjoyM1rOHACCqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QwOTowMTo1NFrOHACnIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA==", "bodyText": "Could you extract this condition (instanceof) to a member on AbstractDeckTreeNode with a reasonable name", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469795498", "createdAt": "2020-08-13T08:46:23Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,7 +2107,21 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_ instanceof DeckDueTreeNode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NjgyMw==", "bodyText": "I don't feel the copy/pasting works well here.\nCombine the two into (deckDueTreeNode_.shouldOpenReviewerOnSelection())", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469796823", "createdAt": "2020-08-13T08:48:33Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,7 +2107,21 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_ instanceof DeckDueTreeNode)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzYyMg==", "bodyText": "@Nullable - and ensure that there are no lint warnings", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469797622", "createdAt": "2020-08-13T08:49:51Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -319,15 +329,23 @@ public int findDeckPosition(long did) {\n     }\n \n \n-    public int getEta() {\n-        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});\n+    public Integer getEta() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NzcwMQ==", "bodyText": "Ditto", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469797701", "createdAt": "2020-08-13T08:49:57Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -319,15 +329,23 @@ public int findDeckPosition(long did) {\n     }\n \n \n-    public int getEta() {\n-        return mCol.getSched().eta(new int[]{mNew, mLrn, mRev});\n+    public Integer getEta() {\n+        if (numbersComputed) {\n+            return mCol.getSched().eta(new int[] {mNew, mLrn, mRev});\n+        } else {\n+            return null;\n+        }\n     }\n \n-    public int getDue() {\n-        return mNew + mLrn + mRev;\n+    public Integer getDue() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw==", "bodyText": "For discussion:\ninstanceof is typically seen as a code smell: https://softwareengineering.stackexchange.com/questions/394856/instanceof-code-smell\nConsider removing this instanceof, and returning 0 (or null, or Optional.none()) from getNewCount on unprocessed nodes", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469799157", "createdAt": "2020-08-13T08:52:15Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +294,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {\n-                mNew += node.getNewCount();\n-                mLrn += node.getLrnCount();\n-                mRev += node.getRevCount();\n+                if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTg2Ng==", "bodyText": "How are partial values guarded against? If some subdecks have counts, and others haven't been processed, is this displayed, should it be, and does it mattter?", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469799866", "createdAt": "2020-08-13T08:53:32Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -267,8 +274,8 @@ private void setDeckExpander(ImageButton expander, ImageButton indent, DeckDueTr\n     }\n \n \n-    private void processNodes(List<DeckDueTreeNode> nodes) {\n-        for (DeckDueTreeNode node : nodes) {\n+    private void processNodes(List<AbstractDeckTreeNode> nodes) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDIyNA==", "bodyText": "node.shouldDisplayCounts, and avoid the instanceof", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800224", "createdAt": "2020-08-13T08:54:08Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -213,12 +217,15 @@ public void onBindViewHolder(ViewHolder holder, int position) {\n         }\n \n         // Set the card counts and their colors\n-        holder.deckNew.setText(String.valueOf(node.getNewCount()));\n-        holder.deckNew.setTextColor((node.getNewCount() == 0) ? mZeroCountColor : mNewCountColor);\n-        holder.deckLearn.setText(String.valueOf(node.getLrnCount()));\n-        holder.deckLearn.setTextColor((node.getLrnCount() == 0) ? mZeroCountColor : mLearnCountColor);\n-        holder.deckRev.setText(String.valueOf(node.getRevCount()));\n-        holder.deckRev.setTextColor((node.getRevCount() == 0) ? mZeroCountColor : mReviewCountColor);\n+        if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDUxOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private boolean numbersComputed;\n          \n          \n            \n                private boolean mNumbersComputed;", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800519", "createdAt": "2020-08-13T08:54:36Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -71,6 +73,7 @@\n     private int mNew;\n     private int mLrn;\n     private int mRev;\n+    private boolean numbersComputed;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDg5MQ==", "bodyText": "maybe rename to LOAD_DECK_QUICK", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469800891", "createdAt": "2020-08-13T08:55:12Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2211,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMTU3NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");\n          \n          \n            \n                        Timber.w(e, \"doInBackgroundLoadDeckCounts - error\");", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469801574", "createdAt": "2020-08-13T08:56:21Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -593,6 +597,20 @@ private TaskData doInBackgroundAnswerCard(TaskData param) {\n     }\n \n \n+    private TaskData doInBackgroundLoadDeck() {\n+        Timber.d(\"doInBackgroundLoadDeckCounts\");\n+        Collection col = CollectionHelper.getInstance().getCol(mContext);\n+        try {\n+            // Get due tree\n+            Object[] o = new Object[] {col.getSched().quickDeckDueTree()};\n+            return new TaskData(o);\n+        } catch (RuntimeException e) {\n+            Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjA0Nw==", "bodyText": "\ud83d\udc4d null is handled correctly", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802047", "createdAt": "2020-08-13T08:57:06Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -593,6 +597,20 @@ private TaskData doInBackgroundAnswerCard(TaskData param) {\n     }\n \n \n+    private TaskData doInBackgroundLoadDeck() {\n+        Timber.d(\"doInBackgroundLoadDeckCounts\");\n+        Collection col = CollectionHelper.getInstance().getCol(mContext);\n+        try {\n+            // Get due tree\n+            Object[] o = new Object[] {col.getSched().quickDeckDueTree()};\n+            return new TaskData(o);\n+        } catch (RuntimeException e) {\n+            Timber.e(e, \"doInBackgroundLoadDeckCounts - error\");\n+            return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjQyOQ==", "bodyText": "can be simplified by an Integer.compareTo(x, y)", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802429", "createdAt": "2020-08-13T08:57:43Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA==", "bodyText": "Needs better internationalisation", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469802858", "createdAt": "2020-08-13T08:58:29Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzQ4Nw==", "bodyText": "This throws when mChildren is null", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469803487", "createdAt": "2020-08-13T08:59:35Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzgzNw==", "bodyText": "I think this needs a null check on mChildren. mChildren is null and tree is non-null would crash", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469803837", "createdAt": "2020-08-13T09:00:10Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDI5NA==", "bodyText": "No null checks for object", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469804294", "createdAt": "2020-08-13T09:00:57Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDgzMw==", "bodyText": "Revert this file - spacing changes", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r469804833", "createdAt": "2020-08-13T09:01:54Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -128,9 +128,9 @@ private void markNextCardAsGood(Sched sched) {\n \n     @NonNull\n     private DeckDueTreeNode getCountsForDid(double didToFind) {\n-        List<DeckDueTreeNode> tree = getCol().getSched().deckDueTree();\n+        List<DeckDueTreeNode> tree =  getCol().getSched().deckDueTree();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/038c805d7ad27694a95f54c0e28d6ec2ca44312a", "committedDate": "2020-08-13T00:40:58Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "954500b41fe4e29244ccadd4781683db650f5865", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/954500b41fe4e29244ccadd4781683db650f5865", "committedDate": "2020-08-13T19:07:58Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MDM2MjYx", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#pullrequestreview-467036261", "createdAt": "2020-08-13T18:43:15Z", "commit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxODo0MzoxNlrOHAY3CA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QxOTowODowMVrOHAZysg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE2OTM1Mg==", "bodyText": "I'm not convinced it makes the code easier to read, because anyway I'm going to use a cast; so instanceOf makes sens here.\nI am pretty sure I had a good reason not to factorize, but I can't recall it", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470169352", "createdAt": "2020-08-13T18:43:16Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,7 +2107,21 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_ instanceof DeckDueTreeNode)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5NTQ5OA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MDU5Mg==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470170592", "createdAt": "2020-08-13T18:45:23Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2211,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDg5MQ=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MTQwNg==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470171406", "createdAt": "2020-08-13T18:46:49Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -71,6 +73,7 @@\n     private int mNew;\n     private int mLrn;\n     private int mRev;\n+    private boolean numbersComputed;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDUxOQ=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MjE2Mw==", "bodyText": "As above, since I need a cast anyway, I'm confused by the fact that you want to remove an instanceOf", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470172163", "createdAt": "2020-08-13T18:48:13Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -213,12 +217,15 @@ public void onBindViewHolder(ViewHolder holder, int position) {\n         }\n \n         // Set the card counts and their colors\n-        holder.deckNew.setText(String.valueOf(node.getNewCount()));\n-        holder.deckNew.setTextColor((node.getNewCount() == 0) ? mZeroCountColor : mNewCountColor);\n-        holder.deckLearn.setText(String.valueOf(node.getLrnCount()));\n-        holder.deckLearn.setTextColor((node.getLrnCount() == 0) ? mZeroCountColor : mLearnCountColor);\n-        holder.deckRev.setText(String.valueOf(node.getRevCount()));\n-        holder.deckRev.setTextColor((node.getRevCount() == 0) ? mZeroCountColor : mReviewCountColor);\n+        if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMDIyNA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3MzY0NA==", "bodyText": "I protected it as well as I could given java type. That is, DeckDueTreeNode is an AbstracDeckTreeNode<DeckDueTreeNode> which means that each children of DeckDueTreeNode are DeckDueTreeNode and similarly for DeckTreeNode.\nI agree that this is far from perfect and we could do error really easily, the typing is a small protection here.", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470173644", "createdAt": "2020-08-13T18:50:57Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -267,8 +274,8 @@ private void setDeckExpander(ImageButton expander, ImageButton indent, DeckDueTr\n     }\n \n \n-    private void processNodes(List<DeckDueTreeNode> nodes) {\n-        for (DeckDueTreeNode node : nodes) {\n+    private void processNodes(List<AbstractDeckTreeNode> nodes) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTg2Ng=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE3NTM5Ng==", "bodyText": "I'm really surprised. Because my first implementation returned 0 when no number were known and you told me to avoid to do that.\nAgreed, I displayed the 0's to the user, which was not a good idea. Having a method returning an arbitrary value seems less a problem. But still, I don't like the idea of returning a wrong value. Nor checking every returned value when it's easy to know in advance whether we will get relevant values", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470175396", "createdAt": "2020-08-13T18:53:59Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +294,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {\n-                mNew += node.getNewCount();\n-                mLrn += node.getLrnCount();\n-                mRev += node.getRevCount();\n+                if (node instanceof DeckDueTreeNode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTc5OTE1Nw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MDE5NA==", "bodyText": "Done in https://github.com/ankidroid/Anki-Android/pull/6890/files", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470180194", "createdAt": "2020-08-13T18:59:45Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjQyOQ=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MDcyOQ==", "bodyText": "I should note that this is only used in Timber. Timber prints recursively the deck and its subdeck, and so I wanted to have a general method to get the timbered line for this specific deck without dealing with recursion.\nSo in this case, I don't believe we actually want to internationalize. Instead we want to write in comment what I just wrote", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470180729", "createdAt": "2020-08-13T19:00:46Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMjg1OA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MjI3Mw==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470182273", "createdAt": "2020-08-13T19:03:24Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzQ4Nw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MzUxNw==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470183517", "createdAt": "2020-08-13T19:05:48Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDI5NA=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4NDMwOA==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470184308", "createdAt": "2020-08-13T19:07:22Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        if (rhs.getDepth() > getDepth()) {\n+            return -1;\n+        } else {\n+            return 1;\n+        }\n+    }\n+\n+    /** Line representing this string without its children */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (!(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwMzgzNw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4NDYyNg==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470184626", "createdAt": "2020-08-13T19:08:01Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -128,9 +128,9 @@ private void markNextCardAsGood(Sched sched) {\n \n     @NonNull\n     private DeckDueTreeNode getCountsForDid(double didToFind) {\n-        List<DeckDueTreeNode> tree = getCol().getSched().deckDueTree();\n+        List<DeckDueTreeNode> tree =  getCol().getSched().deckDueTree();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2OTgwNDgzMw=="}, "originalCommit": {"oid": "038c805d7ad27694a95f54c0e28d6ec2ca44312a"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "954500b41fe4e29244ccadd4781683db650f5865", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/954500b41fe4e29244ccadd4781683db650f5865", "committedDate": "2020-08-13T19:07:58Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "00318d15652b978fa18a213cd0d2598459ee2aa3", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/00318d15652b978fa18a213cd0d2598459ee2aa3", "committedDate": "2020-08-13T19:08:45Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00318d15652b978fa18a213cd0d2598459ee2aa3", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/00318d15652b978fa18a213cd0d2598459ee2aa3", "committedDate": "2020-08-13T19:08:45Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/397e5d1af888b4a2c9469a5f408243c77b0d2fce", "committedDate": "2020-08-13T20:31:44Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTE1MTcw", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#pullrequestreview-467115170", "createdAt": "2020-08-13T20:42:27Z", "commit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0MjoyN1rOHAc7NQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xM1QyMDo0ODo0OVrOHAdJPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNTk1Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (!(deckDueTreeNode_.shouldDisplayCounts())) {\n          \n          \n            \n                    if (!deckDueTreeNode_.shouldDisplayCounts()) {", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470235957", "createdAt": "2020-08-13T20:42:27Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,17 +2118,19 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_.shouldDisplayCounts())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzE4NQ==", "bodyText": "Nicer already!\nCould be even nicer if you performed (!shouldDisplayCounts() || .hasNoPendingReps())", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470237185", "createdAt": "2020-08-13T20:44:38Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2103,17 +2118,19 @@ private void handleDeckSelection(long did, boolean dontSkipStudyOptions) {\n         mFocusedDeck = did;\n         // Get some info about the deck to handle special cases\n         int pos = mDeckListAdapter.findDeckPosition(did);\n-        DeckDueTreeNode deckDueTreeNode = mDeckListAdapter.getDeckList().get(pos);\n+        AbstractDeckTreeNode deckDueTreeNode_ = mDeckListAdapter.getDeckList().get(pos);\n+        if (!(deckDueTreeNode_.shouldDisplayCounts())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzNzQ0NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;\n          \n          \n            \n                    CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470237445", "createdAt": "2020-08-13T20:45:00Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2193,6 +2210,11 @@ private void scrollDecklistToDeck(long did) {\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n+        CollectionTask.TASK_TYPE task_type = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODA1Mw==", "bodyText": "Would be better to use polymorphism here so we don't need to cast. I know there's a discussion below.", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470238053", "createdAt": "2020-08-13T20:46:07Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -213,12 +219,15 @@ public void onBindViewHolder(ViewHolder holder, int position) {\n         }\n \n         // Set the card counts and their colors\n-        holder.deckNew.setText(String.valueOf(node.getNewCount()));\n-        holder.deckNew.setTextColor((node.getNewCount() == 0) ? mZeroCountColor : mNewCountColor);\n-        holder.deckLearn.setText(String.valueOf(node.getLrnCount()));\n-        holder.deckLearn.setTextColor((node.getLrnCount() == 0) ? mZeroCountColor : mLearnCountColor);\n-        holder.deckRev.setText(String.valueOf(node.getRevCount()));\n-        holder.deckRev.setTextColor((node.getRevCount() == 0) ? mZeroCountColor : mReviewCountColor);\n+        if (node.shouldDisplayCounts()) {\n+            DeckDueTreeNode node_ = (DeckDueTreeNode) node;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzODY0Nw==", "bodyText": "It would be better to stop processing straight away if shouldDisplayCounts is false - it means that children also have no counts.\nMaybe alias the name to canCalculateCounts for better semantic meaning here", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470238647", "createdAt": "2020-08-13T20:47:09Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/widgets/DeckAdapter.java", "diffHunk": "@@ -287,9 +296,12 @@ private void processNodes(List<DeckDueTreeNode> nodes) {\n \n             // Add this node's counts to the totals if it's a parent deck\n             if (node.getDepth() == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzOTIxNQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    int childrenHash;\n          \n          \n            \n                    int childrenHash = mChildren == null ? 0 : mChildren.hashCode();", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470239215", "createdAt": "2020-08-13T20:48:15Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,178 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDIzOTU1MQ==", "bodyText": "ditto", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r470239551", "createdAt": "2020-08-13T20:48:49Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/DeckDueTreeNode.java", "diffHunk": "@@ -182,7 +82,13 @@ public void setChildren(@NonNull List<DeckDueTreeNode> children, boolean addRev)\n \n     @Override\n     public int hashCode() {\n-        int childrenHash = mChildren.hashCode();\n+        int childrenHash;\n+        @Nullable List<DeckDueTreeNode> children = getChildren();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce"}, "originalPosition": 157}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "397e5d1af888b4a2c9469a5f408243c77b0d2fce", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/397e5d1af888b4a2c9469a5f408243c77b0d2fce", "committedDate": "2020-08-13T20:31:44Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}, "afterCommit": {"oid": "f52db65a9e18836551684be887d0944ab20c0590", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/f52db65a9e18836551684be887d0944ab20c0590", "committedDate": "2020-08-13T22:06:05Z", "message": "NF: knownToHaveCount"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4MDE4NDkw", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#pullrequestreview-468018490", "createdAt": "2020-08-15T21:24:39Z", "commit": {"oid": "1ed51e5756e17ae88c37943fca8ef57e1dc4b03b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQyMToyNDo0MFrOHBNt2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQyMToyNDo0MFrOHBNt2A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTAzNTM1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void shouldOpenReviewerOnSelection(boolean dontSkipStudyOptions) {\n          \n          \n            \n                private void openReviewerOrStudyOptions(boolean dontSkipStudyOptions) {\n          \n      \n    \n    \n  \n\nJust a name suggestion so it is aligned with what is actually happening in this commit", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r471035352", "createdAt": "2020-08-15T21:24:40Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2090,6 +2090,17 @@ private void openStudyOptions(boolean withDeckOptions) {\n         }\n     }\n \n+    private void shouldOpenReviewerOnSelection(boolean dontSkipStudyOptions) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1ed51e5756e17ae88c37943fca8ef57e1dc4b03b"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f52db65a9e18836551684be887d0944ab20c0590", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/f52db65a9e18836551684be887d0944ab20c0590", "committedDate": "2020-08-13T22:06:05Z", "message": "NF: knownToHaveCount"}, "afterCommit": {"oid": "b9475f67610e111f4f508ed82fec3fd5b4f2e0c4", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/b9475f67610e111f4f508ed82fec3fd5b4f2e0c4", "committedDate": "2020-08-15T21:50:04Z", "message": "NF: knownToHaveCount"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b9475f67610e111f4f508ed82fec3fd5b4f2e0c4", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/b9475f67610e111f4f508ed82fec3fd5b4f2e0c4", "committedDate": "2020-08-15T21:50:04Z", "message": "NF: knownToHaveCount"}, "afterCommit": {"oid": "c5a8d38a8d36d0e72cd6a16c3576c944d2a0c54a", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/c5a8d38a8d36d0e72cd6a16c3576c944d2a0c54a", "committedDate": "2020-08-15T22:09:34Z", "message": "NF: knownToHaveCount"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c5a8d38a8d36d0e72cd6a16c3576c944d2a0c54a", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/c5a8d38a8d36d0e72cd6a16c3576c944d2a0c54a", "committedDate": "2020-08-15T22:09:34Z", "message": "NF: knownToHaveCount"}, "afterCommit": {"oid": "b16d00296eae0eead2fefb9af3f0e686b7b858a6", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/b16d00296eae0eead2fefb9af3f0e686b7b858a6", "committedDate": "2020-08-21T08:01:34Z", "message": "NF: knownToHaveCount"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b16d00296eae0eead2fefb9af3f0e686b7b858a6", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/b16d00296eae0eead2fefb9af3f0e686b7b858a6", "committedDate": "2020-08-21T08:01:34Z", "message": "NF: knownToHaveCount"}, "afterCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "committedDate": "2020-08-22T10:02:28Z", "message": "NF: knownToHaveCount"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MjkzMzA1", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#pullrequestreview-474293305", "createdAt": "2020-08-25T09:16:34Z", "commit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToxNjozNFrOHGPQSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yNVQwOToyMzoyMlrOHGPg2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzQzMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return;", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476303433", "createdAt": "2020-08-25T09:16:34Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2138,6 +2142,17 @@ private void openStudyOptions(boolean withDeckOptions) {\n         }\n     }\n \n+    private void openReviewerOrStudyOptions(boolean dontSkipStudyOptions) {\n+        if (mFragmented || dontSkipStudyOptions) {\n+            // Go to StudyOptions screen when tablet or deck counts area was clicked\n+            openStudyOptions(false);\n+        } else {\n+            // Otherwise jump straight to the reviewer\n+            openReviewer();\n+        }\n+        return;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwMzk4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;\n          \n          \n            \n                    CollectionTask.TASK_TYPE taskType = quick ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476303980", "createdAt": "2020-08-25T09:17:30Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2279,8 +2290,13 @@ public void actualOnPostExecute(@NonNull DeckPicker deckPicker, TaskData result)\n      * This method also triggers an update for the widget to reflect the newly calculated counts.\n      */\n     private void updateDeckList() {\n+        updateDeckList(false);\n+    }\n+\n+    private void updateDeckList(boolean quick) {\n         TaskListener listener = updateDeckListListener();\n-        CollectionTask task = CollectionTask.launchCollectionTask(LOAD_DECK_COUNTS, listener);\n+        CollectionTask.TASK_TYPE taskType = (quick) ? LOAD_DECK_QUICK : LOAD_DECK_COUNTS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNTQwMA==", "bodyText": "addRev is unused", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476305400", "createdAt": "2020-08-25T09:19:41Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNjA2Ng==", "bodyText": "May be able to use Comparable<AbstractDeckTreeNode<T>> to improve the signature of compare()", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476306066", "createdAt": "2020-08-25T09:20:42Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NjMwNzY3Mw==", "bodyText": "Questionable - might be best to extract to return a new (nullable) instance of a DeckCounts class so people don't misuse the API.\nImplementer's choice here", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#discussion_r476307673", "createdAt": "2020-08-25T09:23:22Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractDeckTreeNode.java", "diffHunk": "@@ -0,0 +1,194 @@\n+package com.ichi2.libanki.sched;\n+\n+import com.ichi2.libanki.Collection;\n+import com.ichi2.libanki.Decks;\n+\n+import java.util.List;\n+import java.util.Locale;\n+\n+import androidx.annotation.NonNull;\n+import androidx.annotation.Nullable;\n+\n+/**\n+ * Holds the data for a single node (row) in the deck due tree (the user-visible list\n+ * of decks and their counts). A node also contains a list of nodes that refer to the\n+ * next level of sub-decks for that particular deck (which can be an empty list).\n+ *\n+ * The names field is an array of names that build a deck name from a hierarchy (i.e., a nested\n+ * deck will have an entry for every level of nesting). While the python version interchanges\n+ * between a string and a list of strings throughout processing, we always use an array for\n+ * this field and use getNamePart(0) for those cases.\n+ *\n+ * T represents the type of children. Required for typing purpose only.\n+ */\n+public abstract class AbstractDeckTreeNode<T extends AbstractDeckTreeNode<T>> implements Comparable {\n+    private final String mName;\n+    private final String[] mNameComponents;\n+    private final Collection mCol;\n+    private long mDid;\n+    @Nullable\n+    private List<T> mChildren = null;\n+\n+    public AbstractDeckTreeNode(Collection col, String mName, long mDid) {\n+        this.mCol = col;\n+        this.mName = mName;\n+        this.mDid = mDid;\n+        this.mNameComponents = Decks.path(mName);\n+    }\n+\n+    /**\n+     * Sort on the head of the node.\n+     */\n+    @Override\n+    public int compareTo(Object other) {\n+        AbstractDeckTreeNode<T> rhs = (AbstractDeckTreeNode<T>) other;\n+        int minDepth = Math.min(getDepth(), rhs.getDepth()) + 1;\n+        // Consider each subdeck name in the ordering\n+        for (int i = 0; i < minDepth; i++) {\n+            int cmp = mNameComponents[i].compareTo(rhs.mNameComponents[i]);\n+            if (cmp == 0) {\n+                continue;\n+            }\n+            return cmp;\n+        }\n+        // If we made it this far then the arrays are of different length. The longer one should\n+        // always come after since it contains all of the sections of the shorter one inside it\n+        // (i.e., the short one is an ancestor of the longer one).\n+        return Integer.compare(getDepth(), rhs.getDepth());\n+    }\n+\n+    /** Line representing this string without its children. Used in timbers only. */\n+    protected String toStringLine() {\n+        return String.format(Locale.US, \"%s, %d, %s\",\n+                             mName, mDid, mChildren);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        StringBuffer buf = new StringBuffer();\n+        toString(buf);\n+        return buf.toString();\n+    }\n+\n+    protected void toString(StringBuffer buf) {\n+        for (int i = 0; i < getDepth(); i++ ) {\n+            buf.append(\"  \");\n+        }\n+        buf.append(toStringLine());\n+        if (mChildren == null) {\n+            return;\n+        }\n+        for (T children : mChildren) {\n+            children.toString(buf);\n+        }\n+    }\n+\n+    /**\n+     * @return The full deck name, e.g. \"A::B::C\"\n+     * */\n+    public String getFullDeckName() {\n+        return mName;\n+    }\n+\n+    /**\n+     * For deck \"A::B::C\", `getDeckNameComponent(0)` returns \"A\",\n+     * `getDeckNameComponent(1)` returns \"B\", etc...\n+     */\n+    public String getDeckNameComponent(int part) {\n+        return mNameComponents[part];\n+    }\n+\n+    /**\n+     * The part of the name displayed in deck picker, i.e. the\n+     * part that does not belong to its parents. E.g.  for deck\n+     * \"A::B::C\", returns \"C\".\n+     */\n+    public String getLastDeckNameComponent() {\n+        return getDeckNameComponent(getDepth());\n+    }\n+\n+    public long getDid() {\n+        return mDid;\n+    }\n+\n+    /**\n+     * @return The depth of a deck. Top level decks have depth 0,\n+     * their children have depth 1, etc... So \"A::B::C\" would have\n+     * depth 2.\n+     */\n+    public int getDepth() {\n+        return mNameComponents.length - 1;\n+    }\n+\n+    /**\n+     * @return The children of this deck. Note that they are set\n+     * in the data structure returned by DeckDueTree but are\n+     * always empty when the data structure is returned by\n+     * deckDueList.*/\n+    public List<T> getChildren() {\n+        return mChildren;\n+    }\n+\n+    /**\n+     * @return whether this node as any children. */\n+    public boolean hasChildren() {\n+        return mChildren != null && !mChildren.isEmpty();\n+    }\n+\n+    public void setChildren(@NonNull List<T> children, boolean addRev) {\n+        mChildren = children;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int childrenHash = mChildren == null ? 0 : mChildren.hashCode();\n+        return getFullDeckName().hashCode() + (int) (childrenHash ^ (childrenHash >>> 32));\n+    }\n+\n+\n+    /**\n+     * Whether both elements have the same structure and numbers.\n+     * @param object\n+     * @return\n+     */\n+    @Override\n+    public boolean equals(Object object) {\n+        if (object == null || !(object instanceof AbstractDeckTreeNode)) {\n+            return false;\n+        }\n+        AbstractDeckTreeNode tree = (AbstractDeckTreeNode) object;\n+        return Decks.equalName(getFullDeckName(), tree.getFullDeckName()) &&\n+            (mChildren == null && tree.mChildren == null) || // Would be the case if both are null, or the same pointer\n+            (mChildren != null && mChildren.equals(tree.mChildren))\n+            ;\n+    }\n+\n+    public Collection getCol() {\n+        return mCol;\n+    }\n+\n+    public boolean shouldDisplayCounts() {\n+        return false;\n+    }\n+\n+    /* Number of new cards to see today known to be in this deck and its descendants. The number to show to user*/\n+    public int getNewCount() {\n+        throw new UnsupportedOperationException();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500"}, "originalPosition": 176}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba4adebcd072e9a317c50bb76b961087ef9c62ee", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/ba4adebcd072e9a317c50bb76b961087ef9c62ee", "committedDate": "2020-08-25T23:54:27Z", "message": "NF: shouldOpenReviewerOnSelection"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f3d530084dae78c9600fa35451bf42630571931", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/6f3d530084dae78c9600fa35451bf42630571931", "committedDate": "2020-08-26T00:00:26Z", "message": "NF: Split DeckTreeNode in two\n\nAn abstract version without numbers, and the previous version with numbers."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "35c4301aa72d322ab7e69a96c660925a677cfcf0", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/35c4301aa72d322ab7e69a96c660925a677cfcf0", "committedDate": "2020-08-26T00:00:27Z", "message": "NF: quickDeckDueTree"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b6f8e40d9938f1c8bfc4fc85acded4b7de7ef0b", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/6b6f8e40d9938f1c8bfc4fc85acded4b7de7ef0b", "committedDate": "2020-08-26T00:00:27Z", "message": "UpdateDeckList: first call is quick\n\nNumbers are displayed on second call."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9", "committedDate": "2020-08-26T00:00:27Z", "message": "NF: knownToHaveCount"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/ea82d094e2eaa9f1a1fa45f1f0e196be9f0e8500", "committedDate": "2020-08-22T10:02:28Z", "message": "NF: knownToHaveCount"}, "afterCommit": {"oid": "3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9", "committedDate": "2020-08-26T00:00:27Z", "message": "NF: knownToHaveCount"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc1ODA4MjMw", "url": "https://github.com/ankidroid/Anki-Android/pull/6578#pullrequestreview-475808230", "createdAt": "2020-08-26T19:48:43Z", "commit": {"oid": "3e0f4f9deb7fa0998fe1110deaebbd78f50d67a9"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3036, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}