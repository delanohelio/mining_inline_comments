{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4ODkzMjY0", "number": 6543, "reviewThreads": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMTowNjowMFrOEILuYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjozMzo1MlrOEJZszQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDE2MTYzOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMTowNjowMFrOGn_hkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjowMTo0MFrOGp5olg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4ODQzNA==", "bodyText": "Could you add a comment/reword with the units? Presumably Bytes", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444588434", "createdAt": "2020-06-24T01:06:00Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -65,6 +70,8 @@\n     private static final int REQUEST_AUDIO_PERMISSION = 0;\n     private static final int REQUEST_CAMERA_PERMISSION = 1;\n \n+    public static final int sImageLimit = 1024 * 1024;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTA3OA==", "bodyText": "Still unresolved in my UI - GitHub lag", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589078", "createdAt": "2020-06-28T02:01:40Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -65,6 +70,8 @@\n     private static final int REQUEST_AUDIO_PERMISSION = 0;\n     private static final int REQUEST_CAMERA_PERMISSION = 1;\n \n+    public static final int sImageLimit = 1024 * 1024;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4ODQzNA=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDE3MTY5OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/res/values/16-multimedia-editor.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToxMjoxN1rOGn_nog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTozNTo0N1rOGpRBrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4OTk4Ng==", "bodyText": "translatable=\"false\" ?", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444589986", "createdAt": "2020-06-24T01:12:17Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/res/values/16-multimedia-editor.xml", "diffHunk": "@@ -112,4 +112,11 @@\n \n \t<!-- Network failure -->\n \t<string name=\"network_no_connection\">No connection</string>\n+\n+    <!-- Crop function-->\n+    <string name=\"crop_image\" translatable=\"false\">Do you want to crop this image?</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyMzc1Nw==", "bodyText": "OMG nice catch.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445923757", "createdAt": "2020-06-26T01:35:47Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/res/values/16-multimedia-editor.xml", "diffHunk": "@@ -112,4 +112,11 @@\n \n \t<!-- Network failure -->\n \t<string name=\"network_no_connection\">No connection</string>\n+\n+    <!-- Crop function-->\n+    <string name=\"crop_image\" translatable=\"false\">Do you want to crop this image?</string>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4OTk4Ng=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDE3MzQ2OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToxMzoxMlrOGn_onA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToxMzoxMlrOGn_onA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MDIzNg==", "bodyText": "Maybe go with Formatter.formatShortFileSize.\nYou could bring the format string inside the resource.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444590236", "createdAt": "2020-06-24T01:13:12Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -379,6 +383,30 @@ public void handleFieldChanged(IField newField) {\n         recreateEditingUi(ChangeUIRequest.fieldChange(newField));\n     }\n \n+    public void showLargeFileCropDialog(float length) {\n+        BasicImageFieldController imageFieldController = (BasicImageFieldController) mFieldController;\n+        File file = new File(mField.getImagePath());\n+        Uri uri = FileProvider.getUriForFile(this, this.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        DecimalFormat decimalFormat = new DecimalFormat(\".00\");\n+        String size = decimalFormat.format(length);\n+        String content = getString(R.string.save_dialog_content, size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDE4NTY1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToyMDo0OFrOGn_v8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTozOTo1NFrOGpRFJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MjExMg==", "bodyText": "Could a sample path be provided here? Probably on me to better understand filepaths.xml", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444592112", "createdAt": "2020-06-24T01:20:48Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -71,16 +78,22 @@\n     @VisibleForTesting\n     static final int ACTIVITY_SELECT_IMAGE = 1;\n     private static final int ACTIVITY_TAKE_PICTURE = 2;\n+    private static final int ACTIVITY_CROP_PICTURE = 3;\n     private static final int IMAGE_SAVE_MAX_WIDTH = 1920;\n \n     private ImageView mImagePreview;\n     private TextView mImageFileSize;\n     private TextView mImageFileSizeWarning;\n \n-    private String mTempCameraImagePath;\n+    private @Nullable String mImagePath;\n+    private @Nullable Uri mImageUri;\n+    private @Nullable String mPreviousImagePath; // save the latest path to prevent from cropping or taking photo action canceled\n+    private @Nullable Uri mPreviousImageUri;\n+    private @Nullable String mAnkiCacheDirectory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNDY0NQ==", "bodyText": "Sure, helps with verification, added this in code but pasting here for memory:                                                   // e.g.  '/self/primary/Android/data/com.ichi2.anki.AnkiDroid/cache/'", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445924645", "createdAt": "2020-06-26T01:39:54Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -71,16 +78,22 @@\n     @VisibleForTesting\n     static final int ACTIVITY_SELECT_IMAGE = 1;\n     private static final int ACTIVITY_TAKE_PICTURE = 2;\n+    private static final int ACTIVITY_CROP_PICTURE = 3;\n     private static final int IMAGE_SAVE_MAX_WIDTH = 1920;\n \n     private ImageView mImagePreview;\n     private TextView mImageFileSize;\n     private TextView mImageFileSizeWarning;\n \n-    private String mTempCameraImagePath;\n+    private @Nullable String mImagePath;\n+    private @Nullable Uri mImageUri;\n+    private @Nullable String mPreviousImagePath; // save the latest path to prevent from cropping or taking photo action canceled\n+    private @Nullable Uri mPreviousImageUri;\n+    private @Nullable String mAnkiCacheDirectory;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MjExMg=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDE5Mjc4OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToyNToyOVrOGn_0cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToyNToyOVrOGn_0cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5MzI2Nw==", "bodyText": "(optional) surprised there's not an override for showThemedToast which expects a @StringRes", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444593267", "createdAt": "2020-06-24T01:25:29Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 471}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDE5ODkwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMToyOToyMVrOGn_4HA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo0MDo1MVrOGpRGDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5NDIwNA==", "bodyText": "Interesting... looks like it'll also have application in the import screen. Any reference for how this code came to fruition?\nLooks like: https://stackoverflow.com/a/44172185/13121290\nI suspect this may be device manufacturer specific.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444594204", "createdAt": "2020-06-24T01:29:21Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNDc1MQ==", "bodyText": "Dealing with camera and gallery storage is super API- and device-specific", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445924751", "createdAt": "2020-06-26T01:40:20Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5NDIwNA=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 492}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNDg3OA==", "bodyText": "@NightXlt may have more information on where the code came from, I'm not going to touch this part personally", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445924878", "createdAt": "2020-06-26T01:40:51Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5NDIwNA=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 492}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDIyNzExOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMTo0NjoxMlrOGoAJLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMToyODo1OFrOGpddsg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODU3Mw==", "bodyText": "Has this path been exercised on a later API? I know there were changes to the way file:// data could be accessed", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444598573", "createdAt": "2020-06-24T01:46:12Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTE2MQ==", "bodyText": "Lots of changes - I exercised all the functions on later APIs, but I'm not sure if every case was hit. It should be that on later APIs people are providing files via content provider so this is not actually hit, but I'm not sure?", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445925161", "createdAt": "2020-06-26T01:42:03Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODU3Mw=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 498}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNzUzOA==", "bodyText": "From my understanding: yes and no. they should, but I think a user using an old file browser on a later API can still trigger a crash on this path (or sometimes using the file path in a content provider, but we check this path already).\nMight just be best to confirm that exchanging these paths for a throw will send an exception report and won't crash the app.\nWhere's the can of worms emoji?", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446127538", "createdAt": "2020-06-26T11:28:58Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODU3Mw=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 498}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDIyODY1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMTo0NzoxOFrOGoAKIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxMTozMDowMlrOGpdffA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODgxNw==", "bodyText": "should be in a finally block", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444598817", "createdAt": "2020-06-24T01:47:18Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();\n+        }\n+\n+        return imagePath;\n     }\n \n+\n+    /**\n+     * Get image path based on uri and selection args\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable String getImagePathFromContentResolver(Context context, Uri uri, String selection) {\n+        Timber.d(\"getImagePathFromContentResolver() %s\", uri);\n+        String[] filePathColumn = { MediaStore.MediaColumns.DATA };\n+        Cursor cursor = context.getContentResolver().query(uri, filePathColumn, selection, null, null);\n+\n+        if (cursor == null) {\n+            Timber.w(\"getImagePathFromUri() cursor was null\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        if (!cursor.moveToFirst()) {\n+            //TODO: #5909, it would be best to instrument this to see if we can fix the failure\n+            Timber.w(\"getImagePathFromUri() cursor had no data\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\n+        String path = cursor.getString(columnIndex);\n+        cursor.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNTc3MQ==", "bodyText": "You would think so, but nothing in there throws, and it was not in finally in your previous method that I extracted :-) \n  \n    \n      Anki-Android/AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java\n    \n    \n         Line 287\n      in\n      747d16e\n    \n    \n    \n    \n\n        \n          \n           cursor.close();", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445925771", "createdAt": "2020-06-26T01:44:44Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();\n+        }\n+\n+        return imagePath;\n     }\n \n+\n+    /**\n+     * Get image path based on uri and selection args\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable String getImagePathFromContentResolver(Context context, Uri uri, String selection) {\n+        Timber.d(\"getImagePathFromContentResolver() %s\", uri);\n+        String[] filePathColumn = { MediaStore.MediaColumns.DATA };\n+        Cursor cursor = context.getContentResolver().query(uri, filePathColumn, selection, null, null);\n+\n+        if (cursor == null) {\n+            Timber.w(\"getImagePathFromUri() cursor was null\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        if (!cursor.moveToFirst()) {\n+            //TODO: #5909, it would be best to instrument this to see if we can fix the failure\n+            Timber.w(\"getImagePathFromUri() cursor had no data\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\n+        String path = cursor.getString(columnIndex);\n+        cursor.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODgxNw=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 530}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjEyNzk5Ng==", "bodyText": "I knew my (bad) code when I saw it (thanks!)", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446127996", "createdAt": "2020-06-26T11:30:02Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();\n+        if (uri == null) {\n+            UIUtils.showThemedToast(context, context.getString(R.string.select_image_failed), false);\n+            return null;\n+        }\n+        mImageUri = uri;\n+        mImagePath = getImagePathFromUri(context, uri);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(false);\n+        return mImageUri;\n+    }\n+\n+\n+    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+        Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n+        String imagePath = null;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n+            String docId = DocumentsContract.getDocumentId(uri);\n+            if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n+                String id = docId.split(\":\")[1];\n+                String selection = MediaStore.Images.Media._ID + \"=\" + id;\n+                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+            } else if (\"com.android.providers.downloads.documents\".equals(uri.getAuthority())) {\n+                Uri contentUri = ContentUris.withAppendedId(Uri.parse(\"content://downloads/public_downloads\"), Long.parseLong(docId));\n+                imagePath = getImagePathFromContentResolver(context, contentUri, null);\n+            }\n+        } else if (\"content\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = getImagePathFromContentResolver(context, uri, null);\n+        } else if (\"file\".equalsIgnoreCase(uri.getScheme())) {\n+            imagePath = uri.getPath();\n+        }\n+\n+        return imagePath;\n     }\n \n+\n+    /**\n+     * Get image path based on uri and selection args\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable String getImagePathFromContentResolver(Context context, Uri uri, String selection) {\n+        Timber.d(\"getImagePathFromContentResolver() %s\", uri);\n+        String[] filePathColumn = { MediaStore.MediaColumns.DATA };\n+        Cursor cursor = context.getContentResolver().query(uri, filePathColumn, selection, null, null);\n+\n+        if (cursor == null) {\n+            Timber.w(\"getImagePathFromUri() cursor was null\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        if (!cursor.moveToFirst()) {\n+            //TODO: #5909, it would be best to instrument this to see if we can fix the failure\n+            Timber.w(\"getImagePathFromUri() cursor had no data\");\n+            showSomethingWentWrong();\n+            return null;\n+        }\n+\n+        int columnIndex = cursor.getColumnIndex(filePathColumn[0]);\n+        String path = cursor.getString(columnIndex);\n+        cursor.close();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU5ODgxNw=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 530}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDI2MTMwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMjowNzozNFrOGoAeUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo0OTozMFrOGpRNxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYwMzk4NQ==", "bodyText": "can clipData be used here?", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444603985", "createdAt": "2020-06-24T02:07:34Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 469}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyNjg1Mg==", "bodyText": "I don't believe so, and in your previous time through here I don't think you did either - it's only for image picks which don't have anything to do with clipboard\nThe previous incarnation just called getData() and that was it \n  \n    \n      Anki-Android/AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java\n    \n    \n         Line 260\n      in\n      747d16e\n    \n    \n    \n    \n\n        \n          \n           Uri selectedImage = data.getData(); \n        \n    \n  \n\n\nThis incarnation just does a few more things because there is internal state to keep coherent", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445926852", "createdAt": "2020-06-26T01:49:30Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -351,22 +385,207 @@ private void setPreviewImage(String imagePath, int maxsize) {\n     void setImagePreview(File f, int maxsize) {\n         Bitmap b = BitmapUtil.decodeFile(f, maxsize);\n         if (b == null) {\n-            Timber.i(\"Not displaying preview: Could not process image %s\", f.getPath());\n+            Timber.i(\"setImagePreview() could not process image %s\", f.getPath());\n             return;\n         }\n         b = ExifUtil.rotateFromCamera(f, b);\n         mImagePreview.setImageBitmap(b);\n         mImageFileSize.setVisibility(View.VISIBLE);\n         mImageFileSize.setText(Formatter.formatFileSize(mActivity, f.length()));\n+        mCropButton.setVisibility(View.VISIBLE);\n     }\n \n \n     @Override\n     public void onDestroy() {\n         ImageView imageView = mImagePreview;\n         BitmapUtil.freeImageView(imageView);\n+        mCropButton.setVisibility(View.INVISIBLE);\n+    }\n+\n+\n+    private void handleTakePictureResult() {\n+        Timber.d(\"handleTakePictureResult\");\n+        rotateAndCompress();\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+        showCropDialog(getUriForFile(new File(mImagePath)));\n+    }\n+\n+\n+    /**\n+     * Invoke system crop function\n+     *\n+     * @param uri image's uri\n+     */\n+    public void requestCrop(Uri uri) {\n+        Timber.d(\"photoCrop() on %s\", uri);\n+\n+        if (mImagePath == null) {\n+            Timber.w(\"requestCrop() but mImagePath is null\");\n+            return;\n+        }\n+\n+        // Pre-create a file in our cache for the cropping application to put results in\n+        String fileName = mImagePath.substring(mImagePath.lastIndexOf(\"/\") + 1, mImagePath.lastIndexOf(\".\"));\n+        File image = new File(mAnkiCacheDirectory + \"/\" + fileName + \".png\");\n+        if (!image.exists()) {\n+            try {\n+                if (!image.createNewFile()) {\n+                    Timber.w(\"Failed to create new file for crop %s\", image.getAbsolutePath());\n+                    return;\n+                }\n+            } catch (IOException e) {\n+                Timber.w(e, \"Create cropped file failed\");\n+                return;\n+            }\n+        }\n+\n+        // Save the previous image in case user cancels\n+        mPreviousImagePath = mImagePath;\n+        mPreviousImageUri = mImageUri;\n+        mImagePath = image.getPath();\n+        mImageUri = Uri.fromFile(image);\n+        mField.setImagePath(mImagePath);\n+        mField.setHasTemporaryMedia(true);\n+\n+        // This is basically a \"magic\" recipe to get the system to crop, gleaned from StackOverflow etc\n+        // Intent intent = new Intent(Intent.ACTION_EDIT);  // edit (vs crop) would be even better, but it fails differently and needs lots of testing\n+        Intent intent = new Intent(\"com.android.camera.action.CROP\");\n+        int flags = Intent.FLAG_GRANT_READ_URI_PERMISSION | Intent.FLAG_GRANT_WRITE_URI_PERMISSION;\n+        intent.setFlags(flags);\n+\n+        // For any app that might handle the action, make sure they have permission for our URI\n+        List<ResolveInfo> resInfoList = mActivity.getPackageManager().queryIntentActivities(intent, PackageManager.MATCH_DEFAULT_ONLY);\n+        for (ResolveInfo resolveInfo : resInfoList) {\n+            String packageName = resolveInfo.activityInfo.packageName;\n+            mActivity.grantUriPermission(packageName, uri, flags);\n+        }\n+        intent.setDataAndType(uri, \"image/*\");\n+        intent.putExtra(\"return-data\", false);\n+        intent.putExtra(MediaStore.EXTRA_OUTPUT, mImageUri);\n+        intent.putExtra(\"outputFormat\", Bitmap.CompressFormat.PNG.toString()); // worked w/crop but not edit\n+        intent.putExtra(\"noFaceDetection\", true); // no face detection\n+        mActivity.startActivityForResultWithoutAnimation(Intent.createChooser(intent, null), ACTIVITY_CROP_PICTURE);\n+    }\n+\n+\n+    private void showCropDialog(Uri uri) {\n+        if (uri == null) {\n+            Timber.w(\"showCropDialog called with null URI\");\n+            return;\n+        }\n+        new MaterialDialog.Builder(mActivity)\n+                .content(R.string.crop_image)\n+                .positiveText(R.string.dialog_ok)\n+                .negativeText(R.string.dialog_cancel)\n+                .onPositive((dialog, which) -> requestCrop(uri))\n+                .build().show();\n+    }\n+\n+\n+    private void handleCropResult() {\n+        Timber.d(\"handleCropResult\");\n+        rotateAndCompress(); // this is a long-running operation.\n+        Timber.d(\"handleCropResult() = image path currently %s\", mField.getImagePath());\n+        mField.setImagePath(mImagePath);\n+        Timber.d(\"handleCropResult() = image path now %s\", mField.getImagePath());\n+        mField.setHasTemporaryMedia(true);\n+    }\n+\n+\n+    /**\n+     * Get Uri based on current image path\n+     *\n+     * @param file the file to get URI for\n+     * @return current image path's uri\n+     */\n+    private Uri getUriForFile(File file) {\n+        Timber.d(\"getUriForFile() %s\", file);\n+        Uri uri;\n+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n+            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n+        } else {\n+            uri = Uri.fromFile(file);\n+        }\n+        return uri;\n+    }\n+\n+\n+    /**\n+     * Get image uri that adapts various model\n+     *\n+     * @return image uri\n+     */\n+    private @Nullable Uri getImageUri(Context context, Intent data) {\n+        Timber.d(\"getImageUri for data %s\", data);\n+        Uri uri = data.getData();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYwMzk4NQ=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 469}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MDI2NDc0OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/res/xml/filepaths.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwMjoxMDowMFrOGoAglQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwMTo1NTo1OFrOGpRT4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYwNDU2NQ==", "bodyText": "Would be nice to comment a sample path here.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r444604565", "createdAt": "2020-06-24T02:10:00Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/res/xml/filepaths.xml", "diffHunk": "@@ -2,4 +2,5 @@\n <paths>\n     <external-cache-path path=\"export/\" name=\"export-directory\" />\n     <cache-path path=\"/\" name=\"cache-directory\" />\n+    <external-path path=\".\" name=\"photos\" />", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkyODQxNg==", "bodyText": "This is worth knowing more about but no comment in the code would be sufficient.\nWhat you need to know is that AnkiDroid specifies a ContentProvider based on files, with shareable directories, and this is where you specify the path and name in the ContentProvider registry: https://developer.android.com/training/secure-file-sharing/setup-sharing#DefineMetaData\nThe provider is set up in the manifest\n\n  \n    \n      Anki-Android/AnkiDroid/src/main/AndroidManifest.xml\n    \n    \n        Lines 449 to 458\n      in\n      747d16e\n    \n    \n    \n    \n\n        \n          \n           <provider \n        \n\n        \n          \n               android:name=\"androidx.core.content.FileProvider\" \n        \n\n        \n          \n               android:authorities=\"com.ichi2.anki.apkgfileprovider\" \n        \n\n        \n          \n               android:grantUriPermissions=\"true\" \n        \n\n        \n          \n               android:exported=\"false\" \n        \n\n        \n          \n               > \n        \n\n        \n          \n               <meta-data \n        \n\n        \n          \n                   android:name=\"android.support.FILE_PROVIDER_PATHS\" \n        \n\n        \n          \n                   android:resource=\"@xml/filepaths\" /> \n        \n\n        \n          \n           </provider> \n        \n    \n  \n\n\nAnd it lets us then ask the FileProvider for ContentProvider URIs to our own local files, that are usable by other apps with lines like this\n    private Uri getUriForFile(File file) {\n        Timber.d(\"getUriForFile() %s\", file);\n        Uri uri;\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {\n            uri = FileProvider.getUriForFile(mActivity, mActivity.getApplicationContext().getPackageName() + \".apkgfileprovider\", file);\n        } else {\n            uri = Uri.fromFile(file);\n        }\n        return uri;\n    }", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r445928416", "createdAt": "2020-06-26T01:55:58Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/res/xml/filepaths.xml", "diffHunk": "@@ -2,4 +2,5 @@\n <paths>\n     <external-cache-path path=\"export/\" name=\"export-directory\" />\n     <cache-path path=\"/\" name=\"cache-directory\" />\n+    <external-path path=\".\" name=\"photos\" />", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDYwNDU2NQ=="}, "originalCommit": {"oid": "a4500eda080fb2956f8c0f17b3548d863496ad22"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjkyMDMwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjowMzowNlrOGp5o8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjowMzowNlrOGp5o8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTE3MA==", "bodyText": "Consider promoting to Timber.i", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589170", "createdAt": "2020-06-28T02:03:06Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -80,9 +88,13 @@\n     protected void onCreate(Bundle savedInstanceState) {\n         super.onCreate(savedInstanceState);\n \n+        Bundle controllerBundle = null;\n         if (savedInstanceState != null) {\n+            Timber.d(\"onCreate - saved bundle exists\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjkyMTg3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjowNTozM1rOGp5pqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjowNTozM1rOGp5pqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTM1Mg==", "bodyText": "Likely as the functionality isn't implemented in the controllers", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589352", "createdAt": "2020-06-28T02:05:33Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/activity/MultimediaEditFieldActivity.java", "diffHunk": "@@ -379,22 +393,49 @@ public void handleFieldChanged(IField newField) {\n         recreateEditingUi(ChangeUIRequest.fieldChange(newField));\n     }\n \n+    public void showLargeFileCropDialog(float length) {\n+        BasicImageFieldController imageFieldController = (BasicImageFieldController) mFieldController;\n+        DecimalFormat decimalFormat = new DecimalFormat(\".00\");\n+        String size = decimalFormat.format(length);\n+        String content = getString(R.string.save_dialog_content, size);\n+        imageFieldController.showCropDialog(content, (dialog, which) -> saveAndExit());\n+    }\n+\n+\n+    private void saveAndExit() {\n+        Intent resultData = new Intent();\n+        resultData.putExtra(EXTRA_RESULT_FIELD, mField);\n+        resultData.putExtra(EXTRA_RESULT_FIELD_INDEX, mFieldIndex);\n+        setResult(RESULT_OK, resultData);\n+        finishWithoutAnimation();\n+    }\n \n     @Override\n     protected void onDestroy() {\n-        super.onDestroy();\n-\n         if (mFieldController != null) {\n             mFieldController.onDestroy();\n         }\n-\n+        super.onDestroy();\n     }\n \n \n     @Override\n     protected void onSaveInstanceState(Bundle outState) {\n-        super.onSaveInstanceState(outState);\n+        Timber.d(\"onSaveInstanceState - saving state\");\n+\n+        // This is used to tell the whole activity to shut down if it is restored from Activity restart.\n+        // Why? I am not really sure. Perhaps to avoid terrible bugs due to not implementing things correctly?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 180}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjkyMzE4OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjowNzo1MFrOGp5qRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxNTowODo0MlrOGp-GWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTUwOA==", "bodyText": "Could you mention the method which is problematic", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589508", "createdAt": "2020-06-28T02:07:50Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -91,16 +108,65 @@ private int getMaxImageSize() {\n         return (int) Math.min(height * 0.4, width * 0.6);\n     }\n \n-    // The NewApi deprecation should be removed with API21. UnsupportedChromeOsCameraSystemFeature can be fixed in API16\n-    @SuppressLint( {\"UnsupportedChromeOsCameraSystemFeature\", \"NewApi\"})\n+    public void loadInstanceState(Bundle savedInstanceState) {\n+        if (savedInstanceState == null) {\n+            Timber.d(\"loadInstanceState but null so nothing to load\");\n+            return;\n+        }\n+\n+        Timber.d(\"loadInstanceState loading saved state...\");\n+        mImagePath = savedInstanceState.getString(\"mImagePath\");\n+        mImageUri = savedInstanceState.getParcelable(\"mImageUri\");\n+        mPreviousImagePath = savedInstanceState.getString(\"mPreviousImagePath\");\n+        mPreviousImageUri = savedInstanceState.getParcelable(\"mPreviousImageUri\");\n+    }\n+\n+    public Bundle saveInstanceState() {\n+        Timber.d(\"saveInstanceState\");\n+        Bundle savedInstanceState = new Bundle();\n+        savedInstanceState.putString(\"mImagePath\", mImagePath);\n+        savedInstanceState.putParcelable(\"mImageUri\", mImageUri);\n+        savedInstanceState.putString(\"mPreviousImagePath\", mPreviousImagePath);\n+        savedInstanceState.putParcelable(\"mPreviousImageUri\", mPreviousImageUri);\n+        return savedInstanceState;\n+    }\n+\n+    // The NewApi deprecation should be removed with API21\n+    @SuppressLint(\"NewApi\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2MjIzMw==", "bodyText": "I will experiment with getting rid of it, previously the code directly accessed camera API v2 which would cause an Error throw + crash on API<=21 but I moved that into the Compat infrastructure on some previous pass (where it has a NewApi suppress also) and I don't think the suppress is needed here any longer.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446662233", "createdAt": "2020-06-28T15:08:42Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -91,16 +108,65 @@ private int getMaxImageSize() {\n         return (int) Math.min(height * 0.4, width * 0.6);\n     }\n \n-    // The NewApi deprecation should be removed with API21. UnsupportedChromeOsCameraSystemFeature can be fixed in API16\n-    @SuppressLint( {\"UnsupportedChromeOsCameraSystemFeature\", \"NewApi\"})\n+    public void loadInstanceState(Bundle savedInstanceState) {\n+        if (savedInstanceState == null) {\n+            Timber.d(\"loadInstanceState but null so nothing to load\");\n+            return;\n+        }\n+\n+        Timber.d(\"loadInstanceState loading saved state...\");\n+        mImagePath = savedInstanceState.getString(\"mImagePath\");\n+        mImageUri = savedInstanceState.getParcelable(\"mImageUri\");\n+        mPreviousImagePath = savedInstanceState.getString(\"mPreviousImagePath\");\n+        mPreviousImageUri = savedInstanceState.getParcelable(\"mPreviousImageUri\");\n+    }\n+\n+    public Bundle saveInstanceState() {\n+        Timber.d(\"saveInstanceState\");\n+        Bundle savedInstanceState = new Bundle();\n+        savedInstanceState.putString(\"mImagePath\", mImagePath);\n+        savedInstanceState.putParcelable(\"mImageUri\", mImageUri);\n+        savedInstanceState.putString(\"mPreviousImagePath\", mPreviousImagePath);\n+        savedInstanceState.putParcelable(\"mPreviousImageUri\", mPreviousImageUri);\n+        return savedInstanceState;\n+    }\n+\n+    // The NewApi deprecation should be removed with API21\n+    @SuppressLint(\"NewApi\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTUwOA=="}, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 106}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjkyNDE5OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/res/values/03-dialogs.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjowOTozNFrOGp5quQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxNDowMzo0OFrOGp9qcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTYyNQ==", "bodyText": "Is this automatically cased by the UI library?", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446589625", "createdAt": "2020-06-28T02:09:34Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/res/values/03-dialogs.xml", "diffHunk": "@@ -104,6 +104,7 @@\n \n     <string name=\"dialog_cancel\">Cancel</string>\n     <string name=\"dialog_ok\">OK</string>\n+    <string name=\"dialog_no\">No</string>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY1NTA4OA==", "bodyText": "No the UI library doesn't do any casing", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446655088", "createdAt": "2020-06-28T14:03:48Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/res/values/03-dialogs.xml", "diffHunk": "@@ -104,6 +104,7 @@\n \n     <string name=\"dialog_cancel\">Cancel</string>\n     <string name=\"dialog_ok\">OK</string>\n+    <string name=\"dialog_no\">No</string>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4OTYyNQ=="}, "originalCommit": {"oid": "408192ff445fa2f08a0019df11a2fa7cfd820eac"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjkzMjMyOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjoyNDozOVrOGp5ueQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxNToxMjowN1rOGp-H9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MDU4NQ==", "bodyText": "Use >= here. The pattern is to continually add 1 for different user-defined results.", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446590585", "createdAt": "2020-06-28T02:24:39Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -289,6 +289,11 @@ public void onActivityResult(int requestCode, int resultCode, Intent data) {\n                 default:\n                     break;\n             }\n+\n+            // Some apps send this back with app-specific data, direct the user to another app\n+            if (resultCode == Activity.RESULT_FIRST_USER) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1978f47b29bb15d74ba04bd944abfa743b1c0a61"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2MjY0Nw==", "bodyText": "Nice, thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446662647", "createdAt": "2020-06-28T15:12:07Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -289,6 +289,11 @@ public void onActivityResult(int requestCode, int resultCode, Intent data) {\n                 default:\n                     break;\n             }\n+\n+            // Some apps send this back with app-specific data, direct the user to another app\n+            if (resultCode == Activity.RESULT_FIRST_USER) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MDU4NQ=="}, "originalCommit": {"oid": "1978f47b29bb15d74ba04bd944abfa743b1c0a61"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjkzNjM3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjozMjoyMFrOGp5wYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxNToyNTo1NlrOGp-Njg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTA3NQ==", "bodyText": "(Optional): Might be worth turning the return value into a class. Each time I see the array access, I presume there's a potential indexing bug", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446591075", "createdAt": "2020-06-28T02:32:20Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -590,64 +646,76 @@ private Uri getUriForFile(File file) {\n             return null;\n         }\n         mImageUri = uri;\n-        mImagePath = getImagePathFromUri(context, uri);\n+        mImagePath = getImageInfoFromUri(context, uri)[0];\n         mField.setImagePath(mImagePath);\n         mField.setHasTemporaryMedia(false);\n         return mImageUri;\n     }\n \n \n-    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+    /**\n+     * Get image information based on uri and selection args\n+     *\n+     * @return string[] 0: file path (null if does not exist), 1: display name (null if does not exist)\n+     */\n+    private String[] getImageInfoFromUri(Context context, Uri uri) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8756fd41ee44b8572d81e1c85851ae9519047619"}, "originalPosition": 128}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2NDA3OA==", "bodyText": "I made it into a @NonNull Pair<String, String> where the strings are explicitly mentioned in javadoc as being potentially null but the Pair will always be non-null, so it's pretty easy to safely work with", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446664078", "createdAt": "2020-06-28T15:25:56Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -590,64 +646,76 @@ private Uri getUriForFile(File file) {\n             return null;\n         }\n         mImageUri = uri;\n-        mImagePath = getImagePathFromUri(context, uri);\n+        mImagePath = getImageInfoFromUri(context, uri)[0];\n         mField.setImagePath(mImagePath);\n         mField.setHasTemporaryMedia(false);\n         return mImageUri;\n     }\n \n \n-    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+    /**\n+     * Get image information based on uri and selection args\n+     *\n+     * @return string[] 0: file path (null if does not exist), 1: display name (null if does not exist)\n+     */\n+    private String[] getImageInfoFromUri(Context context, Uri uri) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTA3NQ=="}, "originalCommit": {"oid": "8756fd41ee44b8572d81e1c85851ae9519047619"}, "originalPosition": 128}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4MjkzNzA5OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQwMjozMzo1MlrOGp5wtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yOFQxNToyNjoyM1rOGp-Nyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTE1Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            imageInfo= getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n          \n          \n            \n                            imageInfo = getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446591157", "createdAt": "2020-06-28T02:33:52Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -590,64 +646,76 @@ private Uri getUriForFile(File file) {\n             return null;\n         }\n         mImageUri = uri;\n-        mImagePath = getImagePathFromUri(context, uri);\n+        mImagePath = getImageInfoFromUri(context, uri)[0];\n         mField.setImagePath(mImagePath);\n         mField.setHasTemporaryMedia(false);\n         return mImageUri;\n     }\n \n \n-    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+    /**\n+     * Get image information based on uri and selection args\n+     *\n+     * @return string[] 0: file path (null if does not exist), 1: display name (null if does not exist)\n+     */\n+    private String[] getImageInfoFromUri(Context context, Uri uri) {\n         Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n-        String imagePath = null;\n+        String[] imageInfo = { null, null };\n         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n             String docId = DocumentsContract.getDocumentId(uri);\n             if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n                 String id = docId.split(\":\")[1];\n                 String selection = MediaStore.Images.Media._ID + \"=\" + id;\n-                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+                imageInfo= getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8756fd41ee44b8572d81e1c85851ae9519047619"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjY2NDEzOA==", "bodyText": "Yep, there were some unused imports from codacy as well, cleaned those up", "url": "https://github.com/ankidroid/Anki-Android/pull/6543#discussion_r446664138", "createdAt": "2020-06-28T15:26:23Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java", "diffHunk": "@@ -590,64 +646,76 @@ private Uri getUriForFile(File file) {\n             return null;\n         }\n         mImageUri = uri;\n-        mImagePath = getImagePathFromUri(context, uri);\n+        mImagePath = getImageInfoFromUri(context, uri)[0];\n         mField.setImagePath(mImagePath);\n         mField.setHasTemporaryMedia(false);\n         return mImageUri;\n     }\n \n \n-    private @Nullable String getImagePathFromUri(Context context, Uri uri) {\n+    /**\n+     * Get image information based on uri and selection args\n+     *\n+     * @return string[] 0: file path (null if does not exist), 1: display name (null if does not exist)\n+     */\n+    private String[] getImageInfoFromUri(Context context, Uri uri) {\n         Timber.d(\"getImagePathFromUri() URI: %s\", uri);\n-        String imagePath = null;\n+        String[] imageInfo = { null, null };\n         if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT && DocumentsContract.isDocumentUri(context, uri)) {\n             String docId = DocumentsContract.getDocumentId(uri);\n             if (\"com.android.providers.media.documents\".equals(uri.getAuthority())) {\n                 String id = docId.split(\":\")[1];\n                 String selection = MediaStore.Images.Media._ID + \"=\" + id;\n-                imagePath = getImagePathFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);\n+                imageInfo= getImageInfoFromContentResolver(context, MediaStore.Images.Media.EXTERNAL_CONTENT_URI, selection);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU5MTE1Nw=="}, "originalCommit": {"oid": "8756fd41ee44b8572d81e1c85851ae9519047619"}, "originalPosition": 138}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 23, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}