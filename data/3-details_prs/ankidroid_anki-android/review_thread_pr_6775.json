{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU5MDk0MDEw", "number": 6775, "reviewThreads": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozNDo0OFrOEV4Z9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo1ODoyOFrOEXZW6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzc5NzAxOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozNDo0OFrOG848iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNzowNTo1NlrOG88aJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMDc0NA==", "bodyText": "This could be a functional change - as we change the result code.\nNot sure how to handle it", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466500744", "createdAt": "2020-08-06T15:34:48Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MDkwOA==", "bodyText": "I don't understand. If the code is not executed, it means the viewer is closed, so closing it makes no sens in the first place. What is the point of cosing with a DB_error something already closed ?", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466540908", "createdAt": "2020-08-06T16:37:24Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMDc0NA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1NzQ3OQ==", "bodyText": "This may be overthinking, as the outcome is so unlikely and inconsequential. DB_ERROR isn't too necessary, RESULT_NO_MORE_CARDS had slight properties in changing UI text.\nI'm resolving this as I don't feel we need to do anything here. I've had a look through the code, and I agree. it would be nice to signal to the caller that we have no cards (without using RESULT_CODE), but it doesn't matter.", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466557479", "createdAt": "2020-08-06T17:05:56Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMDc0NA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgwMDY2OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozNToyOFrOG84-tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxOToxOTowNVrOG9A_-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMTMwMQ==", "bodyText": "This will likely be a functional change", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466501301", "createdAt": "2020-08-06T15:35:28Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n                 return;\n             }\n             if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n+                viewer.closeReviewer(RESULT_NO_MORE_CARDS, true);\n             }\n         }\n     };\n \n-    abstract class NextCardHandler extends CollectionTask.TaskListener {\n+    protected abstract static class NextCardHandler<T extends AbstractFlashcardViewer> extends TaskListenerWithContext<T>{\n         private boolean mNoMoreCards;\n \n+        public NextCardHandler(T viewer) {\n+            super(viewer);\n+        }\n \n         @Override\n-        public void onPreExecute() { /* do nothing */}\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) { /* do nothing */}\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            displayNext(value.getCard());\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n+            displayNext(viewer, value.getCard());\n         }\n \n-        protected void displayNext(Card nextCard) {\n+        protected void displayNext(AbstractFlashcardViewer viewer, Card nextCard) {\n \n-            Resources res = getResources();\n+            Resources res = viewer.getResources();\n \n-            if (mSched == null) {\n+            if (viewer.mSched == null) {\n                 // TODO: proper testing for restored activity\n-                finishWithoutAnimation();\n+                viewer.finishWithoutAnimation();\n                 return;\n             }\n \n-            mCurrentCard = nextCard;\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = nextCard;\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true; // other handlers use this, toggle state every time through\n             } else {\n                 mNoMoreCards = false; // other handlers use this, toggle state every time through\n                 // Start reviewing next card\n-                updateTypeAnswerInfo();\n-                hideProgressBar();\n-                AbstractFlashcardViewer.this.unblockControls();\n-                AbstractFlashcardViewer.this.displayCardQuestion();\n+                viewer.updateTypeAnswerInfo();\n+                viewer.hideProgressBar();\n+                viewer.unblockControls();\n+                viewer.displayCardQuestion();\n             }\n \n             // Since reps are incremented on fetch of next card, we will miss counting the\n             // last rep since there isn't a next card. We manually account for it here.\n             if (mNoMoreCards) {\n-                mSched.setReps(mSched.getReps() + 1);\n+                viewer.mSched.setReps(viewer.mSched.getReps() + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzNzY2MA==", "bodyText": "Oh right. I didn't realize that it was doing this change to the scheduler and not to the counts shown to the user.\nIt's possible to just uses a normal listener here and deal with this case manually.", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466537660", "createdAt": "2020-08-06T16:31:50Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n                 return;\n             }\n             if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n+                viewer.closeReviewer(RESULT_NO_MORE_CARDS, true);\n             }\n         }\n     };\n \n-    abstract class NextCardHandler extends CollectionTask.TaskListener {\n+    protected abstract static class NextCardHandler<T extends AbstractFlashcardViewer> extends TaskListenerWithContext<T>{\n         private boolean mNoMoreCards;\n \n+        public NextCardHandler(T viewer) {\n+            super(viewer);\n+        }\n \n         @Override\n-        public void onPreExecute() { /* do nothing */}\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) { /* do nothing */}\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            displayNext(value.getCard());\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n+            displayNext(viewer, value.getCard());\n         }\n \n-        protected void displayNext(Card nextCard) {\n+        protected void displayNext(AbstractFlashcardViewer viewer, Card nextCard) {\n \n-            Resources res = getResources();\n+            Resources res = viewer.getResources();\n \n-            if (mSched == null) {\n+            if (viewer.mSched == null) {\n                 // TODO: proper testing for restored activity\n-                finishWithoutAnimation();\n+                viewer.finishWithoutAnimation();\n                 return;\n             }\n \n-            mCurrentCard = nextCard;\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = nextCard;\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true; // other handlers use this, toggle state every time through\n             } else {\n                 mNoMoreCards = false; // other handlers use this, toggle state every time through\n                 // Start reviewing next card\n-                updateTypeAnswerInfo();\n-                hideProgressBar();\n-                AbstractFlashcardViewer.this.unblockControls();\n-                AbstractFlashcardViewer.this.displayCardQuestion();\n+                viewer.updateTypeAnswerInfo();\n+                viewer.hideProgressBar();\n+                viewer.unblockControls();\n+                viewer.displayCardQuestion();\n             }\n \n             // Since reps are incremented on fetch of next card, we will miss counting the\n             // last rep since there isn't a next card. We manually account for it here.\n             if (mNoMoreCards) {\n-                mSched.setReps(mSched.getReps() + 1);\n+                viewer.mSched.setReps(viewer.mSched.getReps() + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMTMwMQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzOTAyMg==", "bodyText": "I could also just state that this change should be done in background, catch earlier whether the card returned is null, and increase in this case. After all, there is no reason to do this change in the listener and checking whether the card is null is easy to do", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466539022", "createdAt": "2020-08-06T16:34:17Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n                 return;\n             }\n             if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n+                viewer.closeReviewer(RESULT_NO_MORE_CARDS, true);\n             }\n         }\n     };\n \n-    abstract class NextCardHandler extends CollectionTask.TaskListener {\n+    protected abstract static class NextCardHandler<T extends AbstractFlashcardViewer> extends TaskListenerWithContext<T>{\n         private boolean mNoMoreCards;\n \n+        public NextCardHandler(T viewer) {\n+            super(viewer);\n+        }\n \n         @Override\n-        public void onPreExecute() { /* do nothing */}\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) { /* do nothing */}\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            displayNext(value.getCard());\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n+            displayNext(viewer, value.getCard());\n         }\n \n-        protected void displayNext(Card nextCard) {\n+        protected void displayNext(AbstractFlashcardViewer viewer, Card nextCard) {\n \n-            Resources res = getResources();\n+            Resources res = viewer.getResources();\n \n-            if (mSched == null) {\n+            if (viewer.mSched == null) {\n                 // TODO: proper testing for restored activity\n-                finishWithoutAnimation();\n+                viewer.finishWithoutAnimation();\n                 return;\n             }\n \n-            mCurrentCard = nextCard;\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = nextCard;\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true; // other handlers use this, toggle state every time through\n             } else {\n                 mNoMoreCards = false; // other handlers use this, toggle state every time through\n                 // Start reviewing next card\n-                updateTypeAnswerInfo();\n-                hideProgressBar();\n-                AbstractFlashcardViewer.this.unblockControls();\n-                AbstractFlashcardViewer.this.displayCardQuestion();\n+                viewer.updateTypeAnswerInfo();\n+                viewer.hideProgressBar();\n+                viewer.unblockControls();\n+                viewer.displayCardQuestion();\n             }\n \n             // Since reps are incremented on fetch of next card, we will miss counting the\n             // last rep since there isn't a next card. We manually account for it here.\n             if (mNoMoreCards) {\n-                mSched.setReps(mSched.getReps() + 1);\n+                viewer.mSched.setReps(viewer.mSched.getReps() + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMTMwMQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1MTM1OA==", "bodyText": "Might be easier to do this in a separate PR and keep this one with 'clean' changes converting the listeners", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466551358", "createdAt": "2020-08-06T16:55:06Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n                 return;\n             }\n             if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n+                viewer.closeReviewer(RESULT_NO_MORE_CARDS, true);\n             }\n         }\n     };\n \n-    abstract class NextCardHandler extends CollectionTask.TaskListener {\n+    protected abstract static class NextCardHandler<T extends AbstractFlashcardViewer> extends TaskListenerWithContext<T>{\n         private boolean mNoMoreCards;\n \n+        public NextCardHandler(T viewer) {\n+            super(viewer);\n+        }\n \n         @Override\n-        public void onPreExecute() { /* do nothing */}\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) { /* do nothing */}\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            displayNext(value.getCard());\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n+            displayNext(viewer, value.getCard());\n         }\n \n-        protected void displayNext(Card nextCard) {\n+        protected void displayNext(AbstractFlashcardViewer viewer, Card nextCard) {\n \n-            Resources res = getResources();\n+            Resources res = viewer.getResources();\n \n-            if (mSched == null) {\n+            if (viewer.mSched == null) {\n                 // TODO: proper testing for restored activity\n-                finishWithoutAnimation();\n+                viewer.finishWithoutAnimation();\n                 return;\n             }\n \n-            mCurrentCard = nextCard;\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = nextCard;\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true; // other handlers use this, toggle state every time through\n             } else {\n                 mNoMoreCards = false; // other handlers use this, toggle state every time through\n                 // Start reviewing next card\n-                updateTypeAnswerInfo();\n-                hideProgressBar();\n-                AbstractFlashcardViewer.this.unblockControls();\n-                AbstractFlashcardViewer.this.displayCardQuestion();\n+                viewer.updateTypeAnswerInfo();\n+                viewer.hideProgressBar();\n+                viewer.unblockControls();\n+                viewer.displayCardQuestion();\n             }\n \n             // Since reps are incremented on fetch of next card, we will miss counting the\n             // last rep since there isn't a next card. We manually account for it here.\n             if (mNoMoreCards) {\n-                mSched.setReps(mSched.getReps() + 1);\n+                viewer.mSched.setReps(viewer.mSched.getReps() + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMTMwMQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYyMTgxOA==", "bodyText": "Actually, this listener is used with plenty of different task. So no easy way to just do it in background unless we decide that getCard always increment, even when returning null. This would really makes sens, because either we are using getCard from the reviewer, in which cards mReps matter. Or we are using it elsewhere, and mReps is never ever read", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466621818", "createdAt": "2020-08-06T18:58:14Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n                 return;\n             }\n             if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n+                viewer.closeReviewer(RESULT_NO_MORE_CARDS, true);\n             }\n         }\n     };\n \n-    abstract class NextCardHandler extends CollectionTask.TaskListener {\n+    protected abstract static class NextCardHandler<T extends AbstractFlashcardViewer> extends TaskListenerWithContext<T>{\n         private boolean mNoMoreCards;\n \n+        public NextCardHandler(T viewer) {\n+            super(viewer);\n+        }\n \n         @Override\n-        public void onPreExecute() { /* do nothing */}\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) { /* do nothing */}\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            displayNext(value.getCard());\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n+            displayNext(viewer, value.getCard());\n         }\n \n-        protected void displayNext(Card nextCard) {\n+        protected void displayNext(AbstractFlashcardViewer viewer, Card nextCard) {\n \n-            Resources res = getResources();\n+            Resources res = viewer.getResources();\n \n-            if (mSched == null) {\n+            if (viewer.mSched == null) {\n                 // TODO: proper testing for restored activity\n-                finishWithoutAnimation();\n+                viewer.finishWithoutAnimation();\n                 return;\n             }\n \n-            mCurrentCard = nextCard;\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = nextCard;\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true; // other handlers use this, toggle state every time through\n             } else {\n                 mNoMoreCards = false; // other handlers use this, toggle state every time through\n                 // Start reviewing next card\n-                updateTypeAnswerInfo();\n-                hideProgressBar();\n-                AbstractFlashcardViewer.this.unblockControls();\n-                AbstractFlashcardViewer.this.displayCardQuestion();\n+                viewer.updateTypeAnswerInfo();\n+                viewer.hideProgressBar();\n+                viewer.unblockControls();\n+                viewer.displayCardQuestion();\n             }\n \n             // Since reps are incremented on fetch of next card, we will miss counting the\n             // last rep since there isn't a next card. We manually account for it here.\n             if (mNoMoreCards) {\n-                mSched.setReps(mSched.getReps() + 1);\n+                viewer.mSched.setReps(viewer.mSched.getReps() + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMTMwMQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjYzMjY5Nw==", "bodyText": "On third thought: the actual value used is :\nthe diference between mReps when reviewer is opened, and when the timebox ends. If the reviewer get closed, then we can ignore this value anyway.", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466632697", "createdAt": "2020-08-06T19:19:05Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/AbstractFlashcardViewer.java", "diffHunk": "@@ -501,157 +503,174 @@ void processCardAction(Consumer<WebView> cardConsumer) {\n     }\n \n \n-    protected final CollectionTask.TaskListener mDismissCardHandler = new NextCardHandler() { /* superclass is sufficient */ };\n+    protected final TaskListener mDismissCardHandler = new NextCardHandler(this) { /* superclass is sufficient */ };\n \n-\n-    private final CollectionTask.TaskListener mUpdateCardHandler = new CollectionTask.TaskListener() {\n+    // Need a function, because each listener has its mNoMoreCards\n+    private UpdateCardHandler updateCardHandler() {\n+        return new UpdateCardHandler(this);\n+    }\n+    /** This listener does not leak the Activity. If the activity is destroyed, the background action occurs but no UI action.*/\n+    private static class UpdateCardHandler extends TaskListenerWithContext<AbstractFlashcardViewer> {\n         private boolean mNoMoreCards;\n+        public UpdateCardHandler(AbstractFlashcardViewer viewer) {\n+            super(viewer);\n+        }\n \n \n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) {\n+            viewer.showProgressBar();\n         }\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n             boolean cardChanged = false;\n-            if (mCurrentCard != value.getCard()) {\n+            if (viewer.mCurrentCard != value.getCard()) {\n                 /*\n                  * Before updating mCurrentCard, we check whether it is changing or not. If the current card changes,\n                  * then we need to display it as a new card, without showing the answer.\n                  */\n                 sDisplayAnswer = false;\n                 cardChanged = true;  // Keep track of that so we can run a bit of new-card code\n             }\n-            mCurrentCard = value.getCard();\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = value.getCard();\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true;\n-                showProgressBar();\n+                viewer.showProgressBar();\n                 return;\n             }\n-            if (mPrefWhiteboard && mWhiteboard != null) {\n-                mWhiteboard.clear();\n+            if (viewer.mPrefWhiteboard && viewer.mWhiteboard != null) {\n+                viewer.mWhiteboard.clear();\n             }\n \n             if (sDisplayAnswer) {\n-                mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n-                mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n-                generateQuestionSoundList(); // questions must be intentionally regenerated\n-                displayCardAnswer();\n+                viewer.mSoundPlayer.resetSounds(); // load sounds from scratch, to expose any edit changes\n+                viewer.mAnswerSoundsAdded = false; // causes answer sounds to be reloaded\n+                viewer.generateQuestionSoundList(); // questions must be intentionally regenerated\n+                viewer.displayCardAnswer();\n             } else {\n                 if (cardChanged) {\n-                    updateTypeAnswerInfo();\n+                    viewer.updateTypeAnswerInfo();\n                 }\n-                displayCardQuestion();\n-                mCurrentCard.startTimer();\n-                initTimer();\n+                viewer.displayCardQuestion();\n+                viewer.mCurrentCard.startTimer();\n+                viewer.initTimer();\n             }\n-            hideProgressBar();\n+            viewer.hideProgressBar();\n         }\n \n \n         @Override\n-        public void onPostExecute(TaskData result) {\n+        public void actualOnPostExecute(@NonNull AbstractFlashcardViewer viewer, TaskData result) {\n             if (!result.getBoolean()) {\n                 // RuntimeException occurred on update cards\n-                closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n+                viewer.closeReviewer(DeckPicker.RESULT_DB_ERROR, false);\n                 return;\n             }\n             if (mNoMoreCards) {\n-                closeReviewer(RESULT_NO_MORE_CARDS, true);\n+                viewer.closeReviewer(RESULT_NO_MORE_CARDS, true);\n             }\n         }\n     };\n \n-    abstract class NextCardHandler extends CollectionTask.TaskListener {\n+    protected abstract static class NextCardHandler<T extends AbstractFlashcardViewer> extends TaskListenerWithContext<T>{\n         private boolean mNoMoreCards;\n \n+        public NextCardHandler(T viewer) {\n+            super(viewer);\n+        }\n \n         @Override\n-        public void onPreExecute() { /* do nothing */}\n+        public void actualOnPreExecute(@NonNull AbstractFlashcardViewer viewer) { /* do nothing */}\n \n \n         @Override\n-        public void onProgressUpdate(TaskData value) {\n-            displayNext(value.getCard());\n+        public void actualOnProgressUpdate(@NonNull AbstractFlashcardViewer viewer, TaskData value) {\n+            displayNext(viewer, value.getCard());\n         }\n \n-        protected void displayNext(Card nextCard) {\n+        protected void displayNext(AbstractFlashcardViewer viewer, Card nextCard) {\n \n-            Resources res = getResources();\n+            Resources res = viewer.getResources();\n \n-            if (mSched == null) {\n+            if (viewer.mSched == null) {\n                 // TODO: proper testing for restored activity\n-                finishWithoutAnimation();\n+                viewer.finishWithoutAnimation();\n                 return;\n             }\n \n-            mCurrentCard = nextCard;\n-            if (mCurrentCard == null) {\n+            viewer.mCurrentCard = nextCard;\n+            if (viewer.mCurrentCard == null) {\n                 // If the card is null means that there are no more cards scheduled for review.\n                 mNoMoreCards = true; // other handlers use this, toggle state every time through\n             } else {\n                 mNoMoreCards = false; // other handlers use this, toggle state every time through\n                 // Start reviewing next card\n-                updateTypeAnswerInfo();\n-                hideProgressBar();\n-                AbstractFlashcardViewer.this.unblockControls();\n-                AbstractFlashcardViewer.this.displayCardQuestion();\n+                viewer.updateTypeAnswerInfo();\n+                viewer.hideProgressBar();\n+                viewer.unblockControls();\n+                viewer.displayCardQuestion();\n             }\n \n             // Since reps are incremented on fetch of next card, we will miss counting the\n             // last rep since there isn't a next card. We manually account for it here.\n             if (mNoMoreCards) {\n-                mSched.setReps(mSched.getReps() + 1);\n+                viewer.mSched.setReps(viewer.mSched.getReps() + 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMTMwMQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgxMDc2OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTozNzo0NVrOG85FDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjo1ODowOVrOG88JOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMjkyNA==", "bodyText": "Confirm that this can still be undone in the Deck Picker - should be fine", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466502924", "createdAt": "2020-08-06T15:37:45Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1610,68 +1646,95 @@ private void removeNotesView(java.util.Collection<Long> cardsIds, boolean reorde\n         updateList();\n     }\n \n-    private CollectionTask.TaskListener mSuspendCardHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private SuspendCardHandler mSuspendCardHandler = new SuspendCardHandler(this);\n+    private static class SuspendCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public SuspendCardHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n             Card[] cards = (Card[]) result.getObjArray();\n-            updateCardsInList(Arrays.asList(cards), null);\n-            hideProgressBar();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.updateCardsInList(Arrays.asList(cards), null);\n+            browser.hideProgressBar();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n         }\n     };\n-    private CollectionTask.TaskListener mFlagCardHandler = mSuspendCardHandler;\n \n-    private CollectionTask.TaskListener mMarkCardHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private final FlagCardHandler mFlagCardHandler = new FlagCardHandler(this);\n+    private static class FlagCardHandler extends SuspendCardHandler{public FlagCardHandler(CardBrowser browser) {super(browser);}};\n+\n+    private MarkCardHandler mMarkCardHandler = new MarkCardHandler(this);\n+    private static class MarkCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public MarkCardHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n             Card[] cards = (Card[]) result.getObjArray();\n-            updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards))), null);\n-            hideProgressBar();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards))), null);\n+            browser.hideProgressBar();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n         }\n     };\n \n-    private CollectionTask.TaskListener mDeleteNoteHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private DeleteNoteHandler mDeleteNoteHandler = new DeleteNoteHandler(this);\n+    private static class DeleteNoteHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public DeleteNoteHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull CardBrowser browser, TaskData value) {\n             Card[] cards = (Card[]) value.getObjArray();\n             //we don't need to reorder cards here as we've already deselected all notes,\n-            removeNotesView(cards, false);\n+            browser.removeNotesView(cards, false);\n         }\n \n \n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n-            mActionBarTitle.setText(Integer.toString(mCheckedCardPositions.size()));\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n+            browser.mActionBarTitle.setText(Integer.toString(browser.mCheckedCardPositions.size()));\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n             // snackbar to offer undo\n-            mUndoSnackbar = UIUtils.showSnackbar(CardBrowser.this, getString(R.string.deleted_message), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, browser.getString(R.string.deleted_message), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n                 @Override\n                 public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, mUndoHandler);\n+                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0MTg1NA==", "bodyText": "This change means that the undo option is not shown to a non-existing screen. Since it was not adding anythingi n the list of undo, it does not forbid to undo the normal way.", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466541854", "createdAt": "2020-08-06T16:39:06Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1610,68 +1646,95 @@ private void removeNotesView(java.util.Collection<Long> cardsIds, boolean reorde\n         updateList();\n     }\n \n-    private CollectionTask.TaskListener mSuspendCardHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private SuspendCardHandler mSuspendCardHandler = new SuspendCardHandler(this);\n+    private static class SuspendCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public SuspendCardHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n             Card[] cards = (Card[]) result.getObjArray();\n-            updateCardsInList(Arrays.asList(cards), null);\n-            hideProgressBar();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.updateCardsInList(Arrays.asList(cards), null);\n+            browser.hideProgressBar();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n         }\n     };\n-    private CollectionTask.TaskListener mFlagCardHandler = mSuspendCardHandler;\n \n-    private CollectionTask.TaskListener mMarkCardHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private final FlagCardHandler mFlagCardHandler = new FlagCardHandler(this);\n+    private static class FlagCardHandler extends SuspendCardHandler{public FlagCardHandler(CardBrowser browser) {super(browser);}};\n+\n+    private MarkCardHandler mMarkCardHandler = new MarkCardHandler(this);\n+    private static class MarkCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public MarkCardHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n             Card[] cards = (Card[]) result.getObjArray();\n-            updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards))), null);\n-            hideProgressBar();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards))), null);\n+            browser.hideProgressBar();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n         }\n     };\n \n-    private CollectionTask.TaskListener mDeleteNoteHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private DeleteNoteHandler mDeleteNoteHandler = new DeleteNoteHandler(this);\n+    private static class DeleteNoteHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public DeleteNoteHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull CardBrowser browser, TaskData value) {\n             Card[] cards = (Card[]) value.getObjArray();\n             //we don't need to reorder cards here as we've already deselected all notes,\n-            removeNotesView(cards, false);\n+            browser.removeNotesView(cards, false);\n         }\n \n \n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n-            mActionBarTitle.setText(Integer.toString(mCheckedCardPositions.size()));\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n+            browser.mActionBarTitle.setText(Integer.toString(browser.mCheckedCardPositions.size()));\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n             // snackbar to offer undo\n-            mUndoSnackbar = UIUtils.showSnackbar(CardBrowser.this, getString(R.string.deleted_message), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, browser.getString(R.string.deleted_message), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n                 @Override\n                 public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, mUndoHandler);\n+                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMjkyNA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 320}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1MzE0NA==", "bodyText": "Agreed - as long as there's a way for the operation to be undone in the Deck Picker, it's good.", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466553144", "createdAt": "2020-08-06T16:58:09Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1610,68 +1646,95 @@ private void removeNotesView(java.util.Collection<Long> cardsIds, boolean reorde\n         updateList();\n     }\n \n-    private CollectionTask.TaskListener mSuspendCardHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private SuspendCardHandler mSuspendCardHandler = new SuspendCardHandler(this);\n+    private static class SuspendCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public SuspendCardHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n             Card[] cards = (Card[]) result.getObjArray();\n-            updateCardsInList(Arrays.asList(cards), null);\n-            hideProgressBar();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.updateCardsInList(Arrays.asList(cards), null);\n+            browser.hideProgressBar();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n         }\n     };\n-    private CollectionTask.TaskListener mFlagCardHandler = mSuspendCardHandler;\n \n-    private CollectionTask.TaskListener mMarkCardHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private final FlagCardHandler mFlagCardHandler = new FlagCardHandler(this);\n+    private static class FlagCardHandler extends SuspendCardHandler{public FlagCardHandler(CardBrowser browser) {super(browser);}};\n+\n+    private MarkCardHandler mMarkCardHandler = new MarkCardHandler(this);\n+    private static class MarkCardHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public MarkCardHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        protected void actualPostExecute(TaskData result) {\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n             Card[] cards = (Card[]) result.getObjArray();\n-            updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards))), null);\n-            hideProgressBar();\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+            browser.updateCardsInList(CardUtils.getAllCards(CardUtils.getNotes(Arrays.asList(cards))), null);\n+            browser.hideProgressBar();\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n         }\n     };\n \n-    private CollectionTask.TaskListener mDeleteNoteHandler = new ListenerWithProgressBarCloseOnFalse() {\n+    private DeleteNoteHandler mDeleteNoteHandler = new DeleteNoteHandler(this);\n+    private static class DeleteNoteHandler extends ListenerWithProgressBarCloseOnFalse {\n+        public DeleteNoteHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        public void onProgressUpdate(TaskData value) {\n+        public void actualOnProgressUpdate(@NonNull CardBrowser browser, TaskData value) {\n             Card[] cards = (Card[]) value.getObjArray();\n             //we don't need to reorder cards here as we've already deselected all notes,\n-            removeNotesView(cards, false);\n+            browser.removeNotesView(cards, false);\n         }\n \n \n         @Override\n-        protected void actualPostExecute(TaskData result) {\n-            hideProgressBar();\n-            mActionBarTitle.setText(Integer.toString(mCheckedCardPositions.size()));\n-            invalidateOptionsMenu();    // maybe the availability of undo changed\n+        protected void actualActualOnPostExecute(CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n+            browser.mActionBarTitle.setText(Integer.toString(browser.mCheckedCardPositions.size()));\n+            browser.invalidateOptionsMenu();    // maybe the availability of undo changed\n             // snackbar to offer undo\n-            mUndoSnackbar = UIUtils.showSnackbar(CardBrowser.this, getString(R.string.deleted_message), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n+            browser.mUndoSnackbar = UIUtils.showSnackbar(browser, browser.getString(R.string.deleted_message), SNACKBAR_DURATION, R.string.undo, new View.OnClickListener() {\n                 @Override\n                 public void onClick(View v) {\n-                    CollectionTask.launchCollectionTask(UNDO, mUndoHandler);\n+                    CollectionTask.launchCollectionTask(UNDO, browser.mUndoHandler);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwMjkyNA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 320}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzgzMjU2OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckOptions.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo0MjozMFrOG85SgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjo0MzoyMlrOG87nlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNjM2OQ==", "bodyText": "cacheValues seems like IO - might just be local", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466506369", "createdAt": "2020-08-06T15:42:30Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckOptions.java", "diffHunk": "@@ -625,6 +617,29 @@ public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeL\n \n     }\n \n+    private static class ConfChangeHandler extends TaskListenerWithContext<DeckPreferenceHack.Editor> {\n+        public ConfChangeHandler(DeckPreferenceHack.Editor editor) {\n+            super(editor);\n+        }\n+\n+        @Override\n+        public void actualOnPreExecute(@NonNull DeckPreferenceHack.Editor editor) {\n+            Resources res = editor.getDeckPreferenceHack().getDeckOptions().getResources();\n+            editor.getDeckPreferenceHack().mProgressDialog = StyledProgressDialog.show(editor.getDeckPreferenceHack().getDeckOptions(), \"\",\n+                    res.getString(R.string.reordering_cards), false);\n+        }\n+\n+\n+        @Override\n+        public void actualOnPostExecute(@NonNull DeckPreferenceHack.Editor editor, TaskData result) {\n+            editor.getDeckPreferenceHack().cacheValues();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0NDUzMw==", "bodyText": "Nice catch. I should have used DeckPreferenceHack as context. We never need access to the actual Editor class", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466544533", "createdAt": "2020-08-06T16:43:22Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckOptions.java", "diffHunk": "@@ -625,6 +617,29 @@ public void unregisterOnSharedPreferenceChangeListener(OnSharedPreferenceChangeL\n \n     }\n \n+    private static class ConfChangeHandler extends TaskListenerWithContext<DeckPreferenceHack.Editor> {\n+        public ConfChangeHandler(DeckPreferenceHack.Editor editor) {\n+            super(editor);\n+        }\n+\n+        @Override\n+        public void actualOnPreExecute(@NonNull DeckPreferenceHack.Editor editor) {\n+            Resources res = editor.getDeckPreferenceHack().getDeckOptions().getResources();\n+            editor.getDeckPreferenceHack().mProgressDialog = StyledProgressDialog.show(editor.getDeckPreferenceHack().getDeckOptions(), \"\",\n+                    res.getString(R.string.reordering_cards), false);\n+        }\n+\n+\n+        @Override\n+        public void actualOnPostExecute(@NonNull DeckPreferenceHack.Editor editor, TaskData result) {\n+            editor.getDeckPreferenceHack().cacheValues();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwNjM2OQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzg0ODgzOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo0NjoxNVrOG85cuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjo0ODo1OFrOG87z6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwODk4NQ==", "bodyText": "This is an interesting one - might be problematic as it's such a long-running operation. Are we stopping onDestroy() currently with the AsyncTask?", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466508985", "createdAt": "2020-08-06T15:46:15Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -1463,34 +1499,40 @@ public void integrityCheck() {\n \n     private void performIntegrityCheck() {\n         Timber.i(\"performIntegrityCheck()\");\n-        CollectionTask.launchCollectionTask(CHECK_DATABASE, new CheckDatabaseListener());\n+        CollectionTask.launchCollectionTask(CHECK_DATABASE, mCheckDatabaseListener);\n     }\n \n \n-    @Override\n-    public void mediaCheck() {\n-        CollectionTask.TaskListener listener = new CollectionTask.TaskListener() {\n-            @Override\n-            public void onPreExecute() {\n-                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, \"\",\n-                        getResources().getString(R.string.check_media_message), false);\n-            }\n+    private final MediaCheckListener mMediaCheckListener = new MediaCheckListener(this);\n+    private static class MediaCheckListener extends TaskListenerWithContext<DeckPicker>{\n+        public MediaCheckListener (DeckPicker deckPicker) {\n+            super(deckPicker);\n+        }\n \n+        @Override\n+        public void actualOnPreExecute(@NonNull DeckPicker deckPicker) {\n+            deckPicker.mProgressDialog = StyledProgressDialog.show(deckPicker, \"\",\n+                    deckPicker.getResources().getString(R.string.check_media_message), false);\n+        }\n \n-            @Override\n-            public void onPostExecute(TaskData result) {\n-                if (mProgressDialog != null && mProgressDialog.isShowing()) {\n-                    mProgressDialog.dismiss();\n-                }\n-                if (result != null && result.getBoolean()) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    List<List<String>> checkList = (List<List<String>>) result.getObjArray()[0];\n-                    showMediaCheckDialog(MediaCheckDialog.DIALOG_MEDIA_CHECK_RESULTS, checkList);\n-                } else {\n-                    showSimpleMessageDialog(getResources().getString(R.string.check_media_failed));\n-                }\n+\n+        @Override\n+        public void actualOnPostExecute(@NonNull DeckPicker deckPicker, TaskData result) {\n+            if (deckPicker.mProgressDialog != null && deckPicker.mProgressDialog.isShowing()) {\n+                deckPicker.mProgressDialog.dismiss();\n+            }\n+            if (result != null && result.getBoolean()) {\n+                @SuppressWarnings(\"unchecked\")\n+                List<List<String>> checkList = (List<List<String>>) result.getObjArray()[0];\n+                deckPicker.showMediaCheckDialog(MediaCheckDialog.DIALOG_MEDIA_CHECK_RESULTS, checkList);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 348}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0NzY4OQ==", "bodyText": "No idea what current occurs in practice.  I don't expect it to make any difference with this PR. Afterall, if the deckpicker is not shown on screen, whether we show the check dialog or not on the non-existing screen does not matter", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466547689", "createdAt": "2020-08-06T16:48:58Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -1463,34 +1499,40 @@ public void integrityCheck() {\n \n     private void performIntegrityCheck() {\n         Timber.i(\"performIntegrityCheck()\");\n-        CollectionTask.launchCollectionTask(CHECK_DATABASE, new CheckDatabaseListener());\n+        CollectionTask.launchCollectionTask(CHECK_DATABASE, mCheckDatabaseListener);\n     }\n \n \n-    @Override\n-    public void mediaCheck() {\n-        CollectionTask.TaskListener listener = new CollectionTask.TaskListener() {\n-            @Override\n-            public void onPreExecute() {\n-                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, \"\",\n-                        getResources().getString(R.string.check_media_message), false);\n-            }\n+    private final MediaCheckListener mMediaCheckListener = new MediaCheckListener(this);\n+    private static class MediaCheckListener extends TaskListenerWithContext<DeckPicker>{\n+        public MediaCheckListener (DeckPicker deckPicker) {\n+            super(deckPicker);\n+        }\n \n+        @Override\n+        public void actualOnPreExecute(@NonNull DeckPicker deckPicker) {\n+            deckPicker.mProgressDialog = StyledProgressDialog.show(deckPicker, \"\",\n+                    deckPicker.getResources().getString(R.string.check_media_message), false);\n+        }\n \n-            @Override\n-            public void onPostExecute(TaskData result) {\n-                if (mProgressDialog != null && mProgressDialog.isShowing()) {\n-                    mProgressDialog.dismiss();\n-                }\n-                if (result != null && result.getBoolean()) {\n-                    @SuppressWarnings(\"unchecked\")\n-                    List<List<String>> checkList = (List<List<String>>) result.getObjArray()[0];\n-                    showMediaCheckDialog(MediaCheckDialog.DIALOG_MEDIA_CHECK_RESULTS, checkList);\n-                } else {\n-                    showSimpleMessageDialog(getResources().getString(R.string.check_media_failed));\n-                }\n+\n+        @Override\n+        public void actualOnPostExecute(@NonNull DeckPicker deckPicker, TaskData result) {\n+            if (deckPicker.mProgressDialog != null && deckPicker.mProgressDialog.isShowing()) {\n+                deckPicker.mProgressDialog.dismiss();\n+            }\n+            if (result != null && result.getBoolean()) {\n+                @SuppressWarnings(\"unchecked\")\n+                List<List<String>> checkList = (List<List<String>>) result.getObjArray()[0];\n+                deckPicker.showMediaCheckDialog(MediaCheckDialog.DIALOG_MEDIA_CHECK_RESULTS, checkList);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwODk4NQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 348}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzg1NDk1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo0Nzo0M1rOG85gmQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoyMDoxM1rOG-_c8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwOTk3Nw==", "bodyText": "Non-UI-specific change", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466509977", "createdAt": "2020-08-06T15:47:43Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2383,63 +2431,78 @@ public void deleteContextMenuDeck() {\n         deleteDeck(mContextMenuDid);\n     }\n     public void deleteDeck(final long did) {\n-        CollectionTask.TaskListener listener = new CollectionTask.TaskListener() {\n-            // Flag to indicate if the deck being deleted is the current deck.\n-            private boolean removingCurrent;\n-\n-            @Override\n-            public void onPreExecute() {\n-                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, \"\",\n-                        getResources().getString(R.string.delete_deck), false);\n-                if (did == getCol().getDecks().current().optLong(\"id\")) {\n-                    removingCurrent = true;\n-                }\n+        TaskListener listener = deleteDeckListener(did);\n+        CollectionTask.launchCollectionTask(DELETE_DECK, listener, new TaskData(did));\n+    }\n+    private DeleteDeckListener deleteDeckListener(long did) {\n+        return new DeleteDeckListener(did, this);\n+    }\n+    private static class DeleteDeckListener extends TaskListenerWithContext<DeckPicker>{\n+        private final long did;\n+        // Flag to indicate if the deck being deleted is the current deck.\n+        private boolean removingCurrent;\n+\n+        public DeleteDeckListener(long did, DeckPicker deckPicker) {\n+            super(deckPicker);\n+            this.did = did;\n+        }\n+\n+\n+        @Override\n+        public void actualOnPreExecute(@NonNull DeckPicker deckPicker) {\n+            deckPicker.mProgressDialog = StyledProgressDialog.show(deckPicker, \"\",\n+                    deckPicker.getResources().getString(R.string.delete_deck), false);\n+            if (did == deckPicker.getCol().getDecks().current().optLong(\"id\")) {\n+                removingCurrent = true;\n             }\n+        }\n \n \n-            @SuppressWarnings(\"unchecked\")\n-            @Override\n-            public void onPostExecute(@Nullable TaskData result) {\n-                // In fragmented mode, if the deleted deck was the current deck, we need to reload\n-                // the study options fragment with a valid deck and re-center the deck list to the\n-                // new current deck. Otherwise we just update the list normally.\n-                if (mFragmented && removingCurrent) {\n-                    updateDeckList();\n-                    openStudyOptions(false);\n-                } else {\n-                    updateDeckList();\n-                }\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void actualOnPostExecute(@NonNull DeckPicker deckPicker, @Nullable TaskData result) {\n+            // In fragmented mode, if the deleted deck was the current deck, we need to reload\n+            // the study options fragment with a valid deck and re-center the deck list to the\n+            // new current deck. Otherwise we just update the list normally.\n+            if (deckPicker.mFragmented && removingCurrent) {\n+                deckPicker.updateDeckList();\n+                deckPicker.openStudyOptions(false);\n+            } else {\n+                deckPicker.updateDeckList();\n+            }\n \n-                if (mProgressDialog != null && mProgressDialog.isShowing()) {\n-                    try {\n-                        mProgressDialog.dismiss();\n-                    } catch (Exception e) {\n-                        Timber.e(e, \"onPostExecute - Exception dismissing dialog\");\n-                    }\n+            if (deckPicker.mProgressDialog != null && deckPicker.mProgressDialog.isShowing()) {\n+                try {\n+                    deckPicker.mProgressDialog.dismiss();\n+                } catch (Exception e) {\n+                    Timber.e(e, \"onPostExecute - Exception dismissing dialog\");\n                 }\n-                // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n-                getCol().clearUndo();\n             }\n-        };\n-        CollectionTask.launchCollectionTask(DELETE_DECK, listener, new TaskData(did));\n+            // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n+            deckPicker.getCol().clearUndo();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU0ODA3Mw==", "bodyText": "Nice catch. not sure what it is doing in UI. Probably should be moved to background (in another PR)", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466548073", "createdAt": "2020-08-06T16:49:37Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2383,63 +2431,78 @@ public void deleteContextMenuDeck() {\n         deleteDeck(mContextMenuDid);\n     }\n     public void deleteDeck(final long did) {\n-        CollectionTask.TaskListener listener = new CollectionTask.TaskListener() {\n-            // Flag to indicate if the deck being deleted is the current deck.\n-            private boolean removingCurrent;\n-\n-            @Override\n-            public void onPreExecute() {\n-                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, \"\",\n-                        getResources().getString(R.string.delete_deck), false);\n-                if (did == getCol().getDecks().current().optLong(\"id\")) {\n-                    removingCurrent = true;\n-                }\n+        TaskListener listener = deleteDeckListener(did);\n+        CollectionTask.launchCollectionTask(DELETE_DECK, listener, new TaskData(did));\n+    }\n+    private DeleteDeckListener deleteDeckListener(long did) {\n+        return new DeleteDeckListener(did, this);\n+    }\n+    private static class DeleteDeckListener extends TaskListenerWithContext<DeckPicker>{\n+        private final long did;\n+        // Flag to indicate if the deck being deleted is the current deck.\n+        private boolean removingCurrent;\n+\n+        public DeleteDeckListener(long did, DeckPicker deckPicker) {\n+            super(deckPicker);\n+            this.did = did;\n+        }\n+\n+\n+        @Override\n+        public void actualOnPreExecute(@NonNull DeckPicker deckPicker) {\n+            deckPicker.mProgressDialog = StyledProgressDialog.show(deckPicker, \"\",\n+                    deckPicker.getResources().getString(R.string.delete_deck), false);\n+            if (did == deckPicker.getCol().getDecks().current().optLong(\"id\")) {\n+                removingCurrent = true;\n             }\n+        }\n \n \n-            @SuppressWarnings(\"unchecked\")\n-            @Override\n-            public void onPostExecute(@Nullable TaskData result) {\n-                // In fragmented mode, if the deleted deck was the current deck, we need to reload\n-                // the study options fragment with a valid deck and re-center the deck list to the\n-                // new current deck. Otherwise we just update the list normally.\n-                if (mFragmented && removingCurrent) {\n-                    updateDeckList();\n-                    openStudyOptions(false);\n-                } else {\n-                    updateDeckList();\n-                }\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void actualOnPostExecute(@NonNull DeckPicker deckPicker, @Nullable TaskData result) {\n+            // In fragmented mode, if the deleted deck was the current deck, we need to reload\n+            // the study options fragment with a valid deck and re-center the deck list to the\n+            // new current deck. Otherwise we just update the list normally.\n+            if (deckPicker.mFragmented && removingCurrent) {\n+                deckPicker.updateDeckList();\n+                deckPicker.openStudyOptions(false);\n+            } else {\n+                deckPicker.updateDeckList();\n+            }\n \n-                if (mProgressDialog != null && mProgressDialog.isShowing()) {\n-                    try {\n-                        mProgressDialog.dismiss();\n-                    } catch (Exception e) {\n-                        Timber.e(e, \"onPostExecute - Exception dismissing dialog\");\n-                    }\n+            if (deckPicker.mProgressDialog != null && deckPicker.mProgressDialog.isShowing()) {\n+                try {\n+                    deckPicker.mProgressDialog.dismiss();\n+                } catch (Exception e) {\n+                    Timber.e(e, \"onPostExecute - Exception dismissing dialog\");\n                 }\n-                // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n-                getCol().clearUndo();\n             }\n-        };\n-        CollectionTask.launchCollectionTask(DELETE_DECK, listener, new TaskData(did));\n+            // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n+            deckPicker.getCol().clearUndo();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwOTk3Nw=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3Mzc3MQ==", "bodyText": "This appears to still be in actualOnPostExecute? I don't understand why it's safe", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468473771", "createdAt": "2020-08-11T10:14:40Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2383,63 +2431,78 @@ public void deleteContextMenuDeck() {\n         deleteDeck(mContextMenuDid);\n     }\n     public void deleteDeck(final long did) {\n-        CollectionTask.TaskListener listener = new CollectionTask.TaskListener() {\n-            // Flag to indicate if the deck being deleted is the current deck.\n-            private boolean removingCurrent;\n-\n-            @Override\n-            public void onPreExecute() {\n-                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, \"\",\n-                        getResources().getString(R.string.delete_deck), false);\n-                if (did == getCol().getDecks().current().optLong(\"id\")) {\n-                    removingCurrent = true;\n-                }\n+        TaskListener listener = deleteDeckListener(did);\n+        CollectionTask.launchCollectionTask(DELETE_DECK, listener, new TaskData(did));\n+    }\n+    private DeleteDeckListener deleteDeckListener(long did) {\n+        return new DeleteDeckListener(did, this);\n+    }\n+    private static class DeleteDeckListener extends TaskListenerWithContext<DeckPicker>{\n+        private final long did;\n+        // Flag to indicate if the deck being deleted is the current deck.\n+        private boolean removingCurrent;\n+\n+        public DeleteDeckListener(long did, DeckPicker deckPicker) {\n+            super(deckPicker);\n+            this.did = did;\n+        }\n+\n+\n+        @Override\n+        public void actualOnPreExecute(@NonNull DeckPicker deckPicker) {\n+            deckPicker.mProgressDialog = StyledProgressDialog.show(deckPicker, \"\",\n+                    deckPicker.getResources().getString(R.string.delete_deck), false);\n+            if (did == deckPicker.getCol().getDecks().current().optLong(\"id\")) {\n+                removingCurrent = true;\n             }\n+        }\n \n \n-            @SuppressWarnings(\"unchecked\")\n-            @Override\n-            public void onPostExecute(@Nullable TaskData result) {\n-                // In fragmented mode, if the deleted deck was the current deck, we need to reload\n-                // the study options fragment with a valid deck and re-center the deck list to the\n-                // new current deck. Otherwise we just update the list normally.\n-                if (mFragmented && removingCurrent) {\n-                    updateDeckList();\n-                    openStudyOptions(false);\n-                } else {\n-                    updateDeckList();\n-                }\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void actualOnPostExecute(@NonNull DeckPicker deckPicker, @Nullable TaskData result) {\n+            // In fragmented mode, if the deleted deck was the current deck, we need to reload\n+            // the study options fragment with a valid deck and re-center the deck list to the\n+            // new current deck. Otherwise we just update the list normally.\n+            if (deckPicker.mFragmented && removingCurrent) {\n+                deckPicker.updateDeckList();\n+                deckPicker.openStudyOptions(false);\n+            } else {\n+                deckPicker.updateDeckList();\n+            }\n \n-                if (mProgressDialog != null && mProgressDialog.isShowing()) {\n-                    try {\n-                        mProgressDialog.dismiss();\n-                    } catch (Exception e) {\n-                        Timber.e(e, \"onPostExecute - Exception dismissing dialog\");\n-                    }\n+            if (deckPicker.mProgressDialog != null && deckPicker.mProgressDialog.isShowing()) {\n+                try {\n+                    deckPicker.mProgressDialog.dismiss();\n+                } catch (Exception e) {\n+                    Timber.e(e, \"onPostExecute - Exception dismissing dialog\");\n                 }\n-                // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n-                getCol().clearUndo();\n             }\n-        };\n-        CollectionTask.launchCollectionTask(DELETE_DECK, listener, new TaskData(did));\n+            // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n+            deckPicker.getCol().clearUndo();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwOTk3Nw=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 528}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwNDQ5Nw==", "bodyText": "Seems to be caused by a badly done rebase. There was no reason to introduce this method as it has been moved in another PR", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468704497", "createdAt": "2020-08-11T16:20:13Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2383,63 +2431,78 @@ public void deleteContextMenuDeck() {\n         deleteDeck(mContextMenuDid);\n     }\n     public void deleteDeck(final long did) {\n-        CollectionTask.TaskListener listener = new CollectionTask.TaskListener() {\n-            // Flag to indicate if the deck being deleted is the current deck.\n-            private boolean removingCurrent;\n-\n-            @Override\n-            public void onPreExecute() {\n-                mProgressDialog = StyledProgressDialog.show(DeckPicker.this, \"\",\n-                        getResources().getString(R.string.delete_deck), false);\n-                if (did == getCol().getDecks().current().optLong(\"id\")) {\n-                    removingCurrent = true;\n-                }\n+        TaskListener listener = deleteDeckListener(did);\n+        CollectionTask.launchCollectionTask(DELETE_DECK, listener, new TaskData(did));\n+    }\n+    private DeleteDeckListener deleteDeckListener(long did) {\n+        return new DeleteDeckListener(did, this);\n+    }\n+    private static class DeleteDeckListener extends TaskListenerWithContext<DeckPicker>{\n+        private final long did;\n+        // Flag to indicate if the deck being deleted is the current deck.\n+        private boolean removingCurrent;\n+\n+        public DeleteDeckListener(long did, DeckPicker deckPicker) {\n+            super(deckPicker);\n+            this.did = did;\n+        }\n+\n+\n+        @Override\n+        public void actualOnPreExecute(@NonNull DeckPicker deckPicker) {\n+            deckPicker.mProgressDialog = StyledProgressDialog.show(deckPicker, \"\",\n+                    deckPicker.getResources().getString(R.string.delete_deck), false);\n+            if (did == deckPicker.getCol().getDecks().current().optLong(\"id\")) {\n+                removingCurrent = true;\n             }\n+        }\n \n \n-            @SuppressWarnings(\"unchecked\")\n-            @Override\n-            public void onPostExecute(@Nullable TaskData result) {\n-                // In fragmented mode, if the deleted deck was the current deck, we need to reload\n-                // the study options fragment with a valid deck and re-center the deck list to the\n-                // new current deck. Otherwise we just update the list normally.\n-                if (mFragmented && removingCurrent) {\n-                    updateDeckList();\n-                    openStudyOptions(false);\n-                } else {\n-                    updateDeckList();\n-                }\n+        @SuppressWarnings(\"unchecked\")\n+        @Override\n+        public void actualOnPostExecute(@NonNull DeckPicker deckPicker, @Nullable TaskData result) {\n+            // In fragmented mode, if the deleted deck was the current deck, we need to reload\n+            // the study options fragment with a valid deck and re-center the deck list to the\n+            // new current deck. Otherwise we just update the list normally.\n+            if (deckPicker.mFragmented && removingCurrent) {\n+                deckPicker.updateDeckList();\n+                deckPicker.openStudyOptions(false);\n+            } else {\n+                deckPicker.updateDeckList();\n+            }\n \n-                if (mProgressDialog != null && mProgressDialog.isShowing()) {\n-                    try {\n-                        mProgressDialog.dismiss();\n-                    } catch (Exception e) {\n-                        Timber.e(e, \"onPostExecute - Exception dismissing dialog\");\n-                    }\n+            if (deckPicker.mProgressDialog != null && deckPicker.mProgressDialog.isShowing()) {\n+                try {\n+                    deckPicker.mProgressDialog.dismiss();\n+                } catch (Exception e) {\n+                    Timber.e(e, \"onPostExecute - Exception dismissing dialog\");\n                 }\n-                // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n-                getCol().clearUndo();\n             }\n-        };\n-        CollectionTask.launchCollectionTask(DELETE_DECK, listener, new TaskData(did));\n+            // TODO: if we had \"undo delete note\" like desktop client then we won't need this.\n+            deckPicker.getCol().clearUndo();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUwOTk3Nw=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 528}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzg1OTI0OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo0ODo1MFrOG85jhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTozNjozOVrOG_KGfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMDcyNA==", "bodyText": "Questionable whether we still want to signal to the UI on a different activity", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466510724", "createdAt": "2020-08-06T15:48:50Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2594,35 +2668,35 @@ public void onPostExecute(TaskData result) {\n \n             if (!result.getBoolean() || databaseResult.getFailed()) {\n                 if (databaseResult.getDatabaseLocked()) {\n-                    handleDbLocked();\n+                    deckPicker.handleDbLocked();\n                 } else {\n-                    handleDbError();\n+                    deckPicker.handleDbError();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 688}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1MDgzMA==", "bodyText": "I don't understand. Are you making a comment about current behavior or are you noticing a change of behavior ? In the first case, it should probably be considered in another PR. In the second, I don't see how it makes a differenc, since both methods just Timber and then showDatabaseErrorDialog which opens a fragment on top of deck picker.\nSo if there was a DB error, if deckPicker has been left, it can't be to another activity, so it should be ankidroid closed, and so it's not really a change. If we were able to open another activity and display it without problem, there is something quite strange and that should be considered elsewhere", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466550830", "createdAt": "2020-08-06T16:54:15Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2594,35 +2668,35 @@ public void onPostExecute(TaskData result) {\n \n             if (!result.getBoolean() || databaseResult.getFailed()) {\n                 if (databaseResult.getDatabaseLocked()) {\n-                    handleDbLocked();\n+                    deckPicker.handleDbLocked();\n                 } else {\n-                    handleDbError();\n+                    deckPicker.handleDbError();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMDcyNA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 688}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1NDQ5Mw==", "bodyText": ", if deckPicker has been left, it can't be to another activity, so it should be ankidroid closed\n\nIs this the case? I thought \"Don't Keep Activities\" (for example) would mean that DeckPicker would be finalised (and only the bundle would remain) once the user navigated away from it", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466554493", "createdAt": "2020-08-06T17:00:30Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2594,35 +2668,35 @@ public void onPostExecute(TaskData result) {\n \n             if (!result.getBoolean() || databaseResult.getFailed()) {\n                 if (databaseResult.getDatabaseLocked()) {\n-                    handleDbLocked();\n+                    deckPicker.handleDbLocked();\n                 } else {\n-                    handleDbError();\n+                    deckPicker.handleDbError();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMDcyNA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 688}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjY0NjMwMA==", "bodyText": "That was my intuition. I am far from sure. I was here trying to understand what you were trying to state. The first question remains", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466646300", "createdAt": "2020-08-06T19:45:17Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2594,35 +2668,35 @@ public void onPostExecute(TaskData result) {\n \n             if (!result.getBoolean() || databaseResult.getFailed()) {\n                 if (databaseResult.getDatabaseLocked()) {\n-                    handleDbLocked();\n+                    deckPicker.handleDbLocked();\n                 } else {\n-                    handleDbError();\n+                    deckPicker.handleDbError();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMDcyNA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 688}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ2ODA3Mw==", "bodyText": "I'm asking whether we will want to handle a Db Error if the activity has been destroyed. That's technically a functional change, but I believe we'll be fine to allow it.", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468468073", "createdAt": "2020-08-11T10:03:16Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2594,35 +2668,35 @@ public void onPostExecute(TaskData result) {\n \n             if (!result.getBoolean() || databaseResult.getFailed()) {\n                 if (databaseResult.getDatabaseLocked()) {\n-                    handleDbLocked();\n+                    deckPicker.handleDbLocked();\n                 } else {\n-                    handleDbError();\n+                    deckPicker.handleDbError();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMDcyNA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 688}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3ODA5Mg==", "bodyText": "I don't have enough context about what kind of errors may occurs that I am 100% sure that I want to allow a functional change. I'm very much in favor of big NF change and small F change, so I'll just remove this I guess", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468878092", "createdAt": "2020-08-11T21:34:37Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2594,35 +2668,35 @@ public void onPostExecute(TaskData result) {\n \n             if (!result.getBoolean() || databaseResult.getFailed()) {\n                 if (databaseResult.getDatabaseLocked()) {\n-                    handleDbLocked();\n+                    deckPicker.handleDbLocked();\n                 } else {\n-                    handleDbError();\n+                    deckPicker.handleDbError();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMDcyNA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 688}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg3ODk3Mg==", "bodyText": "Actually ,it seems it was already removed anyway", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468878972", "createdAt": "2020-08-11T21:36:39Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/DeckPicker.java", "diffHunk": "@@ -2594,35 +2668,35 @@ public void onPostExecute(TaskData result) {\n \n             if (!result.getBoolean() || databaseResult.getFailed()) {\n                 if (databaseResult.getDatabaseLocked()) {\n-                    handleDbLocked();\n+                    deckPicker.handleDbLocked();\n                 } else {\n-                    handleDbError();\n+                    deckPicker.handleDbError();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMDcyNA=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 688}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzg3ODE1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/async/TaskListenerWithContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo1MzoxN1rOG85vFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjo1NToxNlrOG88ClA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMzY4Nw==", "bodyText": "Maybe use CTX or TContext instead of Context here so it doesn't get mistaken for the class name", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466513687", "createdAt": "2020-08-06T15:53:17Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/TaskListenerWithContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.ichi2.async;\n+\n+import java.lang.ref.WeakReference;\n+\n+import androidx.annotation.NonNull;\n+\n+/** Similar to task listener, but if the context disappear, no action are executed.\n+ * We ensure that the context can't disappear during the execution of the methods. */\n+public abstract class TaskListenerWithContext<Context> extends TaskListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1MTQ0NA==", "bodyText": "Ok", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466551444", "createdAt": "2020-08-06T16:55:16Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/TaskListenerWithContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.ichi2.async;\n+\n+import java.lang.ref.WeakReference;\n+\n+import androidx.annotation.NonNull;\n+\n+/** Similar to task listener, but if the context disappear, no action are executed.\n+ * We ensure that the context can't disappear during the execution of the methods. */\n+public abstract class TaskListenerWithContext<Context> extends TaskListener {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxMzY4Nw=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkxMzg4MjUxOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/async/TaskListenerWithContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNTo1NDoxNlrOG85xmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNlQxNjo1Njo0M1rOG88GDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxNDMzMQ==", "bodyText": "I feel these methods should be final so they can't be overridden, and should have an @Override", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466514331", "createdAt": "2020-08-06T15:54:16Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/TaskListenerWithContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.ichi2.async;\n+\n+import java.lang.ref.WeakReference;\n+\n+import androidx.annotation.NonNull;\n+\n+/** Similar to task listener, but if the context disappear, no action are executed.\n+ * We ensure that the context can't disappear during the execution of the methods. */\n+public abstract class TaskListenerWithContext<Context> extends TaskListener {\n+    private WeakReference<Context> mContext;\n+    protected TaskListenerWithContext(Context context) {\n+        mContext = new WeakReference<>(context);\n+    }\n+\n+    public void onPreExecute() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUzODYwOA==", "bodyText": "I'm not convinced they should be final. Because in cases where listener makes non-UI change that can't easily be moved background, it may be nice to override onPre/Post/execute to deal with this particular case, and still override actualOnPreExecute to do as much of the work as possible for consistency", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466538608", "createdAt": "2020-08-06T16:33:35Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/TaskListenerWithContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.ichi2.async;\n+\n+import java.lang.ref.WeakReference;\n+\n+import androidx.annotation.NonNull;\n+\n+/** Similar to task listener, but if the context disappear, no action are executed.\n+ * We ensure that the context can't disappear during the execution of the methods. */\n+public abstract class TaskListenerWithContext<Context> extends TaskListener {\n+    private WeakReference<Context> mContext;\n+    protected TaskListenerWithContext(Context context) {\n+        mContext = new WeakReference<>(context);\n+    }\n+\n+    public void onPreExecute() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxNDMzMQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjU1MjMzNA==", "bodyText": "Maybe we want a different name than the base class to ensure that someone doesn't accidentally override the wrong method, not realising that we have methods which optionally take the context", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r466552334", "createdAt": "2020-08-06T16:56:43Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/TaskListenerWithContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+package com.ichi2.async;\n+\n+import java.lang.ref.WeakReference;\n+\n+import androidx.annotation.NonNull;\n+\n+/** Similar to task listener, but if the context disappear, no action are executed.\n+ * We ensure that the context can't disappear during the execution of the methods. */\n+public abstract class TaskListenerWithContext<Context> extends TaskListener {\n+    private WeakReference<Context> mContext;\n+    protected TaskListenerWithContext(Context context) {\n+        mContext = new WeakReference<>(context);\n+    }\n+\n+    public void onPreExecute() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjUxNDMzMQ=="}, "originalCommit": {"oid": "027d1f8a704f8c28b944ac9ca6b88b9fc5a447cc"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzAyOTQ2OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDowNzozN1rOG-xKeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoxNzoyOVrOG-_V5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3MDM5NA==", "bodyText": "nit: might be more readable to extract these two lines to a method - becomes more complex with the additional variable", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468470394", "createdAt": "2020-08-11T10:07:37Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1794,44 +1861,49 @@ public void onPostExecute(TaskData result) {\n \n \n         @Override\n-        public void onCancelled() {\n-            hideProgressBar();\n+        public void actualOnCancelled(@NonNull CardBrowser browser) {\n+            browser.hideProgressBar();\n         }\n     };\n \n-    private TaskListener mCheckSelectedCardsHandler = new ListenerWithProgressBar() {\n+    private final CheckSelectedCardsHandler mCheckSelectedCardsHandler = new CheckSelectedCardsHandler(this);\n+    private static class CheckSelectedCardsHandler extends ListenerWithProgressBar {\n+        public CheckSelectedCardsHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        public void onPostExecute(TaskData result) {\n-            hideProgressBar();\n+        public void actualOnPostExecute(@NonNull CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n \n             Object[] resultArr = result.getObjArray();\n             boolean hasUnsuspended = (boolean) resultArr[0];\n             boolean hasUnmarked = (boolean) resultArr[1];\n \n             if (hasUnsuspended) {\n-                mActionBarMenu.findItem(R.id.action_suspend_card).setTitle(getString(R.string.card_browser_suspend_card));\n-                mActionBarMenu.findItem(R.id.action_suspend_card).setIcon(R.drawable.ic_action_suspend);\n+                browser.mActionBarMenu.findItem(R.id.action_suspend_card).setTitle(browser.getString(R.string.card_browser_suspend_card));\n+                browser.mActionBarMenu.findItem(R.id.action_suspend_card).setIcon(R.drawable.ic_action_suspend);\n             } else {\n-                mActionBarMenu.findItem(R.id.action_suspend_card).setTitle(getString(R.string.card_browser_unsuspend_card));\n-                mActionBarMenu.findItem(R.id.action_suspend_card).setIcon(R.drawable.ic_action_unsuspend);\n+                browser.mActionBarMenu.findItem(R.id.action_suspend_card).setTitle(browser.getString(R.string.card_browser_unsuspend_card));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 468}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwMjY5NQ==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468702695", "createdAt": "2020-08-11T16:17:29Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1794,44 +1861,49 @@ public void onPostExecute(TaskData result) {\n \n \n         @Override\n-        public void onCancelled() {\n-            hideProgressBar();\n+        public void actualOnCancelled(@NonNull CardBrowser browser) {\n+            browser.hideProgressBar();\n         }\n     };\n \n-    private TaskListener mCheckSelectedCardsHandler = new ListenerWithProgressBar() {\n+    private final CheckSelectedCardsHandler mCheckSelectedCardsHandler = new CheckSelectedCardsHandler(this);\n+    private static class CheckSelectedCardsHandler extends ListenerWithProgressBar {\n+        public CheckSelectedCardsHandler(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        public void onPostExecute(TaskData result) {\n-            hideProgressBar();\n+        public void actualOnPostExecute(@NonNull CardBrowser browser, TaskData result) {\n+            browser.hideProgressBar();\n \n             Object[] resultArr = result.getObjArray();\n             boolean hasUnsuspended = (boolean) resultArr[0];\n             boolean hasUnmarked = (boolean) resultArr[1];\n \n             if (hasUnsuspended) {\n-                mActionBarMenu.findItem(R.id.action_suspend_card).setTitle(getString(R.string.card_browser_suspend_card));\n-                mActionBarMenu.findItem(R.id.action_suspend_card).setIcon(R.drawable.ic_action_suspend);\n+                browser.mActionBarMenu.findItem(R.id.action_suspend_card).setTitle(browser.getString(R.string.card_browser_suspend_card));\n+                browser.mActionBarMenu.findItem(R.id.action_suspend_card).setIcon(R.drawable.ic_action_suspend);\n             } else {\n-                mActionBarMenu.findItem(R.id.action_suspend_card).setTitle(getString(R.string.card_browser_unsuspend_card));\n-                mActionBarMenu.findItem(R.id.action_suspend_card).setIcon(R.drawable.ic_action_unsuspend);\n+                browser.mActionBarMenu.findItem(R.id.action_suspend_card).setTitle(browser.getString(R.string.card_browser_unsuspend_card));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3MDM5NA=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 468}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzAzNTIwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDowOTozMVrOG-xOCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo1MTozM1rOG_KfWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3MTMwNA==", "bodyText": "Nit: inconsistent use of getResources()", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468471304", "createdAt": "2020-08-11T10:09:31Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java", "diffHunk": "@@ -628,35 +629,40 @@ private void onCardBrowserAppearanceResult(int resultCode, @Nullable Intent data\n         }\n \n         /* Used for updating the collection when a model has been edited */\n-        private TaskListener mSaveModelAndExitHandler = new TaskListener() {\n+        private final SaveModelAndExitHandler mSaveModelAndExitHandler = new SaveModelAndExitHandler(this);\n+        private static class SaveModelAndExitHandler extends TaskListenerWithContext<CardTemplateFragment> {\n+            public SaveModelAndExitHandler(CardTemplateFragment templateFragment) {\n+                super(templateFragment);\n+            }\n+\n             private MaterialDialog mProgressDialog = null;\n             @Override\n-            public void onPreExecute() {\n+            public void actualOnPreExecute(@NonNull CardTemplateFragment templateFragment) {\n                 Timber.d(\"mSaveModelAndExitHandler::preExecute called\");\n-                mProgressDialog = StyledProgressDialog.show(mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),\n-                        getResources().getString(R.string.saving_changes), false);\n+                mProgressDialog = StyledProgressDialog.show(templateFragment.mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwMjQyNA==", "bodyText": "Was there anything wrong with previous version of getResources ?\u00a0Because I uses the same code as before and so would not expect it to be a problem", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468702424", "createdAt": "2020-08-11T16:17:05Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java", "diffHunk": "@@ -628,35 +629,40 @@ private void onCardBrowserAppearanceResult(int resultCode, @Nullable Intent data\n         }\n \n         /* Used for updating the collection when a model has been edited */\n-        private TaskListener mSaveModelAndExitHandler = new TaskListener() {\n+        private final SaveModelAndExitHandler mSaveModelAndExitHandler = new SaveModelAndExitHandler(this);\n+        private static class SaveModelAndExitHandler extends TaskListenerWithContext<CardTemplateFragment> {\n+            public SaveModelAndExitHandler(CardTemplateFragment templateFragment) {\n+                super(templateFragment);\n+            }\n+\n             private MaterialDialog mProgressDialog = null;\n             @Override\n-            public void onPreExecute() {\n+            public void actualOnPreExecute(@NonNull CardTemplateFragment templateFragment) {\n                 Timber.d(\"mSaveModelAndExitHandler::preExecute called\");\n-                mProgressDialog = StyledProgressDialog.show(mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),\n-                        getResources().getString(R.string.saving_changes), false);\n+                mProgressDialog = StyledProgressDialog.show(templateFragment.mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3MTMwNA=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg0ODAwNQ==", "bodyText": "The Application context should have had updateContextWithLanguage called on it. The inconsistent value may be incorrect, but would need to be manually confirmed.", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468848005", "createdAt": "2020-08-11T20:32:48Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java", "diffHunk": "@@ -628,35 +629,40 @@ private void onCardBrowserAppearanceResult(int resultCode, @Nullable Intent data\n         }\n \n         /* Used for updating the collection when a model has been edited */\n-        private TaskListener mSaveModelAndExitHandler = new TaskListener() {\n+        private final SaveModelAndExitHandler mSaveModelAndExitHandler = new SaveModelAndExitHandler(this);\n+        private static class SaveModelAndExitHandler extends TaskListenerWithContext<CardTemplateFragment> {\n+            public SaveModelAndExitHandler(CardTemplateFragment templateFragment) {\n+                super(templateFragment);\n+            }\n+\n             private MaterialDialog mProgressDialog = null;\n             @Override\n-            public void onPreExecute() {\n+            public void actualOnPreExecute(@NonNull CardTemplateFragment templateFragment) {\n                 Timber.d(\"mSaveModelAndExitHandler::preExecute called\");\n-                mProgressDialog = StyledProgressDialog.show(mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),\n-                        getResources().getString(R.string.saving_changes), false);\n+                mProgressDialog = StyledProgressDialog.show(templateFragment.mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3MTMwNA=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4MjkxOQ==", "bodyText": "Would it be okay to deal with it in another\u00a0PR ?\u00a0If it conflict with this PR, I'll rebase. I have no idea what resources works exactly", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468882919", "createdAt": "2020-08-11T21:45:49Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java", "diffHunk": "@@ -628,35 +629,40 @@ private void onCardBrowserAppearanceResult(int resultCode, @Nullable Intent data\n         }\n \n         /* Used for updating the collection when a model has been edited */\n-        private TaskListener mSaveModelAndExitHandler = new TaskListener() {\n+        private final SaveModelAndExitHandler mSaveModelAndExitHandler = new SaveModelAndExitHandler(this);\n+        private static class SaveModelAndExitHandler extends TaskListenerWithContext<CardTemplateFragment> {\n+            public SaveModelAndExitHandler(CardTemplateFragment templateFragment) {\n+                super(templateFragment);\n+            }\n+\n             private MaterialDialog mProgressDialog = null;\n             @Override\n-            public void onPreExecute() {\n+            public void actualOnPreExecute(@NonNull CardTemplateFragment templateFragment) {\n                 Timber.d(\"mSaveModelAndExitHandler::preExecute called\");\n-                mProgressDialog = StyledProgressDialog.show(mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),\n-                        getResources().getString(R.string.saving_changes), false);\n+                mProgressDialog = StyledProgressDialog.show(templateFragment.mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3MTMwNA=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NTMzOQ==", "bodyText": "Sure", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468885339", "createdAt": "2020-08-11T21:51:33Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardTemplateEditor.java", "diffHunk": "@@ -628,35 +629,40 @@ private void onCardBrowserAppearanceResult(int resultCode, @Nullable Intent data\n         }\n \n         /* Used for updating the collection when a model has been edited */\n-        private TaskListener mSaveModelAndExitHandler = new TaskListener() {\n+        private final SaveModelAndExitHandler mSaveModelAndExitHandler = new SaveModelAndExitHandler(this);\n+        private static class SaveModelAndExitHandler extends TaskListenerWithContext<CardTemplateFragment> {\n+            public SaveModelAndExitHandler(CardTemplateFragment templateFragment) {\n+                super(templateFragment);\n+            }\n+\n             private MaterialDialog mProgressDialog = null;\n             @Override\n-            public void onPreExecute() {\n+            public void actualOnPreExecute(@NonNull CardTemplateFragment templateFragment) {\n                 Timber.d(\"mSaveModelAndExitHandler::preExecute called\");\n-                mProgressDialog = StyledProgressDialog.show(mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),\n-                        getResources().getString(R.string.saving_changes), false);\n+                mProgressDialog = StyledProgressDialog.show(templateFragment.mTemplateEditor, AnkiDroidApp.getAppResources().getString(R.string.saving_model),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3MTMwNA=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzA1NjA0OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/dialogs/CustomStudyDialog.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDoxNjowM1rOG-xanw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoyNDoxMlrOG-_mnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3NDUyNw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    private  AnkiActivity activity;\n          \n          \n            \n                    private AnkiActivity activity;", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468474527", "createdAt": "2020-08-11T10:16:03Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/dialogs/CustomStudyDialog.java", "diffHunk": "@@ -512,4 +502,30 @@ private void onLimitsExtended(boolean jumpToReviewer) {\n     protected AnkiActivity getAnkiActivity() {\n         return (AnkiActivity) getActivity();\n     }\n+\n+\n+    private CreateCustomStudySessionListener createCustomStudySessionListener(AnkiActivity activity){\n+        return new CreateCustomStudySessionListener(this, activity);\n+    }\n+    private static class CreateCustomStudySessionListener extends TaskListenerWithContext<CustomStudyDialog> {\n+        private  AnkiActivity activity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwNjk3NQ==", "bodyText": "Deleted", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468706975", "createdAt": "2020-08-11T16:24:12Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/dialogs/CustomStudyDialog.java", "diffHunk": "@@ -512,4 +502,30 @@ private void onLimitsExtended(boolean jumpToReviewer) {\n     protected AnkiActivity getAnkiActivity() {\n         return (AnkiActivity) getActivity();\n     }\n+\n+\n+    private CreateCustomStudySessionListener createCustomStudySessionListener(AnkiActivity activity){\n+        return new CreateCustomStudySessionListener(this, activity);\n+    }\n+    private static class CreateCustomStudySessionListener extends TaskListenerWithContext<CustomStudyDialog> {\n+        private  AnkiActivity activity;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3NDUyNw=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzA1OTUxOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/dialogs/CustomStudyDialog.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDoxNzowNVrOG-xcxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo0Mzo1NlrOG_KSfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3NTA3Ng==", "bodyText": "activity is a context leak, you might be able to do dialog.getActivity() which is nullable", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468475076", "createdAt": "2020-08-11T10:17:05Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/dialogs/CustomStudyDialog.java", "diffHunk": "@@ -512,4 +502,30 @@ private void onLimitsExtended(boolean jumpToReviewer) {\n     protected AnkiActivity getAnkiActivity() {\n         return (AnkiActivity) getActivity();\n     }\n+\n+\n+    private CreateCustomStudySessionListener createCustomStudySessionListener(AnkiActivity activity){\n+        return new CreateCustomStudySessionListener(this, activity);\n+    }\n+    private static class CreateCustomStudySessionListener extends TaskListenerWithContext<CustomStudyDialog> {\n+        private  AnkiActivity activity;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwNjUwMg==", "bodyText": "Thanks", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468706502", "createdAt": "2020-08-11T16:23:24Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/dialogs/CustomStudyDialog.java", "diffHunk": "@@ -512,4 +502,30 @@ private void onLimitsExtended(boolean jumpToReviewer) {\n     protected AnkiActivity getAnkiActivity() {\n         return (AnkiActivity) getActivity();\n     }\n+\n+\n+    private CreateCustomStudySessionListener createCustomStudySessionListener(AnkiActivity activity){\n+        return new CreateCustomStudySessionListener(this, activity);\n+    }\n+    private static class CreateCustomStudySessionListener extends TaskListenerWithContext<CustomStudyDialog> {\n+        private  AnkiActivity activity;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3NTA3Ng=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4MjA0Ng==", "bodyText": "Result can't be cast to anki activity. Anyway, the mistake was that the activity itself could be the context we consider, no need to keep track of CustomStudyDialog.\nChanged", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468882046", "createdAt": "2020-08-11T21:43:56Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/dialogs/CustomStudyDialog.java", "diffHunk": "@@ -512,4 +502,30 @@ private void onLimitsExtended(boolean jumpToReviewer) {\n     protected AnkiActivity getAnkiActivity() {\n         return (AnkiActivity) getActivity();\n     }\n+\n+\n+    private CreateCustomStudySessionListener createCustomStudySessionListener(AnkiActivity activity){\n+        return new CreateCustomStudySessionListener(this, activity);\n+    }\n+    private static class CreateCustomStudySessionListener extends TaskListenerWithContext<CustomStudyDialog> {\n+        private  AnkiActivity activity;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3NTA3Ng=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzA2MTU3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/test/java/com/ichi2/anki/RobolectricTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMDoxNzo0MlrOG-xeCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNjoyNDo1M1rOG-_oWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3NTQwMQ==", "bodyText": "insignificant whitespace change", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468475401", "createdAt": "2020-08-11T10:17:42Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/anki/RobolectricTest.java", "diffHunk": "@@ -40,6 +40,7 @@\n import com.ichi2.utils.JSONObject;\n \n import org.hamcrest.Matcher;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODcwNzQxNg==", "bodyText": "Insignificant commit actually", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468707416", "createdAt": "2020-08-11T16:24:53Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/test/java/com/ichi2/anki/RobolectricTest.java", "diffHunk": "@@ -40,6 +40,7 @@\n import com.ichi2.utils.JSONObject;\n \n import org.hamcrest.Matcher;\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODQ3NTQwMQ=="}, "originalCommit": {"oid": "d284908f7213ee0c88ab6ac67605cb7e449f6f2e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTY3MDQ5OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo1NDoyOFrOG_KkTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjowMzo0OFrOG_KzHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NjYwNQ==", "bodyText": "Maybe? Sounds better than actual actual\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            actualActualOnPostExecute(browser, result);\n          \n          \n            \n                            actualOnValidPostExecute(browser, result);", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468886605", "createdAt": "2020-08-11T21:54:28Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1369,35 +1391,41 @@ private void filterByTag(List<String> selectedTags, int option) {\n     }\n \n \n-    private abstract class ListenerWithProgressBar extends TaskListener {\n+    private static abstract class ListenerWithProgressBar extends TaskListenerWithContext<CardBrowser>{\n+        public ListenerWithProgressBar(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n+            browser.showProgressBar();\n         }\n     }\n \n-    private abstract class ListenerWithProgressBarCloseOnFalse extends ListenerWithProgressBar {\n-        private String timber = null;\n-\n-        public ListenerWithProgressBarCloseOnFalse(String timber) {\n-            this.timber = timber;\n+    /** Does not leak Card Browser. */\n+    private static abstract class ListenerWithProgressBarCloseOnFalse extends ListenerWithProgressBar {\n+        private final String mTimber;\n+        public ListenerWithProgressBarCloseOnFalse(String timber, CardBrowser browser) {\n+            super(browser);\n+            mTimber = timber;\n         }\n \n-        public ListenerWithProgressBarCloseOnFalse() {\n+        public ListenerWithProgressBarCloseOnFalse(CardBrowser browser) {\n+            this(null, browser);\n \t\t}\n \n-        public void onPostExecute(TaskData result) {\n-            if (timber != null) {\n-                Timber.d(timber);\n+        public void actualOnPostExecute(@NonNull CardBrowser browser, TaskData result) {\n+            if (mTimber != null) {\n+                Timber.d(mTimber);\n             }\n             if (result.getBoolean()) {\n-                actualPostExecute(result);\n+                actualActualOnPostExecute(browser, result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46a824f5910cdf41745bcfd9248d97639a8060c4"}, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5MDM5OQ==", "bodyText": "Fine by me. Not an easy task here", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468890399", "createdAt": "2020-08-11T22:03:48Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/CardBrowser.java", "diffHunk": "@@ -1369,35 +1391,41 @@ private void filterByTag(List<String> selectedTags, int option) {\n     }\n \n \n-    private abstract class ListenerWithProgressBar extends TaskListener {\n+    private static abstract class ListenerWithProgressBar extends TaskListenerWithContext<CardBrowser>{\n+        public ListenerWithProgressBar(CardBrowser browser) {\n+            super(browser);\n+        }\n+\n         @Override\n-        public void onPreExecute() {\n-            showProgressBar();\n+        public void actualOnPreExecute(@NonNull CardBrowser browser) {\n+            browser.showProgressBar();\n         }\n     }\n \n-    private abstract class ListenerWithProgressBarCloseOnFalse extends ListenerWithProgressBar {\n-        private String timber = null;\n-\n-        public ListenerWithProgressBarCloseOnFalse(String timber) {\n-            this.timber = timber;\n+    /** Does not leak Card Browser. */\n+    private static abstract class ListenerWithProgressBarCloseOnFalse extends ListenerWithProgressBar {\n+        private final String mTimber;\n+        public ListenerWithProgressBarCloseOnFalse(String timber, CardBrowser browser) {\n+            super(browser);\n+            mTimber = timber;\n         }\n \n-        public ListenerWithProgressBarCloseOnFalse() {\n+        public ListenerWithProgressBarCloseOnFalse(CardBrowser browser) {\n+            this(null, browser);\n \t\t}\n \n-        public void onPostExecute(TaskData result) {\n-            if (timber != null) {\n-                Timber.d(timber);\n+        public void actualOnPostExecute(@NonNull CardBrowser browser, TaskData result) {\n+            if (mTimber != null) {\n+                Timber.d(mTimber);\n             }\n             if (result.getBoolean()) {\n-                actualPostExecute(result);\n+                actualActualOnPostExecute(browser, result);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4NjYwNQ=="}, "originalCommit": {"oid": "46a824f5910cdf41745bcfd9248d97639a8060c4"}, "originalPosition": 217}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyOTY4MTY4OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/ModelFieldEditor.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMTo1ODoyOFrOG_Kq0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQyMjowNDo1MFrOG_K0tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4ODI3NA==", "bodyText": "maybe rename to changeHandler", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468888274", "createdAt": "2020-08-11T21:58:28Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/ModelFieldEditor.java", "diffHunk": "@@ -180,9 +183,10 @@ private void addFieldDialog() {\n                         UIUtils.showThemedToast(this, getResources().getString(R.string.toast_duplicate_field), true);\n                     } else {\n                         //Name is valid, now field is added\n+                        ChangeFieldHandler listener = changeFieldHandler();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46a824f5910cdf41745bcfd9248d97639a8060c4"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg5MDgwNQ==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6775#discussion_r468890805", "createdAt": "2020-08-11T22:04:50Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/ModelFieldEditor.java", "diffHunk": "@@ -180,9 +183,10 @@ private void addFieldDialog() {\n                         UIUtils.showThemedToast(this, getResources().getString(R.string.toast_duplicate_field), true);\n                     } else {\n                         //Name is valid, now field is added\n+                        ChangeFieldHandler listener = changeFieldHandler();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODg4ODI3NA=="}, "originalCommit": {"oid": "46a824f5910cdf41745bcfd9248d97639a8060c4"}, "originalPosition": 21}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4968, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}