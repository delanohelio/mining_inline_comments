{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1MzY2MjAy", "number": 6130, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDowNjo0MVrOD6w5eA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozODozM1rOD6xc3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTQ1MTQ0OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDowNjo0MVrOGSyDog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjowMjo0MlrOGS1CBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzY4Mg==", "bodyText": "PERF: can this be modified so we're not calling StringBuffer.toString on each iteration?", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422347682", "createdAt": "2020-05-08T20:06:41Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);\n+                if (!field_is_empty) {\n+                    if (section.charAt(2) != '^') {\n+                        replacer = render_sections(inner, context);\n+                    }\n+                } else if (field_is_empty && section.charAt(2) == '^') {\n                     replacer = render_sections(inner, context);\n                 }\n-            } else if (field_is_empty && section.charAt(2) == '^') {\n-                replacer = render_sections(inner, context);\n+                match.appendReplacement(sb, Matcher.quoteReplacement(replacer));\n             }\n-            match.appendReplacement(sb, Matcher.quoteReplacement(replacer));\n-        }\n-        match.appendTail(sb);\n-        return sb.toString();\n+            match.appendTail(sb);\n+            template = sb.toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9c0c501aa5b29dacb1748655444c3b66cf166059"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5Mzk4OA==", "bodyText": "I don't believe we can. I don't believe it's a problem either.\nIt is not a problem because there is a single iteration normally. The only case where there is multiple iteration is when a conditional contains itself, or when a conditional contains the start/end of another conditional and the end/start is outside of the conditional. I.e. either the example which cause this PR to existence, or something which is even more broken.\nBoth cases were already broken without my change, and only worked sometime only for some specific combination of fields being filled/empty.\nThe reason why I can not avoid using toString is that I want to run a regexp over the string. I can not run the regexp over a buffer.\nI would like to emphasize that reverting #6073 would probably not increase the performance. The previous code didn't even use buffer, and just called String.replace as many time as they were fields and conditional.", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422393988", "createdAt": "2020-05-08T21:55:15Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);\n+                if (!field_is_empty) {\n+                    if (section.charAt(2) != '^') {\n+                        replacer = render_sections(inner, context);\n+                    }\n+                } else if (field_is_empty && section.charAt(2) == '^') {\n                     replacer = render_sections(inner, context);\n                 }\n-            } else if (field_is_empty && section.charAt(2) == '^') {\n-                replacer = render_sections(inner, context);\n+                match.appendReplacement(sb, Matcher.quoteReplacement(replacer));\n             }\n-            match.appendReplacement(sb, Matcher.quoteReplacement(replacer));\n-        }\n-        match.appendTail(sb);\n-        return sb.toString();\n+            match.appendTail(sb);\n+            template = sb.toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzY4Mg=="}, "originalCommit": {"oid": "9c0c501aa5b29dacb1748655444c3b66cf166059"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5NjQyMg==", "bodyText": "Sounds good to me", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422396422", "createdAt": "2020-05-08T22:02:42Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);\n+                if (!field_is_empty) {\n+                    if (section.charAt(2) != '^') {\n+                        replacer = render_sections(inner, context);\n+                    }\n+                } else if (field_is_empty && section.charAt(2) == '^') {\n                     replacer = render_sections(inner, context);\n                 }\n-            } else if (field_is_empty && section.charAt(2) == '^') {\n-                replacer = render_sections(inner, context);\n+                match.appendReplacement(sb, Matcher.quoteReplacement(replacer));\n             }\n-            match.appendReplacement(sb, Matcher.quoteReplacement(replacer));\n-        }\n-        match.appendTail(sb);\n-        return sb.toString();\n+            match.appendTail(sb);\n+            template = sb.toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM0NzY4Mg=="}, "originalCommit": {"oid": "9c0c501aa5b29dacb1748655444c3b66cf166059"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTU0MjA0OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMDozODozM1rOGSy7ZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMjoxMjo1OFrOGS1N1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk1Nw==", "bodyText": "Nit: Move up one line for clarity", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422361957", "createdAt": "2020-05-08T20:38:33Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b5f9dd8480f017bf7476b722fdacca45f0df1f76"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5MTYyMQ==", "bodyText": "I don't understand what you mean here. What should I move ?", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422391621", "createdAt": "2020-05-08T21:48:14Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk1Nw=="}, "originalCommit": {"oid": "b5f9dd8480f017bf7476b722fdacca45f0df1f76"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5MzI2Mw==", "bodyText": "field_is_empty/it is only mutated if the branch is taken, you can move it inside the if statement for clarity.", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422393263", "createdAt": "2020-05-08T21:52:58Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk1Nw=="}, "originalCommit": {"oid": "b5f9dd8480f017bf7476b722fdacca45f0df1f76"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM5OTQ0NA==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6130#discussion_r422399444", "createdAt": "2020-05-08T22:12:58Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/template/Template.java", "diffHunk": "@@ -119,32 +119,60 @@ private void compile_regexps() {\n      * Expands sections.\n      */\n     private String render_sections(String template, Map<String, String> context) {\n-        StringBuffer sb = new StringBuffer();\n-        Matcher match = sSection_re.matcher(template);\n-        while (match.find()) {\n-            String section = match.group(0);\n-            String section_name = match.group(1);\n-            String inner = match.group(2);\n-            section_name = section_name.trim();\n-            String it = get_or_attr(context, section_name, null);\n-            String replacer = \"\";\n-            boolean field_is_empty = TextUtils.isEmpty(it);\n-\n-            if (!field_is_empty) {\n-                it = Utils.stripHTMLMedia(it).trim();\n-            }\n-            field_is_empty = TextUtils.isEmpty(it);\n-            if (!field_is_empty) {\n-                if (section.charAt(2) != '^') {\n+        /* Normally, after the inner loop, all conditionals have been\n+           evaluated.  There is a single exception, if a conditional\n+           starts in another conditional and is closed outside of\n+           it.\n+\n+           This can be the case in particular when\n+           \"{{#field}}A{{#field}}B{{/field}}C{{/field}}\", because the\n+           regexp find that the closing of the first opening is the\n+           first closing.  So the template gets transformed into\n+           either \"A{{#field}}BC{{/field}}\" or \"C{{/field}}\" depending\n+           on whether \"field\" has content or not.\n+\n+           We thus have the external loop which ensures that, in the\n+           first, the conditional is evaluated again and transformed\n+           into \"ABC\".\n+\n+           Note that having a conditional inside itself is not\n+           generally supported. It bugs when the conditional evaluates\n+           to False. Similarly having conditionals not properly nested\n+           is generally not supported either. So this outer loop will\n+           get the behaviour more confusing to user, as they may fail\n+           to understand why the code breaks only sometime. */\n+        boolean some_change;\n+        do {\n+            StringBuffer sb = new StringBuffer();\n+            some_change = false;\n+            Matcher match = sSection_re.matcher(template);\n+            while (match.find()) {\n+                some_change = true;\n+                String section = match.group(0);\n+                String section_name = match.group(1);\n+                String inner = match.group(2);\n+                section_name = section_name.trim();\n+                String it = get_or_attr(context, section_name, null);\n+                String replacer = \"\";\n+                boolean field_is_empty = TextUtils.isEmpty(it);\n+\n+                if (!field_is_empty) {\n+                    it = Utils.stripHTMLMedia(it).trim();\n+                }\n+                field_is_empty = TextUtils.isEmpty(it);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjM2MTk1Nw=="}, "originalCommit": {"oid": "b5f9dd8480f017bf7476b722fdacca45f0df1f76"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 406, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}