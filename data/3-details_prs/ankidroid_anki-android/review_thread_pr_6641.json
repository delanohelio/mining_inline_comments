{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0OTkxMDcw", "number": 6641, "reviewThreads": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMTowNzowMVrOESwxnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNzo1MlrOEpE5JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTA4OTU2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMTowNzowMVrOG4HqZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMTo0ODo0OVrOG4I6dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5ODk4Mw==", "bodyText": "Is this comment copy-pasted from somewhere else ? It seems more like a tutorial description and not a comment for the method. If so, we would at least need to credit the author properly", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461498983", "createdAt": "2020-07-28T11:07:01Z", "author": {"login": "Arthur-Milchior"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +158,27 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /*\n+    You would likely implement a FileProvider in your API to share the file from your app to \"the system\" as a URI,\n+    and pass that to a new AnkiDroid-API call you implement, where it would use ContentResolver to get the display\n+    name for the file and then open an input stream for it to copy the file in to the collection, similar to the way\n+    BasicImageFieldController does it (or will do it when a PR-in-progress lands) in the internalizeUri method\n+     */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a705ab5c2901707b6453ba9b7f6543f788371cc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUxMzU4OA==", "bodyText": "This was the guidance Matt gave me initially to start working from, I think its probably best to just remove it, right?", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461513588", "createdAt": "2020-07-28T11:36:25Z", "author": {"login": "KieranMigaku"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +158,27 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /*\n+    You would likely implement a FileProvider in your API to share the file from your app to \"the system\" as a URI,\n+    and pass that to a new AnkiDroid-API call you implement, where it would use ContentResolver to get the display\n+    name for the file and then open an input stream for it to copy the file in to the collection, similar to the way\n+    BasicImageFieldController does it (or will do it when a PR-in-progress lands) in the internalizeUri method\n+     */\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5ODk4Mw=="}, "originalCommit": {"oid": "2a705ab5c2901707b6453ba9b7f6543f788371cc"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUxOTQ3Nw==", "bodyText": "Please note I've no idea who Matt is.\nI clearly appreciate that you comment your method/class. The code alone is not sufficient, and so if you can write something relevant for the reader of the code that would be great. The notion of PR-in-progress does not seems to be relevant for future reader;", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461519477", "createdAt": "2020-07-28T11:48:49Z", "author": {"login": "Arthur-Milchior"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +158,27 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /*\n+    You would likely implement a FileProvider in your API to share the file from your app to \"the system\" as a URI,\n+    and pass that to a new AnkiDroid-API call you implement, where it would use ContentResolver to get the display\n+    name for the file and then open an input stream for it to copy the file in to the collection, similar to the way\n+    BasicImageFieldController does it (or will do it when a PR-in-progress lands) in the internalizeUri method\n+     */\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5ODk4Mw=="}, "originalCommit": {"oid": "2a705ab5c2901707b6453ba9b7f6543f788371cc"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTA5MjQ3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMTowNzo1OVrOG4HsIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMTowNzo1OVrOG4HsIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ5OTQyNg==", "bodyText": "It seems you get some value and do nothing with them. Just throw null.\u00a0I don't understand this commit", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461499426", "createdAt": "2020-07-28T11:07:59Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1032,6 +1043,13 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                Uri filUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e8197314503c92e39a116d495d07e305ae83e9ab"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTEwMTEyOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxMDoxNlrOG4HxGA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMjo0MTozMVrOG4KqZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMDY5Ng==", "bodyText": "If you  understand interactive rebase in git, it would be nice to put this import in the commit where it was useful. Makes commit history simpler to read", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461500696", "createdAt": "2020-07-28T11:10:16Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -52,6 +52,7 @@\n import com.ichi2.compat.CompatHelper;\n import com.ichi2.libanki.Consts;\n import com.ichi2.libanki.Media;\n+import com.ichi2.libanki.Decks;\n import com.ichi2.libanki.sched.AbstractSched;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "912e3993c4bbcbc6131a4cec4c47332ee7cab0af"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTU0ODEzMw==", "bodyText": "When trying to rebase I am running into some errors with other commits, I think because my branch was already merged with master. Should I reset to before the merge and then rebase and fix my commit history? Or from here shall I just commit the fixes and push? Thanks for your help", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461548133", "createdAt": "2020-07-28T12:41:31Z", "author": {"login": "KieranMigaku"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -52,6 +52,7 @@\n import com.ichi2.compat.CompatHelper;\n import com.ichi2.libanki.Consts;\n import com.ichi2.libanki.Media;\n+import com.ichi2.libanki.Decks;\n import com.ichi2.libanki.sched.AbstractSched;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMDY5Ng=="}, "originalCommit": {"oid": "912e3993c4bbcbc6131a4cec4c47332ee7cab0af"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTEwNjIwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxMTo0MFrOG4H0Cw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxMTo0MFrOG4H0Cw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMTQ1MQ==", "bodyText": "\"audio file\" ?\u00a0How do you know it's an audio file problem ?\u00a0It seems this code is not audio related.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461501451", "createdAt": "2020-07-28T11:11:40Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1046,9 +1051,58 @@ public Uri insert(Uri uri, ContentValues values) {\n             case MEDIA:\n                 // insert a media file\n                 // contentvalue should have data and preferredFileName values\n-                Uri filUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n                 String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n-                return null;\n+                InputStream inputStream = null;\n+\n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+                    // should we be enforcing strict mimetypes? which types?\n+                    File tempFile;\n+                    try {\n+                        tempFile = File.createTempFile(\n+                                preferredName+\"_\", // the beginning of the filename.\n+                                \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                                new File(media.dir())\n+                        );\n+                        tempFile.deleteOnExit();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Could not create temporary audio file. \");\n+                        return null;\n+                    }\n+\n+                    // copy contents into temp file (possibly check file size and warn if large?)\n+                    try {\n+                        CompatHelper.getCompat().copyFile(inputStream, tempFile.getAbsolutePath());\n+                    } catch (FileNotFoundException e) {\n+                        Timber.e(e, \"File not found when opening stream for supplied media file.\");\n+                        return null;\n+                    }\n+                    catch (Exception e) {\n+                        Timber.e(e, \"Unable to copy audio file from ContentProvider\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e968db654e64746f9a4d74f8901c6799cf71368"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTEwNzM0OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxMTo1OFrOG4H0sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxMTo1OFrOG4H0sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMTYxOQ==", "bodyText": "Would you please put the catch on the same line as } ?", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461501619", "createdAt": "2020-07-28T11:11:58Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1046,9 +1051,58 @@ public Uri insert(Uri uri, ContentValues values) {\n             case MEDIA:\n                 // insert a media file\n                 // contentvalue should have data and preferredFileName values\n-                Uri filUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n                 String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n-                return null;\n+                InputStream inputStream = null;\n+\n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+                    // should we be enforcing strict mimetypes? which types?\n+                    File tempFile;\n+                    try {\n+                        tempFile = File.createTempFile(\n+                                preferredName+\"_\", // the beginning of the filename.\n+                                \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                                new File(media.dir())\n+                        );\n+                        tempFile.deleteOnExit();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Could not create temporary audio file. \");\n+                        return null;\n+                    }\n+\n+                    // copy contents into temp file (possibly check file size and warn if large?)\n+                    try {\n+                        CompatHelper.getCompat().copyFile(inputStream, tempFile.getAbsolutePath());\n+                    } catch (FileNotFoundException e) {\n+                        Timber.e(e, \"File not found when opening stream for supplied media file.\");\n+                        return null;\n+                    }\n+                    catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1e968db654e64746f9a4d74f8901c6799cf71368"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4MTExNDYzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxNDowNFrOG4H5CQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMToxNDowNFrOG4H5CQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTUwMjcyOQ==", "bodyText": "Maybe you could return a boolean instead of 0 or 1", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r461502729", "createdAt": "2020-07-28T11:14:04Z", "author": {"login": "Arthur-Milchior"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +158,27 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /*\n+    You would likely implement a FileProvider in your API to share the file from your app to \"the system\" as a URI,\n+    and pass that to a new AnkiDroid-API call you implement, where it would use ContentResolver to get the display\n+    name for the file and then open an input stream for it to copy the file in to the collection, similar to the way\n+    BasicImageFieldController does it (or will do it when a PR-in-progress lands) in the internalizeUri method\n+     */\n+\n+    public int addMediaFromUri(Uri fileUri, String preferredName) {\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(AnkiMedia.FILE_URI, fileUri.toString());\n+        contentValues.put(AnkiMedia.PREFERRED_NAME, preferredName);\n+\n+        try {\n+            mResolver.insert(AnkiMedia.CONTENT_URI, contentValues);\n+            return 0;\n+        } catch (Exception e){\n+            return 1;\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a705ab5c2901707b6453ba9b7f6543f788371cc"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzIzMjYwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMDo1MFrOHCk5mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMDo1MFrOHCk5mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2Mzc3MQ==", "bodyText": "assert doesn't work in Java, it is typically a no-op but if they ever fix it, then this will crash the app which is a terrible outcome, this should be\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    assert inputStream != null;\n          \n          \n            \n                                    inputStream.close();\n          \n          \n            \n                                    if (inputStream != null) {\n          \n          \n            \n                                        inputStream.close();\n          \n          \n            \n                                    }", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r472463771", "createdAt": "2020-08-18T20:20:50Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1048,7 +1053,60 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+                InputStream inputStream = null;\n \n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+                    // should we be enforcing strict mimetypes? which types?\n+                    File tempFile;\n+                    try {\n+                        tempFile = File.createTempFile(\n+                                preferredName+\"_\", // the beginning of the filename.\n+                                \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                                new File(media.dir())\n+                        );\n+                        tempFile.deleteOnExit();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Could not create temporary media file. \");\n+                        return null;\n+                    }\n+\n+                    // copy contents into temp file (possibly check file size and warn if large?)\n+                    try {\n+                        CompatHelper.getCompat().copyFile(inputStream, tempFile.getAbsolutePath());\n+                    } catch (FileNotFoundException e) {\n+                        Timber.e(e, \"File not found when opening stream for supplied media file.\");\n+                        return null;\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Unable to copy media file from ContentProvider\");\n+                        return null;\n+                    } finally {\n+                        assert inputStream != null;\n+                        inputStream.close();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7207f523cc7d3db7304a6673691545158d2fe76d"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI0Njk5OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMzoyOVrOHClC-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMzoyOVrOHClC-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NjE3MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                e.printStackTrace();\n          \n          \n            \n                                Timber.w(e, \"insert failed from %s\", fileUri);", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r472466171", "createdAt": "2020-08-18T20:23:29Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1048,7 +1053,60 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+                InputStream inputStream = null;\n \n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+                    // should we be enforcing strict mimetypes? which types?\n+                    File tempFile;\n+                    try {\n+                        tempFile = File.createTempFile(\n+                                preferredName+\"_\", // the beginning of the filename.\n+                                \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                                new File(media.dir())\n+                        );\n+                        tempFile.deleteOnExit();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Could not create temporary media file. \");\n+                        return null;\n+                    }\n+\n+                    // copy contents into temp file (possibly check file size and warn if large?)\n+                    try {\n+                        CompatHelper.getCompat().copyFile(inputStream, tempFile.getAbsolutePath());\n+                    } catch (FileNotFoundException e) {\n+                        Timber.e(e, \"File not found when opening stream for supplied media file.\");\n+                        return null;\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Unable to copy media file from ContentProvider\");\n+                        return null;\n+                    } finally {\n+                        assert inputStream != null;\n+                        inputStream.close();\n+                    }\n+\n+                    String fname = media.addFile(tempFile);\n+                    Timber.d(\"insert -> MEDIA: fname = %s\", fname);\n+                    File f = new File(fname);\n+                    Timber.d(\"insert -> MEDIA: f = %s\", f);\n+                    Uri uriFromF = Uri.fromFile(f);\n+                    Timber.d(\"insert -> MEDIA: uriFromF = %s\", uriFromF);\n+                    return Uri.fromFile(new File(fname));\n+\n+                } catch (IOException e) {\n+                    e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7207f523cc7d3db7304a6673691545158d2fe76d"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI0OTQ0OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMzo1NVrOHClEcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyMzo1NVrOHClEcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NjU0Ng==", "bodyText": "This is a lot of code to have as a switch case, extract it to a method with parameters and call it from this case instead", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r472466546", "createdAt": "2020-08-18T20:23:55Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1048,7 +1053,60 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7207f523cc7d3db7304a6673691545158d2fe76d"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI1NjIyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/FlashCardsContract.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNTowMVrOHClIrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNTowMVrOHClIrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ2NzYzMA==", "bodyText": "All the other classes in the contract have explicit usage instructions for integrators and CONTENT_TYPEs, can you add those following the existing pattern(s) above?", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r472467630", "createdAt": "2020-08-18T20:25:01Z", "author": {"login": "mikehardy"}, "path": "api/src/main/java/com/ichi2/anki/FlashCardsContract.java", "diffHunk": "@@ -1185,4 +1185,19 @@ private FlashCardsContract() {\n         public static final String CONTENT_TYPE = \"vnd.android.cursor.dir/vnd.com.ichi2.anki.deck\";\n \n     }\n+\n+    public static class AnkiMedia {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb4577493ffd01d1dbcd5244b10ad5166ef9034d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI3MzYwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDoyNzo1OFrOHClUKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQyMTo1OToyM1rOHE-86w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MDU2OA==", "bodyText": "I wonder if any of the logic here could be re-used? https://github.com/ankidroid/Anki-Android/blob/master/AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java#L410\nThe error handling wouldn't be \"showSomethingWentWrong()\" obviously, but if the common logic could be extracted so we're not handling URI-internalizing in multiple spots that could be a win - it is very tricky stuff!", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r472470568", "createdAt": "2020-08-18T20:27:58Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1048,7 +1053,60 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+                InputStream inputStream = null;\n \n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7207f523cc7d3db7304a6673691545158d2fe76d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mzk0NjA2OA==", "bodyText": "At the moment the internalizeUri is private, and doesn't allow for user-inputted 'preferred names' for the files.\nI think it would work if we allowed a Nullable parameter String preferredName to internalizeUri, which could then be passed as a parameter when creating the internal temp file. Then this function could be called by the BasicImageFieldController and from the CardContentProvider, but I'm not sure where we should extract the internalizeUri function to, where it would be publicly available to other classes.\nThe internalizeUri function also uses another private function createNewCacheFile(@NonNull String extension) which we would also need to possibly extract into the other class where internalizeUri is called from. We could simply write another overloading function createNewCacheFile(@NonNull String extension, @NonNull String preferredName) which takes a String preferredName argument.\npublic internalizeUri(Uri uri, @Nullable String preferredName) {\n    ...\n    String internalFileName\n    if (preferredName != null) {\n        internalFileName = preferredName;\n    } else {\n        internalFileName = uriFileInfo.first; // filepath\n    }\n    ...\n}", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r473946068", "createdAt": "2020-08-20T12:53:09Z", "author": {"login": "KieranMigaku"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1048,7 +1053,60 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+                InputStream inputStream = null;\n \n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MDU2OA=="}, "originalCommit": {"oid": "7207f523cc7d3db7304a6673691545158d2fe76d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDA4NzcxNQ==", "bodyText": "If you wanted to give it a shot, https://github.com/ankidroid/Anki-Android/tree/master/AnkiDroid/src/main/java/com/ichi2/utils seems like as good a place as any to put the \"URI Internalizing utility\" that extracts the cache-creation / file copying etc logic", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r474087715", "createdAt": "2020-08-20T15:48:26Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1048,7 +1053,60 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+                InputStream inputStream = null;\n \n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MDU2OA=="}, "originalCommit": {"oid": "7207f523cc7d3db7304a6673691545158d2fe76d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk4MDI4Mg==", "bodyText": "Would https://github.com/ankidroid/Anki-Android/blob/master/AnkiDroid/src/main/java/com/ichi2/utils/FileUtil.java be a good place to put the functions? At the moment it only has one function getFreeDiskSpace, but I think 'Uri-internalizing' could make sense under FileUtil.java.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r474980282", "createdAt": "2020-08-21T21:35:50Z", "author": {"login": "KieranMigaku"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1048,7 +1053,60 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+                InputStream inputStream = null;\n \n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MDU2OA=="}, "originalCommit": {"oid": "7207f523cc7d3db7304a6673691545158d2fe76d"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDk4Nzc1NQ==", "bodyText": "Yeah, that seems like a fine spot", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r474987755", "createdAt": "2020-08-21T21:59:23Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1048,7 +1053,60 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+                String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+                InputStream inputStream = null;\n \n+                try {\n+                    ContentResolver cR = mContext.getContentResolver();\n+                    Media media = col.getMedia();\n+                    // idea, open input stream and save to cache directory, then\n+                    // pass this (hopefully temporary) file to the media.addFile function.\n+                    inputStream = cR.openInputStream(fileUri);\n+                    String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MDU2OA=="}, "originalCommit": {"oid": "7207f523cc7d3db7304a6673691545158d2fe76d"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzI4NjM1OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDozMDoxM1rOHClcfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDozMDoxM1rOHClcfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3MjcwMg==", "bodyText": "Should protect these from being sent in null as they are accessed blindly, and I think the method can be private so you don't have to worry as much about API contracts as it won't be exposed to other objects. Can return null so should be marked as such as well\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public String formatMediaName(String fname, String mimeType) {\n          \n          \n            \n                private @Nullable String formatMediaName(@NonNull String fname, @NonNull String mimeType) {", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r472472702", "createdAt": "2020-08-18T20:30:13Z", "author": {"login": "mikehardy"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +158,47 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added.\n+     * @param preferredName String that will be added to the beginning of the file name in the media collection\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\"\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card.\n+     */\n+    public String addMediaFromUri(Uri fileUri, String preferredName, String mimeType) {\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(AnkiMedia.FILE_URI, fileUri.toString());\n+        preferredName = preferredName.replace(\" \", \"_\");\n+        contentValues.put(AnkiMedia.PREFERRED_NAME, preferredName);\n+\n+        try {\n+            Uri returnUri = mResolver.insert(AnkiMedia.CONTENT_URI, contentValues);\n+            // get the filename from Uri, return [sound:%s] % file.getName()\n+            String fname = new File(returnUri.getPath()).toString();\n+            String formatted_fname = formatMediaName(fname, mimeType);\n+            return formatted_fname;\n+        } catch (Exception e){\n+            return null;\n+        }\n+\n+    }\n+\n+    public String formatMediaName(String fname, String mimeType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c20248feaf961a65a5c8480c12342018fe8ee5d5"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk1MzMwMTQzOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQyMDozMjo1M1rOHClmOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOVQxOTowOTozN1rOHDVbRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3NTE5NQ==", "bodyText": "Should mark it up with expectations on what can be null and what can't both in docs and as annotations, to guard against crashes - those are common sources of crashes for us\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param fileUri   Uri for the file to be added.\n          \n          \n            \n                 * @param preferredName String that will be added to the beginning of the file name in the media collection\n          \n          \n            \n                 * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\"\n          \n          \n            \n                 * @return the correctly formatted String for the media file to be placed in the desired field of a Card.\n          \n          \n            \n                 */\n          \n          \n            \n                public String addMediaFromUri(Uri fileUri, String preferredName, String mimeType) {\n          \n          \n            \n                 * @param fileUri  Uri for the file to be added, required.\n          \n          \n            \n                 * @param preferredName String that will be added to the beginning of the file name in the media collection, required\n          \n          \n            \n                 * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\", required\n          \n          \n            \n                 * @return the correctly formatted String for the media file to be placed in the desired field of a Card or null if unsuccessful.\n          \n          \n            \n                 */\n          \n          \n            \n                public @Nullable String addMediaFromUri(@NonNull Uri fileUri, @NonNull String preferredName, @NonNull String mimeType) {", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r472475195", "createdAt": "2020-08-18T20:32:53Z", "author": {"login": "mikehardy"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +158,47 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added.\n+     * @param preferredName String that will be added to the beginning of the file name in the media collection\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\"\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card.\n+     */\n+    public String addMediaFromUri(Uri fileUri, String preferredName, String mimeType) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c20248feaf961a65a5c8480c12342018fe8ee5d5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzE2ODc1Ng==", "bodyText": "When I apply the annotations it shows a warning and gives me some options:\n\"Add 'annotations' to classpath\", and\n\"Add dependency on androidx.annotation:annotation\"\nBoth of these edit the build.gradle file for api so I'm wondering what I should do here?", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r473168756", "createdAt": "2020-08-19T16:35:46Z", "author": {"login": "KieranMigaku"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +158,47 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added.\n+     * @param preferredName String that will be added to the beginning of the file name in the media collection\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\"\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card.\n+     */\n+    public String addMediaFromUri(Uri fileUri, String preferredName, String mimeType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3NTE5NQ=="}, "originalCommit": {"oid": "c20248feaf961a65a5c8480c12342018fe8ee5d5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI1ODgyMw==", "bodyText": "Oh interesting! The API module hasn't gotten much love in a while and I guess we just hadn't used annotations there yet. Great question, thank you for asking. Adding those to the build.gradle is the right thing to do", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r473258823", "createdAt": "2020-08-19T19:09:37Z", "author": {"login": "mikehardy"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +158,47 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added.\n+     * @param preferredName String that will be added to the beginning of the file name in the media collection\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\"\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card.\n+     */\n+    public String addMediaFromUri(Uri fileUri, String preferredName, String mimeType) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjQ3NTE5NQ=="}, "originalCommit": {"oid": "c20248feaf961a65a5c8480c12342018fe8ee5d5"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA4MzgxOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/utils/FileUtil.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOToxNTowNlrOHFPPMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODo0ODoyNVrOHJRB5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDU3OQ==", "bodyText": "This doesn't necessarily point to the cache - questionable naming", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r475254579", "createdAt": "2020-08-23T19:15:06Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/utils/FileUtil.java", "diffHunk": "@@ -18,4 +32,54 @@ public static long getFreeDiskSpace(File file, long defaultValue) {\n             return defaultValue;\n         }\n     }\n+\n+    public static File createNewCacheFile(\n+            @NonNull File storageDir, @NonNull String preferredName, @NonNull String extension\n+    ) throws IOException {\n+        return File.createTempFile(preferredName, \".\" + extension, storageDir);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzNjY5NA==", "bodyText": "This was here simply for when extracting the internalizeUri method into the FileUtil class. In hindsight I see no use for this method actually and it would probably be better to simply create the tempFiles as and when they are needed but I could be wrong. What do you think?", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r478536694", "createdAt": "2020-08-27T16:13:36Z", "author": {"login": "KieranMigaku"}, "path": "AnkiDroid/src/main/java/com/ichi2/utils/FileUtil.java", "diffHunk": "@@ -18,4 +32,54 @@ public static long getFreeDiskSpace(File file, long defaultValue) {\n             return defaultValue;\n         }\n     }\n+\n+    public static File createNewCacheFile(\n+            @NonNull File storageDir, @NonNull String preferredName, @NonNull String extension\n+    ) throws IOException {\n+        return File.createTempFile(preferredName, \".\" + extension, storageDir);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDU3OQ=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3ODI0NQ==", "bodyText": "Seems best to inline and remove the method", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r479478245", "createdAt": "2020-08-28T18:48:25Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/utils/FileUtil.java", "diffHunk": "@@ -18,4 +32,54 @@ public static long getFreeDiskSpace(File file, long defaultValue) {\n             return defaultValue;\n         }\n     }\n+\n+    public static File createNewCacheFile(\n+            @NonNull File storageDir, @NonNull String preferredName, @NonNull String extension\n+    ) throws IOException {\n+        return File.createTempFile(preferredName, \".\" + extension, storageDir);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDU3OQ=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA4NDY3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOToxNjoyMFrOHFPPng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxOTozNDozOVrOHJSOvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDY4Ng==", "bodyText": "Why are we using the media directory here? Shouldn't we be using a temp dir to ensure this doesn't interfere with syncing", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r475254686", "createdAt": "2020-08-23T19:16:20Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+            // should we be enforcing strict mimetypes? which types?\n+            File tempFile;\n+            try {\n+                tempFile = File.createTempFile(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ5NzkxOQ==", "bodyText": "I've changed this now to create a \"temp-media\" folder the same as how its done here: https://github.com/ankidroid/Anki-Android/blob/master/AnkiDroid/src/main/java/com/ichi2/anki/multimediacard/fields/BasicImageFieldController.java#L157", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r479497919", "createdAt": "2020-08-28T19:34:39Z", "author": {"login": "KieranMigaku"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+            // should we be enforcing strict mimetypes? which types?\n+            File tempFile;\n+            try {\n+                tempFile = File.createTempFile(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDY4Ng=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA4NTM1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOToxNjo1OFrOHFPP5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODo0OTowOVrOHJRC8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDc1OQ==", "bodyText": "I can see a use case of allowing the caller to pass in the file extension as an override. Was this not required for your use case?", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r475254759", "createdAt": "2020-08-23T19:16:58Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzOTA0NQ==", "bodyText": "For my use case the file that is sent by the client is provided by a File Picker. The extension used is taken from the file itself (the one supplied by the user).\nI have no idea but overriding the extension might cause problems if the client/user supplies an incorrect extension that doesn't work for the file they uploaded.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r478539045", "createdAt": "2020-08-27T16:17:16Z", "author": {"login": "KieranMigaku"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDc1OQ=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3ODUxMw==", "bodyText": "Okay - we should be able to add it in in a backwards-compatible manner if requested.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r479478513", "createdAt": "2020-08-28T18:49:09Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDc1OQ=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA4NTYzOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOToxNzozMVrOHFPQCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yOFQxODowMDowM1rOHJPsaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDc5NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            Timber.e(e, \"Could not create temporary media file. \");\n          \n          \n            \n                            Timber.w(e, \"Could not create temporary media file. \");", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r475254795", "createdAt": "2020-08-23T19:17:31Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+            // should we be enforcing strict mimetypes? which types?\n+            File tempFile;\n+            try {\n+                tempFile = File.createTempFile(\n+                        preferredName+\"_\", // the beginning of the filename.\n+                        \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                        new File(media.dir())\n+                );\n+                tempFile.deleteOnExit();\n+            } catch (Exception e) {\n+                Timber.e(e, \"Could not create temporary media file. \");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NTg5NA==", "bodyText": "Should I change all of the catch blocks here to warnings or just this one? I'll just change this one for now.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r479455894", "createdAt": "2020-08-28T17:59:03Z", "author": {"login": "KieranMigaku"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+            // should we be enforcing strict mimetypes? which types?\n+            File tempFile;\n+            try {\n+                tempFile = File.createTempFile(\n+                        preferredName+\"_\", // the beginning of the filename.\n+                        \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                        new File(media.dir())\n+                );\n+                tempFile.deleteOnExit();\n+            } catch (Exception e) {\n+                Timber.e(e, \"Could not create temporary media file. \");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDc5NQ=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ1NjM2Mw==", "bodyText": "Nevermind that was a brain fart haha.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r479456363", "createdAt": "2020-08-28T18:00:03Z", "author": {"login": "KieranMigaku"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+            // should we be enforcing strict mimetypes? which types?\n+            File tempFile;\n+            try {\n+                tempFile = File.createTempFile(\n+                        preferredName+\"_\", // the beginning of the filename.\n+                        \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                        new File(media.dir())\n+                );\n+                tempFile.deleteOnExit();\n+            } catch (Exception e) {\n+                Timber.e(e, \"Could not create temporary media file. \");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NDc5NQ=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA4ODI1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOToyMToxMVrOHFPRYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNDo0MVrOHaiIyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NTEzNg==", "bodyText": "This returns a file:// URI. Will this work on later APIs? Can we provide this via a FileProvider instead?", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r475255136", "createdAt": "2020-08-23T19:21:11Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+            // should we be enforcing strict mimetypes? which types?\n+            File tempFile;\n+            try {\n+                tempFile = File.createTempFile(\n+                        preferredName+\"_\", // the beginning of the filename.\n+                        \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                        new File(media.dir())\n+                );\n+                tempFile.deleteOnExit();\n+            } catch (Exception e) {\n+                Timber.e(e, \"Could not create temporary media file. \");\n+                return null;\n+            }\n+\n+            FileUtil.internalizeUri(fileUri, null, tempFile, cR);\n+\n+            String fname = media.addFile(tempFile);\n+            Timber.d(\"insert -> MEDIA: fname = %s\", fname);\n+            File f = new File(fname);\n+            Timber.d(\"insert -> MEDIA: f = %s\", f);\n+            Uri uriFromF = Uri.fromFile(f);\n+            Timber.d(\"insert -> MEDIA: uriFromF = %s\", uriFromF);\n+            return Uri.fromFile(new File(fname));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4NDMyOQ==", "bodyText": "I believe file:// URIs will always work on all APIs if you guarantee that you created a real file that you control so you have filesystem access, which we are doing here. The complexity in file handling on Android is that \"files\" can come in to you (from other apps) that are maybe security protected or ephemeral requiring ContentResolver / FileProvider work, but if you are creating a real file in your space you can just use the regular file APIs. That's my understanding", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r497584329", "createdAt": "2020-09-30T15:04:41Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/anki/provider/CardContentProvider.java", "diffHunk": "@@ -1038,12 +1056,59 @@ public Uri insert(Uri uri, ContentValues values) {\n             case DECKS_ID:\n                 // Deck ID is generated automatically by libanki\n                 throw new IllegalArgumentException(\"Not possible to insert deck with specific ID\");\n+            case MEDIA:\n+                // insert a media file\n+                // contentvalue should have data and preferredFileName values\n+                return insertMediaFile(values, col);\n             default:\n                 // Unknown URI type\n                 throw new IllegalArgumentException(\"uri \" + uri + \" is not supported\");\n         }\n     }\n \n+    private Uri insertMediaFile(ContentValues values, Collection col) {\n+        // Insert media file using libanki.Media.addFile and return Uri for the inserted file.\n+        Uri fileUri = Uri.parse(values.getAsString(FlashCardsContract.AnkiMedia.FILE_URI));\n+        String preferredName = values.getAsString(FlashCardsContract.AnkiMedia.PREFERRED_NAME);\n+\n+\n+        try {\n+            ContentResolver cR = mContext.getContentResolver();\n+            Media media = col.getMedia();\n+            // idea, open input stream and save to cache directory, then\n+            // pass this (hopefully temporary) file to the media.addFile function.\n+\n+            String fileMimeType = MimeTypeMap.getSingleton().getExtensionFromMimeType(cR.getType(fileUri)); // return eg \"jpeg\"\n+            // should we be enforcing strict mimetypes? which types?\n+            File tempFile;\n+            try {\n+                tempFile = File.createTempFile(\n+                        preferredName+\"_\", // the beginning of the filename.\n+                        \".\" + fileMimeType, // this is the extension, if null, '.tmp' is used, need to get the extension from MIME type?\n+                        new File(media.dir())\n+                );\n+                tempFile.deleteOnExit();\n+            } catch (Exception e) {\n+                Timber.e(e, \"Could not create temporary media file. \");\n+                return null;\n+            }\n+\n+            FileUtil.internalizeUri(fileUri, null, tempFile, cR);\n+\n+            String fname = media.addFile(tempFile);\n+            Timber.d(\"insert -> MEDIA: fname = %s\", fname);\n+            File f = new File(fname);\n+            Timber.d(\"insert -> MEDIA: f = %s\", f);\n+            Uri uriFromF = Uri.fromFile(f);\n+            Timber.d(\"insert -> MEDIA: uriFromF = %s\", uriFromF);\n+            return Uri.fromFile(new File(fname));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NTEzNg=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA5NTU3OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOTozMDoyOVrOHFPU1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wNFQxOToxMjo0MVrOHcJkAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjAyMA==", "bodyText": "Should the URI be guaranteed to be a file? I feel it will better to return a content:// URI so the calling app doesn't requires file system access.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r475256020", "createdAt": "2020-08-23T19:30:29Z", "author": {"login": "david-allison-1"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +161,51 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added, required.\n+     * @param preferredName String that will be added to the beginning of the file name in the\n+     *                      media collection, required.\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\", required.\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card, or null\n+     *          if unsuccessful.\n+     */\n+    public @Nullable String addMediaFromUri(\n+            @NotNull Uri fileUri, @NotNull String preferredName, @NotNull String mimeType\n+    ) {\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(AnkiMedia.FILE_URI, fileUri.toString());\n+        preferredName = preferredName.replace(\" \", \"_\");\n+        contentValues.put(AnkiMedia.PREFERRED_NAME, preferredName);\n+\n+        try {\n+            Uri returnUri = mResolver.insert(AnkiMedia.CONTENT_URI, contentValues);\n+            // get the filename from Uri, return [sound:%s] % file.getName()\n+            String fname = new File(returnUri.getPath()).toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU5MTYxNQ==", "bodyText": "This one is a big deal if I am reading it correctly. The reason to add the file insert API is because we will soon be forced to observe restricted filesystem access between apps - AnkiDroid API users won't be able to just drop files in - that is understood I think. The symmetrical statement is that AnkiDroid API users won't be able to access the files after adding them via filename I don't think.\nIf the intention here is just to have the filename that AnkiDroid can reliably use to display the file during review, that will work for AnkiDroid even though it is collection-internal and not available to other apps, this is fine for me\nIt may be that when getting card contents from AnkiDroid API, there needs to be some translation of all collection-internal media to a real FileProvider API with content URIs etc, and it may be that's a separate thing, I'm not sure how that is handled now", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r497591615", "createdAt": "2020-09-30T15:14:05Z", "author": {"login": "mikehardy"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +161,51 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added, required.\n+     * @param preferredName String that will be added to the beginning of the file name in the\n+     *                      media collection, required.\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\", required.\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card, or null\n+     *          if unsuccessful.\n+     */\n+    public @Nullable String addMediaFromUri(\n+            @NotNull Uri fileUri, @NotNull String preferredName, @NotNull String mimeType\n+    ) {\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(AnkiMedia.FILE_URI, fileUri.toString());\n+        preferredName = preferredName.replace(\" \", \"_\");\n+        contentValues.put(AnkiMedia.PREFERRED_NAME, preferredName);\n+\n+        try {\n+            Uri returnUri = mResolver.insert(AnkiMedia.CONTENT_URI, contentValues);\n+            // get the filename from Uri, return [sound:%s] % file.getName()\n+            String fname = new File(returnUri.getPath()).toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjAyMA=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI2NTYwOA==", "bodyText": "I'm not sure I'm following 100%, but just to state what I can: my intention is to return the filename of the inserted media file to the user as a string, for instance \"332495_1377171239635.mp3\". Then they can use this when inserting a card so, for example a vocab card for languages, they would also like to insert the audio file for vocab so they can add to an audio field [sound:332495_1377171239635.mp3].\nFor API users that would simply like to insert media files and be done with it, for example static files that will be inserted and 'forgotten' about (I think this is what is needed for #6971 ), then the returned filename wouldn't be needed.\nIn terms of the File part, this was more just the only way I could find to retrieve the filename from the Uri, and it was a Uri simply because that is what the ContentProvider.insert call returns. Perhaps just having a different method in the ContentProvider for inserting a media file and having that method return the inserted String fname would get around this more cleanly.\nI agree that to make this more rigorous it could be a case of making a separate ContentProvider that handles interactions with the anki Media collection. For example this could provide access to querying content URIs from the media collection, as well as inserting files and perhaps other methods as necessary.\nI've only been doing android for about 4 months so I'm not entirely sure, but hopefully this helps explain what was intended with the code in this part.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r499265608", "createdAt": "2020-10-04T16:47:34Z", "author": {"login": "KieranMigaku"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +161,51 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added, required.\n+     * @param preferredName String that will be added to the beginning of the file name in the\n+     *                      media collection, required.\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\", required.\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card, or null\n+     *          if unsuccessful.\n+     */\n+    public @Nullable String addMediaFromUri(\n+            @NotNull Uri fileUri, @NotNull String preferredName, @NotNull String mimeType\n+    ) {\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(AnkiMedia.FILE_URI, fileUri.toString());\n+        preferredName = preferredName.replace(\" \", \"_\");\n+        contentValues.put(AnkiMedia.PREFERRED_NAME, preferredName);\n+\n+        try {\n+            Uri returnUri = mResolver.insert(AnkiMedia.CONTENT_URI, contentValues);\n+            // get the filename from Uri, return [sound:%s] % file.getName()\n+            String fname = new File(returnUri.getPath()).toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjAyMA=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTI3ODg0OA==", "bodyText": "I think that falls under the path that resulted in \"this is fine for me\" :-)", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r499278848", "createdAt": "2020-10-04T19:12:41Z", "author": {"login": "mikehardy"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +161,51 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added, required.\n+     * @param preferredName String that will be added to the beginning of the file name in the\n+     *                      media collection, required.\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\", required.\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card, or null\n+     *          if unsuccessful.\n+     */\n+    public @Nullable String addMediaFromUri(\n+            @NotNull Uri fileUri, @NotNull String preferredName, @NotNull String mimeType\n+    ) {\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(AnkiMedia.FILE_URI, fileUri.toString());\n+        preferredName = preferredName.replace(\" \", \"_\");\n+        contentValues.put(AnkiMedia.PREFERRED_NAME, preferredName);\n+\n+        try {\n+            Uri returnUri = mResolver.insert(AnkiMedia.CONTENT_URI, contentValues);\n+            // get the filename from Uri, return [sound:%s] % file.getName()\n+            String fname = new File(returnUri.getPath()).toString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjAyMA=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA5NTgyOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOTozMDo1N1rOHFPU8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yN1QxNjowNjo0OVrOHIXTWA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA1MQ==", "bodyText": "It would likely be better to return the filename as well as the content URI (not sure if this is possible, but I expect it should be) - it will remove the need to potentially janky URI handling.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r475256051", "createdAt": "2020-08-23T19:30:57Z", "author": {"login": "david-allison-1"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +161,51 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added, required.\n+     * @param preferredName String that will be added to the beginning of the file name in the\n+     *                      media collection, required.\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\", required.\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card, or null\n+     *          if unsuccessful.\n+     */\n+    public @Nullable String addMediaFromUri(\n+            @NotNull Uri fileUri, @NotNull String preferredName, @NotNull String mimeType\n+    ) {\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(AnkiMedia.FILE_URI, fileUri.toString());\n+        preferredName = preferredName.replace(\" \", \"_\");\n+        contentValues.put(AnkiMedia.PREFERRED_NAME, preferredName);\n+\n+        try {\n+            Uri returnUri = mResolver.insert(AnkiMedia.CONTENT_URI, contentValues);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODUzMjQ0MA==", "bodyText": "The insert method of the CardContentProvider currently only returns a Uri.\nWhat I wanted was  return the String filename to the user so they can simply add this / append this string to one of the fields they would like to add.\nSo what I have done is:\n(CardContentProvider.java lines 1098-1104) - convert the File fname returned by media.addFile(tempFile) to a Uri and return this from the insert call.\n(AddContentApi.java lines 187-189) - Convert this from Uri to File to String and then format the string and return this to the user.\nSo essentially I would like to just return the filename straight away, but the Uri was the only way I could see around it.\nI'm not sure of a better solution for this, but I can edit in a suggestion if you have one.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r478532440", "createdAt": "2020-08-27T16:06:49Z", "author": {"login": "KieranMigaku"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +161,51 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added, required.\n+     * @param preferredName String that will be added to the beginning of the file name in the\n+     *                      media collection, required.\n+     * @param mimeType  String indicating the mimeType of the media. Accepts \"audio\" or \"image\", required.\n+     * @return the correctly formatted String for the media file to be placed in the desired field of a Card, or null\n+     *          if unsuccessful.\n+     */\n+    public @Nullable String addMediaFromUri(\n+            @NotNull Uri fileUri, @NotNull String preferredName, @NotNull String mimeType\n+    ) {\n+        ContentValues contentValues = new ContentValues();\n+        contentValues.put(AnkiMedia.FILE_URI, fileUri.toString());\n+        preferredName = preferredName.replace(\" \", \"_\");\n+        contentValues.put(AnkiMedia.PREFERRED_NAME, preferredName);\n+\n+        try {\n+            Uri returnUri = mResolver.insert(AnkiMedia.CONTENT_URI, contentValues);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjA1MQ=="}, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk3MTA5NzYxOnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOTozMzoyNFrOHFPV1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yM1QxOTozMzoyNFrOHFPV1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTI1NjI3Ng==", "bodyText": "Give an example - many people would include the extension here.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r475256276", "createdAt": "2020-08-23T19:33:24Z", "author": {"login": "david-allison-1"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +161,51 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     * getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION) and then afterward\n+     * remove the permission with getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     * @param fileUri   Uri for the file to be added, required.\n+     * @param preferredName String that will be added to the beginning of the file name in the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ce815547847110b28b395642ca8c896ccb2ecb5a"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMDQ2MzAyOnYy", "diffSide": "RIGHT", "path": "api/build.gradle", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxODo0MTo1NVrOHOGLuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wN1QxODo1NToxOVrOHOGUhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0MzQxOQ==", "bodyText": "Don't update robolectric version yet! That one is a really really hard upgrade - I'm working on it already in #7015 and it's a mess\nIn general don't mess with the dependencies, just leave those where they are in master\nI don't blame for your trying, just that this one in particular is a mess :-)", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r484543419", "createdAt": "2020-09-07T18:41:55Z", "author": {"login": "mikehardy"}, "path": "api/build.gradle", "diffHunk": "@@ -50,9 +50,9 @@ apply from: \"../lint.gradle\"\n \n dependencies {\n     api fileTree(dir: 'libs', include: ['*.jar'])\n-    implementation 'org.jetbrains:annotations:15.0'\n+    implementation 'org.jetbrains:annotations:20.0.0'\n     testImplementation 'org.junit.vintage:junit-vintage-engine:5.6.2'\n-    testImplementation 'org.robolectric:robolectric:4.3.1'\n+    testImplementation 'org.robolectric:robolectric:4.4'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a3b55b1a6ddfa3f823f66ae9e4c771a1b395a8d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NDIyNA==", "bodyText": "OK, thanks for catching this so quickly. I was trying to fix the reason the CI failed, and I was just going to make the change and then comment for input. I'll revert that now, although I'm not sure what to do about the fail.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r484544224", "createdAt": "2020-09-07T18:47:07Z", "author": {"login": "KieranMigaku"}, "path": "api/build.gradle", "diffHunk": "@@ -50,9 +50,9 @@ apply from: \"../lint.gradle\"\n \n dependencies {\n     api fileTree(dir: 'libs', include: ['*.jar'])\n-    implementation 'org.jetbrains:annotations:15.0'\n+    implementation 'org.jetbrains:annotations:20.0.0'\n     testImplementation 'org.junit.vintage:junit-vintage-engine:5.6.2'\n-    testImplementation 'org.robolectric:robolectric:4.3.1'\n+    testImplementation 'org.robolectric:robolectric:4.4'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0MzQxOQ=="}, "originalCommit": {"oid": "4a3b55b1a6ddfa3f823f66ae9e4c771a1b395a8d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NDQ3Mg==", "bodyText": "For now I'm just going to update it to the upstream, since at time of writing it is 147 commits behind", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r484544472", "createdAt": "2020-09-07T18:48:38Z", "author": {"login": "KieranMigaku"}, "path": "api/build.gradle", "diffHunk": "@@ -50,9 +50,9 @@ apply from: \"../lint.gradle\"\n \n dependencies {\n     api fileTree(dir: 'libs', include: ['*.jar'])\n-    implementation 'org.jetbrains:annotations:15.0'\n+    implementation 'org.jetbrains:annotations:20.0.0'\n     testImplementation 'org.junit.vintage:junit-vintage-engine:5.6.2'\n-    testImplementation 'org.robolectric:robolectric:4.3.1'\n+    testImplementation 'org.robolectric:robolectric:4.4'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0MzQxOQ=="}, "originalCommit": {"oid": "4a3b55b1a6ddfa3f823f66ae9e4c771a1b395a8d"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0NTY3MA==", "bodyText": "that could help - and to be forward-compatible with regard to Robolectric, the main change between 4.3.1 and 4.4 for tests is LooperMode.PAUSED - if you did that you'd get the benefit of 4.4's changes for the most part. The difficult parts that are separate are that it requires JDK9+ (ouch! all devs and CI need changes) and forces PAUSED looper mode for all tests (major timing issues)", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r484545670", "createdAt": "2020-09-07T18:55:19Z", "author": {"login": "mikehardy"}, "path": "api/build.gradle", "diffHunk": "@@ -50,9 +50,9 @@ apply from: \"../lint.gradle\"\n \n dependencies {\n     api fileTree(dir: 'libs', include: ['*.jar'])\n-    implementation 'org.jetbrains:annotations:15.0'\n+    implementation 'org.jetbrains:annotations:20.0.0'\n     testImplementation 'org.junit.vintage:junit-vintage-engine:5.6.2'\n-    testImplementation 'org.robolectric:robolectric:4.3.1'\n+    testImplementation 'org.robolectric:robolectric:4.4'", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDU0MzQxOQ=="}, "originalCommit": {"oid": "4a3b55b1a6ddfa3f823f66ae9e4c771a1b395a8d"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzExNTA3MjM2OnYy", "diffSide": "RIGHT", "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNzo1MlrOHaiSZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0zMFQxNTowNzo1MlrOHaiSZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4Njc4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param preferredName String that will be added to the beginning of the file name in the\n          \n          \n            \n                 *                      media collection, required.\n          \n          \n            \n                 * @param preferredName String to add to start of filename (do not use a file extension), required.", "url": "https://github.com/ankidroid/Anki-Android/pull/6641#discussion_r497586788", "createdAt": "2020-09-30T15:07:52Z", "author": {"login": "mikehardy"}, "path": "api/src/main/java/com/ichi2/anki/api/AddContentApi.java", "diffHunk": "@@ -151,6 +161,76 @@ public int addNotes(long modelId, long deckId, List<String[]> fieldsList, List<S\n         return getCompat().insertNotes(deckId, newNoteValuesList.toArray(new ContentValues[newNoteValuesList.size()]));\n     }\n \n+    /**\n+     * Add a media file to AnkiDroid's media collection. You would likely supply this uri through a FileProvider, and\n+     * then set FLAG_GRANT_READ_URI_PERMISSION using something like:\n+     *\n+     * <pre>\n+     *     <code>\n+     *     getContext().grantUriPermission(\"com.ichi2.anki\", uri, Intent.FLAG_GRANT_READ_URI_PERMISSION)\n+     *     // Then when file is added, remove the permission\n+     *     // add File ...\n+     *     getContext().revokePermission(uri, Intent.FLAG_GRAN_READ_URI_PERMISSION)\n+     *     </code>\n+     * </pre>\n+     *\n+     * Example usage:\n+     *  <pre>\n+     *      <code>\n+     *      Long modelId = getModelId(); // implementation can be seen in api sample app\n+     *      Long deckId = getDeckId(); // as above\n+     *      Set&lt;String&gt; tags = getTags(); // as above\n+     *      Uri fileUri = ... // this will be returned by a File Picker activity where we select an image file\n+     *      String addedImageFileName = mApi.addMediaFromUri(fileUri, \"My_Image_File\", \"image\");\n+     *\n+     *      String[] fields = new String[] {\"text on front of card\", \"text on back of card \" + addedImageFileName};\n+     *      mApi.addNote(modelId, deckId, fields, tags)\n+     *      </code>\n+     *  </pre>\n+     *\n+     *\n+     *\n+     *\n+     * @param fileUri   Uri for the file to be added, required.\n+     * @param preferredName String that will be added to the beginning of the file name in the\n+     *                      media collection, required.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aebca21534e378125173b7e5346d24df664f6170"}, "originalPosition": 61}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 109, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}