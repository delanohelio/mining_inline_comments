{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyMDg5NDI2", "number": 5854, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQyMzoyMzozMlrODqM3cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzowNDoyMlrODq4xsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTc3NTg1OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQyMzoyMzozMlrOF5zm-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQyMzoyMzozMlrOF5zm-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjE1ODcxMw==", "bodyText": "This allows us to perform pre, and post- actions around any check.", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r396158713", "createdAt": "2020-03-22T23:23:32Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,182 +1608,44 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n+                    try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "442128983578751f02c990e8ee238483ca3794b5"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MTc1NzI2OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMjozNTozOFrOF6uLgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxMzo0MDo0N1rOF6wr9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExODMzNg==", "bodyText": "I don't think this will advance us on the \"it's an OOM / fields value greater than limit\" theory unless you include the total row count and the row you are on. Idea being that if it's a non-zero row count but we are on the first row every time, there's something structural going on, but if any of them are non-zero it indicates that things are mostly working but there are problematic rows out there and it's much more likely it's the overflow similar to the templates which needed a conversion to chunk loading", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397118336", "createdAt": "2020-03-24T12:35:38Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1852,25 +1852,35 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n \n \n     private ArrayList<String> deleteNotesWithWrongFieldCounts(Runnable notifyProgress, JSONObject m) throws JSONException {\n+        Timber.d(\"deleteNotesWithWrongFieldCounts\");\n         ArrayList<String> problems = new ArrayList<>();\n         ArrayList<Long> ids;// notes with invalid field counts\n         ids = new ArrayList<>();\n         Cursor cur = null;\n         try {\n             notifyProgress.run();\n             cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n+            Timber.d(\"cursor size: %d\", cur.getCount());\n+            int rowCount = 0;\n             while (cur.moveToNext()) {\n-                String flds = cur.getString(1);\n-                long id = cur.getLong(0);\n-                int fldsCount = 0;\n-                for (int i = 0; i < flds.length(); i++) {\n-                    if (flds.charAt(i) == 0x1f) {\n-                        fldsCount++;\n+                try {\n+                    Timber.d(\"Handling row: %d. Columns: %d\", rowCount, cur.getColumnCount());\n+                    String flds = cur.getString(1);\n+                    long id = cur.getLong(0);\n+                    int fldsCount = 0;\n+                    for (int i = 0; i < flds.length(); i++) {\n+                        if (flds.charAt(i) == 0x1f) {\n+                            fldsCount++;\n+                        }\n                     }\n+                    if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n+                        ids.add(id);\n+                    }\n+                } catch (IllegalStateException ex) {\n+                    // DEFECT: Theory that is this an OOM is discussed in #5852\n+                    AnkiDroidApp.sendExceptionReport(ex, \"deleteNotesWithWrongFieldCounts\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5096ac4fc98fa19104b933138a4fa8eceae57c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzMTY3MA==", "bodyText": "I'm logging with Timber.d above.\nBut: I intended to ask whether it was OK to perform this inside a while loop, and if so, would including different parameters inside the context cause an issue with deduplication?", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397131670", "createdAt": "2020-03-24T12:58:18Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1852,25 +1852,35 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n \n \n     private ArrayList<String> deleteNotesWithWrongFieldCounts(Runnable notifyProgress, JSONObject m) throws JSONException {\n+        Timber.d(\"deleteNotesWithWrongFieldCounts\");\n         ArrayList<String> problems = new ArrayList<>();\n         ArrayList<Long> ids;// notes with invalid field counts\n         ids = new ArrayList<>();\n         Cursor cur = null;\n         try {\n             notifyProgress.run();\n             cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n+            Timber.d(\"cursor size: %d\", cur.getCount());\n+            int rowCount = 0;\n             while (cur.moveToNext()) {\n-                String flds = cur.getString(1);\n-                long id = cur.getLong(0);\n-                int fldsCount = 0;\n-                for (int i = 0; i < flds.length(); i++) {\n-                    if (flds.charAt(i) == 0x1f) {\n-                        fldsCount++;\n+                try {\n+                    Timber.d(\"Handling row: %d. Columns: %d\", rowCount, cur.getColumnCount());\n+                    String flds = cur.getString(1);\n+                    long id = cur.getLong(0);\n+                    int fldsCount = 0;\n+                    for (int i = 0; i < flds.length(); i++) {\n+                        if (flds.charAt(i) == 0x1f) {\n+                            fldsCount++;\n+                        }\n                     }\n+                    if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n+                        ids.add(id);\n+                    }\n+                } catch (IllegalStateException ex) {\n+                    // DEFECT: Theory that is this an OOM is discussed in #5852\n+                    AnkiDroidApp.sendExceptionReport(ex, \"deleteNotesWithWrongFieldCounts\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExODMzNg=="}, "originalCommit": {"oid": "fc5096ac4fc98fa19104b933138a4fa8eceae57c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzEzODA5Ng==", "bodyText": "If the message is different it will likely not de-duplicate, but...I think more info will be worth it in this case. (does it happen for every row for a person? only one row?). People don't normally have that many templates and we'll learn fast on a beta release I think.\nTimber.d will not log debug in release builds, it will be Timber.i and up only on release builds:\n\n  \n    \n      Anki-Android/AnkiDroid/src/main/java/com/ichi2/anki/AnkiDroidApp.java\n    \n    \n        Lines 204 to 213\n      in\n      a2f8c09\n    \n    \n    \n    \n\n        \n          \n           if (BuildConfig.DEBUG) { \n        \n\n        \n          \n               // Enable verbose error logging and do method tracing to put the Class name as log tag \n        \n\n        \n          \n               Timber.plant(new DebugTree()); \n        \n\n        \n          \n            \n        \n\n        \n          \n               setDebugACRAConfig(preferences); \n        \n\n        \n          \n           } else { \n        \n\n        \n          \n               Timber.plant(new ProductionCrashReportingTree()); \n        \n\n        \n          \n               setProductionACRAConfig(preferences); \n        \n\n        \n          \n           } \n        \n\n        \n          \n           Timber.tag(TAG); \n        \n    \n  \n\n\nand the ProductionCrashReportTree.log impl:\n\n  \n    \n      Anki-Android/AnkiDroid/src/main/java/com/ichi2/anki/AnkiDroidApp.java\n    \n    \n        Lines 503 to 509\n      in\n      a2f8c09\n    \n    \n    \n    \n\n        \n          \n           protected void log(int priority, String tag, @NonNull String message, Throwable t) { \n        \n\n        \n          \n            \n        \n\n        \n          \n               switch (priority) { \n        \n\n        \n          \n                   case Log.VERBOSE: \n        \n\n        \n          \n                   case Log.DEBUG: \n        \n\n        \n          \n                       break;", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397138096", "createdAt": "2020-03-24T13:09:05Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1852,25 +1852,35 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n \n \n     private ArrayList<String> deleteNotesWithWrongFieldCounts(Runnable notifyProgress, JSONObject m) throws JSONException {\n+        Timber.d(\"deleteNotesWithWrongFieldCounts\");\n         ArrayList<String> problems = new ArrayList<>();\n         ArrayList<Long> ids;// notes with invalid field counts\n         ids = new ArrayList<>();\n         Cursor cur = null;\n         try {\n             notifyProgress.run();\n             cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n+            Timber.d(\"cursor size: %d\", cur.getCount());\n+            int rowCount = 0;\n             while (cur.moveToNext()) {\n-                String flds = cur.getString(1);\n-                long id = cur.getLong(0);\n-                int fldsCount = 0;\n-                for (int i = 0; i < flds.length(); i++) {\n-                    if (flds.charAt(i) == 0x1f) {\n-                        fldsCount++;\n+                try {\n+                    Timber.d(\"Handling row: %d. Columns: %d\", rowCount, cur.getColumnCount());\n+                    String flds = cur.getString(1);\n+                    long id = cur.getLong(0);\n+                    int fldsCount = 0;\n+                    for (int i = 0; i < flds.length(); i++) {\n+                        if (flds.charAt(i) == 0x1f) {\n+                            fldsCount++;\n+                        }\n                     }\n+                    if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n+                        ids.add(id);\n+                    }\n+                } catch (IllegalStateException ex) {\n+                    // DEFECT: Theory that is this an OOM is discussed in #5852\n+                    AnkiDroidApp.sendExceptionReport(ex, \"deleteNotesWithWrongFieldCounts\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExODMzNg=="}, "originalCommit": {"oid": "fc5096ac4fc98fa19104b933138a4fa8eceae57c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE0NTk0Mw==", "bodyText": "Thanks for the context (RE: Logging)\nEach row in the cursor is a note, not a template. That's a little more fatal if we get it wrong.", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397145943", "createdAt": "2020-03-24T13:21:32Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1852,25 +1852,35 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n \n \n     private ArrayList<String> deleteNotesWithWrongFieldCounts(Runnable notifyProgress, JSONObject m) throws JSONException {\n+        Timber.d(\"deleteNotesWithWrongFieldCounts\");\n         ArrayList<String> problems = new ArrayList<>();\n         ArrayList<Long> ids;// notes with invalid field counts\n         ids = new ArrayList<>();\n         Cursor cur = null;\n         try {\n             notifyProgress.run();\n             cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n+            Timber.d(\"cursor size: %d\", cur.getCount());\n+            int rowCount = 0;\n             while (cur.moveToNext()) {\n-                String flds = cur.getString(1);\n-                long id = cur.getLong(0);\n-                int fldsCount = 0;\n-                for (int i = 0; i < flds.length(); i++) {\n-                    if (flds.charAt(i) == 0x1f) {\n-                        fldsCount++;\n+                try {\n+                    Timber.d(\"Handling row: %d. Columns: %d\", rowCount, cur.getColumnCount());\n+                    String flds = cur.getString(1);\n+                    long id = cur.getLong(0);\n+                    int fldsCount = 0;\n+                    for (int i = 0; i < flds.length(); i++) {\n+                        if (flds.charAt(i) == 0x1f) {\n+                            fldsCount++;\n+                        }\n                     }\n+                    if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n+                        ids.add(id);\n+                    }\n+                } catch (IllegalStateException ex) {\n+                    // DEFECT: Theory that is this an OOM is discussed in #5852\n+                    AnkiDroidApp.sendExceptionReport(ex, \"deleteNotesWithWrongFieldCounts\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExODMzNg=="}, "originalCommit": {"oid": "fc5096ac4fc98fa19104b933138a4fa8eceae57c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE1OTE3Mw==", "bodyText": "If the message is different it will likely not de-duplicate, but...I think more info will be worth it in this case.\n\nLooks like it will\nACRA states that it's per stack trace\nA quick glance at the code seems to agree. CUSTOM_DATA is a separate field.\nhttps://github.com/ACRA/acra/blob/7e47a2e6f8fd8e9a3b3b7de83f5d54baefb62c97/acra-javacore/src/main/java/org/acra/ReportField.java#L81-L89\nAnd it uses getStacktrace\nhttps://github.com/ACRA/acra/blob/4e2357a9390b7de6d8fd1ae41e167f62270e1606/acra-limiter/src/main/java/org/acra/config/LimitingReportAdministrator.java#L82-L89\nWhich is set to the STACK_TRACE\nhttps://github.com/ACRA/acra/blob/4e2357a9390b7de6d8fd1ae41e167f62270e1606/acra-limiter/src/main/java/org/acra/config/LimiterData.java#L102-L103", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397159173", "createdAt": "2020-03-24T13:40:28Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1852,25 +1852,35 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n \n \n     private ArrayList<String> deleteNotesWithWrongFieldCounts(Runnable notifyProgress, JSONObject m) throws JSONException {\n+        Timber.d(\"deleteNotesWithWrongFieldCounts\");\n         ArrayList<String> problems = new ArrayList<>();\n         ArrayList<Long> ids;// notes with invalid field counts\n         ids = new ArrayList<>();\n         Cursor cur = null;\n         try {\n             notifyProgress.run();\n             cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n+            Timber.d(\"cursor size: %d\", cur.getCount());\n+            int rowCount = 0;\n             while (cur.moveToNext()) {\n-                String flds = cur.getString(1);\n-                long id = cur.getLong(0);\n-                int fldsCount = 0;\n-                for (int i = 0; i < flds.length(); i++) {\n-                    if (flds.charAt(i) == 0x1f) {\n-                        fldsCount++;\n+                try {\n+                    Timber.d(\"Handling row: %d. Columns: %d\", rowCount, cur.getColumnCount());\n+                    String flds = cur.getString(1);\n+                    long id = cur.getLong(0);\n+                    int fldsCount = 0;\n+                    for (int i = 0; i < flds.length(); i++) {\n+                        if (flds.charAt(i) == 0x1f) {\n+                            fldsCount++;\n+                        }\n                     }\n+                    if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n+                        ids.add(id);\n+                    }\n+                } catch (IllegalStateException ex) {\n+                    // DEFECT: Theory that is this an OOM is discussed in #5852\n+                    AnkiDroidApp.sendExceptionReport(ex, \"deleteNotesWithWrongFieldCounts\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExODMzNg=="}, "originalCommit": {"oid": "fc5096ac4fc98fa19104b933138a4fa8eceae57c"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzE1OTQxMg==", "bodyText": "I see what you mean - first they should be Timber.i in order to make sure we get them, then perhaps altering the structure so we Timber.i some general information about row count and that we're starting this work unit. Then we Timber.i with information about what row we are on if one of the rows threw an Exception and we save that we had >= 1 row with a problem as a boolean, and then when the cursor is exhausted we Timber.i that the work unit is done and we send an exception report if problem rows were >= 1. That way we'd only ever get one report, and the report should have a sufficient history of how the while loop unfolded", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397159412", "createdAt": "2020-03-24T13:40:47Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1852,25 +1852,35 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n \n \n     private ArrayList<String> deleteNotesWithWrongFieldCounts(Runnable notifyProgress, JSONObject m) throws JSONException {\n+        Timber.d(\"deleteNotesWithWrongFieldCounts\");\n         ArrayList<String> problems = new ArrayList<>();\n         ArrayList<Long> ids;// notes with invalid field counts\n         ids = new ArrayList<>();\n         Cursor cur = null;\n         try {\n             notifyProgress.run();\n             cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n+            Timber.d(\"cursor size: %d\", cur.getCount());\n+            int rowCount = 0;\n             while (cur.moveToNext()) {\n-                String flds = cur.getString(1);\n-                long id = cur.getLong(0);\n-                int fldsCount = 0;\n-                for (int i = 0; i < flds.length(); i++) {\n-                    if (flds.charAt(i) == 0x1f) {\n-                        fldsCount++;\n+                try {\n+                    Timber.d(\"Handling row: %d. Columns: %d\", rowCount, cur.getColumnCount());\n+                    String flds = cur.getString(1);\n+                    long id = cur.getLong(0);\n+                    int fldsCount = 0;\n+                    for (int i = 0; i < flds.length(); i++) {\n+                        if (flds.charAt(i) == 0x1f) {\n+                            fldsCount++;\n+                        }\n                     }\n+                    if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n+                        ids.add(id);\n+                    }\n+                } catch (IllegalStateException ex) {\n+                    // DEFECT: Theory that is this an OOM is discussed in #5852\n+                    AnkiDroidApp.sendExceptionReport(ex, \"deleteNotesWithWrongFieldCounts\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzExODMzNg=="}, "originalCommit": {"oid": "fc5096ac4fc98fa19104b933138a4fa8eceae57c"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MjkyNTU4OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNjo1Mzo0M1rOF654Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxOTowMDoyNlrOF6-4Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxMDAyMw==", "bodyText": "this one and ensureModelsAreNotEmpty stood out to me because they did not actually use the callback and did not seem to advance progress at all - is that correct? slightly larger question - is progress advancing correctly and terminating on a complete ratio still? (that was manually balanced before and I got it wrong the first couple times, myself", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397310023", "createdAt": "2020-03-24T16:53:43Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n+                return -1;\n             }\n+            mDb.getDatabase().setTransactionSuccessful();\n         } catch (RuntimeException e) {\n             Timber.e(e, \"doInBackgroundCheckDatabase - RuntimeException on marking card\");\n             AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundCheckDatabase\");\n             return -1;\n+        } finally {\n+            mDb.getDatabase().endTransaction();\n         }\n-        // models\n-        if (mModels.ensureNotEmpty()) {\n-            problems.add(\"Added missing note type.\");\n+\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingModel);\n+        // for each model\n+        for (JSONObject m : mModels.all()) {\n+            executeIntegrityTask.consume((callback) -> deleteCardsWithInvalidModelOrdinals(callback, m));\n+            executeIntegrityTask.consume((callback) -> deleteNotesWithWrongFieldCounts(callback, m));\n+        }\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingCards);\n+        executeIntegrityTask.consume(this::deleteCardsWithMissingNotes);\n+        executeIntegrityTask.consume(this::removeOriginalDuePropertyWhereInvalid);\n+        executeIntegrityTask.consume(this::removeDynamicPropertyFromNonDynamicDecks);\n+        executeIntegrityTask.consume(this::removeDeckOptionsFromDynamicDecks);\n+        executeIntegrityTask.consume(this::rebuildTags);\n+        executeIntegrityTask.consume(this::updateFieldCache);\n+        executeIntegrityTask.consume(this::fixNewCardDuePositionOverflow);\n+        executeIntegrityTask.consume((callback) -> resetNewCardInsertionPosition());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2NDU5MQ==", "bodyText": "Models:\n\n  \n    \n      Anki-Android/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java\n    \n    \n        Lines 1793 to 1796\n      in\n      2dd867f\n    \n    \n    \n    \n\n        \n          \n           // models \n        \n\n        \n          \n           if (mModels.ensureNotEmpty()) { \n        \n\n        \n          \n               problems.add(\"Added missing note type.\"); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nInsertionPosition:\n\n  \n    \n      Anki-Android/AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java\n    \n    \n        Lines 1746 to 1754\n      in\n      2dd867f\n    \n    \n    \n    \n\n        \n          \n           fixIntegrityProgress(progressCallback, currentTask++, totalTasks); \n        \n\n        \n          \n           mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn() \n        \n\n        \n          \n                   + \" WHERE due > 1000000 AND type = 0\"); \n        \n\n        \n          \n           // new card position \n        \n\n        \n          \n           mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\")); \n        \n\n        \n          \n           // reviews should have a reasonable due # \n        \n\n        \n          \n           fixIntegrityProgress(progressCallback, currentTask++, totalTasks); \n        \n\n        \n          \n           ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0); \n        \n\n        \n          \n           fixIntegrityProgress(progressCallback, currentTask++, totalTasks); \n        \n    \n  \n\n\nHappy to add in a check and update the count.\nI've only extracted methods, so the number of checks won't change.\nThere will be an undercount now, if certain tasks throw exceptions.", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397364591", "createdAt": "2020-03-24T18:15:02Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n+                return -1;\n             }\n+            mDb.getDatabase().setTransactionSuccessful();\n         } catch (RuntimeException e) {\n             Timber.e(e, \"doInBackgroundCheckDatabase - RuntimeException on marking card\");\n             AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundCheckDatabase\");\n             return -1;\n+        } finally {\n+            mDb.getDatabase().endTransaction();\n         }\n-        // models\n-        if (mModels.ensureNotEmpty()) {\n-            problems.add(\"Added missing note type.\");\n+\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingModel);\n+        // for each model\n+        for (JSONObject m : mModels.all()) {\n+            executeIntegrityTask.consume((callback) -> deleteCardsWithInvalidModelOrdinals(callback, m));\n+            executeIntegrityTask.consume((callback) -> deleteNotesWithWrongFieldCounts(callback, m));\n+        }\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingCards);\n+        executeIntegrityTask.consume(this::deleteCardsWithMissingNotes);\n+        executeIntegrityTask.consume(this::removeOriginalDuePropertyWhereInvalid);\n+        executeIntegrityTask.consume(this::removeDynamicPropertyFromNonDynamicDecks);\n+        executeIntegrityTask.consume(this::removeDeckOptionsFromDynamicDecks);\n+        executeIntegrityTask.consume(this::rebuildTags);\n+        executeIntegrityTask.consume(this::updateFieldCache);\n+        executeIntegrityTask.consume(this::fixNewCardDuePositionOverflow);\n+        executeIntegrityTask.consume((callback) -> resetNewCardInsertionPosition());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxMDAyMw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM4MTkwOA==", "bodyText": "Happy to add in a check and update the count.\n\nNothing like cleaner code to make previous defects / inconsistencies a bit more obvious. As long as this chunk is getting an overhaul (and I think correctly assuming that this won't be onerous at all) making them all consistent seems like the right way to go to me\n\nThere will be an undercount now, if certain tasks throw exceptions.\n\nHmm - just a nit at this point, but structurally, if we are going to continue anyway we should advance the count. Only fully bubbling up a stop-the-check exception should stop it otherwise it should make it to completion", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397381908", "createdAt": "2020-03-24T18:43:23Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n+                return -1;\n             }\n+            mDb.getDatabase().setTransactionSuccessful();\n         } catch (RuntimeException e) {\n             Timber.e(e, \"doInBackgroundCheckDatabase - RuntimeException on marking card\");\n             AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundCheckDatabase\");\n             return -1;\n+        } finally {\n+            mDb.getDatabase().endTransaction();\n         }\n-        // models\n-        if (mModels.ensureNotEmpty()) {\n-            problems.add(\"Added missing note type.\");\n+\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingModel);\n+        // for each model\n+        for (JSONObject m : mModels.all()) {\n+            executeIntegrityTask.consume((callback) -> deleteCardsWithInvalidModelOrdinals(callback, m));\n+            executeIntegrityTask.consume((callback) -> deleteNotesWithWrongFieldCounts(callback, m));\n+        }\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingCards);\n+        executeIntegrityTask.consume(this::deleteCardsWithMissingNotes);\n+        executeIntegrityTask.consume(this::removeOriginalDuePropertyWhereInvalid);\n+        executeIntegrityTask.consume(this::removeDynamicPropertyFromNonDynamicDecks);\n+        executeIntegrityTask.consume(this::removeDeckOptionsFromDynamicDecks);\n+        executeIntegrityTask.consume(this::rebuildTags);\n+        executeIntegrityTask.consume(this::updateFieldCache);\n+        executeIntegrityTask.consume(this::fixNewCardDuePositionOverflow);\n+        executeIntegrityTask.consume((callback) -> resetNewCardInsertionPosition());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxMDAyMw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM4NjExMg==", "bodyText": "I'll add it in as a defect for now, I can see this moving to a declarative style where we'll remove the need for the manual totalTasks count at the same time as fixing this.", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397386112", "createdAt": "2020-03-24T18:50:45Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n+                return -1;\n             }\n+            mDb.getDatabase().setTransactionSuccessful();\n         } catch (RuntimeException e) {\n             Timber.e(e, \"doInBackgroundCheckDatabase - RuntimeException on marking card\");\n             AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundCheckDatabase\");\n             return -1;\n+        } finally {\n+            mDb.getDatabase().endTransaction();\n         }\n-        // models\n-        if (mModels.ensureNotEmpty()) {\n-            problems.add(\"Added missing note type.\");\n+\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingModel);\n+        // for each model\n+        for (JSONObject m : mModels.all()) {\n+            executeIntegrityTask.consume((callback) -> deleteCardsWithInvalidModelOrdinals(callback, m));\n+            executeIntegrityTask.consume((callback) -> deleteNotesWithWrongFieldCounts(callback, m));\n+        }\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingCards);\n+        executeIntegrityTask.consume(this::deleteCardsWithMissingNotes);\n+        executeIntegrityTask.consume(this::removeOriginalDuePropertyWhereInvalid);\n+        executeIntegrityTask.consume(this::removeDynamicPropertyFromNonDynamicDecks);\n+        executeIntegrityTask.consume(this::removeDeckOptionsFromDynamicDecks);\n+        executeIntegrityTask.consume(this::rebuildTags);\n+        executeIntegrityTask.consume(this::updateFieldCache);\n+        executeIntegrityTask.consume(this::fixNewCardDuePositionOverflow);\n+        executeIntegrityTask.consume((callback) -> resetNewCardInsertionPosition());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxMDAyMw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM4OTYyOQ==", "bodyText": "works for me - then no change and it's final review + merge with a reference to a new issue?", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397389629", "createdAt": "2020-03-24T18:56:23Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n+                return -1;\n             }\n+            mDb.getDatabase().setTransactionSuccessful();\n         } catch (RuntimeException e) {\n             Timber.e(e, \"doInBackgroundCheckDatabase - RuntimeException on marking card\");\n             AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundCheckDatabase\");\n             return -1;\n+        } finally {\n+            mDb.getDatabase().endTransaction();\n         }\n-        // models\n-        if (mModels.ensureNotEmpty()) {\n-            problems.add(\"Added missing note type.\");\n+\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingModel);\n+        // for each model\n+        for (JSONObject m : mModels.all()) {\n+            executeIntegrityTask.consume((callback) -> deleteCardsWithInvalidModelOrdinals(callback, m));\n+            executeIntegrityTask.consume((callback) -> deleteNotesWithWrongFieldCounts(callback, m));\n+        }\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingCards);\n+        executeIntegrityTask.consume(this::deleteCardsWithMissingNotes);\n+        executeIntegrityTask.consume(this::removeOriginalDuePropertyWhereInvalid);\n+        executeIntegrityTask.consume(this::removeDynamicPropertyFromNonDynamicDecks);\n+        executeIntegrityTask.consume(this::removeDeckOptionsFromDynamicDecks);\n+        executeIntegrityTask.consume(this::rebuildTags);\n+        executeIntegrityTask.consume(this::updateFieldCache);\n+        executeIntegrityTask.consume(this::fixNewCardDuePositionOverflow);\n+        executeIntegrityTask.consume((callback) -> resetNewCardInsertionPosition());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxMDAyMw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 254}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM5MTkyNg==", "bodyText": "On that aspect, yes.\nGot about 3 review changes to push (integrity check, comment and fix progress notifications), will @ you when done. Logcat just died for me, so may be a few minutes.", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397391926", "createdAt": "2020-03-24T19:00:26Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n+                return -1;\n             }\n+            mDb.getDatabase().setTransactionSuccessful();\n         } catch (RuntimeException e) {\n             Timber.e(e, \"doInBackgroundCheckDatabase - RuntimeException on marking card\");\n             AnkiDroidApp.sendExceptionReport(e, \"doInBackgroundCheckDatabase\");\n             return -1;\n+        } finally {\n+            mDb.getDatabase().endTransaction();\n         }\n-        // models\n-        if (mModels.ensureNotEmpty()) {\n-            problems.add(\"Added missing note type.\");\n+\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingModel);\n+        // for each model\n+        for (JSONObject m : mModels.all()) {\n+            executeIntegrityTask.consume((callback) -> deleteCardsWithInvalidModelOrdinals(callback, m));\n+            executeIntegrityTask.consume((callback) -> deleteNotesWithWrongFieldCounts(callback, m));\n+        }\n+        executeIntegrityTask.consume(this::deleteNotesWithMissingCards);\n+        executeIntegrityTask.consume(this::deleteCardsWithMissingNotes);\n+        executeIntegrityTask.consume(this::removeOriginalDuePropertyWhereInvalid);\n+        executeIntegrityTask.consume(this::removeDynamicPropertyFromNonDynamicDecks);\n+        executeIntegrityTask.consume(this::removeDeckOptionsFromDynamicDecks);\n+        executeIntegrityTask.consume(this::rebuildTags);\n+        executeIntegrityTask.consume(this::updateFieldCache);\n+        executeIntegrityTask.consume(this::fixNewCardDuePositionOverflow);\n+        executeIntegrityTask.consume((callback) -> resetNewCardInsertionPosition());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxMDAyMw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 254}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2Mjk3MDExOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxNzowNDoyMlrOF66VxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQxODozNTo0N1rOF69_hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzU3Mw==", "bodyText": "Just saw that nowadays we can probably use this instead https://developer.android.com/reference/androidx/sqlite/db/SupportSQLiteDatabase#isDatabaseIntegrityOk() - not sure it existed before?", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397317573", "createdAt": "2020-03-24T17:04:22Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzg3OA==", "bodyText": "could maybe be made into a standard consumer that way?", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397317878", "createdAt": "2020-03-24T17:04:49Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzU3Mw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM2MTIzMw==", "bodyText": "It's not a consumer as I wanted to keep the \"if this fails, return -1 and stop\" logic. If we don't want to keep that, then we can turn it into a \"regular\" integrity check.\nI'll take a look through the source of the API, but should be fine to use", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397361233", "createdAt": "2020-03-24T18:09:36Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzU3Mw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3NTY1OQ==", "bodyText": "https://android.googlesource.com/platform/frameworks/base.git/+/43a17654cf4bfe7f1ec22bd8b7b32daccdf27c09/core/java/android/database/sqlite/SQLiteDatabase.java#2632 - LGTM", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397375659", "createdAt": "2020-03-24T18:32:56Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzU3Mw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 225}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzM3NzQxMg==", "bodyText": "Careful - note we use requery which is an external sqlite implementation (so that we have reliable sqlite behavior back to the age dinosaurs roamed) - but still LGTM https://github.com/requery/sqlite-android/blob/master/sqlite-android/src/main/java/io/requery/android/database/sqlite/SQLiteDatabase.java#L2370", "url": "https://github.com/ankidroid/Anki-Android/pull/5854#discussion_r397377412", "createdAt": "2020-03-24T18:35:47Z", "author": {"login": "mikehardy"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Collection.java", "diffHunk": "@@ -1606,196 +1609,71 @@ public long fixIntegrity(DeckTask.ProgressCallback progressCallback) {\n         File file = new File(mPath);\n         ArrayList<String> problems = new ArrayList<>();\n         long oldSize = file.length();\n-        int currentTask = 1;\n+        final int[] currentTask = {1};\n         int totalTasks = (mModels.all().size() * 4) + 21; // a few fixes are in all-models loops, the rest are one-offs\n-        try {\n-            mDb.getDatabase().beginTransaction();\n-            try {\n-                save();\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {\n-                    return -1;\n-                }\n-                // note types with a missing model\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ArrayList<Long> ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE mid NOT IN \" + Utils.ids2str(mModels.ids()), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing note type.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // for each model\n-                for (JSONObject m : mModels.all()) {\n-                    // cards with invalid ordinal\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    if (m.getInt(\"type\") == Consts.MODEL_STD) {\n-                        ArrayList<Integer> ords = new ArrayList<>();\n-                        JSONArray tmpls = m.getJSONArray(\"tmpls\");\n-                        for (int t = 0; t < tmpls.length(); t++) {\n-                            ords.add(tmpls.getJSONObject(t).getInt(\"ord\"));\n-                        }\n-                        ids = mDb.queryColumn(Long.class,\n-                                \"SELECT id FROM cards WHERE ord NOT IN \" + Utils.ids2str(ords) + \" AND nid IN ( \" +\n-                                \"SELECT id FROM notes WHERE mid = \" + m.getLong(\"id\") + \")\", 0);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" card(s) with missing template.\");\n-                            remCards(Utils.arrayList2array(ids));\n-                        }\n-                    }\n-                    // notes with invalid field counts\n-                    ids = new ArrayList<>();\n-                    Cursor cur = null;\n+        Runnable notifyProgress = () -> fixIntegrityProgress(progressCallback, currentTask[0]++, totalTasks);\n+        FunctionalInterfaces.Consumer<FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException>> executeIntegrityTask =\n+                (FunctionalInterfaces.FunctionThrowable<Runnable, List<String>, JSONException> function) -> {\n                     try {\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        cur = mDb.getDatabase().query(\"select id, flds from notes where mid = \" + m.getLong(\"id\"), null);\n-                        while (cur.moveToNext()) {\n-                            String flds = cur.getString(1);\n-                            long id = cur.getLong(0);\n-                            int fldsCount = 0;\n-                            for (int i = 0; i < flds.length(); i++) {\n-                                if (flds.charAt(i) == 0x1f) {\n-                                    fldsCount++;\n-                                }\n-                            }\n-                            if (fldsCount + 1 != m.getJSONArray(\"flds\").length()) {\n-                                ids.add(id);\n-                            }\n-                        }\n-                        fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                        if (ids.size() > 0) {\n-                            problems.add(\"Deleted \" + ids.size() + \" note(s) with wrong field count.\");\n-                            _remNotes(Utils.arrayList2array(ids));\n-                        }\n+                        mDb.getDatabase().beginTransaction();\n+                        problems.addAll(function.apply(notifyProgress));\n+                        mDb.getDatabase().setTransactionSuccessful();\n+                    } catch (Exception e) {\n+                        Timber.e(e, \"Failed to execute integrity check\");\n+                        AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity\");\n                     } finally {\n-                        if (cur != null && !cur.isClosed()) {\n-                            cur.close();\n-                        }\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                // delete any notes with missing cards\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM notes WHERE id NOT IN (SELECT DISTINCT nid FROM cards)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                \tproblems.add(\"Deleted \" + ids.size() + \" note(s) with missing no cards.\");\n-\t                _remNotes(Utils.arrayList2array(ids));\n-                }\n-                // cards with missing notes\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"SELECT id FROM cards WHERE nid NOT IN (SELECT id FROM notes)\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Deleted \" + ids.size() + \" card(s) with missing note.\");\n-                    remCards(Utils.arrayList2array(ids));\n-                }\n-                // cards with odue set when it shouldn't be\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odue > 0 and (type=1 or queue=2) and not odid\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                // cards with odid set when not in a dyn deck\n-                ArrayList<Long> dids = new ArrayList<>();\n-                for (long id : mDecks.allIds()) {\n-                    if (!mDecks.isDyn(id)) {\n-                        dids.add(id);\n-                    }\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class,\n-                        \"select id from cards where odid > 0 and did in \" + Utils.ids2str(dids), 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() != 0) {\n-                    problems.add(\"Fixed \" + ids.size() + \" card(s) with invalid properties.\");\n-                    mDb.execute(\"update cards set odid=0, odue=0 where id in \" + Utils.ids2str(ids));\n-                }\n-                {\n-                    //#5708 - a dynamic deck should not have \"Deck Options\"\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    int fixCount = 0;\n-                    for (long id : mDecks.allDynamicDeckIds()) {\n                         try {\n-                            if (mDecks.hasDeckOptions(id)) {\n-                                mDecks.removeDeckOptions(id);\n-                                fixCount++;\n-                            }\n-                        } catch (NoSuchDeckException e) {\n-                            Timber.e(\"Unable to find dynamic deck %d\", id);\n+                            mDb.getDatabase().endTransaction();\n+                        } catch (Exception e) {\n+                            Timber.e(e, \"Failed to end integrity check transaction\");\n+                            AnkiDroidApp.sendExceptionReport(e, \"fixIntegrity - endTransaction\");\n                         }\n                     }\n-                    if (fixCount > 0) {\n-                        mDecks.save();\n-                        problems.add(String.format(Locale.US, \"%d dynamic deck(s) had deck options.\", fixCount));\n-                    }\n-                }\n-                // tags\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mTags.registerNotes();\n-                // field cache\n-                for (JSONObject m : mModels.all()) {\n-                    fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                    updateFieldCache(Utils.arrayList2array(mModels.nids(m)));\n-                }\n-                // new cards can't have a due position > 32 bits\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                mDb.execute(\"UPDATE cards SET due = 1000000, mod = \" + Utils.intTime() + \", usn = \" + usn()\n-                        + \" WHERE due > 1000000 AND type = 0\");\n-                // new card position\n-                mConf.put(\"nextPos\", mDb.queryScalar(\"SELECT max(due) + 1 FROM cards WHERE type = 0\"));\n-                // reviews should have a reasonable due #\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                ids = mDb.queryColumn(Long.class, \"SELECT id FROM cards WHERE queue = 2 AND due > 100000\", 0);\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                if (ids.size() > 0) {\n-                \tproblems.add(\"Reviews had incorrect due date.\");\n-                    mDb.execute(\"UPDATE cards SET due = \" + mSched.getToday() + \", ivl = 1, mod = \" +  Utils.intTime() +\n-                            \", usn = \" + usn() + \" WHERE id IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n-                }\n-                // v2 sched had a bug that could create decimal intervals\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                SupportSQLiteStatement s = mDb.getDatabase().compileStatement(\n-                        \"update cards set ivl=round(ivl),due=round(due) where ivl!=round(ivl) or due!=round(due)\");\n-                int rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" cards with v2 scheduler bug.\");\n-                }\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                s = mDb.getDatabase().compileStatement(\n-                        \"update revlog set ivl=round(ivl),lastIvl=round(lastIvl) where ivl!=round(ivl) or lastIvl!=round(lastIvl)\");\n-                rowCount = s.executeUpdateDelete();\n-                if (rowCount > 0) {\n-                    problems.add(\"Fixed \" + rowCount + \" review history entries with v2 scheduler bug.\");\n-                }\n-                mDb.getDatabase().setTransactionSuccessful();\n-                // DB must have indices. Older versions of AnkiDroid didn't create them for new collections.\n-                fixIntegrityProgress(progressCallback, currentTask++, totalTasks);\n-                int ixs = mDb.queryScalar(\"select count(name) from sqlite_master where type = 'index'\");\n-                if (ixs < 7) {\n-                    problems.add(\"Indices were missing.\");\n-                    Storage.addIndices(mDb);\n-                }\n-            } catch (JSONException e) {\n-                throw new RuntimeException(e);\n-            } finally {\n-                mDb.getDatabase().endTransaction();\n+                };\n+        try {\n+            mDb.getDatabase().beginTransaction();\n+            save();\n+            notifyProgress.run();\n+            if (!\"ok\".equals(mDb.queryString(\"PRAGMA integrity_check\"))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzMxNzU3Mw=="}, "originalCommit": {"oid": "21ed675a78eb287a79218de5ac3b0eb80570c56e"}, "originalPosition": 225}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 458, "cost": 1, "resetAt": "2021-11-11T21:28:48Z"}}}