{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0MTAwNjg5", "number": 6706, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTozNDo1M1rOEQzf6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTowOTo0NVrOEQ_9SQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDU2NDI3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTozNDo1M1rOG1Ko-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwMDoxMDo1NlrOG1OJLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMjA0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public DismissType getDt() {\n          \n          \n            \n                public DismissType getDismissType() {", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458402043", "createdAt": "2020-07-21T21:34:53Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1OTQzNw==", "bodyText": "Done", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458459437", "createdAt": "2020-07-22T00:10:56Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMjA0Mw=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDU2OTAwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTozNjoxN1rOG1Krtg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMzo1NTozNVrOG1N3dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMjc0Mg==", "bodyText": "It's a little unusual to have an undo without a \"do\", as having the \"undo\" close to the \"do\" means that there's additional mental context when changes to the \"do\" are made.\nI'm not requesting a change now, but would this direction be possible in the future?", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458402742", "createdAt": "2020-07-21T21:36:17Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1NDkwMw==", "bodyText": "I thought about it, but I don't really see how to do it. The trouble is that usually, an \"undo\" may cancel multiple \"undo\". E.g. undoing some burying can cancel the burying of a note from the reviewer. It can also undo the burying of multiple selection done in the card browser.", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458454903", "createdAt": "2020-07-21T23:55:35Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMjc0Mg=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDU3NDU3OnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTozODowNlrOG1Ku-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMDoxMFrOG1fOqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMzU3Nw==", "bodyText": "Does this need to be copied? Ditto for the other instances", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458403577", "createdAt": "2020-07-21T21:38:06Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1MzU1MQ==", "bodyText": "What is \"this\" ? the list of cards ? The card of the list ?\nThe list was not copied before so I assumed it was not needed here, I tried to stay close to previous code.\nThe reason why some card are cloned and the list does not need to be cloned/copied is that the card object may potentially evolve, while the list may not. Indeed, the list is is created when UndoBuryCard is called, and the calling code does not even have access to the code anyway.\nI guess it may be relevant to request that caller does not change the value sent to the Undoable action, remove the cloning from the Undo classes and move it to their callers, that would make thing more consistent", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458453551", "createdAt": "2020-07-21T23:51:25Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMzU3Nw=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1ODI1Ng==", "bodyText": "\"This\" meaning either the list or the cards in the list.\nPresumably it wasn't cloned previously, so it should be fine, but it'd be unintuitive if the collection was mutated after the class was created.", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458458256", "createdAt": "2020-07-22T00:06:53Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMzU3Nw=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1OTczNg==", "bodyText": "I added a comment to require that elements sent to constructor are never mutated later. That's usually the case, and the cases where the element may be mutated are the exceptions right now. Cloning everything would be uselessly costly.\nOf course, that assumes the next programmer will read comments...", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458459736", "createdAt": "2020-07-22T00:11:56Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMzU3Nw=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczOTM2OQ==", "bodyText": "Constants used.", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458739369", "createdAt": "2020-07-22T12:00:10Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMzU3Nw=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDU3NjEyOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTozODo0MFrOG1Kv7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMzo0MzoxNVrOG1Nocg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMzgyMQ==", "bodyText": "Maybe \"Undoable\"", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458403821", "createdAt": "2020-07-21T21:38:40Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1MTA1OA==", "bodyText": "Ok.", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458451058", "createdAt": "2020-07-21T23:43:15Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwMzgyMQ=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MDU4MDMwOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQyMTozOTo1OVrOG1KyZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQwNDo0NzoxM1rOG1SjUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwNDQ1Mw==", "bodyText": "Could we change the -1 to a const/enum if we're doing a lot of work here", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458404453", "createdAt": "2020-07-21T21:39:59Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Bury Card\");\n+            for (Card cc : mCards) {\n+                cc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoBuryNote extends Undo {\n+        private final long mCid;\n+        private final List<Card> mCards;\n+        public UndoBuryNote(List<Card> cards,  long cid) {\n+            super(BURY_NOTE);\n+            mCid = cid;\n+            mCards = cards;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"UNDO: Burying notes\");\n+            for (Card cc : mCards) {\n+                cc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoSuspendCard extends Undo {\n+        private Card mSuspendedCard;\n+        public UndoSuspendCard(Card card) {\n+            super(SUSPEND_CARD);\n+            mSuspendedCard = card.clone();\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"UNDO: Suspend Card %d\", mSuspendedCard.getId());\n+            mSuspendedCard.flush(false);\n+            return mSuspendedCard.getId();\n+        }\n+    }\n+\n+    public static class UndoSuspendCardMulti extends Undo {\n+        private final Card[] mCards;\n+        private final boolean[] mOriginalSuspended;\n+        public UndoSuspendCardMulti(Card[] cards, boolean[] originalSuspended) {\n+            super(SUSPEND_CARD_MULTI);\n+            mCards = cards;\n+            mOriginalSuspended = originalSuspended;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Suspend multiple cards\");\n+            List<Long> toSuspendIds = new ArrayList<>();\n+            List<Long> toUnsuspendIds = new ArrayList<>();\n+            for (int i = 0; i < mCards.length; i++) {\n+                Card card = mCards[i];\n+                if (mOriginalSuspended[i]) {\n+                    toSuspendIds.add(card.getId());\n+                } else {\n+                    toUnsuspendIds.add(card.getId());\n+                }\n+            }\n+\n+            // unboxing\n+            long[] toSuspendIdsArray = new long[toSuspendIds.size()];\n+            long[] toUnsuspendIdsArray = new long[toUnsuspendIds.size()];\n+            for (int i = 0; i < toSuspendIds.size(); i++) {\n+                toSuspendIdsArray[i] = toSuspendIds.get(i);\n+            }\n+            for (int i = 0; i < toUnsuspendIds.size(); i++) {\n+                toUnsuspendIdsArray[i] = toUnsuspendIds.get(i);\n+            }\n+\n+            col.getSched().suspendCards(toSuspendIdsArray);\n+            col.getSched().unsuspendCards(toUnsuspendIdsArray);\n+\n+            return -1;  // don't fetch new card\n+\n+        }\n+    }\n+\n+    public static class UndoSuspendNote extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoSuspendNote(List<Card> cards, long cid) {\n+            super(SUSPEND_NOTE);\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Suspend note\");\n+            for (Card ccc : mCards) {\n+                ccc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoDeleteNote extends Undo {\n+        private final Note mNote;\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoDeleteNote(Note note, List<Card> cards, long cid) {\n+            super(DELETE_NOTE);\n+            mNote = note;\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Delete note\");\n+            ArrayList<Long> ids = new ArrayList<>();\n+            mNote.flush(mNote.getMod(), false);\n+            ids.add(mNote.getId());\n+            for (Card c : mCards) {\n+                c.flush(false);\n+                ids.add(c.getId());\n+            }\n+            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoDeleteNoteMulti extends Undo {\n+        private final List<Card> mAllCards;\n+        private final Note[] mNotes;\n+        public UndoDeleteNoteMulti(Note[] notes, List<Card> allCards) {\n+            super(DELETE_NOTE_MULTI);\n+            mNotes = notes;\n+            mAllCards = allCards;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Delete notes\");\n+            // undo all of these at once instead of one-by-one\n+            ArrayList<Long> ids = new ArrayList<>();\n+            for (Note n : mNotes) {\n+                n.flush(n.getMod(), false);\n+                ids.add(n.getId());\n+            }\n+            for (Card c : mAllCards) {\n+                c.flush(false);\n+                ids.add(c.getId());\n+            }\n+            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n+            return -1;  // don't fetch new card\n+\n+        }\n+    }\n+\n+    public static class UndoChangeDeckMulti extends Undo {\n+        private final Card[] mCards;\n+        private final long[] mOriginalDid;\n+        public UndoChangeDeckMulti(Card[]cards, long[] originalDid) {\n+            super(CHANGE_DECK_MULTI);\n+            mCards = cards;\n+            mOriginalDid = originalDid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Change Decks\");\n+            // move cards to original deck\n+            for (int i = 0; i < mCards.length; i++) {\n+                Card card = mCards[i];\n+                card.load();\n+                card.setDid(mOriginalDid[i]);\n+                Note note = card.note();\n+                note.flush();\n+                card.flush();\n+            }\n+            return -1;  // don't fetch new card", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ1NDEyNA==", "bodyText": "It's not clear how to do it, because -1 and 0 has special meaning while positive numbers represent card id.\nIn OCaml or Haskell I would simply do an algebraic type which is either 0, -1, or card id. But I don't know java enough to do how to do it here", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458454124", "createdAt": "2020-07-21T23:53:17Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Bury Card\");\n+            for (Card cc : mCards) {\n+                cc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoBuryNote extends Undo {\n+        private final long mCid;\n+        private final List<Card> mCards;\n+        public UndoBuryNote(List<Card> cards,  long cid) {\n+            super(BURY_NOTE);\n+            mCid = cid;\n+            mCards = cards;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"UNDO: Burying notes\");\n+            for (Card cc : mCards) {\n+                cc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoSuspendCard extends Undo {\n+        private Card mSuspendedCard;\n+        public UndoSuspendCard(Card card) {\n+            super(SUSPEND_CARD);\n+            mSuspendedCard = card.clone();\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"UNDO: Suspend Card %d\", mSuspendedCard.getId());\n+            mSuspendedCard.flush(false);\n+            return mSuspendedCard.getId();\n+        }\n+    }\n+\n+    public static class UndoSuspendCardMulti extends Undo {\n+        private final Card[] mCards;\n+        private final boolean[] mOriginalSuspended;\n+        public UndoSuspendCardMulti(Card[] cards, boolean[] originalSuspended) {\n+            super(SUSPEND_CARD_MULTI);\n+            mCards = cards;\n+            mOriginalSuspended = originalSuspended;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Suspend multiple cards\");\n+            List<Long> toSuspendIds = new ArrayList<>();\n+            List<Long> toUnsuspendIds = new ArrayList<>();\n+            for (int i = 0; i < mCards.length; i++) {\n+                Card card = mCards[i];\n+                if (mOriginalSuspended[i]) {\n+                    toSuspendIds.add(card.getId());\n+                } else {\n+                    toUnsuspendIds.add(card.getId());\n+                }\n+            }\n+\n+            // unboxing\n+            long[] toSuspendIdsArray = new long[toSuspendIds.size()];\n+            long[] toUnsuspendIdsArray = new long[toUnsuspendIds.size()];\n+            for (int i = 0; i < toSuspendIds.size(); i++) {\n+                toSuspendIdsArray[i] = toSuspendIds.get(i);\n+            }\n+            for (int i = 0; i < toUnsuspendIds.size(); i++) {\n+                toUnsuspendIdsArray[i] = toUnsuspendIds.get(i);\n+            }\n+\n+            col.getSched().suspendCards(toSuspendIdsArray);\n+            col.getSched().unsuspendCards(toUnsuspendIdsArray);\n+\n+            return -1;  // don't fetch new card\n+\n+        }\n+    }\n+\n+    public static class UndoSuspendNote extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoSuspendNote(List<Card> cards, long cid) {\n+            super(SUSPEND_NOTE);\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Suspend note\");\n+            for (Card ccc : mCards) {\n+                ccc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoDeleteNote extends Undo {\n+        private final Note mNote;\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoDeleteNote(Note note, List<Card> cards, long cid) {\n+            super(DELETE_NOTE);\n+            mNote = note;\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Delete note\");\n+            ArrayList<Long> ids = new ArrayList<>();\n+            mNote.flush(mNote.getMod(), false);\n+            ids.add(mNote.getId());\n+            for (Card c : mCards) {\n+                c.flush(false);\n+                ids.add(c.getId());\n+            }\n+            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoDeleteNoteMulti extends Undo {\n+        private final List<Card> mAllCards;\n+        private final Note[] mNotes;\n+        public UndoDeleteNoteMulti(Note[] notes, List<Card> allCards) {\n+            super(DELETE_NOTE_MULTI);\n+            mNotes = notes;\n+            mAllCards = allCards;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Delete notes\");\n+            // undo all of these at once instead of one-by-one\n+            ArrayList<Long> ids = new ArrayList<>();\n+            for (Note n : mNotes) {\n+                n.flush(n.getMod(), false);\n+                ids.add(n.getId());\n+            }\n+            for (Card c : mAllCards) {\n+                c.flush(false);\n+                ids.add(c.getId());\n+            }\n+            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n+            return -1;  // don't fetch new card\n+\n+        }\n+    }\n+\n+    public static class UndoChangeDeckMulti extends Undo {\n+        private final Card[] mCards;\n+        private final long[] mOriginalDid;\n+        public UndoChangeDeckMulti(Card[]cards, long[] originalDid) {\n+            super(CHANGE_DECK_MULTI);\n+            mCards = cards;\n+            mOriginalDid = originalDid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Change Decks\");\n+            // move cards to original deck\n+            for (int i = 0; i < mCards.length; i++) {\n+                Card card = mCards[i];\n+                card.load();\n+                card.setDid(mOriginalDid[i]);\n+                Note note = card.note();\n+                note.flush();\n+                card.flush();\n+            }\n+            return -1;  // don't fetch new card", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwNDQ1Mw=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ2NTQyOQ==", "bodyText": "Easier to use a const - may be possible as an enum", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458465429", "createdAt": "2020-07-22T00:32:47Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Bury Card\");\n+            for (Card cc : mCards) {\n+                cc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoBuryNote extends Undo {\n+        private final long mCid;\n+        private final List<Card> mCards;\n+        public UndoBuryNote(List<Card> cards,  long cid) {\n+            super(BURY_NOTE);\n+            mCid = cid;\n+            mCards = cards;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"UNDO: Burying notes\");\n+            for (Card cc : mCards) {\n+                cc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoSuspendCard extends Undo {\n+        private Card mSuspendedCard;\n+        public UndoSuspendCard(Card card) {\n+            super(SUSPEND_CARD);\n+            mSuspendedCard = card.clone();\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"UNDO: Suspend Card %d\", mSuspendedCard.getId());\n+            mSuspendedCard.flush(false);\n+            return mSuspendedCard.getId();\n+        }\n+    }\n+\n+    public static class UndoSuspendCardMulti extends Undo {\n+        private final Card[] mCards;\n+        private final boolean[] mOriginalSuspended;\n+        public UndoSuspendCardMulti(Card[] cards, boolean[] originalSuspended) {\n+            super(SUSPEND_CARD_MULTI);\n+            mCards = cards;\n+            mOriginalSuspended = originalSuspended;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Suspend multiple cards\");\n+            List<Long> toSuspendIds = new ArrayList<>();\n+            List<Long> toUnsuspendIds = new ArrayList<>();\n+            for (int i = 0; i < mCards.length; i++) {\n+                Card card = mCards[i];\n+                if (mOriginalSuspended[i]) {\n+                    toSuspendIds.add(card.getId());\n+                } else {\n+                    toUnsuspendIds.add(card.getId());\n+                }\n+            }\n+\n+            // unboxing\n+            long[] toSuspendIdsArray = new long[toSuspendIds.size()];\n+            long[] toUnsuspendIdsArray = new long[toUnsuspendIds.size()];\n+            for (int i = 0; i < toSuspendIds.size(); i++) {\n+                toSuspendIdsArray[i] = toSuspendIds.get(i);\n+            }\n+            for (int i = 0; i < toUnsuspendIds.size(); i++) {\n+                toUnsuspendIdsArray[i] = toUnsuspendIds.get(i);\n+            }\n+\n+            col.getSched().suspendCards(toSuspendIdsArray);\n+            col.getSched().unsuspendCards(toUnsuspendIdsArray);\n+\n+            return -1;  // don't fetch new card\n+\n+        }\n+    }\n+\n+    public static class UndoSuspendNote extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoSuspendNote(List<Card> cards, long cid) {\n+            super(SUSPEND_NOTE);\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Suspend note\");\n+            for (Card ccc : mCards) {\n+                ccc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoDeleteNote extends Undo {\n+        private final Note mNote;\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoDeleteNote(Note note, List<Card> cards, long cid) {\n+            super(DELETE_NOTE);\n+            mNote = note;\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Delete note\");\n+            ArrayList<Long> ids = new ArrayList<>();\n+            mNote.flush(mNote.getMod(), false);\n+            ids.add(mNote.getId());\n+            for (Card c : mCards) {\n+                c.flush(false);\n+                ids.add(c.getId());\n+            }\n+            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoDeleteNoteMulti extends Undo {\n+        private final List<Card> mAllCards;\n+        private final Note[] mNotes;\n+        public UndoDeleteNoteMulti(Note[] notes, List<Card> allCards) {\n+            super(DELETE_NOTE_MULTI);\n+            mNotes = notes;\n+            mAllCards = allCards;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Delete notes\");\n+            // undo all of these at once instead of one-by-one\n+            ArrayList<Long> ids = new ArrayList<>();\n+            for (Note n : mNotes) {\n+                n.flush(n.getMod(), false);\n+                ids.add(n.getId());\n+            }\n+            for (Card c : mAllCards) {\n+                c.flush(false);\n+                ids.add(c.getId());\n+            }\n+            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n+            return -1;  // don't fetch new card\n+\n+        }\n+    }\n+\n+    public static class UndoChangeDeckMulti extends Undo {\n+        private final Card[] mCards;\n+        private final long[] mOriginalDid;\n+        public UndoChangeDeckMulti(Card[]cards, long[] originalDid) {\n+            super(CHANGE_DECK_MULTI);\n+            mCards = cards;\n+            mOriginalDid = originalDid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Change Decks\");\n+            // move cards to original deck\n+            for (int i = 0; i < mCards.length; i++) {\n+                Card card = mCards[i];\n+                card.load();\n+                card.setDid(mOriginalDid[i]);\n+                Note note = card.note();\n+                note.flush();\n+                card.flush();\n+            }\n+            return -1;  // don't fetch new card", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwNDQ1Mw=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 247}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODUzMTY2Nw==", "bodyText": "I added a class with three subclass, so that the one subclass for card id has an id.", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458531667", "createdAt": "2020-07-22T04:47:13Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/Undo.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.CardUtils;\n+import com.ichi2.anki.R;\n+import com.ichi2.libanki.Collection.DismissType;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.Collection.DismissType.*;\n+\n+public abstract class Undo {\n+    private final DismissType mDt;\n+\n+    public Undo(DismissType dt) {\n+        mDt = dt;\n+    }\n+\n+    public String name(Resources res) {\n+        return res.getString(mDt.undoNameId);\n+    }\n+\n+    public DismissType getDt() {\n+        return mDt;\n+    }\n+\n+    public abstract long undo(Collection col);\n+\n+    public static class UndoReview extends Undo {\n+        private final Card mCard;\n+        private final boolean mWasLeech;\n+        public UndoReview(Card card, boolean wasLeach) {\n+            super(REVIEW);\n+            mCard = card.clone();\n+            mWasLeech = wasLeach;\n+        }\n+\n+        public long undo(Collection col) {\n+            // remove leech tag if it didn't have it before\n+            if (!mWasLeech && mCard.note().hasTag(\"leech\")) {\n+                mCard.note().delTag(\"leech\");\n+                mCard.note().flush();\n+            }\n+            Timber.i(\"Undo Review of card %d, leech: %b\", mCard.getId(), mWasLeech);\n+            // write old data\n+            mCard.flush(false);\n+            // and delete revlog entry\n+            long last = col.getDb().queryLongScalar(\"SELECT id FROM revlog WHERE cid = ? ORDER BY id DESC LIMIT 1\", new Object [] {mCard.getId()});\n+            col.getDb().execute(\"DELETE FROM revlog WHERE id = \" + last);\n+            // restore any siblings\n+            col.getDb().execute(\"update cards set queue=type,mod=?,usn=? where queue=\" + Consts.QUEUE_TYPE_SIBLING_BURIED + \" and nid=?\",\n+                        new Object[]{Utils.intTime(), col.usn(), mCard.getNid()});\n+            // and finally, update daily count\n+            @Consts.CARD_QUEUE int n = mCard.getQueue() == Consts.QUEUE_TYPE_DAY_LEARN_RELEARN ? Consts.QUEUE_TYPE_LRN : mCard.getQueue();\n+            String type = (new String[]{\"new\", \"lrn\", \"rev\"})[n];\n+            col.getSched()._updateStats(mCard, type, -1);\n+            col.getSched().setReps(col.getSched().getReps() - 1);\n+            return mCard.getId();\n+        }\n+    }\n+\n+    public static class UndoBuryCard extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoBuryCard(List<Card> cards, long cid) {\n+            super(BURY_CARD);\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Bury Card\");\n+            for (Card cc : mCards) {\n+                cc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoBuryNote extends Undo {\n+        private final long mCid;\n+        private final List<Card> mCards;\n+        public UndoBuryNote(List<Card> cards,  long cid) {\n+            super(BURY_NOTE);\n+            mCid = cid;\n+            mCards = cards;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"UNDO: Burying notes\");\n+            for (Card cc : mCards) {\n+                cc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoSuspendCard extends Undo {\n+        private Card mSuspendedCard;\n+        public UndoSuspendCard(Card card) {\n+            super(SUSPEND_CARD);\n+            mSuspendedCard = card.clone();\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"UNDO: Suspend Card %d\", mSuspendedCard.getId());\n+            mSuspendedCard.flush(false);\n+            return mSuspendedCard.getId();\n+        }\n+    }\n+\n+    public static class UndoSuspendCardMulti extends Undo {\n+        private final Card[] mCards;\n+        private final boolean[] mOriginalSuspended;\n+        public UndoSuspendCardMulti(Card[] cards, boolean[] originalSuspended) {\n+            super(SUSPEND_CARD_MULTI);\n+            mCards = cards;\n+            mOriginalSuspended = originalSuspended;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Suspend multiple cards\");\n+            List<Long> toSuspendIds = new ArrayList<>();\n+            List<Long> toUnsuspendIds = new ArrayList<>();\n+            for (int i = 0; i < mCards.length; i++) {\n+                Card card = mCards[i];\n+                if (mOriginalSuspended[i]) {\n+                    toSuspendIds.add(card.getId());\n+                } else {\n+                    toUnsuspendIds.add(card.getId());\n+                }\n+            }\n+\n+            // unboxing\n+            long[] toSuspendIdsArray = new long[toSuspendIds.size()];\n+            long[] toUnsuspendIdsArray = new long[toUnsuspendIds.size()];\n+            for (int i = 0; i < toSuspendIds.size(); i++) {\n+                toSuspendIdsArray[i] = toSuspendIds.get(i);\n+            }\n+            for (int i = 0; i < toUnsuspendIds.size(); i++) {\n+                toUnsuspendIdsArray[i] = toUnsuspendIds.get(i);\n+            }\n+\n+            col.getSched().suspendCards(toSuspendIdsArray);\n+            col.getSched().unsuspendCards(toUnsuspendIdsArray);\n+\n+            return -1;  // don't fetch new card\n+\n+        }\n+    }\n+\n+    public static class UndoSuspendNote extends Undo {\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoSuspendNote(List<Card> cards, long cid) {\n+            super(SUSPEND_NOTE);\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Suspend note\");\n+            for (Card ccc : mCards) {\n+                ccc.flush(false);\n+            }\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoDeleteNote extends Undo {\n+        private final Note mNote;\n+        private final List<Card> mCards;\n+        private final long mCid;\n+        public UndoDeleteNote(Note note, List<Card> cards, long cid) {\n+            super(DELETE_NOTE);\n+            mNote = note;\n+            mCards = cards;\n+            mCid = cid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Delete note\");\n+            ArrayList<Long> ids = new ArrayList<>();\n+            mNote.flush(mNote.getMod(), false);\n+            ids.add(mNote.getId());\n+            for (Card c : mCards) {\n+                c.flush(false);\n+                ids.add(c.getId());\n+            }\n+            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n+            return mCid;\n+        }\n+    }\n+\n+    public static class UndoDeleteNoteMulti extends Undo {\n+        private final List<Card> mAllCards;\n+        private final Note[] mNotes;\n+        public UndoDeleteNoteMulti(Note[] notes, List<Card> allCards) {\n+            super(DELETE_NOTE_MULTI);\n+            mNotes = notes;\n+            mAllCards = allCards;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Delete notes\");\n+            // undo all of these at once instead of one-by-one\n+            ArrayList<Long> ids = new ArrayList<>();\n+            for (Note n : mNotes) {\n+                n.flush(n.getMod(), false);\n+                ids.add(n.getId());\n+            }\n+            for (Card c : mAllCards) {\n+                c.flush(false);\n+                ids.add(c.getId());\n+            }\n+            col.getDb().execute(\"DELETE FROM graves WHERE oid IN \" + Utils.ids2str(Utils.arrayList2array(ids)));\n+            return -1;  // don't fetch new card\n+\n+        }\n+    }\n+\n+    public static class UndoChangeDeckMulti extends Undo {\n+        private final Card[] mCards;\n+        private final long[] mOriginalDid;\n+        public UndoChangeDeckMulti(Card[]cards, long[] originalDid) {\n+            super(CHANGE_DECK_MULTI);\n+            mCards = cards;\n+            mOriginalDid = originalDid;\n+        }\n+\n+        public long undo(Collection col) {\n+            Timber.i(\"Undo: Change Decks\");\n+            // move cards to original deck\n+            for (int i = 0; i < mCards.length; i++) {\n+                Card card = mCards[i];\n+                card.load();\n+                card.setDid(mOriginalDid[i]);\n+                Note note = card.note();\n+                note.flush();\n+                card.flush();\n+            }\n+            return -1;  // don't fetch new card", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQwNDQ1Mw=="}, "originalCommit": {"oid": "6f2f5d41b4f22ef5e3ad6003aa9193647bb410f9"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg2MjYwNTUzOnYy", "diffSide": "RIGHT", "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMTowOTo0NVrOG1dt8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMlQxMjowMDo1OVrOG1fQgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxNDYwOQ==", "bodyText": "Best to use an enum, const, or switch back to the long, instanceof is typically a code smell", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458714609", "createdAt": "2020-07-22T11:09:45Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -920,24 +921,24 @@ private TaskData doInBackgroundUndo() {\n             col.getDb().getDatabase().beginTransaction();\n             Card newCard = null;\n             try {\n-                long cid = col.undo();\n-                if (cid == 0) {\n+                UndoType undoType = col.undo();\n+                if (undoType instanceof UndoType.NonReview) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3404502622b4c7279bb7458f683623d545b6844c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcyNTQ1NQ==", "bodyText": "I am sorry, but I really don't see how to use an enum if we need to store an arbitrary value", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458725455", "createdAt": "2020-07-22T11:32:37Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -920,24 +921,24 @@ private TaskData doInBackgroundUndo() {\n             col.getDb().getDatabase().beginTransaction();\n             Card newCard = null;\n             try {\n-                long cid = col.undo();\n-                if (cid == 0) {\n+                UndoType undoType = col.undo();\n+                if (undoType instanceof UndoType.NonReview) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxNDYwOQ=="}, "originalCommit": {"oid": "3404502622b4c7279bb7458f683623d545b6844c"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODczOTg0Mw==", "bodyText": "Constant used here", "url": "https://github.com/ankidroid/Anki-Android/pull/6706#discussion_r458739843", "createdAt": "2020-07-22T12:00:59Z", "author": {"login": "Arthur-Milchior"}, "path": "AnkiDroid/src/main/java/com/ichi2/async/CollectionTask.java", "diffHunk": "@@ -920,24 +921,24 @@ private TaskData doInBackgroundUndo() {\n             col.getDb().getDatabase().beginTransaction();\n             Card newCard = null;\n             try {\n-                long cid = col.undo();\n-                if (cid == 0) {\n+                UndoType undoType = col.undo();\n+                if (undoType instanceof UndoType.NonReview) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODcxNDYwOQ=="}, "originalCommit": {"oid": "3404502622b4c7279bb7458f683623d545b6844c"}, "originalPosition": 101}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4931, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}