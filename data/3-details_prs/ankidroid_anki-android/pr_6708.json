{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU0MjY2NzIy", "number": 6708, "title": "Upstream test", "bodyText": "This PR contains the PR I\u00a0made this week-end, with what I believe to be code improvement.\nIt contains all libanki's upstream test, ported to java. The exceptions are the tests which deal with files or with time. I'll need to figure this out later. There are also errors that are commented with @ Ignore or todo because they show real problem with current AnkiDroid code and that my goal here is not to correct those problems.\nI usually prefer to keep the commit history. In this case, I believe the commits should probably be stashed. This history is currently useful because when\u00a0I did some mistake while porting python to java, I want to understand how I did add the error and whether I added other errors simultaneously. Appart from that,\u00a0I don't think those steps will be useful in the future, appart if someone wants to figure out how\u00a0I did this whole work in two days\nI'll wait until all PRs of this week-end are merged before rebasing this PR and ensuring that there is no conflict, that merge can occur.\nI don't really know how to licence properly. This is essentially upstream code, so I am note sure whether we should follow AGPL or GPL here. Furthermore, most code is essentially done by @dae , I only translated it. (Thanks to him for accepting the corrections\u00a0I sent while porting the code)", "createdAt": "2020-07-21T08:30:42Z", "url": "https://github.com/ankidroid/Anki-Android/pull/6708", "merged": true, "mergeCommit": {"oid": "67160fde21de1b5bd56855afa862e2cf4d03efdd"}, "closed": true, "closedAt": "2020-08-04T21:37:34Z", "author": {"login": "Arthur-Milchior"}, "timelineItems": {"totalCount": 48, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3CAFQgBqjM1Njk5NjY0Mzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc7r3ugAFqTQ2MTExNDI0MQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "df828cc31272c32c1dc371e3beb7c62b7671a313", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/df828cc31272c32c1dc371e3beb7c62b7671a313", "committedDate": "2020-07-21T08:26:41Z", "message": "Split upstream test"}, "afterCommit": {"oid": "dc650f8688e05460fda671b2c8f2948235d88ba2", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/dc650f8688e05460fda671b2c8f2948235d88ba2", "committedDate": "2020-07-21T08:31:41Z", "message": "Split upstream test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUyNDY2MjAy", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-452466202", "createdAt": "2020-07-21T13:39:12Z", "commit": {"oid": "9d12079cb749bd65f3323e3d99fe3a7e39c69cfa"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzozOToxMlrOG04bHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yMVQxMzozOToxMlrOG04bHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODEwMzU4MA==", "bodyText": "Maybe I missed it, but this strong typing would be an easy one to split into a separate PR.\nOverall, it'd be great to get the individual code changes into separate PRs, then this would just contain test changes (which would end up being a simple \"approve\" as long as the tests aren't flaky and look reasonable).", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r458103580", "createdAt": "2020-07-21T13:39:12Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/androidTest/java/com/ichi2/anki/tests/ContentProviderTest.java", "diffHunk": "@@ -511,7 +513,7 @@ public void testInsertAndUpdateModel() {\n             // Delete the model (this will force a full-sync)\n             col.modSchemaNoCheck();\n             try {\n-                JSONObject model = col.getModels().get(mid);\n+                Model model = col.getModels().get(mid);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9d12079cb749bd65f3323e3d99fe3a7e39c69cfa"}, "originalPosition": 69}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9d12079cb749bd65f3323e3d99fe3a7e39c69cfa", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/9d12079cb749bd65f3323e3d99fe3a7e39c69cfa", "committedDate": "2020-07-21T08:42:35Z", "message": "empty test"}, "afterCommit": {"oid": "61479352011c9504450bae9f74f31a90c9a8da3f", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/61479352011c9504450bae9f74f31a90c9a8da3f", "committedDate": "2020-07-22T07:58:56Z", "message": "empty test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "61479352011c9504450bae9f74f31a90c9a8da3f", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/61479352011c9504450bae9f74f31a90c9a8da3f", "committedDate": "2020-07-22T07:58:56Z", "message": "empty test"}, "afterCommit": {"oid": "91f17fe1901c34ffbbdcfdf89b5757d6598606f4", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/91f17fe1901c34ffbbdcfdf89b5757d6598606f4", "committedDate": "2020-07-22T08:08:30Z", "message": "NF: UnburyType is an enum"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "91f17fe1901c34ffbbdcfdf89b5757d6598606f4", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/91f17fe1901c34ffbbdcfdf89b5757d6598606f4", "committedDate": "2020-07-22T08:08:30Z", "message": "NF: UnburyType is an enum"}, "afterCommit": {"oid": "5790f41bd472f2e800f4d9d2bc6293b0018b6130", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/5790f41bd472f2e800f4d9d2bc6293b0018b6130", "committedDate": "2020-07-22T08:12:22Z", "message": "NF: UnburyType is an enum"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5790f41bd472f2e800f4d9d2bc6293b0018b6130", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/5790f41bd472f2e800f4d9d2bc6293b0018b6130", "committedDate": "2020-07-22T08:12:22Z", "message": "NF: UnburyType is an enum"}, "afterCommit": {"oid": "9156283a8d2872b54c73bfe59031855b15a84430", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/9156283a8d2872b54c73bfe59031855b15a84430", "committedDate": "2020-07-22T08:17:55Z", "message": "NF: UnburyType is an enum"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9156283a8d2872b54c73bfe59031855b15a84430", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/9156283a8d2872b54c73bfe59031855b15a84430", "committedDate": "2020-07-22T08:17:55Z", "message": "NF: UnburyType is an enum"}, "afterCommit": {"oid": "7bb45696cb9df018c1dc385e920f58bf92d81abe", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7bb45696cb9df018c1dc385e920f58bf92d81abe", "committedDate": "2020-07-22T08:20:39Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7bb45696cb9df018c1dc385e920f58bf92d81abe", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7bb45696cb9df018c1dc385e920f58bf92d81abe", "committedDate": "2020-07-22T08:20:39Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "03ce3bfcf442c35e2a5c6f30f5da138b688cb0cc", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/03ce3bfcf442c35e2a5c6f30f5da138b688cb0cc", "committedDate": "2020-07-22T08:43:05Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "03ce3bfcf442c35e2a5c6f30f5da138b688cb0cc", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/03ce3bfcf442c35e2a5c6f30f5da138b688cb0cc", "committedDate": "2020-07-22T08:43:05Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "147a0e2bc1dab2bcdd42ab9dd368334e4429e841", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/147a0e2bc1dab2bcdd42ab9dd368334e4429e841", "committedDate": "2020-07-22T10:08:23Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "147a0e2bc1dab2bcdd42ab9dd368334e4429e841", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/147a0e2bc1dab2bcdd42ab9dd368334e4429e841", "committedDate": "2020-07-22T10:08:23Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "19afe66a863852726d46a1081d38a9f0d254e864", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/19afe66a863852726d46a1081d38a9f0d254e864", "committedDate": "2020-07-22T11:12:49Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "19afe66a863852726d46a1081d38a9f0d254e864", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/19afe66a863852726d46a1081d38a9f0d254e864", "committedDate": "2020-07-22T11:12:49Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "24563c2ee75db6b411e4b078b448b0555fd54108", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/24563c2ee75db6b411e4b078b448b0555fd54108", "committedDate": "2020-07-23T08:03:28Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "24563c2ee75db6b411e4b078b448b0555fd54108", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/24563c2ee75db6b411e4b078b448b0555fd54108", "committedDate": "2020-07-23T08:03:28Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "43cab6c262905a54d62c3cf9a813a633e8ff1adb", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/43cab6c262905a54d62c3cf9a813a633e8ff1adb", "committedDate": "2020-07-23T14:40:03Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "43cab6c262905a54d62c3cf9a813a633e8ff1adb", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/43cab6c262905a54d62c3cf9a813a633e8ff1adb", "committedDate": "2020-07-23T14:40:03Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "7bcdee34f532ec41b635cc253bb30523adaf45dc", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7bcdee34f532ec41b635cc253bb30523adaf45dc", "committedDate": "2020-07-23T16:31:08Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7bcdee34f532ec41b635cc253bb30523adaf45dc", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7bcdee34f532ec41b635cc253bb30523adaf45dc", "committedDate": "2020-07-23T16:31:08Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "b7752803726920a4f4d0ef384d7250446a9d703e", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/b7752803726920a4f4d0ef384d7250446a9d703e", "committedDate": "2020-07-23T17:16:01Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b7752803726920a4f4d0ef384d7250446a9d703e", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/b7752803726920a4f4d0ef384d7250446a9d703e", "committedDate": "2020-07-23T17:16:01Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "618ffbf36af7a55ec716378edb675ca8ecba6c5e", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/618ffbf36af7a55ec716378edb675ca8ecba6c5e", "committedDate": "2020-07-23T17:17:31Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "618ffbf36af7a55ec716378edb675ca8ecba6c5e", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/618ffbf36af7a55ec716378edb675ca8ecba6c5e", "committedDate": "2020-07-23T17:17:31Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "05796f89dbd4b7f9a0707bb595a9b6cdb5ad5ac4", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/05796f89dbd4b7f9a0707bb595a9b6cdb5ad5ac4", "committedDate": "2020-07-24T06:20:25Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "05796f89dbd4b7f9a0707bb595a9b6cdb5ad5ac4", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/05796f89dbd4b7f9a0707bb595a9b6cdb5ad5ac4", "committedDate": "2020-07-24T06:20:25Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7fb841064b6dcac188793a341c1188f3fb5f468f", "committedDate": "2020-07-24T15:57:23Z", "message": "Upstream libanki tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MDA0Mzgz", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-455004383", "createdAt": "2020-07-24T15:59:35Z", "commit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "state": "COMMENTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNTo1OTozNVrOG209Gg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNjowODo1NlrOG21Saw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0Mzg5OA==", "bodyText": "Could you mark that this throws if empty", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460143898", "createdAt": "2020-07-24T15:59:35Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/CollectionUtils.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.ichi2.libanki;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+public class CollectionUtils {\n+    public static <T> T getLastListElement(List<T> l) {\n+        return l.get(l.size()-1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NDEwMg==", "bodyText": "We have a few utils packages already, would be better in there", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460144102", "createdAt": "2020-07-24T15:59:56Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/CollectionUtils.java", "diffHunk": "@@ -0,0 +1,10 @@\n+package com.ichi2.libanki;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NDc5Ng==", "bodyText": "This one might be better as a PR", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460144796", "createdAt": "2020-07-24T16:01:04Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/main/java/com/ichi2/libanki/sched/AbstractSched.java", "diffHunk": "@@ -145,6 +148,12 @@\n     public abstract void maybeRandomizeDeck();\n     public abstract void maybeRandomizeDeck(Long did);\n     public abstract boolean haveBuried(long did);\n+    public enum UnburyType {\n+        ALL,\n+        MANUAL,\n+        SIBLINGS;\n+    }\n+    public abstract void unburyCardsForDeck(UnburyType type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTEyMg==", "bodyText": "Mention that these were autogenerated, and the commit hash", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460145122", "createdAt": "2020-07-24T16:01:36Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CardTest.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CardTest extends RobolectricTest {\n+    /******************\n+     ** Upstream tests*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NTcyMQ==", "bodyText": "assertThat(d.addNote(f), greaterThan(0))", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460145721", "createdAt": "2020-07-24T16:02:36Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ClozeTest.java", "diffHunk": "@@ -37,7 +38,7 @@ public void testCloze() {\n         }\n         // a cloze model with no clozes is not empty\n         f.setItem(\"Text\", \"nothing\");\n-        assertTrue(d.addNote(f) > 0);\n+        assertNotEquals(0, d.addNote(f));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzAxMA==", "bodyText": "Does this mean it's broken? Could do with elaboration", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460147010", "createdAt": "2020-07-24T16:04:56Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CollectionTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CollectionTest extends RobolectricTest {\n+\n+    /*******************\n+     ** Upstream tests *\n+     *******************/\n+\n+    /*TODO\n+      @Test\n+      public void test_create_open(){\n+      (fd, path) = tempfile.mkstemp(suffix=\".anki2\", prefix=\"test_attachNew\");\n+      try {\n+      os.close(fd);\n+      os.unlink(path);\n+      } catch (OSError) {\n+      }\n+      Collection col = aopen(path);\n+      // for open()\n+      String newPath = col.getPath();\n+      long newMod = col.getMod();\n+      col.close();\n+\n+      // reopen\n+      col = aopen(newPath);\n+      assertEquals(newMod, col.getMod());\n+      col.close();\n+\n+      // non-writeable dir\n+      if (isWin) {\n+      String dir = \"c:\\root.anki2\";\n+      } else {\n+      String dir = \"/attachroot.anki2\";\n+      }\n+      assertException(Exception, lambda: aopen(dir));\n+      // reuse tmp file from before, test non-writeable file\n+      os.chmod(newPath, 0);\n+      assertException(Exception, lambda: aopen(newPath));\n+      os.chmod(newPath, 0o666);\n+      os.unlink(newPath);\n+      } */\n+\n+    @Test\n+    public void test_noteAddDelete(){\n+        Collection col = getCol();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"one\");\n+        note.setItem(\"Back\",\"two\");\n+        int n = col.addNote(note);\n+        assertEquals(1, n);\n+        // test multiple cards - add another template\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m, true); // todo:\u00a0remove true which is not upstream\n+        assertEquals(2, col.cardCount());\n+        // creating new notes should use both cards\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"three\");\n+        note.setItem(\"Back\",\"four\");\n+        n = col.addNote(note);\n+        assertEquals(2, n);\n+        assertEquals(4, col.cardCount());\n+        // check q/a generation\n+        Card c0 = note.cards().get(0);\n+        assertTrue(c0.q().contains(\"three\"));\n+        // it should not be a duplicate\n+        assertEquals(note.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // now let's make a duplicate\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"one\");\n+        note2.setItem(\"Back\",\"\");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // empty first field should not be permitted either\n+        note2.setItem(\"Front\",\" \");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+    }\n+\n+    @Test\n+    @Ignore(\"I don't understand this csum\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzMyNA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    note.setItem(\"Front\",\"1\");\n          \n          \n            \n                    note.setItem(\"Front\", \"1\");", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460147324", "createdAt": "2020-07-24T16:05:25Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CardTest.java", "diffHunk": "@@ -0,0 +1,146 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CardTest extends RobolectricTest {\n+    /******************\n+     ** Upstream tests*\n+     ******************/\n+    \n+    @Test\n+    public void test_delete(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        long cid = note.cards().get(0).getId();\n+        col.reset();\n+        col.getSched().answerCard(col.getSched().getCard(), 2);\n+        col.remCards(Arrays.asList(new Long [] {cid}));\n+        assertEquals(0, col.cardCount());\n+        assertEquals(0, col.noteCount());\n+        assertEquals(0, col.getDb().queryScalar(\"select count() from notes\"));\n+        assertEquals(0, col.getDb().queryScalar(\"select count() from cards\"));\n+        assertEquals(2, col.getDb().queryScalar(\"select count() from graves\"));\n+    }\n+\n+    @Test\n+    public void test_misc_cards(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0NzgwMA==", "bodyText": "This is a feature that we need to implement - the new style of media that Rust uses", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460147800", "createdAt": "2020-07-24T16:06:13Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CollectionTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CollectionTest extends RobolectricTest {\n+\n+    /*******************\n+     ** Upstream tests *\n+     *******************/\n+\n+    /*TODO\n+      @Test\n+      public void test_create_open(){\n+      (fd, path) = tempfile.mkstemp(suffix=\".anki2\", prefix=\"test_attachNew\");\n+      try {\n+      os.close(fd);\n+      os.unlink(path);\n+      } catch (OSError) {\n+      }\n+      Collection col = aopen(path);\n+      // for open()\n+      String newPath = col.getPath();\n+      long newMod = col.getMod();\n+      col.close();\n+\n+      // reopen\n+      col = aopen(newPath);\n+      assertEquals(newMod, col.getMod());\n+      col.close();\n+\n+      // non-writeable dir\n+      if (isWin) {\n+      String dir = \"c:\\root.anki2\";\n+      } else {\n+      String dir = \"/attachroot.anki2\";\n+      }\n+      assertException(Exception, lambda: aopen(dir));\n+      // reuse tmp file from before, test non-writeable file\n+      os.chmod(newPath, 0);\n+      assertException(Exception, lambda: aopen(newPath));\n+      os.chmod(newPath, 0o666);\n+      os.unlink(newPath);\n+      } */\n+\n+    @Test\n+    public void test_noteAddDelete(){\n+        Collection col = getCol();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"one\");\n+        note.setItem(\"Back\",\"two\");\n+        int n = col.addNote(note);\n+        assertEquals(1, n);\n+        // test multiple cards - add another template\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m, true); // todo:\u00a0remove true which is not upstream\n+        assertEquals(2, col.cardCount());\n+        // creating new notes should use both cards\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"three\");\n+        note.setItem(\"Back\",\"four\");\n+        n = col.addNote(note);\n+        assertEquals(2, n);\n+        assertEquals(4, col.cardCount());\n+        // check q/a generation\n+        Card c0 = note.cards().get(0);\n+        assertTrue(c0.q().contains(\"three\"));\n+        // it should not be a duplicate\n+        assertEquals(note.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // now let's make a duplicate\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"one\");\n+        note2.setItem(\"Back\",\"\");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // empty first field should not be permitted either\n+        note2.setItem(\"Front\",\" \");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+    }\n+\n+    @Test\n+    @Ignore(\"I don't understand this csum\")\n+    public void test_fieldChecksum(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"new\");\n+        note.setItem(\"Back\",\"new2\");\n+        col.addNote(note);\n+        assertEquals(0xc2a6b03f, col.getDb().queryLongScalar(\"select csum from notes\"));\n+        // changing the val should change the checksum\n+        note.setItem(\"Front\",\"newx\");\n+        note.flush();\n+        assertEquals(0x302811ae, col.getDb().queryLongScalar(\"select csum from notes\"));\n+    }\n+\n+    @Test\n+    public void test_addDelTags(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        col.addNote(note);\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"2\");\n+        col.addNote(note2);\n+        // adding for a given id\n+        col.getTags().bulkAdd(Arrays.asList(new Long[] {note.getId()}), \"foo\");\n+        note.load();\n+        note2.load();\n+        assertTrue(note.getTags().contains(\"foo\"));\n+        assertFalse(note2.getTags().contains(\"foo\"));\n+        // should be canonified\n+        col.getTags().bulkAdd(Arrays.asList(new Long [] {note.getId()}), \"foo aaa\");\n+        note.load();\n+        assertEquals(\"aaa\", note.getTags().get(0));\n+        assertEquals(2, note.getTags().size());\n+    }\n+\n+    @Test\n+    public void test_timestamps(){\n+        Collection col = getCol();\n+        int stdModelSize = StdModels.stdModels.length;\n+        assertEquals(col.getModels().all().size(), stdModelSize);\n+        for (int i = 0; i < 100; i++) {\n+            StdModels.basicModel.add(col);\n+        }\n+        assertEquals(col.getModels().all().size(), 100 + stdModelSize);\n+    }\n+\n+    @Test\n+    @Ignore(\"What is anki:play\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0ODQ2OA==", "bodyText": "This can go - we use a different translation mechanism", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460148468", "createdAt": "2020-07-24T16:07:19Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/CollectionTest.java", "diffHunk": "@@ -0,0 +1,230 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class CollectionTest extends RobolectricTest {\n+\n+    /*******************\n+     ** Upstream tests *\n+     *******************/\n+\n+    /*TODO\n+      @Test\n+      public void test_create_open(){\n+      (fd, path) = tempfile.mkstemp(suffix=\".anki2\", prefix=\"test_attachNew\");\n+      try {\n+      os.close(fd);\n+      os.unlink(path);\n+      } catch (OSError) {\n+      }\n+      Collection col = aopen(path);\n+      // for open()\n+      String newPath = col.getPath();\n+      long newMod = col.getMod();\n+      col.close();\n+\n+      // reopen\n+      col = aopen(newPath);\n+      assertEquals(newMod, col.getMod());\n+      col.close();\n+\n+      // non-writeable dir\n+      if (isWin) {\n+      String dir = \"c:\\root.anki2\";\n+      } else {\n+      String dir = \"/attachroot.anki2\";\n+      }\n+      assertException(Exception, lambda: aopen(dir));\n+      // reuse tmp file from before, test non-writeable file\n+      os.chmod(newPath, 0);\n+      assertException(Exception, lambda: aopen(newPath));\n+      os.chmod(newPath, 0o666);\n+      os.unlink(newPath);\n+      } */\n+\n+    @Test\n+    public void test_noteAddDelete(){\n+        Collection col = getCol();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"one\");\n+        note.setItem(\"Back\",\"two\");\n+        int n = col.addNote(note);\n+        assertEquals(1, n);\n+        // test multiple cards - add another template\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m, true); // todo:\u00a0remove true which is not upstream\n+        assertEquals(2, col.cardCount());\n+        // creating new notes should use both cards\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"three\");\n+        note.setItem(\"Back\",\"four\");\n+        n = col.addNote(note);\n+        assertEquals(2, n);\n+        assertEquals(4, col.cardCount());\n+        // check q/a generation\n+        Card c0 = note.cards().get(0);\n+        assertTrue(c0.q().contains(\"three\"));\n+        // it should not be a duplicate\n+        assertEquals(note.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // now let's make a duplicate\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"one\");\n+        note2.setItem(\"Back\",\"\");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+        // empty first field should not be permitted either\n+        note2.setItem(\"Front\",\" \");\n+        assertNotEquals(note2.dupeOrEmpty(), Note.DupeOrEmpty.CORRECT);\n+    }\n+\n+    @Test\n+    @Ignore(\"I don't understand this csum\")\n+    public void test_fieldChecksum(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"new\");\n+        note.setItem(\"Back\",\"new2\");\n+        col.addNote(note);\n+        assertEquals(0xc2a6b03f, col.getDb().queryLongScalar(\"select csum from notes\"));\n+        // changing the val should change the checksum\n+        note.setItem(\"Front\",\"newx\");\n+        note.flush();\n+        assertEquals(0x302811ae, col.getDb().queryLongScalar(\"select csum from notes\"));\n+    }\n+\n+    @Test\n+    public void test_addDelTags(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        col.addNote(note);\n+        Note note2 = col.newNote();\n+        note2.setItem(\"Front\",\"2\");\n+        col.addNote(note2);\n+        // adding for a given id\n+        col.getTags().bulkAdd(Arrays.asList(new Long[] {note.getId()}), \"foo\");\n+        note.load();\n+        note2.load();\n+        assertTrue(note.getTags().contains(\"foo\"));\n+        assertFalse(note2.getTags().contains(\"foo\"));\n+        // should be canonified\n+        col.getTags().bulkAdd(Arrays.asList(new Long [] {note.getId()}), \"foo aaa\");\n+        note.load();\n+        assertEquals(\"aaa\", note.getTags().get(0));\n+        assertEquals(2, note.getTags().size());\n+    }\n+\n+    @Test\n+    public void test_timestamps(){\n+        Collection col = getCol();\n+        int stdModelSize = StdModels.stdModels.length;\n+        assertEquals(col.getModels().all().size(), stdModelSize);\n+        for (int i = 0; i < 100; i++) {\n+            StdModels.basicModel.add(col);\n+        }\n+        assertEquals(col.getModels().all().size(), 100 + stdModelSize);\n+    }\n+\n+    @Test\n+    @Ignore(\"What is anki:play\")\n+    public void test_furigana(){\n+        Collection col = getCol();\n+        Models mm = col.getModels();\n+        Model m = mm.current();\n+        // filter should work\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{kana:Front}}\");\n+        mm.save(m);\n+        Note n = col.newNote();\n+        n.setItem(\"Front\", \"foo[abc]\");\n+        col.addNote(n);\n+        Card c = n.cards().get(0);\n+        assertTrue(c.q().endsWith(\"abc\"));\n+        // and should avoid sound\n+        n.setItem(\"Front\", \"foo[sound:abc.mp3]\");\n+        n.flush();\n+        String question = c.q(true);\n+        assertTrue(\"Question \u00ab\" + question +\"\u00bb does not contains \u00abanki:play\u00bb.\", question.contains(\"anki:play\"));\n+        // it shouldn't throw an error while people are editing\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{kana:}}\");\n+        mm.save(m);\n+        c.q(true);\n+    }\n+\n+    /*\n+      @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTE3Mg==", "bodyText": "let's get rid of this", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460149172", "createdAt": "2020-07-24T16:08:37Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ExportingTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ExportingTest extends RobolectricTest {\n+     /*****************\n+      ** Exporting    *\n+      *****************/\n+    private Collection setup1(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"foo\");\n+        note.setItem(\"Back\",\"bar<br>\");\n+        note.setTagsFromStr(\"tag, tag2\");\n+        col.addNote(note);\n+        // with a different col\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"baz\");\n+        note.setItem(\"Back\",\"qux\");\n+        note.model().put(\"did\", col.getDecks().id(\"new col\"));\n+        col.addNote(note);\n+        return col;\n+    }\n+\n+    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */\n+    @Test\n+    public void empty_test() {\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE0OTM1NQ==", "bodyText": "We should flag this one as one we should get working", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460149355", "createdAt": "2020-07-24T16:08:56Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ExportingTest.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package com.ichi2.libanki;\n+\n+import android.content.res.Resources;\n+import android.database.Cursor;\n+import android.icu.util.Calendar;\n+import android.util.Pair;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.anki.exception.DeckRenameException;\n+import com.ichi2.libanki.sched.AbstractSched;\n+import com.ichi2.libanki.sched.Sched;\n+import com.ichi2.testutils.AnkiAssert;\n+import com.ichi2.utils.Assert;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.apache.http.util.Asserts;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+import timber.log.Timber;\n+\n+import static com.ichi2.libanki.CollectionUtils.getLastListElement;\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.hamcrest.MatcherAssert.*;\n+import static org.hamcrest.Matchers.*;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ExportingTest extends RobolectricTest {\n+     /*****************\n+      ** Exporting    *\n+      *****************/\n+    private Collection setup1(){\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"foo\");\n+        note.setItem(\"Back\",\"bar<br>\");\n+        note.setTagsFromStr(\"tag, tag2\");\n+        col.addNote(note);\n+        // with a different col\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"baz\");\n+        note.setItem(\"Back\",\"qux\");\n+        note.model().put(\"did\", col.getDecks().id(\"new col\"));\n+        col.addNote(note);\n+        return col;\n+    }\n+\n+    /*//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// */\n+    @Test\n+    public void empty_test() {\n+    }\n+\n+\n+    /* TODO\n+       @Test\n+       public void test_export_anki(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f"}, "originalPosition": 77}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7fb841064b6dcac188793a341c1188f3fb5f468f", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7fb841064b6dcac188793a341c1188f3fb5f468f", "committedDate": "2020-07-24T15:57:23Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "committedDate": "2020-07-24T16:43:28Z", "message": "Upstream libanki tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MDQ4NDcw", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-455048470", "createdAt": "2020-07-24T17:05:24Z", "commit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNzowNToyNVrOG23HLQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNFQxNzoxMTowOFrOG23SHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE3OTI0NQ==", "bodyText": "We can get this one working", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460179245", "createdAt": "2020-07-24T17:05:25Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/MediaTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.testutils.AnkiAssert.assertEqualsArrayList;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class MediaTest extends RobolectricTest {\n+    /*****************\n+     ** Media        *\n+     *****************/\n+    // copying files to media folder\n+    \n+    /* TODO: media\n+       @Test\n+       public void test_add(){\n+       Collection col = getCol();\n+       String dir = tempfile.mkdtemp(prefix=\"anki\");\n+       String path = os.path.join(dir, \"foo.jpg\");\n+       with open(path, \"w\") as note:\n+       note.write(\"hello\");\n+       // new file, should preserve name\n+       assertEquals(\"foo.jpg\", col.getMedia().addFile(path));\n+       // adding the same file again should not create a duplicate\n+       assertEquals(\"foo.jpg\", col.getMedia().addFile(path));\n+       // but if it has a different sha1, it should\n+       with open(path, \"w\") as note:\n+       note.write(\"world\");\n+       assertEquals(\"foo-7c211433f02071597741e6ff5a8ea34789abbf43.jpg\", col.getMedia().addFile(path));\n+       } */\n+    \n+    @Test\n+    public void test_strings(){\n+        Collection col = getCol();\n+        long mid = col.getModels().current().getLong(\"id\");\n+        assertEquals(0, col.getMedia().filesInStr(mid, \"aoeu\").size());\n+        assertEqualsArrayList(new String [] {\"foo.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src='foo.jpg'>ao\"));\n+        assertEqualsArrayList(new String [] {\"foo.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src='foo.jpg' style='test'>ao\"));\n+        assertEqualsArrayList(new String [] {\"foo.jpg\", \"bar.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src='foo.jpg'><img src=\\\"bar.jpg\\\">ao\"));\n+        assertEqualsArrayList(new String [] {\"foo.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src=foo.jpg style=bar>ao\"));\n+        assertEqualsArrayList(new String [] {\"one\", \"two\"}, col.getMedia().filesInStr(mid, \"<img src=one><img src=two>\"));\n+        assertEqualsArrayList(new String [] {\"foo.jpg\"}, col.getMedia().filesInStr(mid, \"aoeu<img src=\\\"foo.jpg\\\">ao\"));\n+        assertEqualsArrayList(new String[] {\"foo.jpg\", \"fo\"},\n+                              col.getMedia().filesInStr(mid, \"aoeu<img src=\\\"foo.jpg\\\"><img class=yo src=fo>ao\"));\n+        assertEqualsArrayList(new String [] {\"foo.mp3\"}, col.getMedia().filesInStr(mid, \"aou[sound:foo.mp3]aou\"));\n+        assertEquals(\"aoeu\", col.getMedia().strip(\"aoeu\"));\n+        assertEquals(\"aoeuaoeu\", col.getMedia().strip(\"aoeu[sound:foo.mp3]aoeu\"));\n+        assertEquals(\"aoeu\", col.getMedia().strip(\"a<img src=yo>oeu\"));\n+        assertEquals(\"aoeu\", col.getMedia().escapeImages(\"aoeu\"));\n+        assertEquals(\"<img src='http://foo.com'>\", col.getMedia().escapeImages(\"<img src='http://foo.com'>\"));\n+        assertEquals(\"<img src=\\\"foo%20bar.jpg\\\">\", col.getMedia().escapeImages(\"<img src=\\\"foo bar.jpg\\\">\"));\n+    }\n+    \n+    /** TODO: file\n+        @Test\n+        public void test_deckIntegration(){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "originalPosition": 70}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDExNg==", "bodyText": "Should be able to:\nassertThat(note.cards().get(0).q(), containsString(\"class=cloze\"));", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460180116", "createdAt": "2020-07-24T17:07:13Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ModelTest.java", "diffHunk": "@@ -0,0 +1,450 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ModelTest extends RobolectricTest {\n+    /*****************\n+     ** Models       *\n+     *****************/\n+    \n+    @Test\n+    public void test_modelDelete() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(1, col.cardCount());\n+        col.getModels().rem(col.getModels().current());\n+        assertEquals(0, col.cardCount());\n+    }\n+    \n+    @Test\n+    public void test_modelCopy(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Model m2 = col.getModels().copy(m);\n+        assertEquals(\"Basic copy\", m2.getString(\"name\"));\n+        assertNotEquals(m2.getLong(\"id\"), m.getLong(\"id\"));\n+        assertEquals(2, m2.getJSONArray(\"flds\").length());\n+        assertEquals(2, m.getJSONArray(\"flds\").length());\n+        assertEquals(m.getJSONArray(\"flds\").length(), m2.getJSONArray(\"flds\").length());\n+        assertEquals(1, m.getJSONArray(\"tmpls\").length());\n+        assertEquals(1, m2.getJSONArray(\"tmpls\").length());\n+        assertEquals(col.getModels().scmhash(m), col.getModels().scmhash(m2));\n+    }\n+    \n+    @Test\n+    public void test_fields() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        Model m = col.getModels().current();\n+        // make sure renaming a field updates the templates\n+        col.getModels().renameField(m, m.getJSONArray(\"flds\").getJSONObject(0), \"NewFront\");\n+        assertTrue(m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\").contains(\"{{NewFront}}\"));\n+        String h = col.getModels().scmhash(m);\n+        // add a field\n+        JSONObject field = col.getModels().newField(\"foo\");\n+        col.getModels().addField(m, field);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        assertNotEquals(h, col.getModels().scmhash(m));\n+        // rename it\n+        field = m.getJSONArray(\"flds\").getJSONObject(2);\n+        col.getModels().renameField(m, field, \"bar\");\n+        assertEquals(\"\", col.getNote(col.getModels().nids(m).get(0)).getItem(\"bar\"));\n+        // delete back\n+        col.getModels().remField(m, m.getJSONArray(\"flds\").getJSONObject(1));\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 1 -> 0\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(1), 0);\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // add another and put in middle\n+        field = col.getModels().newField(\"baz\");\n+        col.getModels().addField(m, field);\n+        note = col.getNote(col.getModels().nids(m).get(0));\n+        note.setItem(\"baz\",\"2\");\n+        note.flush();\n+        assertArrayEquals(new String [] {\"1\", \"\", \"2\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 2 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(2), 1);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 2\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 2);\n+        assertArrayEquals(new String [] {\"2\", \"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"2\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+    }\n+    \n+    @Test\n+    public void test_templates() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+        // switch templates\n+        col.getModels().moveTemplate(m, c.template(), 1);\n+        c.load();\n+        c2.load();\n+        assertEquals(1, c.getOrd());\n+        assertEquals(0, c2.getOrd());\n+        // removing a template should delete its cards\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(1, col.cardCount());\n+        // and should have updated the other cards' ordinals\n+        c = note.cards().get(0);\n+        assertEquals(0, c.getOrd());\n+        assertEquals(\"1\", stripHTML(c.q()));\n+        // it shouldn't be possible to orphan notes by removing templates\n+        t = mm.newTemplate(\"template name\");\n+        mm.addTemplateModChanged(m, t);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(0,\n+                     col.getDb().queryLongScalar(\n+                                                 \"select count() from cards where nid not in (select id from notes)\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze_ordinals() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{text:cloze:Text}}\");\n+        t.put(\"afmt\", \"{{text:cloze:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"{{c1::firstQ::firstA}}{{c2::secondQ::secondA}}\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+    }\n+    \n+    @Test\n+    public void test_text(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{text:Front}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"hello<b>world\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"helloworld\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        assertEquals(\"Cloze\", note.model().getString(\"name\"));\n+        // a cloze model with no clozes is not empty\n+        note.setItem(\"Text\",\"nothing\");\n+        assertNotEquals(0, col.addNote(note));\n+        // try with one cloze\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"hello <span class=cloze>[...]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"hello <span class=cloze>world</span>\"));\n+        // and with a comment\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world::typical}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"<span class=cloze>[typical]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>world</span>\"));\n+        // and with 2 clozes\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}} {{c2::bar}}\");\n+        assertEquals(2, col.addNote(note));\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c1 = cards.get(0);\n+        Card c2 = cards.get(1);\n+        assertTrue(c1.q().contains(\"<span class=cloze>[...]</span> bar\"));\n+        assertTrue(c1.a().contains(\"<span class=cloze>world</span> bar\"));\n+        assertTrue(c2.q().contains(\"world <span class=cloze>[...]</span>\"));\n+        assertTrue(c2.a().contains(\"world <span class=cloze>bar</span>\"));\n+        // if there are multiple answers for a single cloze, they are given in a\n+        // list\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"a {{c1::b}} {{c1::c}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>b</span> <span class=cloze>c</span>\"));\n+        // if we add another cloze, a card should be generated\n+        int cnt = col.cardCount();\n+        note.setItem(\"Text\",\"{{c2::hello}} {{c1::foo}}\");\n+        note.flush();\n+        assertEquals(cnt + 1, col.cardCount());\n+        // 0 or negative indices are not supported\n+        note.setItem(\"Text\",\"{{c0::zero}} {{c-1:foo}}\");\n+        note.flush();\n+        assertEquals(2, note.numberOfCards());\n+    }\n+    \n+    @Test\n+    public void test_cloze_mathjax(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        note.setItem(\"Text\", \"{{c1::ok}} \\\\(2^2\\\\) {{c2::not ok}} \\\\(2^{{c3::2}}\\\\) \\\\(x^3\\\\) {{c4::blah}} {{c5::text with \\\\(x^2\\\\) jax}}\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(5, note.numberOfCards());\n+        assertTrue(note.cards().get(0).q().contains(\"class=cloze\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDM2MQ==", "bodyText": "Hamcrest: endsWith", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460180361", "createdAt": "2020-07-24T17:07:49Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ModelTest.java", "diffHunk": "@@ -0,0 +1,450 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ModelTest extends RobolectricTest {\n+    /*****************\n+     ** Models       *\n+     *****************/\n+    \n+    @Test\n+    public void test_modelDelete() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(1, col.cardCount());\n+        col.getModels().rem(col.getModels().current());\n+        assertEquals(0, col.cardCount());\n+    }\n+    \n+    @Test\n+    public void test_modelCopy(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Model m2 = col.getModels().copy(m);\n+        assertEquals(\"Basic copy\", m2.getString(\"name\"));\n+        assertNotEquals(m2.getLong(\"id\"), m.getLong(\"id\"));\n+        assertEquals(2, m2.getJSONArray(\"flds\").length());\n+        assertEquals(2, m.getJSONArray(\"flds\").length());\n+        assertEquals(m.getJSONArray(\"flds\").length(), m2.getJSONArray(\"flds\").length());\n+        assertEquals(1, m.getJSONArray(\"tmpls\").length());\n+        assertEquals(1, m2.getJSONArray(\"tmpls\").length());\n+        assertEquals(col.getModels().scmhash(m), col.getModels().scmhash(m2));\n+    }\n+    \n+    @Test\n+    public void test_fields() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        Model m = col.getModels().current();\n+        // make sure renaming a field updates the templates\n+        col.getModels().renameField(m, m.getJSONArray(\"flds\").getJSONObject(0), \"NewFront\");\n+        assertTrue(m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\").contains(\"{{NewFront}}\"));\n+        String h = col.getModels().scmhash(m);\n+        // add a field\n+        JSONObject field = col.getModels().newField(\"foo\");\n+        col.getModels().addField(m, field);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        assertNotEquals(h, col.getModels().scmhash(m));\n+        // rename it\n+        field = m.getJSONArray(\"flds\").getJSONObject(2);\n+        col.getModels().renameField(m, field, \"bar\");\n+        assertEquals(\"\", col.getNote(col.getModels().nids(m).get(0)).getItem(\"bar\"));\n+        // delete back\n+        col.getModels().remField(m, m.getJSONArray(\"flds\").getJSONObject(1));\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 1 -> 0\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(1), 0);\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // add another and put in middle\n+        field = col.getModels().newField(\"baz\");\n+        col.getModels().addField(m, field);\n+        note = col.getNote(col.getModels().nids(m).get(0));\n+        note.setItem(\"baz\",\"2\");\n+        note.flush();\n+        assertArrayEquals(new String [] {\"1\", \"\", \"2\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 2 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(2), 1);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 2\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 2);\n+        assertArrayEquals(new String [] {\"2\", \"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"2\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+    }\n+    \n+    @Test\n+    public void test_templates() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+        // switch templates\n+        col.getModels().moveTemplate(m, c.template(), 1);\n+        c.load();\n+        c2.load();\n+        assertEquals(1, c.getOrd());\n+        assertEquals(0, c2.getOrd());\n+        // removing a template should delete its cards\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(1, col.cardCount());\n+        // and should have updated the other cards' ordinals\n+        c = note.cards().get(0);\n+        assertEquals(0, c.getOrd());\n+        assertEquals(\"1\", stripHTML(c.q()));\n+        // it shouldn't be possible to orphan notes by removing templates\n+        t = mm.newTemplate(\"template name\");\n+        mm.addTemplateModChanged(m, t);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(0,\n+                     col.getDb().queryLongScalar(\n+                                                 \"select count() from cards where nid not in (select id from notes)\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze_ordinals() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{text:cloze:Text}}\");\n+        t.put(\"afmt\", \"{{text:cloze:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"{{c1::firstQ::firstA}}{{c2::secondQ::secondA}}\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+    }\n+    \n+    @Test\n+    public void test_text(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{text:Front}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"hello<b>world\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"helloworld\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        assertEquals(\"Cloze\", note.model().getString(\"name\"));\n+        // a cloze model with no clozes is not empty\n+        note.setItem(\"Text\",\"nothing\");\n+        assertNotEquals(0, col.addNote(note));\n+        // try with one cloze\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"hello <span class=cloze>[...]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"hello <span class=cloze>world</span>\"));\n+        // and with a comment\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world::typical}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"<span class=cloze>[typical]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>world</span>\"));\n+        // and with 2 clozes\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}} {{c2::bar}}\");\n+        assertEquals(2, col.addNote(note));\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c1 = cards.get(0);\n+        Card c2 = cards.get(1);\n+        assertTrue(c1.q().contains(\"<span class=cloze>[...]</span> bar\"));\n+        assertTrue(c1.a().contains(\"<span class=cloze>world</span> bar\"));\n+        assertTrue(c2.q().contains(\"world <span class=cloze>[...]</span>\"));\n+        assertTrue(c2.a().contains(\"world <span class=cloze>bar</span>\"));\n+        // if there are multiple answers for a single cloze, they are given in a\n+        // list\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"a {{c1::b}} {{c1::c}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>b</span> <span class=cloze>c</span>\"));\n+        // if we add another cloze, a card should be generated\n+        int cnt = col.cardCount();\n+        note.setItem(\"Text\",\"{{c2::hello}} {{c1::foo}}\");\n+        note.flush();\n+        assertEquals(cnt + 1, col.cardCount());\n+        // 0 or negative indices are not supported\n+        note.setItem(\"Text\",\"{{c0::zero}} {{c-1:foo}}\");\n+        note.flush();\n+        assertEquals(2, note.numberOfCards());\n+    }\n+    \n+    @Test\n+    public void test_cloze_mathjax(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        note.setItem(\"Text\", \"{{c1::ok}} \\\\(2^2\\\\) {{c2::not ok}} \\\\(2^{{c3::2}}\\\\) \\\\(x^3\\\\) {{c4::blah}} {{c5::text with \\\\(x^2\\\\) jax}}\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(5, note.numberOfCards());\n+        assertTrue(note.cards().get(0).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(1).q().contains(\"class=cloze\"));\n+        assertFalse(note.cards().get(2).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(3).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(4).q().contains(\"class=cloze\"));\n+        \n+        note = col.newNote();\n+        note.setItem(\"Text\",\"\\\\(a\\\\) {{c1::b}} \\\\[ {{c1::c}} \\\\]\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(1, note.numberOfCards());\n+        String question = note.cards().get(0).q();\n+        assertTrue(\"Question \u00ab\"+question+\"\u00bb does not end correctly\", question.endsWith(\"\\\\(a\\\\) <span class=cloze>[...]</span> \\\\[ [...] \\\\]\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MDY0NQ==", "bodyText": "If you comment out the assertions, please assume false or ignore the test", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460180645", "createdAt": "2020-07-24T17:08:25Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ModelTest.java", "diffHunk": "@@ -0,0 +1,450 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ModelTest extends RobolectricTest {\n+    /*****************\n+     ** Models       *\n+     *****************/\n+    \n+    @Test\n+    public void test_modelDelete() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(1, col.cardCount());\n+        col.getModels().rem(col.getModels().current());\n+        assertEquals(0, col.cardCount());\n+    }\n+    \n+    @Test\n+    public void test_modelCopy(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Model m2 = col.getModels().copy(m);\n+        assertEquals(\"Basic copy\", m2.getString(\"name\"));\n+        assertNotEquals(m2.getLong(\"id\"), m.getLong(\"id\"));\n+        assertEquals(2, m2.getJSONArray(\"flds\").length());\n+        assertEquals(2, m.getJSONArray(\"flds\").length());\n+        assertEquals(m.getJSONArray(\"flds\").length(), m2.getJSONArray(\"flds\").length());\n+        assertEquals(1, m.getJSONArray(\"tmpls\").length());\n+        assertEquals(1, m2.getJSONArray(\"tmpls\").length());\n+        assertEquals(col.getModels().scmhash(m), col.getModels().scmhash(m2));\n+    }\n+    \n+    @Test\n+    public void test_fields() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        Model m = col.getModels().current();\n+        // make sure renaming a field updates the templates\n+        col.getModels().renameField(m, m.getJSONArray(\"flds\").getJSONObject(0), \"NewFront\");\n+        assertTrue(m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\").contains(\"{{NewFront}}\"));\n+        String h = col.getModels().scmhash(m);\n+        // add a field\n+        JSONObject field = col.getModels().newField(\"foo\");\n+        col.getModels().addField(m, field);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        assertNotEquals(h, col.getModels().scmhash(m));\n+        // rename it\n+        field = m.getJSONArray(\"flds\").getJSONObject(2);\n+        col.getModels().renameField(m, field, \"bar\");\n+        assertEquals(\"\", col.getNote(col.getModels().nids(m).get(0)).getItem(\"bar\"));\n+        // delete back\n+        col.getModels().remField(m, m.getJSONArray(\"flds\").getJSONObject(1));\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 1 -> 0\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(1), 0);\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // add another and put in middle\n+        field = col.getModels().newField(\"baz\");\n+        col.getModels().addField(m, field);\n+        note = col.getNote(col.getModels().nids(m).get(0));\n+        note.setItem(\"baz\",\"2\");\n+        note.flush();\n+        assertArrayEquals(new String [] {\"1\", \"\", \"2\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 2 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(2), 1);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 2\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 2);\n+        assertArrayEquals(new String [] {\"2\", \"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"2\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+    }\n+    \n+    @Test\n+    public void test_templates() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+        // switch templates\n+        col.getModels().moveTemplate(m, c.template(), 1);\n+        c.load();\n+        c2.load();\n+        assertEquals(1, c.getOrd());\n+        assertEquals(0, c2.getOrd());\n+        // removing a template should delete its cards\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(1, col.cardCount());\n+        // and should have updated the other cards' ordinals\n+        c = note.cards().get(0);\n+        assertEquals(0, c.getOrd());\n+        assertEquals(\"1\", stripHTML(c.q()));\n+        // it shouldn't be possible to orphan notes by removing templates\n+        t = mm.newTemplate(\"template name\");\n+        mm.addTemplateModChanged(m, t);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(0,\n+                     col.getDb().queryLongScalar(\n+                                                 \"select count() from cards where nid not in (select id from notes)\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze_ordinals() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{text:cloze:Text}}\");\n+        t.put(\"afmt\", \"{{text:cloze:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"{{c1::firstQ::firstA}}{{c2::secondQ::secondA}}\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+    }\n+    \n+    @Test\n+    public void test_text(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{text:Front}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"hello<b>world\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"helloworld\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        assertEquals(\"Cloze\", note.model().getString(\"name\"));\n+        // a cloze model with no clozes is not empty\n+        note.setItem(\"Text\",\"nothing\");\n+        assertNotEquals(0, col.addNote(note));\n+        // try with one cloze\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"hello <span class=cloze>[...]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"hello <span class=cloze>world</span>\"));\n+        // and with a comment\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world::typical}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"<span class=cloze>[typical]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>world</span>\"));\n+        // and with 2 clozes\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}} {{c2::bar}}\");\n+        assertEquals(2, col.addNote(note));\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c1 = cards.get(0);\n+        Card c2 = cards.get(1);\n+        assertTrue(c1.q().contains(\"<span class=cloze>[...]</span> bar\"));\n+        assertTrue(c1.a().contains(\"<span class=cloze>world</span> bar\"));\n+        assertTrue(c2.q().contains(\"world <span class=cloze>[...]</span>\"));\n+        assertTrue(c2.a().contains(\"world <span class=cloze>bar</span>\"));\n+        // if there are multiple answers for a single cloze, they are given in a\n+        // list\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"a {{c1::b}} {{c1::c}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>b</span> <span class=cloze>c</span>\"));\n+        // if we add another cloze, a card should be generated\n+        int cnt = col.cardCount();\n+        note.setItem(\"Text\",\"{{c2::hello}} {{c1::foo}}\");\n+        note.flush();\n+        assertEquals(cnt + 1, col.cardCount());\n+        // 0 or negative indices are not supported\n+        note.setItem(\"Text\",\"{{c0::zero}} {{c-1:foo}}\");\n+        note.flush();\n+        assertEquals(2, note.numberOfCards());\n+    }\n+    \n+    @Test\n+    public void test_cloze_mathjax(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        note.setItem(\"Text\", \"{{c1::ok}} \\\\(2^2\\\\) {{c2::not ok}} \\\\(2^{{c3::2}}\\\\) \\\\(x^3\\\\) {{c4::blah}} {{c5::text with \\\\(x^2\\\\) jax}}\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(5, note.numberOfCards());\n+        assertTrue(note.cards().get(0).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(1).q().contains(\"class=cloze\"));\n+        assertFalse(note.cards().get(2).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(3).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(4).q().contains(\"class=cloze\"));\n+        \n+        note = col.newNote();\n+        note.setItem(\"Text\",\"\\\\(a\\\\) {{c1::b}} \\\\[ {{c1::c}} \\\\]\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(1, note.numberOfCards());\n+        String question = note.cards().get(0).q();\n+        assertTrue(\"Question \u00ab\"+question+\"\u00bb does not end correctly\", question.endsWith(\"\\\\(a\\\\) <span class=cloze>[...]</span> \\\\[ [...] \\\\]\"));\n+    }\n+    \n+    @Test\n+    public void test_typecloze(){\n+        Collection col = getCol();\n+        Model m = col.getModels().byName(\"Cloze\");\n+        col.getModels().setCurrent(m);\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{cloze:Text}}{{type:cloze:Text}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"[[type:cloze:Text]]\"));\n+    }\n+    \n+    @Test\n+    public void test_chained_mods() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{cloze:text:Text}}\");\n+        t.put(\"afmt\", \"{{cloze:text:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        String q1 = \"<span style=\\\"color:red\\\">phrase</span>\";\n+        String a1 = \"<b>sentence</b>\";\n+        String q2 = \"<span style=\\\"color:red\\\">en chaine</span>\";\n+        String a2 = \"<i>chained</i>\";\n+        note.setItem(\"Text\",\"This {{c1::\"+q1+\"::\"+a1+\"}} demonstrates {{c1::\"+q2+\"::\"+a2+\"}} clozes.\");\n+        assertEquals(1, col.addNote(note));\n+        String question = note.cards().get(0).q();\n+        /* TODO: chained modifier", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTE1Nw==", "bodyText": "TODO: me - Can be improved by hamcrest", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460181157", "createdAt": "2020-07-24T17:09:26Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ModelTest.java", "diffHunk": "@@ -0,0 +1,450 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+import com.ichi2.anki.exception.ConfirmModSchemaException;\n+import com.ichi2.utils.JSONArray;\n+import com.ichi2.utils.JSONObject;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.*;\n+import static com.ichi2.libanki.Utils.intTime;\n+import static com.ichi2.libanki.Utils.stripHTML;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThrows;\n+import static org.junit.Assert.assertTrue;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ModelTest extends RobolectricTest {\n+    /*****************\n+     ** Models       *\n+     *****************/\n+    \n+    @Test\n+    public void test_modelDelete() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(1, col.cardCount());\n+        col.getModels().rem(col.getModels().current());\n+        assertEquals(0, col.cardCount());\n+    }\n+    \n+    @Test\n+    public void test_modelCopy(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Model m2 = col.getModels().copy(m);\n+        assertEquals(\"Basic copy\", m2.getString(\"name\"));\n+        assertNotEquals(m2.getLong(\"id\"), m.getLong(\"id\"));\n+        assertEquals(2, m2.getJSONArray(\"flds\").length());\n+        assertEquals(2, m.getJSONArray(\"flds\").length());\n+        assertEquals(m.getJSONArray(\"flds\").length(), m2.getJSONArray(\"flds\").length());\n+        assertEquals(1, m.getJSONArray(\"tmpls\").length());\n+        assertEquals(1, m2.getJSONArray(\"tmpls\").length());\n+        assertEquals(col.getModels().scmhash(m), col.getModels().scmhash(m2));\n+    }\n+    \n+    @Test\n+    public void test_fields() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        Model m = col.getModels().current();\n+        // make sure renaming a field updates the templates\n+        col.getModels().renameField(m, m.getJSONArray(\"flds\").getJSONObject(0), \"NewFront\");\n+        assertTrue(m.getJSONArray(\"tmpls\").getJSONObject(0).getString(\"qfmt\").contains(\"{{NewFront}}\"));\n+        String h = col.getModels().scmhash(m);\n+        // add a field\n+        JSONObject field = col.getModels().newField(\"foo\");\n+        col.getModels().addField(m, field);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        assertNotEquals(h, col.getModels().scmhash(m));\n+        // rename it\n+        field = m.getJSONArray(\"flds\").getJSONObject(2);\n+        col.getModels().renameField(m, field, \"bar\");\n+        assertEquals(\"\", col.getNote(col.getModels().nids(m).get(0)).getItem(\"bar\"));\n+        // delete back\n+        col.getModels().remField(m, m.getJSONArray(\"flds\").getJSONObject(1));\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 1 -> 0\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(1), 0);\n+        assertArrayEquals(new String [] {\"1\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // add another and put in middle\n+        field = col.getModels().newField(\"baz\");\n+        col.getModels().addField(m, field);\n+        note = col.getNote(col.getModels().nids(m).get(0));\n+        note.setItem(\"baz\",\"2\");\n+        note.flush();\n+        assertArrayEquals(new String [] {\"1\", \"\", \"2\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 2 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(2), 1);\n+        assertArrayEquals(new String [] {\"1\", \"2\", \"\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 2\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 2);\n+        assertArrayEquals(new String [] {\"2\", \"\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+        // move 0 -> 1\n+        col.getModels().moveField(m, m.getJSONArray(\"flds\").getJSONObject(0), 1);\n+        assertArrayEquals(new String [] {\"\", \"2\", \"1\"}, col.getNote(col.getModels().nids(m).get(0)).getFields());\n+    }\n+    \n+    @Test\n+    public void test_templates() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"1\");\n+        note.setItem(\"Back\",\"2\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+        // switch templates\n+        col.getModels().moveTemplate(m, c.template(), 1);\n+        c.load();\n+        c2.load();\n+        assertEquals(1, c.getOrd());\n+        assertEquals(0, c2.getOrd());\n+        // removing a template should delete its cards\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(1, col.cardCount());\n+        // and should have updated the other cards' ordinals\n+        c = note.cards().get(0);\n+        assertEquals(0, c.getOrd());\n+        assertEquals(\"1\", stripHTML(c.q()));\n+        // it shouldn't be possible to orphan notes by removing templates\n+        t = mm.newTemplate(\"template name\");\n+        mm.addTemplateModChanged(m, t);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        assertEquals(0,\n+                     col.getDb().queryLongScalar(\n+                                                 \"select count() from cards where nid not in (select id from notes)\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze_ordinals() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{text:cloze:Text}}\");\n+        t.put(\"afmt\", \"{{text:cloze:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"{{c1::firstQ::firstA}}{{c2::secondQ::secondA}}\");\n+        col.addNote(note);\n+        assertEquals(2, col.cardCount());\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c = cards.get(0);\n+        Card c2 = cards.get(1);\n+        // first card should have first ord\n+        assertEquals(0, c.getOrd());\n+        assertEquals(1, c2.getOrd());\n+    }\n+    \n+    @Test\n+    public void test_text(){\n+        Collection col = getCol();\n+        Model m = col.getModels().current();\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{text:Front}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"hello<b>world\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"helloworld\"));\n+    }\n+    \n+    @Test\n+    public void test_cloze(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        assertEquals(\"Cloze\", note.model().getString(\"name\"));\n+        // a cloze model with no clozes is not empty\n+        note.setItem(\"Text\",\"nothing\");\n+        assertNotEquals(0, col.addNote(note));\n+        // try with one cloze\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"hello <span class=cloze>[...]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"hello <span class=cloze>world</span>\"));\n+        // and with a comment\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world::typical}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).q().contains(\"<span class=cloze>[typical]</span>\"));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>world</span>\"));\n+        // and with 2 clozes\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}} {{c2::bar}}\");\n+        assertEquals(2, col.addNote(note));\n+        List<Card> cards =  note.cards();\n+        assertEquals(2, cards.size());\n+        Card c1 = cards.get(0);\n+        Card c2 = cards.get(1);\n+        assertTrue(c1.q().contains(\"<span class=cloze>[...]</span> bar\"));\n+        assertTrue(c1.a().contains(\"<span class=cloze>world</span> bar\"));\n+        assertTrue(c2.q().contains(\"world <span class=cloze>[...]</span>\"));\n+        assertTrue(c2.a().contains(\"world <span class=cloze>bar</span>\"));\n+        // if there are multiple answers for a single cloze, they are given in a\n+        // list\n+        note = col.newNote();\n+        note.setItem(\"Text\",\"a {{c1::b}} {{c1::c}}\");\n+        assertEquals(1, col.addNote(note));\n+        assertTrue(note.cards().get(0).a().contains(\"<span class=cloze>b</span> <span class=cloze>c</span>\"));\n+        // if we add another cloze, a card should be generated\n+        int cnt = col.cardCount();\n+        note.setItem(\"Text\",\"{{c2::hello}} {{c1::foo}}\");\n+        note.flush();\n+        assertEquals(cnt + 1, col.cardCount());\n+        // 0 or negative indices are not supported\n+        note.setItem(\"Text\",\"{{c0::zero}} {{c-1:foo}}\");\n+        note.flush();\n+        assertEquals(2, note.numberOfCards());\n+    }\n+    \n+    @Test\n+    public void test_cloze_mathjax(){\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Note note = col.newNote();\n+        note.setItem(\"Text\", \"{{c1::ok}} \\\\(2^2\\\\) {{c2::not ok}} \\\\(2^{{c3::2}}\\\\) \\\\(x^3\\\\) {{c4::blah}} {{c5::text with \\\\(x^2\\\\) jax}}\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(5, note.numberOfCards());\n+        assertTrue(note.cards().get(0).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(1).q().contains(\"class=cloze\"));\n+        assertFalse(note.cards().get(2).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(3).q().contains(\"class=cloze\"));\n+        assertTrue(note.cards().get(4).q().contains(\"class=cloze\"));\n+        \n+        note = col.newNote();\n+        note.setItem(\"Text\",\"\\\\(a\\\\) {{c1::b}} \\\\[ {{c1::c}} \\\\]\");\n+        assertNotEquals(0, col.addNote(note));\n+        assertEquals(1, note.numberOfCards());\n+        String question = note.cards().get(0).q();\n+        assertTrue(\"Question \u00ab\"+question+\"\u00bb does not end correctly\", question.endsWith(\"\\\\(a\\\\) <span class=cloze>[...]</span> \\\\[ [...] \\\\]\"));\n+    }\n+    \n+    @Test\n+    public void test_typecloze(){\n+        Collection col = getCol();\n+        Model m = col.getModels().byName(\"Cloze\");\n+        col.getModels().setCurrent(m);\n+        m.getJSONArray(\"tmpls\").getJSONObject(0).put(\"qfmt\", \"{{cloze:Text}}{{type:cloze:Text}}\");\n+        col.getModels().save(m);\n+        Note note = col.newNote();\n+        note.setItem(\"Text\",\"hello {{c1::world}}\");\n+        col.addNote(note);\n+        assertTrue(note.cards().get(0).q().contains(\"[[type:cloze:Text]]\"));\n+    }\n+    \n+    @Test\n+    public void test_chained_mods() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.getModels().setCurrent(col.getModels().byName(\"Cloze\"));\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        \n+        // We replace the default Cloze template\n+        JSONObject t = mm.newTemplate(\"ChainedCloze\");\n+        t.put(\"qfmt\", \"{{cloze:text:Text}}\");\n+        t.put(\"afmt\", \"{{cloze:text:Text}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        col.getModels().remTemplate(m, m.getJSONArray(\"tmpls\").getJSONObject(0));\n+        \n+        Note note = col.newNote();\n+        String q1 = \"<span style=\\\"color:red\\\">phrase</span>\";\n+        String a1 = \"<b>sentence</b>\";\n+        String q2 = \"<span style=\\\"color:red\\\">en chaine</span>\";\n+        String a2 = \"<i>chained</i>\";\n+        note.setItem(\"Text\",\"This {{c1::\"+q1+\"::\"+a1+\"}} demonstrates {{c1::\"+q2+\"::\"+a2+\"}} clozes.\");\n+        assertEquals(1, col.addNote(note));\n+        String question = note.cards().get(0).q();\n+        /* TODO: chained modifier\n+        assertTrue(\"Question \u00ab\"+question+\"\u00bb does not contain the expected string\", question.contains(\"This <span class=cloze>[sentence]</span> demonstrates <span class=cloze>[chained]</span> clozes.\")\n+                   );\n+        assertTrue(note.cards().get(0).a().contains(\"This <span class=cloze>phrase</span> demonstrates <span class=cloze>en chaine</span> clozes.\"\n+                                                    ));\n+\n+         */\n+    }\n+    \n+    @Test\n+    public void test_modelChange() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        Model cloze = col.getModels().byName(\"Cloze\");\n+        // enable second template and add a note\n+        Model m = col.getModels().current();\n+        Models mm = col.getModels();\n+        JSONObject t = mm.newTemplate(\"Reverse\");\n+        t.put(\"qfmt\", \"{{Back}}\");\n+        t.put(\"afmt\", \"{{Front}}\");\n+        mm.addTemplateModChanged(m, t);\n+        mm.save(m);\n+        Model basic = m;\n+        Note note = col.newNote();\n+        note.setItem(\"Front\",\"note\");\n+        note.setItem(\"Back\",\"b123\");\n+        col.addNote(note);\n+        // switch fields\n+        Map<Integer, Integer> map = new HashMap<>();\n+        map.put(0, 1);\n+        map.put(1, 0);\n+        col.getModels().change(basic,new long [] {note.getId()}, basic, map, null);\n+        note.load();\n+        assertEquals(\"b123\", note.getItem(\"Front\"));\n+        assertEquals(\"note\", note.getItem(\"Back\"));\n+        // switch cards\n+        Card c0 = note.cards().get(0);\n+        Card c1 = note.cards().get(1);\n+        assertTrue(c0.q().contains(\"b123\"));\n+        assertTrue(c1.q().contains(\"note\"));\n+        assertEquals(0, c0.getOrd());\n+        assertEquals(1, c1.getOrd());\n+        col.getModels().change(basic,new long []{note.getId()}, basic, null, map);\n+        note.load();\n+        c0.load();\n+        c1.load();\n+        assertTrue(c0.q().contains(\"note\"));\n+        assertTrue(c1.q().contains(\"b123\"));\n+        assertEquals(1, c0.getOrd());\n+        assertEquals(0, c1.getOrd());\n+        // .cards() returns cards in order\n+        assertEquals(c1.getId(), note.cards().get(0).getId());\n+        // delete first card\n+        map = new HashMap<>();\n+        map.put(0, null);\n+        map.put(1, 1);\n+        // if (isWin) {\n+        //     // The low precision timer on Windows reveals a race condition\n+        //     time.sleep(0.05);\n+        // }\n+        col.getModels().change(basic,new long [] {note.getId()}, basic, null, map);\n+        note.load();\n+        c0.load();\n+        // the card was deleted\n+        // but we have two cards, as a new one was generated\n+        assertEquals(2, note.numberOfCards());\n+        // an unmapped field becomes blank\n+        assertEquals(\"b123\", note.getItem(\"Front\"));\n+        assertEquals(\"note\", note.getItem(\"Back\"));\n+        col.getModels().change(basic,new long [] {note.getId()}, basic, map, null);\n+        note.load();\n+        assertEquals(\"\", note.getItem(\"Front\"));\n+        assertEquals(\"note\", note.getItem(\"Back\"));\n+        // another note to try model conversion\n+        note = col.newNote();\n+        note.setItem(\"Front\",\"f2\");\n+        note.setItem(\"Back\",\"b2\");\n+        col.addNote(note);\n+        // counts = col.getModels().all_use_counts();\n+        // Using older version of the test\n+        assertEquals(2, col.getModels().useCount(basic));\n+        assertEquals(0, col.getModels().useCount(cloze));\n+        // Identity map\n+        map = new HashMap<>();\n+        map.put(0, 0);\n+        map.put(1, 1);\n+        col.getModels().change(basic,new long []{note.getId()}, cloze, map, map);\n+        note.load();\n+        assertEquals(\"f2\", note.getItem(\"Text\"));\n+        assertEquals(2, note.numberOfCards());\n+        // back the other way, with deletion of second ord\n+        col.getModels().remTemplate(basic, basic.getJSONArray(\"tmpls\").getJSONObject(1));\n+        assertEquals(2, col.getDb().queryScalar(\"select count() from cards where nid = ?\", note.getId()));\n+        map = new HashMap<>();\n+        map.put(0, 0);\n+        col.getModels().change(cloze,new long []{note.getId()}, basic, map, map);\n+        assertEquals(1, col.getDb().queryScalar(\"select count() from cards where nid = ?\", note.getId()));\n+    }\n+    \n+    \n+    private void reqSize(Model model) {\n+        if (model.getInt(\"type\") == MODEL_CLOZE) {\n+            return;\n+        }\n+        assertEquals(model.getJSONArray(\"req\").length(), model.getJSONArray(\"tmpls\").length());\n+    }\n+    \n+    @Test\n+    public void test_req(){\n+        \n+        Collection col = getCol();\n+        Models mm = col.getModels();\n+        Model basic = mm.byName(\"Basic\");\n+        assertTrue(basic.has(\"req\"));\n+        reqSize(basic);\n+        JSONArray r = basic.getJSONArray(\"req\").getJSONArray(0);\n+        assertEquals(0, r.getInt(0));\n+        assertTrue(Arrays.asList(new String[]{\"any\", \"all\"}).contains(r.getString(1)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "originalPosition": 419}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTU3MA==", "bodyText": "Try to avoid commenting out assertions if the test would still \"pass\"", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460181570", "createdAt": "2020-07-24T17:10:11Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/UndoTest.java", "diffHunk": "@@ -0,0 +1,126 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.COUNT_REMAINING;\n+import static com.ichi2.libanki.Consts.QUEUE_TYPE_LRN;\n+import static com.ichi2.libanki.Consts.QUEUE_TYPE_NEW;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+\n+@RunWith(AndroidJUnit4.class)\n+public class UndoTest extends RobolectricTest {\n+    /*****************\n+     ** Undo         *\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+    @Test\n+    @Ignore(\"We need to figure out how to test save/undo\")\n+    public void test_op() throws Exception {\n+        Collection col = getColV2();\n+        // should have no undo by default\n+        assertNull(col.undoType());\n+        // let's adjust a study option\n+        col.save(\"studyopts\");\n+        col.getConf().put(\"abc\", 5);\n+        // it should be listed as undoable\n+        assertEquals(\"studyopts\", col.undoName(getTargetContext().getResources()));\n+        // with about 5 minutes until it's clobbered\n+        /* lastSave\n+           assertThat(Utils.now() - col._lastSave, lesserThan(1));\n+        */\n+        // undoing should restore the old value\n+        col.undo();\n+        assertEquals(null, col.undoType());\n+        assertFalse(col.getConf().has(\"abc\"));\n+        // an (auto)save will clear the undo\n+        col.save(\"foo\");\n+        assertEquals(\"foo\", col.undoName(getTargetContext().getResources()));\n+        col.save();\n+        assertEquals(\"\", col.undoName(getTargetContext().getResources()));\n+        // and a review will, too\n+        col.save(\"add\");\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        assertEquals(\"add\", col.undoName(getTargetContext().getResources()));\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(\"Review\", col.undoName(getTargetContext().getResources()));\n+    }\n+\n+\n+    @Test\n+    public void test_review() throws Exception {\n+        Collection col = getColV2();\n+        col.getConf().put(\"counts\", COUNT_REMAINING);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        /* TODO:\u00a0 undo after reset ?\n+        assertNotNull(col.undoType());\n+\n+         */\n+        // answer\n+        assertArrayEquals(new int[] {1, 0, 0}, col.getSched().counts());\n+        Card c = col.getSched().getCard();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(1001, c.getLeft());\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        // undo\n+        assertNotNull(col.undoType());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {1, 0, 0}, col.getSched().counts());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertNotEquals(1001, c.getLeft());\n+        assertNull(col.undoType());\n+        // we should be able to undo multiple answers too\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 2, 0}, col.getSched().counts());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {1, 1, 0}, col.getSched().counts());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+        // performing a normal op will clear the review queue\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(Collection.DismissType.REVIEW, col.undoType());\n+        col.save(\"foo\");\n+        /* TODO: save and undo\n+        assertEquals(\"foo\", col.undoName(getTargetContext().getResources()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MTcxMA==", "bodyText": "This change seems unnecessary", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460181710", "createdAt": "2020-07-24T17:10:27Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/UtilsTest.java", "diffHunk": "@@ -84,4 +86,7 @@ public void testCopyFile() throws Exception {\n         Utils.copyFile(new File(resource.toURI()), copy);\n         Assert.assertEquals(TestUtils.getMD5(resourcePath), TestUtils.getMD5(copy.getCanonicalPath()));\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDE4MjA0Ng==", "bodyText": "More commented out assertions", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460182046", "createdAt": "2020-07-24T17:11:08Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -126,20 +156,1248 @@ private void selectNewDeck() {\n         getCol().getDecks().select(did);\n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         getCol().getSched().deckDueTree();\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", SchedV2Test.expectedTree(sched, false), tree);\n+        assertEquals(\"Tree has not the expected structure\", SchedV2Test.expectedTree(sched, false), tree);\n \n     }\n \n \n     private void selectDefaultDeck() {\n         getCol().getDecks().select(Consts.DEFAULT_DECK_ID);\n     }\n-}\n\\ No newline at end of file\n+\n+\n+    /*****************\n+     ** Upstream test*\n+     *****************/\n+    private Collection getColV1() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(1);\n+        return col;\n+    }\n+\n+\n+    public void test_new_v1() throws Exception {\n+        Collection col = getColV1();\n+        col.reset();\n+        assertEquals(0, col.getSched().newDue());\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount); get access of new count\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee"}, "originalPosition": 137}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a5909b8f3791133d4d28358eb41b6d465eb3f0ee", "committedDate": "2020-07-24T16:43:28Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "7536c16bf956a6c2821814eabd6af5685913774f", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7536c16bf956a6c2821814eabd6af5685913774f", "committedDate": "2020-07-24T18:47:20Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7536c16bf956a6c2821814eabd6af5685913774f", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/7536c16bf956a6c2821814eabd6af5685913774f", "committedDate": "2020-07-24T18:47:20Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "5402e975c6a82c1902595f1837f06e8abcd75077", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/5402e975c6a82c1902595f1837f06e8abcd75077", "committedDate": "2020-07-24T18:52:54Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5402e975c6a82c1902595f1837f06e8abcd75077", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/5402e975c6a82c1902595f1837f06e8abcd75077", "committedDate": "2020-07-24T18:52:54Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "59d5761081c79d8aef9b0bd799f664f2e78d15d7", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/59d5761081c79d8aef9b0bd799f664f2e78d15d7", "committedDate": "2020-07-24T20:04:25Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "59d5761081c79d8aef9b0bd799f664f2e78d15d7", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/59d5761081c79d8aef9b0bd799f664f2e78d15d7", "committedDate": "2020-07-24T20:04:25Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a74f9f92032777f428b26b339caf53bdc302345c", "committedDate": "2020-07-25T18:12:18Z", "message": "Upstream libanki tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MzAzMDI5", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-455303029", "createdAt": "2020-07-25T18:51:18Z", "commit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxODo1MToxOVrOG3GnBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxODo1MToxOVrOG3GnBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzE1OA==", "bodyText": "I think we should move this into a separate PR", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460433158", "createdAt": "2020-07-25T18:51:19Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ClozeTest.java", "diffHunk": "@@ -72,7 +69,7 @@ public void testCloze() {\n         int cnt = d.cardCount();\n         f.setItem(\"Text\", \"{{c2::hello}} {{c1::foo}}\");\n         f.flush();\n-        assertEquals(cnt+1, d.cardCount());\n+        assertEquals(cnt + 1, d.cardCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU1MzAzMjIw", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-455303220", "createdAt": "2020-07-25T18:54:51Z", "commit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxODo1NDo1MVrOG3GoKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yNVQxOTozMDoyMlrOG3G0VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzQ0OQ==", "bodyText": "This should probably override setUp and use a local variable - avoids the need to call it on each", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460433449", "createdAt": "2020-07-25T18:54:51Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/ExportingTest.java", "diffHunk": "@@ -0,0 +1,173 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+@RunWith(AndroidJUnit4.class)\n+public class ExportingTest extends RobolectricTest {\n+    /*****************\n+     ** Exporting    *\n+     *****************/\n+    private Collection setup1() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzMzk1OQ==", "bodyText": "Could you move this to a separate PR, or remove the change - not relevant to porting", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460433959", "createdAt": "2020-07-25T19:00:35Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/MathJaxClozeTest.java", "diffHunk": "@@ -41,6 +41,7 @@ public void removeFormattingFromMathjax() {\n         assertEquals(escaped_s2, Template.removeFormattingFromMathjax(original_s2, \"1\"));\n     }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDQzMg==", "bodyText": "Could you remove this file from the PR?", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460434432", "createdAt": "2020-07-25T19:06:08Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/NoteTest.java", "diffHunk": "@@ -22,6 +22,7 @@ public void noFieldDataReturnsFirstClozeIndex() {\n         assertThat(\"No data should return a cloze index of 1 the next.\", expected, is(1));\n     }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDY0Mg==", "bodyText": "Again, maybe for another PR", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460434642", "createdAt": "2020-07-25T19:08:48Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/UtilsTest.java", "diffHunk": "@@ -43,15 +43,15 @@ public void testZipWithPathTraversal() {\n             Enumeration zipEntries = zipFile.getEntries();\n             while (zipEntries.hasMoreElements()) {\n                 ZipArchiveEntry ze2 = (ZipArchiveEntry) zipEntries.nextElement();\n-                Utils.unzipFiles(zipFile, \"/tmp\", new String[]{ze2.getName()}, null);\n+                Utils.unzipFiles(zipFile, \"/tmp\", new String[] {ze2.getName()}, null);\n             }\n             Assert.fail(\"Expected an IOException\");\n-        }\n-        catch (Exception e) {\n+        } catch (Exception e) {\n             Assert.assertEquals(\"File is outside extraction target directory.\", e.getMessage());\n         }\n     }\n \n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTI5OQ==", "bodyText": "Ignore the test for now", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460435299", "createdAt": "2020-07-25T19:16:19Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedTest.java", "diffHunk": "@@ -126,20 +158,1248 @@ private void selectNewDeck() {\n         getCol().getDecks().select(did);\n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         getCol().getSched().deckDueTree();\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", SchedV2Test.expectedTree(sched, false), tree);\n+        assertEquals(\"Tree has not the expected structure\", SchedV2Test.expectedTree(sched, false), tree);\n \n     }\n \n \n     private void selectDefaultDeck() {\n         getCol().getDecks().select(Consts.DEFAULT_DECK_ID);\n     }\n-}\n\\ No newline at end of file\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py*\n+     *****************/\n+    private Collection getColV1() throws ConfirmModSchemaException {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(1);\n+        return col;\n+    }\n+\n+\n+    public void test_new_v1() throws Exception {\n+        Collection col = getColV1();\n+        col.reset();\n+        assertEquals(0, col.getSched().newDue());\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount); get access of new count\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail\n+        // // the default order should ensure siblings are not seen together, and\n+        // // should show all cards\n+        // Model m = col.getModels().current(); Models mm = col.getModels()\n+        // JSONObject t = mm.newTemplate(\"Reverse\")\n+        // t['qfmt'] = \"{{Back}}\"\n+        // t['afmt'] = \"{{Front}}\"\n+        // mm.addTemplateModChanged(m, t)\n+        // mm.save(m)\n+        // note = col.newNote()\n+        // note['Front'] = u\"2\"; note['Back'] = u\"2\"\n+        // col.addNote(note)\n+        // note = col.newNote()\n+        // note['Front'] = u\"3\"; note['Back'] = u\"3\"\n+        // col.addNote(note)\n+        // col.reset()\n+        // qs = (\"2\", \"3\", \"2\", \"3\")\n+        // for (int n = 0; n < 4; n++) {\n+        //     c = col.getSched().getCard()\n+        //     assertTrue(qs[n] in c.q())\n+        //     col.getSched().answerCard(c, 2)\n+        // }\n+    }\n+\n+\n+    @Test\n+    public void test_newLimits_V1() throws Exception {\n+        Collection col = getColV1();\n+        // add some notes\n+        long deck2 = col.getDecks().id(\"Default::foo\");\n+        Note note;\n+        for (int i = 0; i < 30; i++) {\n+            note = col.newNote();\n+            note.setItem(\"Front\", Integer.toString(i));\n+            if (i > 4) {\n+                note.model().put(\"did\", deck2);\n+            }\n+            col.addNote(note);\n+        }\n+        // give the child deck a different configuration\n+        long c2 = col.getDecks().confId(\"new conf\");\n+        col.getDecks().setConf(col.getDecks().get(deck2), c2);\n+        col.reset();\n+        // both confs have defaulted to a limit of 20\n+        // assertEquals(20, col.getSched().newCount); TODO: newCount getter\n+        // first card we get comes from parent\n+        Card c = col.getSched().getCard();\n+        assertEquals(1, c.getDid());\n+        // limit the parent to 10 cards, meaning we get 10 in total\n+        DeckConfig conf1 = col.getDecks().confForDid(1);\n+        conf1.getJSONObject(\"new\").put(\"perDay\", 10);\n+        col.getDecks().save(conf1);\n+        col.reset();\n+        //assertEquals(10, col.getSched().newCount);TODO: newCount getter\n+        // if we limit child to 4, we should get 9\n+        DeckConfig conf2 = col.getDecks().confForDid(deck2);\n+        conf2.getJSONObject(\"new\").put(\"perDay\", 4);\n+        col.getDecks().save(conf2);\n+        col.reset();\n+        //assertEquals(9, col.getSched().newCount);TODO: newCount getter\n+    }\n+\n+\n+    @Test\n+    public void test_newBoxes_v1() throws Exception {\n+        Collection col = getColV1();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 2, 3, 4, 5}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+        // should handle gracefully\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+    }\n+\n+\n+    @Test\n+    public void test_learnV1() throws Exception {\n+        Collection col = getColV1();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // sched.getCard should return it, since it's due in the past\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        col.getDecks().save(conf);\n+        // fail it\n+        col.getSched().answerCard(c, 1);\n+        // it should have three reps left to graduation\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(3, c.getLeft() / 1000);\n+        // it should be due in 30 seconds\n+        long t = Math.round(c.getDue() - Utils.now());\n+        assertTrue(t >= 25 && t <= 40);\n+        // pass it once\n+        col.getSched().answerCard(c, 2);\n+        // it should be due in 3 minutes\n+        assertEquals(Math.round(c.getDue() - Utils.now()), 179, 1);\n+        assertEquals(2, c.getLeft() % 1000);\n+        assertEquals(2, c.getLeft() / 1000);\n+        // check log is accurate\n+        Cursor log = col.getDb().getDatabase().query(\"select * from revlog order by id desc\");\n+        assertTrue(log.moveToFirst());\n+        assertEquals(2, log.getInt(3));\n+        assertEquals(-180, log.getInt(4));\n+        assertEquals(-30, log.getInt(5));\n+        // pass again\n+        col.getSched().answerCard(c, 2);\n+        // it should be due in 10 minutes\n+        assertEquals(c.getDue() - Utils.now(), 599, 1);\n+        assertEquals(1, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        // the next pass should graduate the card\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        // should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(1, c.getIvl());\n+        // or normal removal\n+        c.setType(CARD_TYPE_NEW);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertTrue(checkRevIvl(col, c, 4));\n+        // revlog should have been updated each time\n+        assertEquals(5, col.getDb().queryScalar(\"select count() from revlog where type = 0\"));\n+        // now failed card handling\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        c.setODue(123);\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(123, c.getDue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // we should be able to remove manually, too\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        c.setODue(321);\n+        c.flush();\n+        ((Sched) col.getSched()).removeLrn();\n+        c.load();\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(321, c.getDue());\n+    }\n+\n+\n+    @Test\n+    public void test_learn_collapsedV1() throws Exception {\n+        Collection col = getColV1();\n+        // add 2 notes\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"1\");\n+        col.addNote(note);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"2\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // should get '1' first\n+        Card c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"1\"));\n+        // pass it so it's due in 10 minutes\n+        col.getSched().answerCard(c, 2);\n+        // get the other card\n+        c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"2\"));\n+        // fail it so it's due in 1 minute\n+        col.getSched().answerCard(c, 1);\n+        // we shouldn't get the same card again\n+        c = col.getSched().getCard();\n+        assertFalse(c.q().endsWith(\"2\"));\n+    }\n+\n+\n+    @Test\n+    public void test_learn_dayV1() throws Exception {\n+        Collection col = getColV1();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.getSched().reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 10, 1440, 2880}));\n+        col.getDecks().save(conf);\n+        // pass it\n+        col.getSched().answerCard(c, 2);\n+        // two reps to graduate, 1 more today\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+\n+        assertEquals(86400, col.getSched().nextIvl(c, 2));\n+        // answering it will place it in queue 3\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getQueue());\n+        assertNull(col.getSched().getCard());\n+        // for testing, move it back a day\n+        c.setDue(c.getDue() - 1);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        // nextIvl should work\n+        assertEquals(86400 * 2, col.getSched().nextIvl(c, 2));\n+        // if we fail it, it should be back in the correct queue\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        col.undo();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 2);\n+        // simulate the passing of another two days\n+        c.setDue(c.getDue() - 2);\n+        c.flush();\n+        col.reset();\n+        // the last pass should graduate it into a review card\n+        assertEquals(86400, col.getSched().nextIvl(c, 2));\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // if the lapse step is tomorrow, failing it should handle the counts\n+        // correctly\n+        c.setDue(0);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1440}));\n+        col.getDecks().save(conf);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(CARD_TYPE_RELEARNING, c.getQueue());\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_reviewsV1() throws Exception {\n+        Collection col = getColV1();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set the card up as a review card, due 8 days ago\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday() - 8);\n+        c.setFactor(STARTING_FACTOR);\n+        c.setReps(3);\n+        c.setLapses(1);\n+        c.setIvl(100);\n+        c.startTimer();\n+        c.flush();\n+        // save it for later use as well\n+        Card cardcopy = c.clone();\n+        // failing it should put it in the learn queue with the default options\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        // different delay to new\n+        col.reset();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {2, 20}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        // it should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getODue());\n+        assertEquals(1, c.getIvl());\n+        // but because it's in the learn queue, its current due time should be in\n+        // the future\n+        assertTrue(c.getDue() >= Utils.now());\n+        assertTrue((c.getDue() - Utils.now()) > 118);\n+        // factor should have been decremented\n+        assertEquals(2300, c.getFactor());\n+        // check counters\n+        assertEquals(2, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // check ests.\n+\n+        assertEquals(120, col.getSched().nextIvl(c, 1));\n+        assertEquals(20 * 60, col.getSched().nextIvl(c, 2));\n+        // try again with an ease of 2 instead\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // the new interval should be (100 + 8/4) * 1.2 = 122\n+        assertTrue(checkRevIvl(col, c, 122));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been decremented\n+        assertEquals(2350, c.getFactor());\n+        // check counters\n+        assertEquals(1, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // ease 3\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 3);\n+        // the new interval should be (100 + 8/2) * 2.5 = 260\n+        assertTrue(checkRevIvl(col, c, 260));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been left alone\n+        assertEquals(STARTING_FACTOR, c.getFactor());\n+        // ease 4\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 4);\n+        // the new interval should be (100 + 8) * 2.5 * 1.3 = 351\n+        assertTrue(checkRevIvl(col, c, 351));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been increased\n+        assertEquals(2650, c.getFactor());\n+    }\n+\n+\n+\n+\n+    @Test\n+    public void test_button_spacingV1() throws Exception {\n+        Collection col = getColV1();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        // 1 day ivl review card due now\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday());\n+        c.setReps(1);\n+        c.setIvl(1);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        // Upstream, there is no space in 2d\n+        assertEquals(\"2 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n+        assertEquals(\"3 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 3)));\n+        assertEquals(\"4 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+    }\n+\n+\n+    @Test\n+    public void test_overdue_lapseV1() throws Exception {\n+        // disabled in commit anki@3069729776990980f34c25be66410e947e9d51a2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 507}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTYzOA==", "bodyText": "\ud83d\uded1 This will be flaky in CI", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460435638", "createdAt": "2020-07-25T19:20:02Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +182,1429 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNTkwOQ==", "bodyText": "ditto - ignore", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460435909", "createdAt": "2020-07-25T19:22:54Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +182,1429 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {\n+            throw new Exception(\"Unit tests will fail around the day rollover.\");\n+        }\n+    }\n+\n+\n+    @Test\n+    public void test_basics() throws Exception {\n+        Collection col = getCol();\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+    }\n+\n+\n+    @Test\n+    public void test_new_v2() throws Exception {\n+        Collection col = getColV2();\n+        col.reset();\n+        // assertEquals(0, col.getSched().newCount);TODO: newCount getter\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount);TODO: newCount getter\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail\n+        // // the default order should ensure siblings are not seen together, and\n+        // // should show all cards\n+        // Model m = col.getModels().current(); Models mm = col.getModels()\n+        // JSONObject t = mm.newTemplate(\"Reverse\")\n+        // t['qfmt'] = \"{{Back}}\"\n+        // t['afmt'] = \"{{Front}}\"\n+        // mm.addTemplateModChanged(m, t)\n+        // mm.save(m)\n+        // note = col.newNote()\n+        // note['Front'] = u\"2\"; note['Back'] = u\"2\"\n+        // col.addNote(note)\n+        // note = col.newNote()\n+        // note['Front'] = u\"3\"; note['Back'] = u\"3\"\n+        // col.addNote(note)\n+        // col.reset()\n+        // qs = (\"2\", \"3\", \"2\", \"3\")\n+        // for (int n = 0; n < 4; n++) {\n+        //     c = col.getSched().getCard()\n+        //     assertTrue(qs[n] in c.q())\n+        //     col.getSched().answerCard(c, 2)\n+        // }\n+    }\n+\n+\n+    @Test\n+    public void test_newLimits_V2() throws Exception {\n+        Collection col = getColV2();\n+        // add some notes\n+        long deck2 = col.getDecks().id(\"Default::foo\");\n+        for (int i = 0; i < 30; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", Integer.toString(i));\n+            if (i > 4) {\n+                note.model().put(\"did\", deck2);\n+            }\n+            col.addNote(note);\n+        }\n+        // give the child deck a different configuration\n+        long c2 = col.getDecks().confId(\"new conf\");\n+        col.getDecks().setConf(col.getDecks().get(deck2), c2);\n+        col.reset();\n+        // both confs have defaulted to a limit of 20\n+        // assertEquals(20, col.getSched().newCount);TODO: newCount getter\n+        // first card we get comes from parent\n+        Card c = col.getSched().getCard();\n+        assertEquals(1, c.getDid());\n+        // limit the parent to 10 cards, meaning we get 10 in total\n+        DeckConfig conf1 = col.getDecks().confForDid(1);\n+        conf1.getJSONObject(\"new\").put(\"perDay\", 10);\n+        col.getDecks().save(conf1);\n+        col.reset();\n+        // assertEquals(10, col.getSched().newCount);TODO: newCount getter\n+        // if we limit child to 4, we should get 9\n+        DeckConfig conf2 = col.getDecks().confForDid(deck2);\n+        conf2.getJSONObject(\"new\").put(\"perDay\", 4);\n+        col.getDecks().save(conf2);\n+        col.reset();\n+        //assertEquals(9, col.getSched().newCount);TODO: newCount getter\n+    }\n+\n+\n+    @Test\n+    public void test_newBoxes_v2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 2, 3, 4, 5}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+        // should handle gracefully\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+    }\n+\n+\n+    @Test\n+    public void test_learnV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // sched.getCard should return it, since it's due in the past\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        col.getDecks().save(conf);\n+        // fail it\n+        col.getSched().answerCard(c, 1);\n+        // it should have three reps left to graduation\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(3, c.getLeft() / 1000);\n+        // it should be due in 30 seconds\n+        long t = Math.round(c.getDue() - Utils.now());\n+        assertTrue(t >= 25 && t <= 40);\n+        // pass it once\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 3 minutes\n+        double dueIn = c.getDue() - Utils.now();\n+        assertTrue(178 <= dueIn && dueIn <= 180 * 1.25);\n+        assertEquals(2, c.getLeft() % 1000);\n+        assertEquals(2, c.getLeft() / 1000);\n+        // check log is accurate\n+        Cursor log = col.getDb().getDatabase().query(\"select * from revlog order by id desc\");\n+        assertTrue(log.moveToFirst());\n+        assertEquals(3, log.getInt(3));\n+        assertEquals(-180, log.getInt(4));\n+        assertEquals(-30, log.getInt(5));\n+        // pass again\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 10 minutes\n+        dueIn = c.getDue() - Utils.now();\n+        assertTrue(599 <= dueIn && dueIn <= 600 * 1.25);\n+        assertEquals(1, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        // the next pass should graduate the card\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        // should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(1, c.getIvl());\n+        // or normal removal\n+        c.setType(CARD_TYPE_NEW);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertTrue(checkRevIvl(col, c, 4));\n+        // revlog should have been updated each time\n+        assertEquals(5, col.getDb().queryScalar(\"select count() from revlog where type = 0\"));\n+    }\n+\n+\n+    @Test\n+    public void test_relearn() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        assertEquals(1, c.getIvl());\n+\n+        // immediately graduate it\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(2, c.getIvl());\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+    }\n+\n+\n+    @Test\n+    public void test_relearn_no_steps() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+    }\n+\n+\n+    @Test\n+    public void test_learn_collapsedV2() throws Exception {\n+        Collection col = getColV2();\n+        // add 2 notes\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"1\");\n+        col.addNote(note);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"2\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // should get '1' first\n+        Card c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"1\"));\n+        // pass it so it's due in 10 minutes\n+        col.getSched().answerCard(c, 3);\n+        // get the other card\n+        c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"2\"));\n+        // fail it so it's due in 1 minute\n+        col.getSched().answerCard(c, 1);\n+        // we shouldn't get the same card again\n+        c = col.getSched().getCard();\n+        assertFalse(c.q().endsWith(\"2\"));\n+    }\n+\n+\n+    @Test\n+    public void test_learn_dayV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.getSched().reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 10, 1440, 2880}));\n+        col.getDecks().save(conf);\n+        // pass it\n+        col.getSched().answerCard(c, 3);\n+        // two reps to graduate, 1 more today\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        // answering it will place it in queue 3\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertNull(col.getSched().getCard());\n+        // for testing, move it back a day\n+        c.setDue(c.getDue() - 1);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        // nextIvl should work\n+        assertEquals(86400 * 2, col.getSched().nextIvl(c, 3));\n+        // if we fail it, it should be back in the correct queue\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        col.undo();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        // simulate the passing of another two days\n+        c.setDue(c.getDue() - 2);\n+        c.flush();\n+        col.reset();\n+        // the last pass should graduate it into a review card\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // if the lapse step is tomorrow, failing it should handle the counts\n+        // correctly\n+        c.setDue(0);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1440}));\n+        col.getDecks().save(conf);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_reviewsV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set the card up as a review card, due 8 days ago\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday() - 8);\n+        c.setFactor(STARTING_FACTOR);\n+        c.setReps(3);\n+        c.setLapses(1);\n+        c.setIvl(100);\n+        c.startTimer();\n+        c.flush();\n+        // save it for later use as well\n+        Card cardcopy = c.clone();\n+        // try with an ease of 2\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.reset();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // the new interval should be (100) * 1.2 = 120\n+        assertTrue(checkRevIvl(col, c, 120));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been decremented\n+        assertEquals(2350, c.getFactor());\n+        // check counters\n+        assertEquals(1, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // ease 3\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 3);\n+        // the new interval should be (100 + 8/2) * 2.5 = 260\n+        assertTrue(checkRevIvl(col, c, 260));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been left alone\n+        assertEquals(STARTING_FACTOR, c.getFactor());\n+        // ease 4\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 4);\n+        // the new interval should be (100 + 8) * 2.5 * 1.3 = 351\n+        assertTrue(checkRevIvl(col, c, 351));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been increased\n+        assertEquals(2650, c.getFactor());\n+        // leech handling\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        DeckConfig conf = col.getDecks().getConf(1);\n+        conf.getJSONObject(\"lapse\").put(\"leechAction\", LEECH_SUSPEND);\n+        col.getDecks().save(conf);\n+        c = cardcopy.clone();\n+        c.setLapses(7);\n+        c.flush();\n+        /* todo hook\n+        // steup hook\n+        hooked = new [] {};\n+        \n+        def onLeech(card):\n+        hooked.append(1);\n+        \n+        hooks.card_did_leech.append(onLeech);\n+        col.getSched().answerCard(c, 1);\n+        assertTrue(hooked);\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        */\n+    }\n+\n+\n+    @Test\n+    public void test_review_limits() throws Exception {\n+        Collection col = getColV2();\n+\n+        Deck parent = col.getDecks().get(col.getDecks().id(\"parent\"));\n+        Deck child = col.getDecks().get(col.getDecks().id(\"parent::child\"));\n+\n+        DeckConfig pconf = col.getDecks().getConf(col.getDecks().confId(\"parentConf\"));\n+        DeckConfig cconf = col.getDecks().getConf(col.getDecks().confId(\"childConf\"));\n+\n+        pconf.getJSONObject(\"rev\").put(\"perDay\", 5);\n+        col.getDecks().updateConf(pconf);\n+        col.getDecks().setConf(parent, pconf.getLong(\"id\"));\n+        cconf.getJSONObject(\"rev\").put(\"perDay\", 10);\n+        col.getDecks().updateConf(cconf);\n+        col.getDecks().setConf(child, cconf.getLong(\"id\"));\n+\n+        Model m = col.getModels().current();\n+        m.put(\"did\", child.getLong(\"id\"));\n+        col.getModels().save(m, false);\n+\n+        // add some cards\n+        for (int i = 0; i < 20; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", \"one\");\n+            note.setItem(\"Back\", \"two\");\n+            col.addNote(note);\n+\n+            // make them reviews\n+            Card c = note.cards().get(0);\n+            c.setQueue(CARD_TYPE_REV);\n+            c.setType(QUEUE_TYPE_REV);\n+            c.setDue(0);\n+            c.flush();\n+        }\n+\n+        // position 0 is default deck. Different from upstream\n+        AbstractSched.DeckDueTreeNode tree = col.getSched().deckDueTree().get(1);\n+        // (('parent', 1514457677462, 5, 0, 0, (('child', 1514457677463, 5, 0, 0, ()),)))\n+        assertEquals(\"parent\", tree.getFullDeckName());\n+        assertEquals(5, tree.getRevCount());  // paren, tree.review_count)t\n+        assertEquals(5, tree.getChildren().get(0).getRevCount());\n+\n+        // .counts() should match\n+        col.getDecks().select(child.getLong(\"id\"));\n+        col.getSched().reset();\n+        assertArrayEquals(new int[] {0, 0, 5}, col.getSched().counts());\n+\n+        // answering a card in the child should decrement parent count\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 0, 4}, col.getSched().counts());\n+\n+        tree = col.getSched().deckDueTree().get(1);\n+        assertEquals(4, tree.getRevCount());\n+        assertEquals(4, tree.getChildren().get(0).getRevCount());\n+    }\n+\n+\n+    @Test\n+    public void test_button_spacingV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        // 1 day ivl review card due now\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday());\n+        c.setReps(1);\n+        c.setIvl(1);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        // Upstream, there is no space in 2d\n+        assertEquals(\"2 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n+        assertEquals(\"3 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 3)));\n+        assertEquals(\"4 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+\n+        // if hard factor is <= 1, then hard may not increase\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"rev\").put(\"hardFactor\", 1);\n+        col.getDecks().save(conf);\n+        assertEquals(\"1 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n     }\n \n \n+    @Test\n+    public void test_overdue_lapseV2() throws Exception {\n+        // disabled in commit 3069729776990980f34c25be66410e947e9d51a2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 632}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjQ2MQ==", "bodyText": "Let's keep parity with upstream, and ignore the test for now", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460436461", "createdAt": "2020-07-25T19:29:20Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +182,1429 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {\n+            throw new Exception(\"Unit tests will fail around the day rollover.\");\n+        }\n+    }\n+\n+\n+    @Test\n+    public void test_basics() throws Exception {\n+        Collection col = getCol();\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+    }\n+\n+\n+    @Test\n+    public void test_new_v2() throws Exception {\n+        Collection col = getColV2();\n+        col.reset();\n+        // assertEquals(0, col.getSched().newCount);TODO: newCount getter\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount);TODO: newCount getter\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail\n+        // // the default order should ensure siblings are not seen together, and\n+        // // should show all cards\n+        // Model m = col.getModels().current(); Models mm = col.getModels()\n+        // JSONObject t = mm.newTemplate(\"Reverse\")\n+        // t['qfmt'] = \"{{Back}}\"\n+        // t['afmt'] = \"{{Front}}\"\n+        // mm.addTemplateModChanged(m, t)\n+        // mm.save(m)\n+        // note = col.newNote()\n+        // note['Front'] = u\"2\"; note['Back'] = u\"2\"\n+        // col.addNote(note)\n+        // note = col.newNote()\n+        // note['Front'] = u\"3\"; note['Back'] = u\"3\"\n+        // col.addNote(note)\n+        // col.reset()\n+        // qs = (\"2\", \"3\", \"2\", \"3\")\n+        // for (int n = 0; n < 4; n++) {\n+        //     c = col.getSched().getCard()\n+        //     assertTrue(qs[n] in c.q())\n+        //     col.getSched().answerCard(c, 2)\n+        // }\n+    }\n+\n+\n+    @Test\n+    public void test_newLimits_V2() throws Exception {\n+        Collection col = getColV2();\n+        // add some notes\n+        long deck2 = col.getDecks().id(\"Default::foo\");\n+        for (int i = 0; i < 30; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", Integer.toString(i));\n+            if (i > 4) {\n+                note.model().put(\"did\", deck2);\n+            }\n+            col.addNote(note);\n+        }\n+        // give the child deck a different configuration\n+        long c2 = col.getDecks().confId(\"new conf\");\n+        col.getDecks().setConf(col.getDecks().get(deck2), c2);\n+        col.reset();\n+        // both confs have defaulted to a limit of 20\n+        // assertEquals(20, col.getSched().newCount);TODO: newCount getter\n+        // first card we get comes from parent\n+        Card c = col.getSched().getCard();\n+        assertEquals(1, c.getDid());\n+        // limit the parent to 10 cards, meaning we get 10 in total\n+        DeckConfig conf1 = col.getDecks().confForDid(1);\n+        conf1.getJSONObject(\"new\").put(\"perDay\", 10);\n+        col.getDecks().save(conf1);\n+        col.reset();\n+        // assertEquals(10, col.getSched().newCount);TODO: newCount getter\n+        // if we limit child to 4, we should get 9\n+        DeckConfig conf2 = col.getDecks().confForDid(deck2);\n+        conf2.getJSONObject(\"new\").put(\"perDay\", 4);\n+        col.getDecks().save(conf2);\n+        col.reset();\n+        //assertEquals(9, col.getSched().newCount);TODO: newCount getter\n+    }\n+\n+\n+    @Test\n+    public void test_newBoxes_v2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 2, 3, 4, 5}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+        // should handle gracefully\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+    }\n+\n+\n+    @Test\n+    public void test_learnV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // sched.getCard should return it, since it's due in the past\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        col.getDecks().save(conf);\n+        // fail it\n+        col.getSched().answerCard(c, 1);\n+        // it should have three reps left to graduation\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(3, c.getLeft() / 1000);\n+        // it should be due in 30 seconds\n+        long t = Math.round(c.getDue() - Utils.now());\n+        assertTrue(t >= 25 && t <= 40);\n+        // pass it once\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 3 minutes\n+        double dueIn = c.getDue() - Utils.now();\n+        assertTrue(178 <= dueIn && dueIn <= 180 * 1.25);\n+        assertEquals(2, c.getLeft() % 1000);\n+        assertEquals(2, c.getLeft() / 1000);\n+        // check log is accurate\n+        Cursor log = col.getDb().getDatabase().query(\"select * from revlog order by id desc\");\n+        assertTrue(log.moveToFirst());\n+        assertEquals(3, log.getInt(3));\n+        assertEquals(-180, log.getInt(4));\n+        assertEquals(-30, log.getInt(5));\n+        // pass again\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 10 minutes\n+        dueIn = c.getDue() - Utils.now();\n+        assertTrue(599 <= dueIn && dueIn <= 600 * 1.25);\n+        assertEquals(1, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        // the next pass should graduate the card\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        // should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(1, c.getIvl());\n+        // or normal removal\n+        c.setType(CARD_TYPE_NEW);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertTrue(checkRevIvl(col, c, 4));\n+        // revlog should have been updated each time\n+        assertEquals(5, col.getDb().queryScalar(\"select count() from revlog where type = 0\"));\n+    }\n+\n+\n+    @Test\n+    public void test_relearn() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        assertEquals(1, c.getIvl());\n+\n+        // immediately graduate it\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(2, c.getIvl());\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+    }\n+\n+\n+    @Test\n+    public void test_relearn_no_steps() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+    }\n+\n+\n+    @Test\n+    public void test_learn_collapsedV2() throws Exception {\n+        Collection col = getColV2();\n+        // add 2 notes\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"1\");\n+        col.addNote(note);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"2\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // should get '1' first\n+        Card c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"1\"));\n+        // pass it so it's due in 10 minutes\n+        col.getSched().answerCard(c, 3);\n+        // get the other card\n+        c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"2\"));\n+        // fail it so it's due in 1 minute\n+        col.getSched().answerCard(c, 1);\n+        // we shouldn't get the same card again\n+        c = col.getSched().getCard();\n+        assertFalse(c.q().endsWith(\"2\"));\n+    }\n+\n+\n+    @Test\n+    public void test_learn_dayV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.getSched().reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 10, 1440, 2880}));\n+        col.getDecks().save(conf);\n+        // pass it\n+        col.getSched().answerCard(c, 3);\n+        // two reps to graduate, 1 more today\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        // answering it will place it in queue 3\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertNull(col.getSched().getCard());\n+        // for testing, move it back a day\n+        c.setDue(c.getDue() - 1);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        // nextIvl should work\n+        assertEquals(86400 * 2, col.getSched().nextIvl(c, 3));\n+        // if we fail it, it should be back in the correct queue\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        col.undo();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        // simulate the passing of another two days\n+        c.setDue(c.getDue() - 2);\n+        c.flush();\n+        col.reset();\n+        // the last pass should graduate it into a review card\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // if the lapse step is tomorrow, failing it should handle the counts\n+        // correctly\n+        c.setDue(0);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1440}));\n+        col.getDecks().save(conf);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_reviewsV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set the card up as a review card, due 8 days ago\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday() - 8);\n+        c.setFactor(STARTING_FACTOR);\n+        c.setReps(3);\n+        c.setLapses(1);\n+        c.setIvl(100);\n+        c.startTimer();\n+        c.flush();\n+        // save it for later use as well\n+        Card cardcopy = c.clone();\n+        // try with an ease of 2\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.reset();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // the new interval should be (100) * 1.2 = 120\n+        assertTrue(checkRevIvl(col, c, 120));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been decremented\n+        assertEquals(2350, c.getFactor());\n+        // check counters\n+        assertEquals(1, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // ease 3\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 3);\n+        // the new interval should be (100 + 8/2) * 2.5 = 260\n+        assertTrue(checkRevIvl(col, c, 260));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been left alone\n+        assertEquals(STARTING_FACTOR, c.getFactor());\n+        // ease 4\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 4);\n+        // the new interval should be (100 + 8) * 2.5 * 1.3 = 351\n+        assertTrue(checkRevIvl(col, c, 351));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been increased\n+        assertEquals(2650, c.getFactor());\n+        // leech handling\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        DeckConfig conf = col.getDecks().getConf(1);\n+        conf.getJSONObject(\"lapse\").put(\"leechAction\", LEECH_SUSPEND);\n+        col.getDecks().save(conf);\n+        c = cardcopy.clone();\n+        c.setLapses(7);\n+        c.flush();\n+        /* todo hook\n+        // steup hook\n+        hooked = new [] {};\n+        \n+        def onLeech(card):\n+        hooked.append(1);\n+        \n+        hooks.card_did_leech.append(onLeech);\n+        col.getSched().answerCard(c, 1);\n+        assertTrue(hooked);\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        */\n+    }\n+\n+\n+    @Test\n+    public void test_review_limits() throws Exception {\n+        Collection col = getColV2();\n+\n+        Deck parent = col.getDecks().get(col.getDecks().id(\"parent\"));\n+        Deck child = col.getDecks().get(col.getDecks().id(\"parent::child\"));\n+\n+        DeckConfig pconf = col.getDecks().getConf(col.getDecks().confId(\"parentConf\"));\n+        DeckConfig cconf = col.getDecks().getConf(col.getDecks().confId(\"childConf\"));\n+\n+        pconf.getJSONObject(\"rev\").put(\"perDay\", 5);\n+        col.getDecks().updateConf(pconf);\n+        col.getDecks().setConf(parent, pconf.getLong(\"id\"));\n+        cconf.getJSONObject(\"rev\").put(\"perDay\", 10);\n+        col.getDecks().updateConf(cconf);\n+        col.getDecks().setConf(child, cconf.getLong(\"id\"));\n+\n+        Model m = col.getModels().current();\n+        m.put(\"did\", child.getLong(\"id\"));\n+        col.getModels().save(m, false);\n+\n+        // add some cards\n+        for (int i = 0; i < 20; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", \"one\");\n+            note.setItem(\"Back\", \"two\");\n+            col.addNote(note);\n+\n+            // make them reviews\n+            Card c = note.cards().get(0);\n+            c.setQueue(CARD_TYPE_REV);\n+            c.setType(QUEUE_TYPE_REV);\n+            c.setDue(0);\n+            c.flush();\n+        }\n+\n+        // position 0 is default deck. Different from upstream\n+        AbstractSched.DeckDueTreeNode tree = col.getSched().deckDueTree().get(1);\n+        // (('parent', 1514457677462, 5, 0, 0, (('child', 1514457677463, 5, 0, 0, ()),)))\n+        assertEquals(\"parent\", tree.getFullDeckName());\n+        assertEquals(5, tree.getRevCount());  // paren, tree.review_count)t\n+        assertEquals(5, tree.getChildren().get(0).getRevCount());\n+\n+        // .counts() should match\n+        col.getDecks().select(child.getLong(\"id\"));\n+        col.getSched().reset();\n+        assertArrayEquals(new int[] {0, 0, 5}, col.getSched().counts());\n+\n+        // answering a card in the child should decrement parent count\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 0, 4}, col.getSched().counts());\n+\n+        tree = col.getSched().deckDueTree().get(1);\n+        assertEquals(4, tree.getRevCount());\n+        assertEquals(4, tree.getChildren().get(0).getRevCount());\n+    }\n+\n+\n+    @Test\n+    public void test_button_spacingV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        // 1 day ivl review card due now\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday());\n+        c.setReps(1);\n+        c.setIvl(1);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        // Upstream, there is no space in 2d\n+        assertEquals(\"2 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n+        assertEquals(\"3 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 3)));\n+        assertEquals(\"4 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+\n+        // if hard factor is <= 1, then hard may not increase\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"rev\").put(\"hardFactor\", 1);\n+        col.getDecks().save(conf);\n+        assertEquals(\"1 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n     }\n \n \n+    @Test\n+    public void test_overdue_lapseV2() throws Exception {\n+        // disabled in commit 3069729776990980f34c25be66410e947e9d51a2\n+        return;\n+        /* Upstream does not execute it\n+           Collection col = getColV2()  // pylint: disable=unreachable\n+           // add a note\n+           Note note = col.newNote();\n+           note.setItem(\"Front\",\"one\");\n+           col.addNote(note);\n+           // simulate a review that was lapsed and is now due for its normal review\n+           Card c = note.cards().get(0);\n+           c.setType(CARD_TYPE_REV);\n+           c.setQueue(QUEUE_TYPE_LRN);\n+           c.setDue(-1);\n+           c.setODue(-1);\n+           c.setFactor(STARTING_FACTOR);\n+           c.setLeft(2002);\n+           c.setIvl(0);\n+           c.flush();\n+           // checkpoint\n+           col.save();\n+           col.getSched().reset();\n+           assertArrayEquals(new int[]{0, 2, 0}, col.getSched().counts());\n+           c = col.getSched().getCard();\n+           col.getSched().answerCard(c, 3);\n+           // it should be due tomorrow\n+           assertEquals(col.getSched().getToday()+ 1, c.getDue());\n+           // revert to before\n+           /* todo: rollback\n+           col.rollback();\n+           // with the default settings, the overdue card should be removed from the\n+           // learning queue\n+           col.getSched().reset();\n+           assertArrayEquals(new int[]{0, 0, 1}, col.getSched().counts());\n+        */\n+\n+    }\n+\n+\n+    @Test\n+    public void test_finishedV2() throws Exception {\n+        Collection col = getColV2();\n+        // nothing due\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"Congratulations\"));\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), not(containsString(\"limit\")));\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // have a new card\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"new cards available\"));\n+        // turn it into a review\n+        col.reset();\n+        Card c = note.cards().get(0);\n+        c.startTimer();\n+        col.getSched().answerCard(c, 3);\n+        // nothing should be due tomorrow, as it's due in a week\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"Congratulations\"));\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), not(containsString(\"limit\")));\n+    }\n+\n+\n+    @Test\n+    public void test_nextIvlV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1, 5, 9}));\n+        col.getDecks().save(conf);\n+        Card c = col.getSched().getCard();\n+        // new cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((30 + 180) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(180, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 1);\n+        // cards in learning\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((30 + 180) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(180, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((180 + 600) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(600, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 3);\n+        // normal graduation is tomorrow\n+        assertEquals(1 * 86400, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        // lapsed cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c.setType(CARD_TYPE_REV);\n+        c.setIvl(100);\n+        c.setFactor(STARTING_FACTOR);\n+        assertEquals(60, col.getSched().nextIvl(c, 1));\n+        assertEquals(100 * 86400, col.getSched().nextIvl(c, 3));\n+        assertEquals(101 * 86400, col.getSched().nextIvl(c, 4));\n+        // review cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setIvl(100);\n+        c.setFactor(STARTING_FACTOR);\n+        // failing it should put it at 60s\n+        assertEquals(60, col.getSched().nextIvl(c, 1));\n+        // or 1 day if relearn is false\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+        assertEquals(1 * 86400, col.getSched().nextIvl(c, 1));\n+        // (* 100 1.2 86400)10368000.0\n+        assertEquals(10368000, col.getSched().nextIvl(c, 2));\n+        // (* 100 2.5 86400)21600000.0\n+        assertEquals(21600000, col.getSched().nextIvl(c, 3));\n+        // (* 100 2.5 1.3 86400)28080000.0\n+        assertEquals(28080000, col.getSched().nextIvl(c, 4));\n+        // TODO: upstream is 10.8, try to understand the difference\n+        assertEquals(\"10.7 mo\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 755}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNjU2NQ==", "bodyText": "flagging - might want to ignore here", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r460436565", "createdAt": "2020-07-25T19:30:22Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +182,1429 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {\n+            throw new Exception(\"Unit tests will fail around the day rollover.\");\n+        }\n+    }\n+\n+\n+    @Test\n+    public void test_basics() throws Exception {\n+        Collection col = getCol();\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+    }\n+\n+\n+    @Test\n+    public void test_new_v2() throws Exception {\n+        Collection col = getColV2();\n+        col.reset();\n+        // assertEquals(0, col.getSched().newCount);TODO: newCount getter\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        // assertEquals(1, col.getSched().newCount);TODO: newCount getter\n+        // fetch it\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertEquals(CARD_TYPE_NEW, c.getType());\n+        // if we answer it, it should become a learn card\n+        long t = intTime();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        assertTrue(c.getDue() >= t);\n+\n+        // disabled for now, as the learn fudging makes this randomly fail\n+        // // the default order should ensure siblings are not seen together, and\n+        // // should show all cards\n+        // Model m = col.getModels().current(); Models mm = col.getModels()\n+        // JSONObject t = mm.newTemplate(\"Reverse\")\n+        // t['qfmt'] = \"{{Back}}\"\n+        // t['afmt'] = \"{{Front}}\"\n+        // mm.addTemplateModChanged(m, t)\n+        // mm.save(m)\n+        // note = col.newNote()\n+        // note['Front'] = u\"2\"; note['Back'] = u\"2\"\n+        // col.addNote(note)\n+        // note = col.newNote()\n+        // note['Front'] = u\"3\"; note['Back'] = u\"3\"\n+        // col.addNote(note)\n+        // col.reset()\n+        // qs = (\"2\", \"3\", \"2\", \"3\")\n+        // for (int n = 0; n < 4; n++) {\n+        //     c = col.getSched().getCard()\n+        //     assertTrue(qs[n] in c.q())\n+        //     col.getSched().answerCard(c, 2)\n+        // }\n+    }\n+\n+\n+    @Test\n+    public void test_newLimits_V2() throws Exception {\n+        Collection col = getColV2();\n+        // add some notes\n+        long deck2 = col.getDecks().id(\"Default::foo\");\n+        for (int i = 0; i < 30; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", Integer.toString(i));\n+            if (i > 4) {\n+                note.model().put(\"did\", deck2);\n+            }\n+            col.addNote(note);\n+        }\n+        // give the child deck a different configuration\n+        long c2 = col.getDecks().confId(\"new conf\");\n+        col.getDecks().setConf(col.getDecks().get(deck2), c2);\n+        col.reset();\n+        // both confs have defaulted to a limit of 20\n+        // assertEquals(20, col.getSched().newCount);TODO: newCount getter\n+        // first card we get comes from parent\n+        Card c = col.getSched().getCard();\n+        assertEquals(1, c.getDid());\n+        // limit the parent to 10 cards, meaning we get 10 in total\n+        DeckConfig conf1 = col.getDecks().confForDid(1);\n+        conf1.getJSONObject(\"new\").put(\"perDay\", 10);\n+        col.getDecks().save(conf1);\n+        col.reset();\n+        // assertEquals(10, col.getSched().newCount);TODO: newCount getter\n+        // if we limit child to 4, we should get 9\n+        DeckConfig conf2 = col.getDecks().confForDid(deck2);\n+        conf2.getJSONObject(\"new\").put(\"perDay\", 4);\n+        col.getDecks().save(conf2);\n+        col.reset();\n+        //assertEquals(9, col.getSched().newCount);TODO: newCount getter\n+    }\n+\n+\n+    @Test\n+    public void test_newBoxes_v2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 2, 3, 4, 5}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+        // should handle gracefully\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1}));\n+        col.getDecks().save(conf);\n+        col.getSched().answerCard(c, 2);\n+    }\n+\n+\n+    @Test\n+    public void test_learnV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // sched.getCard should return it, since it's due in the past\n+        Card c = col.getSched().getCard();\n+        assertNotNull(c);\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        col.getDecks().save(conf);\n+        // fail it\n+        col.getSched().answerCard(c, 1);\n+        // it should have three reps left to graduation\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(3, c.getLeft() / 1000);\n+        // it should be due in 30 seconds\n+        long t = Math.round(c.getDue() - Utils.now());\n+        assertTrue(t >= 25 && t <= 40);\n+        // pass it once\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 3 minutes\n+        double dueIn = c.getDue() - Utils.now();\n+        assertTrue(178 <= dueIn && dueIn <= 180 * 1.25);\n+        assertEquals(2, c.getLeft() % 1000);\n+        assertEquals(2, c.getLeft() / 1000);\n+        // check log is accurate\n+        Cursor log = col.getDb().getDatabase().query(\"select * from revlog order by id desc\");\n+        assertTrue(log.moveToFirst());\n+        assertEquals(3, log.getInt(3));\n+        assertEquals(-180, log.getInt(4));\n+        assertEquals(-30, log.getInt(5));\n+        // pass again\n+        col.getSched().answerCard(c, 3);\n+        // it should be due in 10 minutes\n+        dueIn = c.getDue() - Utils.now();\n+        assertTrue(599 <= dueIn && dueIn <= 600 * 1.25);\n+        assertEquals(1, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        // the next pass should graduate the card\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_LRN, c.getType());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        // should be due tomorrow, with an interval of 1\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(1, c.getIvl());\n+        // or normal removal\n+        c.setType(CARD_TYPE_NEW);\n+        c.setQueue(QUEUE_TYPE_LRN);\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertTrue(checkRevIvl(col, c, 4));\n+        // revlog should have been updated each time\n+        assertEquals(5, col.getDb().queryScalar(\"select count() from revlog where type = 0\"));\n+    }\n+\n+\n+    @Test\n+    public void test_relearn() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        assertEquals(1, c.getIvl());\n+\n+        // immediately graduate it\n+        col.getSched().answerCard(c, 4);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        assertEquals(2, c.getIvl());\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+    }\n+\n+\n+    @Test\n+    public void test_relearn_no_steps() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setDue(col.getSched().getToday());\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        c.flush();\n+\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+\n+        // fail the card\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+    }\n+\n+\n+    @Test\n+    public void test_learn_collapsedV2() throws Exception {\n+        Collection col = getColV2();\n+        // add 2 notes\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"1\");\n+        col.addNote(note);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"2\");\n+        col.addNote(note);\n+        // set as a learn card and rebuild queues\n+        col.getDb().execute(\"update cards set queue=0, type=0\");\n+        col.reset();\n+        // should get '1' first\n+        Card c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"1\"));\n+        // pass it so it's due in 10 minutes\n+        col.getSched().answerCard(c, 3);\n+        // get the other card\n+        c = col.getSched().getCard();\n+        assertTrue(c.q().endsWith(\"2\"));\n+        // fail it so it's due in 1 minute\n+        col.getSched().answerCard(c, 1);\n+        // we shouldn't get the same card again\n+        c = col.getSched().getCard();\n+        assertFalse(c.q().endsWith(\"2\"));\n+    }\n+\n+\n+    @Test\n+    public void test_learn_dayV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.getSched().reset();\n+        Card c = col.getSched().getCard();\n+        DeckConfig conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {1, 10, 1440, 2880}));\n+        col.getDecks().save(conf);\n+        // pass it\n+        col.getSched().answerCard(c, 3);\n+        // two reps to graduate, 1 more today\n+        assertEquals(3, c.getLeft() % 1000);\n+        assertEquals(1, c.getLeft() / 1000);\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        // answering it will place it in queue 3\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(col.getSched().getToday() + 1, c.getDue());\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertNull(col.getSched().getCard());\n+        // for testing, move it back a day\n+        c.setDue(c.getDue() - 1);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        // nextIvl should work\n+        assertEquals(86400 * 2, col.getSched().nextIvl(c, 3));\n+        // if we fail it, it should be back in the correct queue\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        col.undo();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        // simulate the passing of another two days\n+        c.setDue(c.getDue() - 2);\n+        c.flush();\n+        col.reset();\n+        // the last pass should graduate it into a review card\n+        assertEquals(86400, col.getSched().nextIvl(c, 3));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(CARD_TYPE_REV, c.getType());\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // if the lapse step is tomorrow, failing it should handle the counts\n+        // correctly\n+        c.setDue(0);\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        conf = col.getSched()._cardConf(c);\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1440}));\n+        col.getDecks().save(conf);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertEquals(QUEUE_TYPE_DAY_LEARN_RELEARN, c.getQueue());\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_reviewsV2() throws Exception {\n+        Collection col = getColV2();\n+        // add a note\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // set the card up as a review card, due 8 days ago\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday() - 8);\n+        c.setFactor(STARTING_FACTOR);\n+        c.setReps(3);\n+        c.setLapses(1);\n+        c.setIvl(100);\n+        c.startTimer();\n+        c.flush();\n+        // save it for later use as well\n+        Card cardcopy = c.clone();\n+        // try with an ease of 2\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.reset();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(QUEUE_TYPE_REV, c.getQueue());\n+        // the new interval should be (100) * 1.2 = 120\n+        assertTrue(checkRevIvl(col, c, 120));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been decremented\n+        assertEquals(2350, c.getFactor());\n+        // check counters\n+        assertEquals(1, c.getLapses());\n+        assertEquals(4, c.getReps());\n+        // ease 3\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 3);\n+        // the new interval should be (100 + 8/2) * 2.5 = 260\n+        assertTrue(checkRevIvl(col, c, 260));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been left alone\n+        assertEquals(STARTING_FACTOR, c.getFactor());\n+        // ease 4\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c = cardcopy.clone();\n+        c.flush();\n+        col.getSched().answerCard(c, 4);\n+        // the new interval should be (100 + 8) * 2.5 * 1.3 = 351\n+        assertTrue(checkRevIvl(col, c, 351));\n+        assertEquals(col.getSched().getToday() + c.getIvl(), c.getDue());\n+        // factor should have been increased\n+        assertEquals(2650, c.getFactor());\n+        // leech handling\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        DeckConfig conf = col.getDecks().getConf(1);\n+        conf.getJSONObject(\"lapse\").put(\"leechAction\", LEECH_SUSPEND);\n+        col.getDecks().save(conf);\n+        c = cardcopy.clone();\n+        c.setLapses(7);\n+        c.flush();\n+        /* todo hook\n+        // steup hook\n+        hooked = new [] {};\n+        \n+        def onLeech(card):\n+        hooked.append(1);\n+        \n+        hooks.card_did_leech.append(onLeech);\n+        col.getSched().answerCard(c, 1);\n+        assertTrue(hooked);\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_SUSPENDED, c.getQueue());\n+        */\n+    }\n+\n+\n+    @Test\n+    public void test_review_limits() throws Exception {\n+        Collection col = getColV2();\n+\n+        Deck parent = col.getDecks().get(col.getDecks().id(\"parent\"));\n+        Deck child = col.getDecks().get(col.getDecks().id(\"parent::child\"));\n+\n+        DeckConfig pconf = col.getDecks().getConf(col.getDecks().confId(\"parentConf\"));\n+        DeckConfig cconf = col.getDecks().getConf(col.getDecks().confId(\"childConf\"));\n+\n+        pconf.getJSONObject(\"rev\").put(\"perDay\", 5);\n+        col.getDecks().updateConf(pconf);\n+        col.getDecks().setConf(parent, pconf.getLong(\"id\"));\n+        cconf.getJSONObject(\"rev\").put(\"perDay\", 10);\n+        col.getDecks().updateConf(cconf);\n+        col.getDecks().setConf(child, cconf.getLong(\"id\"));\n+\n+        Model m = col.getModels().current();\n+        m.put(\"did\", child.getLong(\"id\"));\n+        col.getModels().save(m, false);\n+\n+        // add some cards\n+        for (int i = 0; i < 20; i++) {\n+            Note note = col.newNote();\n+            note.setItem(\"Front\", \"one\");\n+            note.setItem(\"Back\", \"two\");\n+            col.addNote(note);\n+\n+            // make them reviews\n+            Card c = note.cards().get(0);\n+            c.setQueue(CARD_TYPE_REV);\n+            c.setType(QUEUE_TYPE_REV);\n+            c.setDue(0);\n+            c.flush();\n+        }\n+\n+        // position 0 is default deck. Different from upstream\n+        AbstractSched.DeckDueTreeNode tree = col.getSched().deckDueTree().get(1);\n+        // (('parent', 1514457677462, 5, 0, 0, (('child', 1514457677463, 5, 0, 0, ()),)))\n+        assertEquals(\"parent\", tree.getFullDeckName());\n+        assertEquals(5, tree.getRevCount());  // paren, tree.review_count)t\n+        assertEquals(5, tree.getChildren().get(0).getRevCount());\n+\n+        // .counts() should match\n+        col.getDecks().select(child.getLong(\"id\"));\n+        col.getSched().reset();\n+        assertArrayEquals(new int[] {0, 0, 5}, col.getSched().counts());\n+\n+        // answering a card in the child should decrement parent count\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 0, 4}, col.getSched().counts());\n+\n+        tree = col.getSched().deckDueTree().get(1);\n+        assertEquals(4, tree.getRevCount());\n+        assertEquals(4, tree.getChildren().get(0).getRevCount());\n+    }\n+\n+\n+    @Test\n+    public void test_button_spacingV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        // 1 day ivl review card due now\n+        Card c = note.cards().get(0);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setDue(col.getSched().getToday());\n+        c.setReps(1);\n+        c.setIvl(1);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        // Upstream, there is no space in 2d\n+        assertEquals(\"2 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n+        assertEquals(\"3 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 3)));\n+        assertEquals(\"4 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+\n+        // if hard factor is <= 1, then hard may not increase\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"rev\").put(\"hardFactor\", 1);\n+        col.getDecks().save(conf);\n+        assertEquals(\"1 d\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 2)));\n     }\n \n \n+    @Test\n+    public void test_overdue_lapseV2() throws Exception {\n+        // disabled in commit 3069729776990980f34c25be66410e947e9d51a2\n+        return;\n+        /* Upstream does not execute it\n+           Collection col = getColV2()  // pylint: disable=unreachable\n+           // add a note\n+           Note note = col.newNote();\n+           note.setItem(\"Front\",\"one\");\n+           col.addNote(note);\n+           // simulate a review that was lapsed and is now due for its normal review\n+           Card c = note.cards().get(0);\n+           c.setType(CARD_TYPE_REV);\n+           c.setQueue(QUEUE_TYPE_LRN);\n+           c.setDue(-1);\n+           c.setODue(-1);\n+           c.setFactor(STARTING_FACTOR);\n+           c.setLeft(2002);\n+           c.setIvl(0);\n+           c.flush();\n+           // checkpoint\n+           col.save();\n+           col.getSched().reset();\n+           assertArrayEquals(new int[]{0, 2, 0}, col.getSched().counts());\n+           c = col.getSched().getCard();\n+           col.getSched().answerCard(c, 3);\n+           // it should be due tomorrow\n+           assertEquals(col.getSched().getToday()+ 1, c.getDue());\n+           // revert to before\n+           /* todo: rollback\n+           col.rollback();\n+           // with the default settings, the overdue card should be removed from the\n+           // learning queue\n+           col.getSched().reset();\n+           assertArrayEquals(new int[]{0, 0, 1}, col.getSched().counts());\n+        */\n+\n+    }\n+\n+\n+    @Test\n+    public void test_finishedV2() throws Exception {\n+        Collection col = getColV2();\n+        // nothing due\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"Congratulations\"));\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), not(containsString(\"limit\")));\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        // have a new card\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"new cards available\"));\n+        // turn it into a review\n+        col.reset();\n+        Card c = note.cards().get(0);\n+        c.startTimer();\n+        col.getSched().answerCard(c, 3);\n+        // nothing should be due tomorrow, as it's due in a week\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), containsString(\"Congratulations\"));\n+        assertThat(col.getSched().finishedMsg(getTargetContext()).toString(), not(containsString(\"limit\")));\n+    }\n+\n+\n+    @Test\n+    public void test_nextIvlV2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        note.setItem(\"Back\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        DeckConfig conf = col.getDecks().confForDid(1);\n+        conf.getJSONObject(\"new\").put(\"delays\", new JSONArray(new double[] {0.5, 3, 10}));\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {1, 5, 9}));\n+        col.getDecks().save(conf);\n+        Card c = col.getSched().getCard();\n+        // new cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((30 + 180) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(180, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 1);\n+        // cards in learning\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((30 + 180) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(180, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(30, col.getSched().nextIvl(c, 1));\n+        assertEquals((180 + 600) / 2, col.getSched().nextIvl(c, 2));\n+        assertEquals(600, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        col.getSched().answerCard(c, 3);\n+        // normal graduation is tomorrow\n+        assertEquals(1 * 86400, col.getSched().nextIvl(c, 3));\n+        assertEquals(4 * 86400, col.getSched().nextIvl(c, 4));\n+        // lapsed cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c.setType(CARD_TYPE_REV);\n+        c.setIvl(100);\n+        c.setFactor(STARTING_FACTOR);\n+        assertEquals(60, col.getSched().nextIvl(c, 1));\n+        assertEquals(100 * 86400, col.getSched().nextIvl(c, 3));\n+        assertEquals(101 * 86400, col.getSched().nextIvl(c, 4));\n+        // review cards\n+        ////////////////////////////////////////////////////////////////////////////////////////////////////\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.setIvl(100);\n+        c.setFactor(STARTING_FACTOR);\n+        // failing it should put it at 60s\n+        assertEquals(60, col.getSched().nextIvl(c, 1));\n+        // or 1 day if relearn is false\n+        conf.getJSONObject(\"lapse\").put(\"delays\", new JSONArray(new double[] {}));\n+        col.getDecks().save(conf);\n+        assertEquals(1 * 86400, col.getSched().nextIvl(c, 1));\n+        // (* 100 1.2 86400)10368000.0\n+        assertEquals(10368000, col.getSched().nextIvl(c, 2));\n+        // (* 100 2.5 86400)21600000.0\n+        assertEquals(21600000, col.getSched().nextIvl(c, 3));\n+        // (* 100 2.5 1.3 86400)28080000.0\n+        assertEquals(28080000, col.getSched().nextIvl(c, 4));\n+        // TODO: upstream is 10.8, try to understand the difference\n+        assertEquals(\"10.7 mo\", without_unicode_isolation(col.getSched().nextIvlStr(getTargetContext(), c, 4)));\n+    }\n+\n+\n+    @Test\n+    public void test_bury() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"two\");\n+        col.addNote(note);\n+        Card c2 = note.cards().get(0);\n+        // burying\n+        col.getSched().buryCards(new long[] {c.getId()}, true);\n+        c.load();\n+        assertEquals(QUEUE_TYPE_MANUALLY_BURIED, c.getQueue());\n+        col.getSched().buryCards(new long[] {c2.getId()}, false);\n+        c2.load();\n+        assertEquals(QUEUE_TYPE_SIBLING_BURIED, c2.getQueue());\n+\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+\n+        col.getSched().unburyCardsForDeck(AbstractSched.UnburyType.MANUAL);\n+        c.load();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        c2.load();\n+        assertEquals(QUEUE_TYPE_SIBLING_BURIED, c2.getQueue());\n+\n+        col.getSched().unburyCardsForDeck(AbstractSched.UnburyType.SIBLINGS);\n+        c2.load();\n+        assertEquals(QUEUE_TYPE_NEW, c2.getQueue());\n+\n+        col.getSched().buryCards(new long[] {c.getId(), c2.getId()});\n+        col.getSched().unburyCardsForDeck(AbstractSched.UnburyType.ALL);\n+\n+        col.reset();\n+\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+    }\n+\n+\n+    @Test\n+    public void test_suspendv2() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        // suspending\n+        col.reset();\n+        assertNotNull(col.getSched().getCard());\n+        col.getSched().suspendCards(new long[] {c.getId()});\n+        col.reset();\n+        assertNull(col.getSched().getCard());\n+        // unsuspending\n+        col.getSched().unsuspendCards(new long[] {c.getId()});\n+        col.reset();\n+        assertNotNull(col.getSched().getCard());\n+        // should cope with rev cards being relearnt\n+        c.setDue(0);\n+        c.setIvl(100);\n+        c.setType(CARD_TYPE_REV);\n+        c.setQueue(QUEUE_TYPE_REV);\n+        c.flush();\n+        col.reset();\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 1);\n+        assertTrue(c.getDue() >= Utils.now());\n+        long due = c.getDue();\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        col.getSched().suspendCards(new long[] {c.getId()});\n+        col.getSched().unsuspendCards(new long[] {c.getId()});\n+        c.load();\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        assertEquals(CARD_TYPE_RELEARNING, c.getType());\n+        assertEquals(due, c.getDue());\n+        // should cope with cards in cram decks\n+        c.setDue(1);\n+        c.flush();\n+        col.getDecks().newDyn(\"tmp\");\n+        col.getSched().rebuildDyn();\n+        c.load();\n+        assertNotEquals(1, c.getDue());\n+        assertNotEquals(1, c.getDid());\n+        col.getSched().suspendCards(new long[] {c.getId()});\n+        c.load();\n+        assertNotEquals(1, c.getDue());\n+        assertNotEquals(1, c.getDid());\n+        assertEquals(1, c.getODue());\n+    }\n+\n+\n+    @Test\n+    public void test_filt_reviewing_early_normal() throws Exception {\n+        Collection col = getColV2();\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        Card c = note.cards().get(0);\n+        c.setIvl(100);\n+        c.setQueue(CARD_TYPE_REV);\n+        c.setType(QUEUE_TYPE_REV);\n+        // due in 25 days, so it's been waiting 75 days\n+        c.setDue(col.getSched().getToday() + 25);\n+        c.setMod(1);\n+        c.setFactor(STARTING_FACTOR);\n+        c.startTimer();\n+        c.flush();\n+        col.reset();\n+        assertArrayEquals(new int[] {0, 0, 0}, col.getSched().counts());\n+        // create a dynamic deck and refresh it\n+        long did = col.getDecks().newDyn(\"Cram\");\n+        col.getSched().rebuildDyn(did);\n+        col.reset();\n+        // should appear as normal in the deck list\n+        /* todo sort\n+           assertEquals(1, sorted(col.getSched().deckDueTree().getChildren())[0].review_count);\n+        */\n+        // and should appear in the counts\n+        assertArrayEquals(new int[] {0, 0, 1}, col.getSched().counts());\n+        // grab it and check estimates\n+        c = col.getSched().getCard();\n+        assertEquals(4, col.getSched().answerButtons(c));\n+        assertEquals(600, col.getSched().nextIvl(c, 1));\n+        assertEquals(Math.round(75 * 1.2) * 86400, col.getSched().nextIvl(c, 2));\n+        /* TODO: Investigate this difference", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c"}, "originalPosition": 885}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a74f9f92032777f428b26b339caf53bdc302345c", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a74f9f92032777f428b26b339caf53bdc302345c", "committedDate": "2020-07-25T18:12:18Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "84a83e215ae8ec591b110dc0c351543c7c9221eb", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/84a83e215ae8ec591b110dc0c351543c7c9221eb", "committedDate": "2020-07-27T02:41:24Z", "message": "Upstream libanki tests"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "84a83e215ae8ec591b110dc0c351543c7c9221eb", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/84a83e215ae8ec591b110dc0c351543c7c9221eb", "committedDate": "2020-07-27T02:41:24Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "db23af9deff12e5db3cdc73155ddd6abd52324ba", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/db23af9deff12e5db3cdc73155ddd6abd52324ba", "committedDate": "2020-07-28T12:22:11Z", "message": "Upstream libanki tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU4Nzc4ODY1", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-458778865", "createdAt": "2020-07-30T21:46:05Z", "commit": {"oid": "db23af9deff12e5db3cdc73155ddd6abd52324ba"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "db23af9deff12e5db3cdc73155ddd6abd52324ba", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/db23af9deff12e5db3cdc73155ddd6abd52324ba", "committedDate": "2020-07-28T12:22:11Z", "message": "Upstream libanki tests"}, "afterCommit": {"oid": "1af03a1a4a0477aa6ab60844846f6a09a264f835", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/1af03a1a4a0477aa6ab60844846f6a09a264f835", "committedDate": "2020-08-01T13:45:32Z", "message": "NF: upstream test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1af03a1a4a0477aa6ab60844846f6a09a264f835", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/1af03a1a4a0477aa6ab60844846f6a09a264f835", "committedDate": "2020-08-01T13:45:32Z", "message": "NF: upstream test"}, "afterCommit": {"oid": "0f3e26eb70edc3c744068f4e34fb261eaab26882", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/0f3e26eb70edc3c744068f4e34fb261eaab26882", "committedDate": "2020-08-01T13:46:50Z", "message": "NF: upstream test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0f3e26eb70edc3c744068f4e34fb261eaab26882", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/0f3e26eb70edc3c744068f4e34fb261eaab26882", "committedDate": "2020-08-01T13:46:50Z", "message": "NF: upstream test"}, "afterCommit": {"oid": "c9e737d047dd18953e580a72bfa261ab64dd34ce", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/c9e737d047dd18953e580a72bfa261ab64dd34ce", "committedDate": "2020-08-01T13:55:47Z", "message": "NF: upstream test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c9e737d047dd18953e580a72bfa261ab64dd34ce", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/c9e737d047dd18953e580a72bfa261ab64dd34ce", "committedDate": "2020-08-01T13:55:47Z", "message": "NF: upstream test"}, "afterCommit": {"oid": "5bc11ccd93bd9da970c3d85b7eb297f1ab600c3e", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/5bc11ccd93bd9da970c3d85b7eb297f1ab600c3e", "committedDate": "2020-08-02T17:04:52Z", "message": "NF: upstream test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5bc11ccd93bd9da970c3d85b7eb297f1ab600c3e", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/5bc11ccd93bd9da970c3d85b7eb297f1ab600c3e", "committedDate": "2020-08-02T17:04:52Z", "message": "NF: upstream test"}, "afterCommit": {"oid": "327897a0592a09e9258d21338476e5245d29fee0", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/327897a0592a09e9258d21338476e5245d29fee0", "committedDate": "2020-08-03T18:12:08Z", "message": "NF: upstream test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYwNjMxMzg4", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-460631388", "createdAt": "2020-08-04T09:05:20Z", "commit": {"oid": "327897a0592a09e9258d21338476e5245d29fee0"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOTowNToyMFrOG7Xw9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQwOTowNjoxMlrOG7Xy2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwODUzMg==", "bodyText": "shouldn't this have a getColV2", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464908532", "createdAt": "2020-08-04T09:05:20Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +185,1428 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327897a0592a09e9258d21338476e5245d29fee0"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NDkwOTAxOQ==", "bodyText": "getColV2?", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r464909019", "createdAt": "2020-08-04T09:06:12Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/sched/SchedV2Test.java", "diffHunk": "@@ -146,15 +185,1428 @@ private void ensureLapseMatchesSppliedAnkiDesktopConfig(JSONObject lapse) {\n \n     }\n \n+\n     @Test\n     public void ensureDeckTree() {\n-        for (String deckName: TEST_DECKS) {\n+        for (String deckName : TEST_DECKS) {\n             addDeck(deckName);\n         }\n         AbstractSched sched = getCol().getSched();\n         List<AbstractSched.DeckDueTreeNode> tree = sched.deckDueTree();\n-        Assert.assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+        assertEquals(\"Tree has not the expected structure\", expectedTree(sched, true), tree);\n+    }\n+\n+\n+    /*****************\n+     ** autogenerated from https://github.com/ankitects/anki/blob/2c73dcb2e547c44d9e02c20a00f3c52419dc277b/pylib/tests/test_cards.py\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    @Ignore(\"Risks to be flaky in CI\")\n+    public void test_clock() throws Exception {\n+        Collection col = getColV2();\n+        if ((col.getSched().getDayCutoff() - intTime()) < 10 * 60) {\n+            throw new Exception(\"Unit tests will fail around the day rollover.\");\n+        }\n+    }\n+\n+\n+    @Test\n+    public void test_basics() throws Exception {\n+        Collection col = getCol();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "327897a0592a09e9258d21338476e5245d29fee0"}, "originalPosition": 137}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "327897a0592a09e9258d21338476e5245d29fee0", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/327897a0592a09e9258d21338476e5245d29fee0", "committedDate": "2020-08-03T18:12:08Z", "message": "NF: upstream test"}, "afterCommit": {"oid": "3433e045e0e27402c5056aceeecc069167017514", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/3433e045e0e27402c5056aceeecc069167017514", "committedDate": "2020-08-04T15:34:38Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3433e045e0e27402c5056aceeecc069167017514", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/3433e045e0e27402c5056aceeecc069167017514", "committedDate": "2020-08-04T15:34:38Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}, "afterCommit": {"oid": "a8d5f83aaa6d1628d4ca6d7bd3027fcffc5da9fa", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a8d5f83aaa6d1628d4ca6d7bd3027fcffc5da9fa", "committedDate": "2020-08-04T15:43:00Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a8d5f83aaa6d1628d4ca6d7bd3027fcffc5da9fa", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/a8d5f83aaa6d1628d4ca6d7bd3027fcffc5da9fa", "committedDate": "2020-08-04T15:43:00Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}, "afterCommit": {"oid": "4adac09acf50fb7b1d9bab12e070ef4e6bd5390e", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/4adac09acf50fb7b1d9bab12e070ef4e6bd5390e", "committedDate": "2020-08-04T15:43:33Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4adac09acf50fb7b1d9bab12e070ef4e6bd5390e", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/4adac09acf50fb7b1d9bab12e070ef4e6bd5390e", "committedDate": "2020-08-04T15:43:33Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}, "afterCommit": {"oid": "36e8a2891f99c483c64f9c760c3592ba9423ee6d", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/36e8a2891f99c483c64f9c760c3592ba9423ee6d", "committedDate": "2020-08-04T15:54:11Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "36e8a2891f99c483c64f9c760c3592ba9423ee6d", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/36e8a2891f99c483c64f9c760c3592ba9423ee6d", "committedDate": "2020-08-04T15:54:11Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}, "afterCommit": {"oid": "55fe489094fb330c234c5b329664220e778d2b49", "author": {"user": {"login": "david-allison-1", "name": "David Allison"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/55fe489094fb330c234c5b329664220e778d2b49", "committedDate": "2020-08-04T17:02:47Z", "message": "Please Squash - fix the clock to avoid the day cutoff"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDEzNTYz", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-461013563", "createdAt": "2020-08-04T17:16:26Z", "commit": {"oid": "55fe489094fb330c234c5b329664220e778d2b49"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoxNjoyNlrOG7p6TA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoxNjoyNlrOG7p6TA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIwNTgzNg==", "bodyText": "(Optional) It would be helpful to extract assumeThat() and assumeX this code into RobolectricTest so we always get this behaviour.", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465205836", "createdAt": "2020-08-04T17:16:26Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/libanki/UndoTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.ichi2.libanki;\n+\n+import com.ichi2.anki.RobolectricTest;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+\n+import androidx.test.ext.junit.runners.AndroidJUnit4;\n+\n+import static com.ichi2.libanki.Consts.COUNT_REMAINING;\n+import static com.ichi2.libanki.Consts.QUEUE_TYPE_LRN;\n+import static com.ichi2.libanki.Consts.QUEUE_TYPE_NEW;\n+import static org.hamcrest.Matchers.is;\n+import static org.junit.Assert.assertArrayEquals;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assume.assumeThat;\n+\n+\n+@RunWith(AndroidJUnit4.class)\n+public class UndoTest extends RobolectricTest {\n+    /*****************\n+     ** Undo         *\n+     *****************/\n+    public Collection getColV2() throws Exception {\n+        Collection col = getCol();\n+        col.changeSchedulerVer(2);\n+        return col;\n+    }\n+\n+\n+    @Test\n+    @Ignore(\"We need to figure out how to test save/undo\")\n+    public void test_op() throws Exception {\n+        Collection col = getColV2();\n+        // should have no undo by default\n+        assertNull(col.undoType());\n+        // let's adjust a study option\n+        col.save(\"studyopts\");\n+        col.getConf().put(\"abc\", 5);\n+        // it should be listed as undoable\n+        assertEquals(\"studyopts\", col.undoName(getTargetContext().getResources()));\n+        // with about 5 minutes until it's clobbered\n+        /* lastSave\n+           assertThat(Utils.now() - col._lastSave, lesserThan(1));\n+        */\n+        // undoing should restore the old value\n+        col.undo();\n+        assertEquals(null, col.undoType());\n+        assertFalse(col.getConf().has(\"abc\"));\n+        // an (auto)save will clear the undo\n+        col.save(\"foo\");\n+        assertEquals(\"foo\", col.undoName(getTargetContext().getResources()));\n+        col.save();\n+        assertEquals(\"\", col.undoName(getTargetContext().getResources()));\n+        // and a review will, too\n+        col.save(\"add\");\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        assertEquals(\"add\", col.undoName(getTargetContext().getResources()));\n+        Card c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 2);\n+        assertEquals(\"Review\", col.undoName(getTargetContext().getResources()));\n+    }\n+\n+\n+    @Test\n+    public void test_review() throws Exception {\n+        Collection col = getColV2();\n+        col.getConf().put(\"counts\", COUNT_REMAINING);\n+        Note note = col.newNote();\n+        note.setItem(\"Front\", \"one\");\n+        col.addNote(note);\n+        col.reset();\n+        /* TODO:\u00a0 undo after reset ?\n+        assertNotNull(col.undoType());\n+\n+         */\n+        // answer\n+        assertArrayEquals(new int[] {1, 0, 0}, col.getSched().counts());\n+        Card c = col.getSched().getCard();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(1001, c.getLeft());\n+        assertArrayEquals(new int[] {0, 1, 0}, col.getSched().counts());\n+        assertEquals(QUEUE_TYPE_LRN, c.getQueue());\n+        // undo\n+        assertNotNull(col.undoType());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {1, 0, 0}, col.getSched().counts());\n+        c.load();\n+        assertEquals(QUEUE_TYPE_NEW, c.getQueue());\n+        assertNotEquals(1001, c.getLeft());\n+        assertNull(col.undoType());\n+        // we should be able to undo multiple answers too\n+        note = col.newNote();\n+        note.setItem(\"Front\", \"two\");\n+        col.addNote(note);\n+        col.reset();\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertArrayEquals(new int[] {0, 2, 0}, col.getSched().counts());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {1, 1, 0}, col.getSched().counts());\n+        col.undo();\n+        col.reset();\n+        assertArrayEquals(new int[] {2, 0, 0}, col.getSched().counts());\n+        // performing a normal op will clear the review queue\n+        c = col.getSched().getCard();\n+        col.getSched().answerCard(c, 3);\n+        assertEquals(Collection.DismissType.REVIEW, col.undoType());\n+        col.save(\"foo\");\n+        // Upstream, \"save\" can be undone. This test fails here because it's not the case in AnkiDroid\n+        this.advanceRobolectricLooper();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "55fe489094fb330c234c5b329664220e778d2b49"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDIyODM1", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-461022835", "createdAt": "2020-08-04T17:29:15Z", "commit": {"oid": "94afb42a5b60e76386d5c3a5575798099b3ebfb1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoyOToxNVrOG7qXcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxNzoyOToxNVrOG7qXcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMzI5Nw==", "bodyText": "Probably should also handle:\nassumeThat(message, x, is(y))\nassumeThat(x, is(y))\nassumeTrue(false)", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465213297", "createdAt": "2020-08-04T17:29:15Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/anki/RobolectricTest.java", "diffHunk": "@@ -291,4 +295,61 @@ public void onPostExecute(TaskData result) {\n             throw new IllegalStateException(String.format(\"Task %s didn't finish in %d ms\", taskType, timeoutMs));\n         }\n     }\n+    /**\n+     * Call to assume that <code>actual</code> satisfies the condition specified by <code>matcher</code>.\n+     * If not, the test halts and is ignored.\n+     * Example:\n+     * <pre>:\n+     *   assumeThat(1, is(1)); // passes\n+     *   foo(); // will execute\n+     *   assumeThat(0, is(1)); // assumption failure! test halts\n+     *   int x = 1 / 0; // will never execute\n+     * </pre>\n+     *\n+     * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems such as {@code assumeThat(1, is(\"a\"))}\n+     * @param actual the computed value being compared\n+     * @param matcher an expression, built of {@link Matcher}s, specifying allowed values\n+     * @see org.hamcrest.CoreMatchers\n+     * @see org.junit.matchers.JUnitMatchers\n+     */\n+    public <T> void assumeThat(T actual, Matcher<T> matcher) {\n+        this.advanceRobolectricLooper();\n+        Assume.assumeThat(actual, matcher);\n+    }\n+\n+    /**\n+     * Call to assume that <code>actual</code> satisfies the condition specified by <code>matcher</code>.\n+     * If not, the test halts and is ignored.\n+     * Example:\n+     * <pre>:\n+     *   assumeThat(\"alwaysPasses\", 1, is(1)); // passes\n+     *   foo(); // will execute\n+     *   assumeThat(\"alwaysFails\", 0, is(1)); // assumption failure! test halts\n+     *   int x = 1 / 0; // will never execute\n+     * </pre>\n+     *\n+     * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems such as {@code assumeThat(1, is(\"a\"))}\n+     * @param actual the computed value being compared\n+     * @param matcher an expression, built of {@link Matcher}s, specifying allowed values\n+     * @see org.hamcrest.CoreMatchers\n+     * @see org.junit.matchers.JUnitMatchers\n+     */\n+    public <T> void assumeThat(String message, T actual, Matcher<T> matcher) {\n+        this.advanceRobolectricLooper();\n+        Assume.assumeThat(message, actual, matcher);\n+    }\n+\n+\n+\n+    /**\n+     * If called with an expression evaluating to {@code false}, the test will halt and be ignored.\n+     *\n+     * @param b If <code>false</code>, the method will attempt to stop the test and ignore it by\n+     * throwing {@link AssumptionViolatedException}.\n+     * @param message A message to pass to {@link AssumptionViolatedException}.\n+     */\n+    public void assumeTrue(String message, boolean b) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94afb42a5b60e76386d5c3a5575798099b3ebfb1"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDU1NzQ0", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-461055744", "createdAt": "2020-08-04T18:16:09Z", "commit": {"oid": "94afb42a5b60e76386d5c3a5575798099b3ebfb1"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODoxNjowOVrOG7r-dQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wNFQxODoxNjowOVrOG7r-dQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIzOTY2OQ==", "bodyText": "I only saw a single method when I reviewed", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#discussion_r465239669", "createdAt": "2020-08-04T18:16:09Z", "author": {"login": "david-allison-1"}, "path": "AnkiDroid/src/test/java/com/ichi2/anki/RobolectricTest.java", "diffHunk": "@@ -291,4 +295,61 @@ public void onPostExecute(TaskData result) {\n             throw new IllegalStateException(String.format(\"Task %s didn't finish in %d ms\", taskType, timeoutMs));\n         }\n     }\n+    /**\n+     * Call to assume that <code>actual</code> satisfies the condition specified by <code>matcher</code>.\n+     * If not, the test halts and is ignored.\n+     * Example:\n+     * <pre>:\n+     *   assumeThat(1, is(1)); // passes\n+     *   foo(); // will execute\n+     *   assumeThat(0, is(1)); // assumption failure! test halts\n+     *   int x = 1 / 0; // will never execute\n+     * </pre>\n+     *\n+     * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems such as {@code assumeThat(1, is(\"a\"))}\n+     * @param actual the computed value being compared\n+     * @param matcher an expression, built of {@link Matcher}s, specifying allowed values\n+     * @see org.hamcrest.CoreMatchers\n+     * @see org.junit.matchers.JUnitMatchers\n+     */\n+    public <T> void assumeThat(T actual, Matcher<T> matcher) {\n+        this.advanceRobolectricLooper();\n+        Assume.assumeThat(actual, matcher);\n+    }\n+\n+    /**\n+     * Call to assume that <code>actual</code> satisfies the condition specified by <code>matcher</code>.\n+     * If not, the test halts and is ignored.\n+     * Example:\n+     * <pre>:\n+     *   assumeThat(\"alwaysPasses\", 1, is(1)); // passes\n+     *   foo(); // will execute\n+     *   assumeThat(\"alwaysFails\", 0, is(1)); // assumption failure! test halts\n+     *   int x = 1 / 0; // will never execute\n+     * </pre>\n+     *\n+     * @param <T> the static type accepted by the matcher (this can flag obvious compile-time problems such as {@code assumeThat(1, is(\"a\"))}\n+     * @param actual the computed value being compared\n+     * @param matcher an expression, built of {@link Matcher}s, specifying allowed values\n+     * @see org.hamcrest.CoreMatchers\n+     * @see org.junit.matchers.JUnitMatchers\n+     */\n+    public <T> void assumeThat(String message, T actual, Matcher<T> matcher) {\n+        this.advanceRobolectricLooper();\n+        Assume.assumeThat(message, actual, matcher);\n+    }\n+\n+\n+\n+    /**\n+     * If called with an expression evaluating to {@code false}, the test will halt and be ignored.\n+     *\n+     * @param b If <code>false</code>, the method will attempt to stop the test and ignore it by\n+     * throwing {@link AssumptionViolatedException}.\n+     * @param message A message to pass to {@link AssumptionViolatedException}.\n+     */\n+    public void assumeTrue(String message, boolean b) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTIxMzI5Nw=="}, "originalCommit": {"oid": "94afb42a5b60e76386d5c3a5575798099b3ebfb1"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDU3NDQ0", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-461057444", "createdAt": "2020-08-04T18:18:33Z", "commit": {"oid": "94afb42a5b60e76386d5c3a5575798099b3ebfb1"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "210e9a5249c5269dcd4670dfd11fb19480e08aec", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/210e9a5249c5269dcd4670dfd11fb19480e08aec", "committedDate": "2020-08-04T18:36:37Z", "message": "NF: upstream test"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "94afb42a5b60e76386d5c3a5575798099b3ebfb1", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/94afb42a5b60e76386d5c3a5575798099b3ebfb1", "committedDate": "2020-08-04T17:25:20Z", "message": "NF: Assume uses advanceRobolectricLooper"}, "afterCommit": {"oid": "210e9a5249c5269dcd4670dfd11fb19480e08aec", "author": {"user": {"login": "Arthur-Milchior", "name": "Arthur Milchior"}}, "url": "https://github.com/ankidroid/Anki-Android/commit/210e9a5249c5269dcd4670dfd11fb19480e08aec", "committedDate": "2020-08-04T18:36:37Z", "message": "NF: upstream test"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMDc3NzQw", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-461077740", "createdAt": "2020-08-04T18:48:32Z", "commit": {"oid": "210e9a5249c5269dcd4670dfd11fb19480e08aec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYxMTE0MjQx", "url": "https://github.com/ankidroid/Anki-Android/pull/6708#pullrequestreview-461114241", "createdAt": "2020-08-04T19:34:24Z", "commit": {"oid": "210e9a5249c5269dcd4670dfd11fb19480e08aec"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3034, "cost": 1, "resetAt": "2021-10-29T17:30:11Z"}}}