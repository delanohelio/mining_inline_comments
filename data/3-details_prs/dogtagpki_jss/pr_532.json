{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExODMyMzcz", "number": 532, "title": "SSLSocket from SSLEngine", "bodyText": "Now that we have an SSLEngine implementation in hand, various other applications and libaries (such as resteasy) expect SSLSocket  as well. The issue is that our existing SSLSocket (under org.mozilla.jss.ssl.SSLSocket) doesn't conform at all to the javax.net.ssl.SSLSocket abstract class.\nEven if we hacked a javax-conforming SSLSocket out of a jss.ssl.SSLSocket, we'd still need to figure out how to allocate sockets correctly and close the existing one -- but immediate reuse might not be possible!\nSo, implement SSLSocket using our new SSLEngine.\nTODO:\n\n Implement SSLSocket\n\n Figure out underlying socket construction\n Figure out consuming an existing Socket.\n Figure out reading/writing\n Figure out SocketChannel\n\n\n Implement SSLServerSocket (#539)\n Implement SSLSocketFactory (#540)\n Implement SSLServerSocketFactory (#540)\n Clean up\n Provide javadocs\n Verify JSSSocketChannel implementation\n Test:\n\n with old jss.ssl.SSLSocket\n with javax SSLSocket\n with BadSSL (#540)", "createdAt": "2020-04-30T20:59:19Z", "url": "https://github.com/dogtagpki/jss/pull/532", "merged": true, "mergeCommit": {"oid": "1ca5fa6fcd1a83de0d9467c3cda3bf3d8088f9a3"}, "closed": true, "closedAt": "2020-05-07T20:03:43Z", "author": {"login": "cipherboy"}, "timelineItems": {"totalCount": 27, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcc2NFyABqjMyOTE3OTc0OTA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfC6jZAFqTQwNzc5NDE3NQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "10ebd3bb9d2422915b0f25d385b4efaf86527ed9", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/10ebd3bb9d2422915b0f25d385b4efaf86527ed9", "committedDate": "2020-04-30T20:57:19Z", "message": "FIXUP org/mozilla/jss/ssl/javax/JSSSocket.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "385c7d09cc10285847fc03559ad88501bba84f0e", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/385c7d09cc10285847fc03559ad88501bba84f0e", "committedDate": "2020-05-01T00:05:02Z", "message": "FIXUP JSSSocketChannel.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00dc6e8317b4597400ef6b9e8fec8f2458f4a6c2", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/00dc6e8317b4597400ef6b9e8fec8f2458f4a6c2", "committedDate": "2020-05-01T08:55:58Z", "message": "FIXUP ../org/mozilla/jss/ssl/javax/JSSSocketFactory.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "2203730211840cc3cf2d35ff09722c496debf08b", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/2203730211840cc3cf2d35ff09722c496debf08b", "committedDate": "2020-05-01T08:58:50Z", "message": "FIXUP ../org/mozilla/jss/ssl/javax/JSSSocketFactory.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2203730211840cc3cf2d35ff09722c496debf08b", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/2203730211840cc3cf2d35ff09722c496debf08b", "committedDate": "2020-05-01T08:58:50Z", "message": "FIXUP ../org/mozilla/jss/ssl/javax/JSSSocketFactory.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "34dfcb730433af05c6368572d4ed4a6d8da842ce", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/34dfcb730433af05c6368572d4ed4a6d8da842ce", "committedDate": "2020-05-04T14:07:38Z", "message": "FIXUP org/mozilla/jss/provider/javax/net/JSSContextSpi.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "34dfcb730433af05c6368572d4ed4a6d8da842ce", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/34dfcb730433af05c6368572d4ed4a6d8da842ce", "committedDate": "2020-05-04T14:07:38Z", "message": "FIXUP org/mozilla/jss/provider/javax/net/JSSContextSpi.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "3d37f279000c29a5f5b890d372fe0598b9a85c98", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/3d37f279000c29a5f5b890d372fe0598b9a85c98", "committedDate": "2020-05-04T14:09:40Z", "message": "FIXUP org/mozilla/jss/provider/javax/net/JSSContextSpi.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3d37f279000c29a5f5b890d372fe0598b9a85c98", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/3d37f279000c29a5f5b890d372fe0598b9a85c98", "committedDate": "2020-05-04T14:09:40Z", "message": "FIXUP org/mozilla/jss/provider/javax/net/JSSContextSpi.java\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "e8860b31031b4c3a9c2f5413d760967a6e988a6e", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/e8860b31031b4c3a9c2f5413d760967a6e988a6e", "committedDate": "2020-05-04T16:40:59Z", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e8860b31031b4c3a9c2f5413d760967a6e988a6e", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/e8860b31031b4c3a9c2f5413d760967a6e988a6e", "committedDate": "2020-05-04T16:40:59Z", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "ed35cf52b0de78a1a52139f9d0455b33913e3bba", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/ed35cf52b0de78a1a52139f9d0455b33913e3bba", "committedDate": "2020-05-04T18:16:12Z", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ed35cf52b0de78a1a52139f9d0455b33913e3bba", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/ed35cf52b0de78a1a52139f9d0455b33913e3bba", "committedDate": "2020-05-04T18:16:12Z", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/82cbc0d7ae3093b76592f8deb910362fe44c4089", "committedDate": "2020-05-04T19:46:01Z", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1ODgyMjkw", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-405882290", "createdAt": "2020-05-05T15:07:09Z", "commit": {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTowNzowOVrOGQt8OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTowNzowOVrOGQt8OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4MzA5Ng==", "bodyText": "Should be Math.min.", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420183096", "createdAt": "2020-05-05T15:07:09Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (parent != null && !parent.isBlocking()) {\n+            // If there is a channel, it could be blocking or non-blocking; in\n+            // the non-blocking case, we can safely return the suggested\n+            // amount, but in the blocking case, we still need to bound our\n+            // read.\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.max(suggested, available);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089"}, "originalPosition": 94}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1ODgyNDYw", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-405882460", "createdAt": "2020-05-05T15:07:20Z", "commit": {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTowNzoyMFrOGQt8yw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTowNzoyMFrOGQt8yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4MzI0Mw==", "bodyText": "Again, Math.min", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420183243", "createdAt": "2020-05-05T15:07:20Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (parent != null && !parent.isBlocking()) {\n+            // If there is a channel, it could be blocking or non-blocking; in\n+            // the non-blocking case, we can safely return the suggested\n+            // amount, but in the blocking case, we still need to bound our\n+            // read.\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.max(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                SSLEngineResult ret;\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    ByteBuffer src = null;\n+                    ByteBuffer dst = ByteBuffer.allocate(engine.BUFFER_SIZE);\n+\n+                    long sent = 0;\n+                    long encrypted = 0;\n+\n+                    do {\n+                        ret = engine.wrap(src, dst);\n+                        if (ret.getStatus() != SSLEngineResult.Status.OK && ret.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                            throw new IOException(\"Unexpected status from wrap: \" + ret);\n+                        }\n+\n+                        encrypted += ret.bytesProduced();\n+\n+                        int this_write = writeChannel.write(dst);\n+                        sent += this_write;\n+\n+                        if (sent < encrypted && ret.bytesProduced() == 0 && this_write == 0) {\n+                            String msg = \"Error attempting to write to remote \";\n+                            msg += \"peer: calls to wrap or write stalled, \";\n+                            msg += \"consuming and producing no data: sent \";\n+                            msg += sent + \" bytes of \" + encrypted + \" bytes \";\n+                            msg += \"encrypted to remote peer\";\n+                            throw new IOException(msg);\n+                        }\n+                    } while (sent < encrypted);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    int buffer_size = boundRead(engine.BUFFER_SIZE);\n+                    ByteBuffer src = ByteBuffer.allocate(buffer_size);\n+                    ByteBuffer dst = null;\n+\n+                    int remoteRead = readChannel.read(src);\n+                    if (remoteRead == 0) {\n+                        // Nothing to do; use this to step the unknown state\n+                        // counter and continue.\n+                        state = engine.getHandshakeStatus();\n+                        continue;\n+                    }\n+\n+                    int unwrapped = 0;\n+                    do {\n+                        ret = engine.unwrap(src, dst);\n+                        if (ret.getStatus() != SSLEngineResult.Status.OK && ret.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                            throw new IOException(\"Unexpected status from unwrap: \" + ret);\n+                        }\n+\n+                        unwrapped += ret.bytesConsumed();\n+                        if (unwrapped < remoteRead && ret.bytesConsumed() == 0) {\n+                            String msg = \"Error during handshake: unable to \";\n+                            msg += \"consume some bytes of this handshake \";\n+                            msg += \"message. Consumed: \" + unwrapped;\n+                            msg += \" Total available: \" + remoteRead;\n+                            throw new IOException(msg);\n+                        }\n+                    } while (unwrapped < remoteRead);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                if (ret.getStatus() != SSLEngineResult.Status.OK) {\n+                    String msg = \"Error attempting to handshake: unexpected\";\n+                    msg += \"SSLEngineResult status code: \" + ret.getStatus();\n+                    msg += \" -- \" + ret;\n+                    throw new IOException(msg);\n+                }\n+\n+                state = engine.getHandshakeStatus();\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (!finishConnect()) {\n+            throw new IOException(\"Unable to finish handshake for an unknown reason.\");\n+        }\n+\n+        long capacity = computeSize(dsts, offset, length);\n+        int buffer_size = boundRead((int) Math.max(capacity, Integer.MAX_VALUE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089"}, "originalPosition": 231}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1ODgyNjQx", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-405882641", "createdAt": "2020-05-05T15:07:32Z", "commit": {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTowNzozMlrOGQt9WQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNTowNzozMlrOGQt9WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE4MzM4NQ==", "bodyText": "Math.min here as well.", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420183385", "createdAt": "2020-05-05T15:07:32Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (parent != null && !parent.isBlocking()) {\n+            // If there is a channel, it could be blocking or non-blocking; in\n+            // the non-blocking case, we can safely return the suggested\n+            // amount, but in the blocking case, we still need to bound our\n+            // read.\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.max(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                SSLEngineResult ret;\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    ByteBuffer src = null;\n+                    ByteBuffer dst = ByteBuffer.allocate(engine.BUFFER_SIZE);\n+\n+                    long sent = 0;\n+                    long encrypted = 0;\n+\n+                    do {\n+                        ret = engine.wrap(src, dst);\n+                        if (ret.getStatus() != SSLEngineResult.Status.OK && ret.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                            throw new IOException(\"Unexpected status from wrap: \" + ret);\n+                        }\n+\n+                        encrypted += ret.bytesProduced();\n+\n+                        int this_write = writeChannel.write(dst);\n+                        sent += this_write;\n+\n+                        if (sent < encrypted && ret.bytesProduced() == 0 && this_write == 0) {\n+                            String msg = \"Error attempting to write to remote \";\n+                            msg += \"peer: calls to wrap or write stalled, \";\n+                            msg += \"consuming and producing no data: sent \";\n+                            msg += sent + \" bytes of \" + encrypted + \" bytes \";\n+                            msg += \"encrypted to remote peer\";\n+                            throw new IOException(msg);\n+                        }\n+                    } while (sent < encrypted);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    int buffer_size = boundRead(engine.BUFFER_SIZE);\n+                    ByteBuffer src = ByteBuffer.allocate(buffer_size);\n+                    ByteBuffer dst = null;\n+\n+                    int remoteRead = readChannel.read(src);\n+                    if (remoteRead == 0) {\n+                        // Nothing to do; use this to step the unknown state\n+                        // counter and continue.\n+                        state = engine.getHandshakeStatus();\n+                        continue;\n+                    }\n+\n+                    int unwrapped = 0;\n+                    do {\n+                        ret = engine.unwrap(src, dst);\n+                        if (ret.getStatus() != SSLEngineResult.Status.OK && ret.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                            throw new IOException(\"Unexpected status from unwrap: \" + ret);\n+                        }\n+\n+                        unwrapped += ret.bytesConsumed();\n+                        if (unwrapped < remoteRead && ret.bytesConsumed() == 0) {\n+                            String msg = \"Error during handshake: unable to \";\n+                            msg += \"consume some bytes of this handshake \";\n+                            msg += \"message. Consumed: \" + unwrapped;\n+                            msg += \" Total available: \" + remoteRead;\n+                            throw new IOException(msg);\n+                        }\n+                    } while (unwrapped < remoteRead);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                if (ret.getStatus() != SSLEngineResult.Status.OK) {\n+                    String msg = \"Error attempting to handshake: unexpected\";\n+                    msg += \"SSLEngineResult status code: \" + ret.getStatus();\n+                    msg += \" -- \" + ret;\n+                    throw new IOException(msg);\n+                }\n+\n+                state = engine.getHandshakeStatus();\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (!finishConnect()) {\n+            throw new IOException(\"Unable to finish handshake for an unknown reason.\");\n+        }\n+\n+        long capacity = computeSize(dsts, offset, length);\n+        int buffer_size = boundRead((int) Math.max(capacity, Integer.MAX_VALUE));\n+        ByteBuffer src = ByteBuffer.allocate(buffer_size);\n+\n+        long remoteRead = readChannel.read(src);\n+        if (remoteRead == 0) {\n+            return 0;\n+        }\n+\n+        long unwrapped = 0;\n+        long decrypted = 0;\n+\n+        try {\n+            do {\n+                SSLEngineResult result = engine.unwrap(src, dsts, offset, length);\n+                if (result.getStatus() != SSLEngineResult.Status.OK && result.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                }\n+\n+                unwrapped += result.bytesConsumed();\n+                decrypted += result.bytesProduced();\n+\n+                if (unwrapped < remoteRead && result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n+                    String msg = \"Error attempting to read from remote peer: \";\n+                    msg += \"calls to unwrap stalled, consuming and producing \";\n+                    msg += \"no data: unwrapped \" + unwrapped + \" bytes of \";\n+                    msg += remoteRead + \" bytes read from remote peer; got a \";\n+                    msg += \"decrypted size of \" + decrypted + \" bytes.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (unwrapped < remoteRead);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to read from remote peer: \";\n+            msg += \"got unexpected exception during unwrap call: \";\n+            msg += ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        return decrypted;\n+    }\n+\n+    public int write(ByteBuffer src) throws IOException {\n+        return (int) write(new ByteBuffer[] { src });\n+    }\n+\n+    public long write(ByteBuffer[] srcs, int offset, int length) throws IOException {\n+        if (!finishConnect()) {\n+            throw new IOException(\"Unable to finish handshake for an unknown reason.\");\n+        }\n+\n+        long capacity = computeSize(srcs, offset, length);\n+        int buffer_size = boundRead((int) Math.max(capacity, Integer.MAX_VALUE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089"}, "originalPosition": 281}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "82cbc0d7ae3093b76592f8deb910362fe44c4089", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/82cbc0d7ae3093b76592f8deb910362fe44c4089", "committedDate": "2020-05-04T19:46:01Z", "message": "Switch to JSS-provided SSL SocketFactories\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "3c41f064781ba207a0008323cbc8ad710260eb23", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/3c41f064781ba207a0008323cbc8ad710260eb23", "committedDate": "2020-05-05T23:05:23Z", "message": "Allow null src[index] in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3c41f064781ba207a0008323cbc8ad710260eb23", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/3c41f064781ba207a0008323cbc8ad710260eb23", "committedDate": "2020-05-05T23:05:23Z", "message": "Allow null src[index] in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "7ac6fe7fb45341b9e036dcff2de94ec602c8ae58", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/7ac6fe7fb45341b9e036dcff2de94ec602c8ae58", "committedDate": "2020-05-06T12:47:39Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NjAxNTk5", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-406601599", "createdAt": "2020-05-06T13:17:58Z", "commit": {"oid": "7ac6fe7fb45341b9e036dcff2de94ec602c8ae58"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzoxNzo1OFrOGRSf8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMzoxNzo1OFrOGRSf8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDc4MjA2NA==", "bodyText": "need to call configureBlocking(); otherwise this and the parent channel become out of sync.", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420782064", "createdAt": "2020-05-06T13:17:58Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,462 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7ac6fe7fb45341b9e036dcff2de94ec602c8ae58"}, "originalPosition": 43}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7ac6fe7fb45341b9e036dcff2de94ec602c8ae58", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/7ac6fe7fb45341b9e036dcff2de94ec602c8ae58", "committedDate": "2020-05-06T12:47:39Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "3f871da0653b989298d521bbf7a377e9f6c75fe4", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/3f871da0653b989298d521bbf7a377e9f6c75fe4", "committedDate": "2020-05-06T13:19:42Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3f871da0653b989298d521bbf7a377e9f6c75fe4", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/3f871da0653b989298d521bbf7a377e9f6c75fe4", "committedDate": "2020-05-06T13:19:42Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "7ee2f29f56f394434ca65cc8f85aa2cc1ffed3fd", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/7ee2f29f56f394434ca65cc8f85aa2cc1ffed3fd", "committedDate": "2020-05-06T13:23:10Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7ee2f29f56f394434ca65cc8f85aa2cc1ffed3fd", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/7ee2f29f56f394434ca65cc8f85aa2cc1ffed3fd", "committedDate": "2020-05-06T13:23:10Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "72a7ebd72a8fc7f07a491b36bed6747dc911e14c", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/72a7ebd72a8fc7f07a491b36bed6747dc911e14c", "committedDate": "2020-05-06T13:31:00Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "72a7ebd72a8fc7f07a491b36bed6747dc911e14c", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/72a7ebd72a8fc7f07a491b36bed6747dc911e14c", "committedDate": "2020-05-06T13:31:00Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/9bb24402c211d609d0f0007fef4b21272be7f4ea", "committedDate": "2020-05-06T13:40:11Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Nzg3NTE4", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-406787518", "createdAt": "2020-05-06T16:32:24Z", "commit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjozMjoyNFrOGRbc3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjozMjoyNFrOGRbc3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkyODczMw==", "bodyText": "Move byte buffers here and make them sized based on engine.getSession().getApplicationBufferSize() rather than the internal constant value. This will reduce the number of allocations we have to do, at the risk of needing to make read/write synchronized around it.", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420928733", "createdAt": "2020-05-06T16:32:24Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,465 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NzkzNzQ3", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-406793747", "createdAt": "2020-05-06T16:40:04Z", "commit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0MDowNFrOGRbxEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0MDowNFrOGRbxEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMzkwNg==", "bodyText": "If we switch to per-instance buffers, we can change this call to:\nread_buffer.clear();\nByteBuffer.wrap(read_buffer.array(), 0, buffer_size);", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420933906", "createdAt": "2020-05-06T16:40:04Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,465 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        ByteBuffer empty = ByteBuffer.allocate(0);\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather\n+            // return false than take too much time in this method.\n+            maxHandshakeAttempts = 10;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    // Write from an empty buffer to wrap.\n+                    write(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    // Read into an empty buffer to unwrap.\n+                    read(empty);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                SSLEngineResult.HandshakeStatus last_state = state;\n+                state = engine.getHandshakeStatus();\n+                handshakeAttempts += 1;\n+\n+                if (state == last_state) {\n+                    try {\n+                        // This sleep is necessary in order to wait for\n+                        // incoming data. If it turns out our\n+                        // NEED_UNWRAP is premature (and we're stuck in\n+                        // a blocking read() call because we issued a\n+                        // non-zero read!), we might cause the remote\n+                        // peer to timeout and send a CLOSE_NOTIFY\n+                        // alert. This wouldn't be good, so sleep\n+                        // instead. Use an exponential backoff in case\n+                        // the remote server is really slow.\n+                        Thread.sleep(handshakeAttempts * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (handshakeAttempts > maxHandshakeAttempts) {\n+                    if (!isBlocking()) {\n+                        // In the event we failed to connect under a\n+                        // non-blocking socket, return false rather than fail\n+                        // here. It could just be that we don't have enough\n+                        // data to continue. In that case, doHandshake() in\n+                        // JSSSocket will re-try until the connection succeeds.\n+                        return false;\n+                    }\n+\n+                    String msg = \"Error attempting to handshake: unable to \";\n+                    msg += \"complete handshake successfully in \";\n+                    msg += maxHandshakeAttempts + \" calls to wrap or unwrap. \";\n+                    msg += \"Connection stalled.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED && state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        sslSocket.notifyHandshakeCompletedListeners();\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (inboundClosed) {\n+            return -1;\n+        }\n+\n+        int buffer_size = boundRead(JSSEngine.BUFFER_SIZE);\n+        ByteBuffer src = ByteBuffer.allocate(buffer_size);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea"}, "originalPosition": 226}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2Nzk5NTQy", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-406799542", "createdAt": "2020-05-06T16:47:17Z", "commit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0NzoxN1rOGRcDTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxNjo0NzoxN1rOGRcDTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzODU3NA==", "bodyText": "@edewata Should we move this inside the loop below? In particular, if we read a non-zero amount and then unwrap it all, we could retry the read and potentially get more data. Thoughts?\nNote that we'd have to handle the case where the consumed has data left, but we don't currently handle that either way.\nIt'd make the read() code look more like write() though.\nThoughts?", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420938574", "createdAt": "2020-05-06T16:47:17Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,465 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining case (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        ByteBuffer empty = ByteBuffer.allocate(0);\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather\n+            // return false than take too much time in this method.\n+            maxHandshakeAttempts = 10;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    // Write from an empty buffer to wrap.\n+                    write(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    // Read into an empty buffer to unwrap.\n+                    read(empty);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                SSLEngineResult.HandshakeStatus last_state = state;\n+                state = engine.getHandshakeStatus();\n+                handshakeAttempts += 1;\n+\n+                if (state == last_state) {\n+                    try {\n+                        // This sleep is necessary in order to wait for\n+                        // incoming data. If it turns out our\n+                        // NEED_UNWRAP is premature (and we're stuck in\n+                        // a blocking read() call because we issued a\n+                        // non-zero read!), we might cause the remote\n+                        // peer to timeout and send a CLOSE_NOTIFY\n+                        // alert. This wouldn't be good, so sleep\n+                        // instead. Use an exponential backoff in case\n+                        // the remote server is really slow.\n+                        Thread.sleep(handshakeAttempts * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (handshakeAttempts > maxHandshakeAttempts) {\n+                    if (!isBlocking()) {\n+                        // In the event we failed to connect under a\n+                        // non-blocking socket, return false rather than fail\n+                        // here. It could just be that we don't have enough\n+                        // data to continue. In that case, doHandshake() in\n+                        // JSSSocket will re-try until the connection succeeds.\n+                        return false;\n+                    }\n+\n+                    String msg = \"Error attempting to handshake: unable to \";\n+                    msg += \"complete handshake successfully in \";\n+                    msg += maxHandshakeAttempts + \" calls to wrap or unwrap. \";\n+                    msg += \"Connection stalled.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED && state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        sslSocket.notifyHandshakeCompletedListeners();\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (inboundClosed) {\n+            return -1;\n+        }\n+\n+        int buffer_size = boundRead(JSSEngine.BUFFER_SIZE);\n+        ByteBuffer src = ByteBuffer.allocate(buffer_size);\n+\n+        long remoteRead = readChannel.read(src);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea"}, "originalPosition": 228}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/9bb24402c211d609d0f0007fef4b21272be7f4ea", "committedDate": "2020-05-06T13:40:11Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/defd123758ba3b850d09b5bf095f70c586f48a39", "committedDate": "2020-05-06T18:27:37Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA1Mzc3OTY1", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-405377965", "createdAt": "2020-05-04T21:58:44Z", "commit": {"oid": "cb1f6bb0e94acecd3c025a263f43a13fb1351fa6"}, "state": "APPROVED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQyMzoxMToxMFrOGQVbDQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QwMDozMjowOVrOGRqL3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTc4MTM4OQ==", "bodyText": "How is long boundRead(long) going to be used? So far I only see int boundRead(int) in line 248.", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r419781389", "createdAt": "2020-05-04T23:11:10Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,449 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private boolean autoClose = true;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parent.socket();\n+        readChannel = parent;\n+        writeChannel = parent;\n+        this.engine = engine;\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        this.consumed = consumed;\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb1f6bb0e94acecd3c025a263f43a13fb1351fa6"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDkzMjkxMg==", "bodyText": "This code will catch generic exceptions, so probably the exception message should be a bit more generic as well, for example:\nString msg = \"Unable to create JSSContext: \" + e.getMessage()", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r420932912", "createdAt": "2020-05-06T16:38:39Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {\n+    /**\n+     * Name of the SSLEngine protocol to use.\n+     */\n+    private String engineProviderProtocol = \"TLS\";\n+\n+    /**\n+     * Name of the SSLEngine provider to use.\n+     */\n+    private String engineProvider = \"Mozilla-JSS\";\n+\n+    /**\n+     * SSLContext to use to create the JSSEngine. Note that JSSSocket will fail\n+     * if the context doesn't create JSSEngine instances.\n+     */\n+    private SSLContext jssContext;\n+\n+    /**\n+     * JSSEngine instance to utilize for SSLEngine operations.\n+     */\n+    private JSSEngine engine;\n+\n+    /**\n+     * All registered handshake callbacks.\n+     */\n+    private ArrayList<HandshakeCompletedListener> handshakeCallbacks = new ArrayList<HandshakeCompletedListener>();\n+\n+    /**\n+     * The socket this JSSSocket was created over; all read/write operations\n+     * go through this socket and all information exposed via Socket members\n+     * go through here.\n+     */\n+    private Socket parent;\n+\n+    /**\n+     * Previously consumed data, if any; utilized for certain SSLSocketFactory\n+     * calls.\n+     */\n+    private InputStream consumedData;\n+\n+    /**\n+     * Underlying SocketChannel for this socket; always exists.\n+     */\n+    private JSSSocketChannel channel;\n+\n+    /**\n+     * Whether or not to automatically close the underlying Socket when this\n+     * socket has been closed; defaults to true.\n+     */\n+    private boolean autoClose = true;\n+\n+    /**\n+     * Start building a new JSSSocket.\n+     *\n+     * We specifically avoid creating any other constructors as we wish to\n+     * consume an existing socket rather than creating a new one.\n+     */\n+    public JSSSocket() {}\n+\n+    /**\n+     * Consume a parent socket, utilizing it for all read/write operations.\n+     *\n+     * This JSSSocket instance will inherit all information about the\n+     * connection from this underlying socket. When utilized in a JSSSocket,\n+     * callers should refrain from interacting with the underlying socket\n+     * directly until the TLS connection is closed. Otherwise, messages may\n+     * get dropped.\n+     */\n+    public void consumeSocket(Socket parent) throws IOException {\n+        if (parent == null) {\n+            String msg = \"Unable to consume and utilize null parent socket!\";\n+            throw new IOException(msg);\n+        }\n+\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get the SSLContext if one exists or create a new instance.\n+     *\n+     * This is used by initSSLEngine(..) to create the underlying SSLEngine.\n+     */\n+    protected SSLContext getSSLContext() throws IOException {\n+        if (jssContext == null) {\n+            try {\n+                jssContext = SSLContext.getInstance(engineProviderProtocol, engineProvider);\n+            } catch (Exception e) {\n+                String msg = \"Unable to create JSSSocket prior to Mozilla-JSS \";\n+                msg += \"initialization! \" + e.getMessage();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9bb24402c211d609d0f0007fef4b21272be7f4ea"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwNzYzNQ==", "bodyText": "IIUC the current code uses a linear backoff with a maximum sleep of 2.5 seconds and total wait time of 32.5 seconds. Is that the intention, or should we use something like this?\nint connectAttempts = 1;\nwhile (!status) {\n    connectAttempts *= 2;\n}", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421107635", "createdAt": "2020-05-06T21:37:22Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {\n+    /**\n+     * Name of the SSLEngine protocol to use.\n+     */\n+    private String engineProviderProtocol = \"TLS\";\n+\n+    /**\n+     * Name of the SSLEngine provider to use.\n+     */\n+    private String engineProvider = \"Mozilla-JSS\";\n+\n+    /**\n+     * SSLContext to use to create the JSSEngine. Note that JSSSocket will fail\n+     * if the context doesn't create JSSEngine instances.\n+     */\n+    private SSLContext jssContext;\n+\n+    /**\n+     * JSSEngine instance to utilize for SSLEngine operations.\n+     */\n+    private JSSEngine engine;\n+\n+    /**\n+     * All registered handshake callbacks.\n+     */\n+    private ArrayList<HandshakeCompletedListener> handshakeCallbacks = new ArrayList<HandshakeCompletedListener>();\n+\n+    /**\n+     * The socket this JSSSocket was created over; all read/write operations\n+     * go through this socket and all information exposed via Socket members\n+     * go through here.\n+     */\n+    private Socket parent;\n+\n+    /**\n+     * Previously consumed data, if any; utilized for certain SSLSocketFactory\n+     * calls.\n+     */\n+    private InputStream consumedData;\n+\n+    /**\n+     * Underlying SocketChannel for this socket; always exists.\n+     */\n+    private JSSSocketChannel channel;\n+\n+    /**\n+     * Whether or not to automatically close the underlying Socket when this\n+     * socket has been closed; defaults to true.\n+     */\n+    private boolean autoClose = true;\n+\n+    /**\n+     * Start building a new JSSSocket.\n+     *\n+     * We specifically avoid creating any other constructors as we wish to\n+     * consume an existing socket rather than creating a new one.\n+     */\n+    public JSSSocket() {}\n+\n+    /**\n+     * Consume a parent socket, utilizing it for all read/write operations.\n+     *\n+     * This JSSSocket instance will inherit all information about the\n+     * connection from this underlying socket. When utilized in a JSSSocket,\n+     * callers should refrain from interacting with the underlying socket\n+     * directly until the TLS connection is closed. Otherwise, messages may\n+     * get dropped.\n+     */\n+    public void consumeSocket(Socket parent) throws IOException {\n+        if (parent == null) {\n+            String msg = \"Unable to consume and utilize null parent socket!\";\n+            throw new IOException(msg);\n+        }\n+\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get the SSLContext if one exists or create a new instance.\n+     *\n+     * This is used by initSSLEngine(..) to create the underlying SSLEngine.\n+     */\n+    protected SSLContext getSSLContext() throws IOException {\n+        if (jssContext == null) {\n+            try {\n+                jssContext = SSLContext.getInstance(engineProviderProtocol, engineProvider);\n+            } catch (Exception e) {\n+                String msg = \"Unable to create JSSSocket prior to Mozilla-JSS \";\n+                msg += \"initialization! \" + e.getMessage();\n+                throw new IOException(msg, e);\n+            }\n+        }\n+\n+        return jssContext;\n+    }\n+\n+    /**\n+     * Explicitly set the SSLContext utilized by this JSSSocket instance.\n+     *\n+     * This enables JSSServerSocket to copy its SSLContext over to the accepted\n+     * JSSSocket.\n+     */\n+    public void setSSLContext(SSLContext ctx) throws IOException {\n+        jssContext = ctx;\n+    }\n+\n+    /**\n+     * Initialize the underlying SocketChannel.\n+     */\n+    private void init() throws IOException {\n+        if (engine == null) {\n+            initEngine();\n+        }\n+\n+        SocketChannel parentChannel = parent.getChannel();\n+\n+        if (parentChannel == null) {\n+            ReadableByteChannel read = Channels.newChannel(parent.getInputStream());\n+            WritableByteChannel write = Channels.newChannel(parent.getOutputStream());\n+\n+            channel = new JSSSocketChannel(this, parent, read, write, engine);\n+        } else {\n+            channel = new JSSSocketChannel(this, parentChannel, engine);\n+        }\n+\n+        channel.setConsumedData(consumedData);\n+        channel.setAutoClose(autoClose);\n+    }\n+\n+    /**\n+     * Explicitly initialize the SSLEngine with no session resumption\n+     * information.\n+     */\n+    public void initEngine() throws IOException {\n+        engine = (JSSEngine) getSSLContext().createSSLEngine();\n+    }\n+\n+    /**\n+     * Explicitly initialize the SSLEngine with information for session\n+     * resumption, including peer's hostname and port.\n+     */\n+    public void initEngine(String host, int port) throws IOException {\n+        engine = (JSSEngine) getSSLContext().createSSLEngine(host, port);\n+    }\n+\n+    /**\n+     * Get the underlying JSSEngine instance.\n+     *\n+     * Note that, just like accessing the underlying Socket instance while the\n+     * JSSSocket instance is still open is dangerous, performing other TLS\n+     * operations directly via JSSEngine is also dangerous. This is mostly\n+     * exposed to enable advanced configuration of the JSSEngine that isn't\n+     * otherwise allowed by JSSSocket, and to facilitate the accept() method\n+     * on JSSServerSocket.\n+     */\n+    public JSSEngine getEngine() {\n+        return engine;\n+    }\n+\n+    /**\n+     * Get the underlying SocketChannel for this Socket.\n+     *\n+     * @see java.net.Socket#getChannel()\n+     */\n+    public JSSSocketChannel getChannel() {\n+        if (channel == null) {\n+            try {\n+                init();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Unexpected error trying to construct channel: \" + e.getMessage(), e);\n+            }\n+        }\n+\n+        return channel;\n+    }\n+\n+    /**\n+     * Get a copy of an input stream for this Socket.\n+     *\n+     * @see java.net.Socket#getInputStream()\n+     */\n+    public InputStream getInputStream() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        return Channels.newInputStream(channel);\n+    }\n+\n+    /**\n+     * Get a copy of an output stream for this Socket.\n+     *\n+     * @see java.net.Socket#getOutputStream()\n+     */\n+    public OutputStream getOutputStream() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        return Channels.newOutputStream(channel);\n+    }\n+\n+    /**\n+     * Internal helper to perform the handshake operation, blocking.\n+     *\n+     * Note that JSSSocket doesn't invoke JSSEngine.wrap/unwrap directly;\n+     * instead everything is contained within JSSSocketChannel.\n+     */\n+    private void doHandshake() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        boolean status = channel.finishConnect();\n+        if (!channel.isBlocking()) {\n+            // SSLSocket semantics explicitly say:\n+            //     > This method is synchronous for the initial handshake on\n+            //     > a connection and returns when the negotiated handshake is\n+            //     > complete.\n+            // so we have to block until the connection is complete. But use an\n+            // exponential backoff so we have a chance of catching any peer\n+            // data.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39"}, "originalPosition": 273}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTEwOTQzNw==", "bodyText": "The event seems to be generally read-only, so we might be able to reuse a single event object for all callbacks.", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421109437", "createdAt": "2020-05-06T21:41:25Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {\n+    /**\n+     * Name of the SSLEngine protocol to use.\n+     */\n+    private String engineProviderProtocol = \"TLS\";\n+\n+    /**\n+     * Name of the SSLEngine provider to use.\n+     */\n+    private String engineProvider = \"Mozilla-JSS\";\n+\n+    /**\n+     * SSLContext to use to create the JSSEngine. Note that JSSSocket will fail\n+     * if the context doesn't create JSSEngine instances.\n+     */\n+    private SSLContext jssContext;\n+\n+    /**\n+     * JSSEngine instance to utilize for SSLEngine operations.\n+     */\n+    private JSSEngine engine;\n+\n+    /**\n+     * All registered handshake callbacks.\n+     */\n+    private ArrayList<HandshakeCompletedListener> handshakeCallbacks = new ArrayList<HandshakeCompletedListener>();\n+\n+    /**\n+     * The socket this JSSSocket was created over; all read/write operations\n+     * go through this socket and all information exposed via Socket members\n+     * go through here.\n+     */\n+    private Socket parent;\n+\n+    /**\n+     * Previously consumed data, if any; utilized for certain SSLSocketFactory\n+     * calls.\n+     */\n+    private InputStream consumedData;\n+\n+    /**\n+     * Underlying SocketChannel for this socket; always exists.\n+     */\n+    private JSSSocketChannel channel;\n+\n+    /**\n+     * Whether or not to automatically close the underlying Socket when this\n+     * socket has been closed; defaults to true.\n+     */\n+    private boolean autoClose = true;\n+\n+    /**\n+     * Start building a new JSSSocket.\n+     *\n+     * We specifically avoid creating any other constructors as we wish to\n+     * consume an existing socket rather than creating a new one.\n+     */\n+    public JSSSocket() {}\n+\n+    /**\n+     * Consume a parent socket, utilizing it for all read/write operations.\n+     *\n+     * This JSSSocket instance will inherit all information about the\n+     * connection from this underlying socket. When utilized in a JSSSocket,\n+     * callers should refrain from interacting with the underlying socket\n+     * directly until the TLS connection is closed. Otherwise, messages may\n+     * get dropped.\n+     */\n+    public void consumeSocket(Socket parent) throws IOException {\n+        if (parent == null) {\n+            String msg = \"Unable to consume and utilize null parent socket!\";\n+            throw new IOException(msg);\n+        }\n+\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get the SSLContext if one exists or create a new instance.\n+     *\n+     * This is used by initSSLEngine(..) to create the underlying SSLEngine.\n+     */\n+    protected SSLContext getSSLContext() throws IOException {\n+        if (jssContext == null) {\n+            try {\n+                jssContext = SSLContext.getInstance(engineProviderProtocol, engineProvider);\n+            } catch (Exception e) {\n+                String msg = \"Unable to create JSSSocket prior to Mozilla-JSS \";\n+                msg += \"initialization! \" + e.getMessage();\n+                throw new IOException(msg, e);\n+            }\n+        }\n+\n+        return jssContext;\n+    }\n+\n+    /**\n+     * Explicitly set the SSLContext utilized by this JSSSocket instance.\n+     *\n+     * This enables JSSServerSocket to copy its SSLContext over to the accepted\n+     * JSSSocket.\n+     */\n+    public void setSSLContext(SSLContext ctx) throws IOException {\n+        jssContext = ctx;\n+    }\n+\n+    /**\n+     * Initialize the underlying SocketChannel.\n+     */\n+    private void init() throws IOException {\n+        if (engine == null) {\n+            initEngine();\n+        }\n+\n+        SocketChannel parentChannel = parent.getChannel();\n+\n+        if (parentChannel == null) {\n+            ReadableByteChannel read = Channels.newChannel(parent.getInputStream());\n+            WritableByteChannel write = Channels.newChannel(parent.getOutputStream());\n+\n+            channel = new JSSSocketChannel(this, parent, read, write, engine);\n+        } else {\n+            channel = new JSSSocketChannel(this, parentChannel, engine);\n+        }\n+\n+        channel.setConsumedData(consumedData);\n+        channel.setAutoClose(autoClose);\n+    }\n+\n+    /**\n+     * Explicitly initialize the SSLEngine with no session resumption\n+     * information.\n+     */\n+    public void initEngine() throws IOException {\n+        engine = (JSSEngine) getSSLContext().createSSLEngine();\n+    }\n+\n+    /**\n+     * Explicitly initialize the SSLEngine with information for session\n+     * resumption, including peer's hostname and port.\n+     */\n+    public void initEngine(String host, int port) throws IOException {\n+        engine = (JSSEngine) getSSLContext().createSSLEngine(host, port);\n+    }\n+\n+    /**\n+     * Get the underlying JSSEngine instance.\n+     *\n+     * Note that, just like accessing the underlying Socket instance while the\n+     * JSSSocket instance is still open is dangerous, performing other TLS\n+     * operations directly via JSSEngine is also dangerous. This is mostly\n+     * exposed to enable advanced configuration of the JSSEngine that isn't\n+     * otherwise allowed by JSSSocket, and to facilitate the accept() method\n+     * on JSSServerSocket.\n+     */\n+    public JSSEngine getEngine() {\n+        return engine;\n+    }\n+\n+    /**\n+     * Get the underlying SocketChannel for this Socket.\n+     *\n+     * @see java.net.Socket#getChannel()\n+     */\n+    public JSSSocketChannel getChannel() {\n+        if (channel == null) {\n+            try {\n+                init();\n+            } catch (IOException e) {\n+                throw new RuntimeException(\"Unexpected error trying to construct channel: \" + e.getMessage(), e);\n+            }\n+        }\n+\n+        return channel;\n+    }\n+\n+    /**\n+     * Get a copy of an input stream for this Socket.\n+     *\n+     * @see java.net.Socket#getInputStream()\n+     */\n+    public InputStream getInputStream() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        return Channels.newInputStream(channel);\n+    }\n+\n+    /**\n+     * Get a copy of an output stream for this Socket.\n+     *\n+     * @see java.net.Socket#getOutputStream()\n+     */\n+    public OutputStream getOutputStream() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        return Channels.newOutputStream(channel);\n+    }\n+\n+    /**\n+     * Internal helper to perform the handshake operation, blocking.\n+     *\n+     * Note that JSSSocket doesn't invoke JSSEngine.wrap/unwrap directly;\n+     * instead everything is contained within JSSSocketChannel.\n+     */\n+    private void doHandshake() throws IOException {\n+        if (channel == null) {\n+            init();\n+        }\n+\n+        boolean status = channel.finishConnect();\n+        if (!channel.isBlocking()) {\n+            // SSLSocket semantics explicitly say:\n+            //     > This method is synchronous for the initial handshake on\n+            //     > a connection and returns when the negotiated handshake is\n+            //     > complete.\n+            // so we have to block until the connection is complete. But use an\n+            // exponential backoff so we have a chance of catching any peer\n+            // data.\n+            int connectAttempts = 0;\n+            while (!status) {\n+                status = channel.finishConnect();\n+\n+                try {\n+                    Thread.sleep(connectAttempts * 100);\n+                } catch (Exception e) {}\n+\n+                connectAttempts += 1;\n+                if (connectAttempts > 25) {\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (!status) {\n+            throw new IOException(\"Unable to finish handshake for an unknown reason.\");\n+        }\n+    }\n+\n+    /**\n+     * Helper to inform this socket of data already consumed from the wrapped\n+     * socket.\n+     *\n+     * This is provided to facilitate a SSLSocketFactory call which allows\n+     * construction of SSLSocket instances from a non-SSL ServerSocket,\n+     * allowing the application to check SNI information directly.\n+     */\n+    public void setConsumedData(InputStream consumed) {\n+        consumedData = consumed;\n+    }\n+\n+    /**\n+     * Get the autoClose status of this socket, that is, whether or not its\n+     * parent socket will be automatically closed.\n+     */\n+    public boolean getAutoClose() {\n+        return autoClose;\n+    }\n+\n+    /**\n+     * Set the autoClose status of this socket, that is, whether or not its\n+     * parent socket will be automatically closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+\n+        // When the channel already exists, we need to propagate the status\n+        // to the channel as that actually handles closing this socket.\n+        if (channel != null) {\n+            channel.setAutoClose(on);\n+        }\n+    }\n+\n+    /* == stubs over JSSEngine == */\n+\n+    /**\n+     * Set the hostname this client socket is connecting to, for HTTPS TLS\n+     * certificate validation purposes.\n+     *\n+     * @see JSSEngine#setHostname(String)\n+     */\n+    public void setHostname(String name) {\n+        engine.setHostname(name);\n+    }\n+\n+    /**\n+     * Set the certificate this SSLSocket will utilize from an alias in the\n+     * NSS DB.\n+     *\n+     * @see JSSEngine#setCertFromAlias(String)\n+     */\n+    public void setCertFromAlias(String alias) throws IllegalArgumentException {\n+        engine.setCertFromAlias(alias);\n+    }\n+\n+    /**\n+     * Set the certificate this SSLSocket will utilize from a certificate and\n+     * its matching private key.\n+     *\n+     * @see JSSEngine#setKeyMaterials(PK11Cert, PK11PrivKey)\n+     */\n+    public void setKeyMaterials(PK11Cert our_cert, PK11PrivKey our_key) throws IllegalArgumentException {\n+        engine.setKeyMaterials(our_cert, our_key);\n+    }\n+\n+    /**\n+     * Set the KeyManager this SSLSocket will utilize to select a key.\n+     *\n+     * @see JSSEngine#setKeyManager(X509KeyManager)\n+     */\n+    public void setKeyManager(X509KeyManager km) {\n+        engine.setKeyManager(km);\n+    }\n+\n+    /**\n+     * Set the key managers this SSLSocket will utilize to select a key.\n+     *\n+     * @see JSSEngine#setKeyManagers(X509KeyManager[])\n+     */\n+    public void setKeyManagers(X509KeyManager[] xkms) {\n+        engine.setKeyManagers(xkms);\n+    }\n+\n+    /**\n+     * Set the trust manager this SSLSocket will utilize to validate a peer's\n+     * certificate.\n+     *\n+     * @see JSSEngine#setTrustManager(JSSTrustManager)\n+     */\n+    public void setTrustManager(JSSTrustManager tm) {\n+        engine.setTrustManager(tm);\n+    }\n+\n+    /**\n+     * Set the trust managers this SSLSocket will utilize to validate a peer's\n+     * certificate.\n+     *\n+     * @see JSSEngine#setTrustManagers(X509TrustManager[])\n+     */\n+    public void setTrustManagers(X509TrustManager[] xtms) {\n+        engine.setTrustManagers(xtms);\n+    }\n+\n+    /* == stubs over SSLSocket == */\n+\n+    /**\n+     * Begin a handshake, blocking to completion; this will begin a new\n+     * handshake when one has already been issued.\n+     *\n+     * @see JSSEngine#beginHandshake()\n+     * @see javax.net.ssl.SSLSocket#startHandshake()\n+     */\n+    @Override\n+    public void startHandshake() throws IOException {\n+        engine.beginHandshake();\n+\n+        if (channel == null) {\n+            // Only be blocking on the first handshake call.\n+            doHandshake();\n+        }\n+    }\n+\n+    /**\n+     * Add a callback to fire on handshake completion.\n+     *\n+     * @see javax.net.ssl.SSLSocket#addHandshakeCompletedListener(HandshakeCompletedListener)\n+     */\n+    @Override\n+    public void addHandshakeCompletedListener(HandshakeCompletedListener callback) throws IllegalArgumentException {\n+        if (callback == null) {\n+            throw new IllegalArgumentException(\"Expected non-null HandshakeCompletedListener instance.\");\n+        }\n+\n+        handshakeCallbacks.add(callback);\n+    }\n+\n+    /**\n+     * Internal helper to fire callbacks on handshake completion.\n+     */\n+    protected void notifyHandshakeCompletedListeners() {\n+        for (HandshakeCompletedListener callback : handshakeCallbacks) {\n+            HandshakeCompletedEvent event = new HandshakeCompletedEvent(this, getSession());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39"}, "originalPosition": 436}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MjI2NQ==", "bodyText": "According to Socket.getChannel():\n\nA socket will have a channel if, and only if, the channel itself was created via the SocketChannel.open or ServerSocketChannel.accept methods.\n\nand according to SocketChannel.open():\n\nOpens a socket channel. The new channel is created by invoking the openSocketChannel method of the system-wide default SelectorProvider object.\n\nso should we create a JSSSelectorProvider and register it as a default selector provider?", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421152265", "createdAt": "2020-05-06T23:34:46Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE1MzA3Mw==", "bodyText": "It looks like we're supposed to create a JSSSocketChannel first using SocketChannel.open(), then get the socket associated with the channel instead of creating a JSSSocket that has a channel in it.", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421153073", "createdAt": "2020-05-06T23:37:25Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {\n+    /**\n+     * Name of the SSLEngine protocol to use.\n+     */\n+    private String engineProviderProtocol = \"TLS\";\n+\n+    /**\n+     * Name of the SSLEngine provider to use.\n+     */\n+    private String engineProvider = \"Mozilla-JSS\";\n+\n+    /**\n+     * SSLContext to use to create the JSSEngine. Note that JSSSocket will fail\n+     * if the context doesn't create JSSEngine instances.\n+     */\n+    private SSLContext jssContext;\n+\n+    /**\n+     * JSSEngine instance to utilize for SSLEngine operations.\n+     */\n+    private JSSEngine engine;\n+\n+    /**\n+     * All registered handshake callbacks.\n+     */\n+    private ArrayList<HandshakeCompletedListener> handshakeCallbacks = new ArrayList<HandshakeCompletedListener>();\n+\n+    /**\n+     * The socket this JSSSocket was created over; all read/write operations\n+     * go through this socket and all information exposed via Socket members\n+     * go through here.\n+     */\n+    private Socket parent;\n+\n+    /**\n+     * Previously consumed data, if any; utilized for certain SSLSocketFactory\n+     * calls.\n+     */\n+    private InputStream consumedData;\n+\n+    /**\n+     * Underlying SocketChannel for this socket; always exists.\n+     */\n+    private JSSSocketChannel channel;\n+\n+    /**\n+     * Whether or not to automatically close the underlying Socket when this\n+     * socket has been closed; defaults to true.\n+     */\n+    private boolean autoClose = true;\n+\n+    /**\n+     * Start building a new JSSSocket.\n+     *\n+     * We specifically avoid creating any other constructors as we wish to\n+     * consume an existing socket rather than creating a new one.\n+     */\n+    public JSSSocket() {}\n+\n+    /**\n+     * Consume a parent socket, utilizing it for all read/write operations.\n+     *\n+     * This JSSSocket instance will inherit all information about the\n+     * connection from this underlying socket. When utilized in a JSSSocket,\n+     * callers should refrain from interacting with the underlying socket\n+     * directly until the TLS connection is closed. Otherwise, messages may\n+     * get dropped.\n+     */\n+    public void consumeSocket(Socket parent) throws IOException {\n+        if (parent == null) {\n+            String msg = \"Unable to consume and utilize null parent socket!\";\n+            throw new IOException(msg);\n+        }\n+\n+        this.parent = parent;\n+    }\n+\n+    /**\n+     * Get the SSLContext if one exists or create a new instance.\n+     *\n+     * This is used by initSSLEngine(..) to create the underlying SSLEngine.\n+     */\n+    protected SSLContext getSSLContext() throws IOException {\n+        if (jssContext == null) {\n+            try {\n+                jssContext = SSLContext.getInstance(engineProviderProtocol, engineProvider);\n+            } catch (Exception e) {\n+                String msg = \"Unable to create JSSSocket prior to Mozilla-JSS \";\n+                msg += \"initialization! \" + e.getMessage();\n+                throw new IOException(msg, e);\n+            }\n+        }\n+\n+        return jssContext;\n+    }\n+\n+    /**\n+     * Explicitly set the SSLContext utilized by this JSSSocket instance.\n+     *\n+     * This enables JSSServerSocket to copy its SSLContext over to the accepted\n+     * JSSSocket.\n+     */\n+    public void setSSLContext(SSLContext ctx) throws IOException {\n+        jssContext = ctx;\n+    }\n+\n+    /**\n+     * Initialize the underlying SocketChannel.\n+     */\n+    private void init() throws IOException {\n+        if (engine == null) {\n+            initEngine();\n+        }\n+\n+        SocketChannel parentChannel = parent.getChannel();\n+\n+        if (parentChannel == null) {\n+            ReadableByteChannel read = Channels.newChannel(parent.getInputStream());\n+            WritableByteChannel write = Channels.newChannel(parent.getOutputStream());\n+\n+            channel = new JSSSocketChannel(this, parent, read, write, engine);\n+        } else {\n+            channel = new JSSSocketChannel(this, parentChannel, engine);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39"}, "originalPosition": 175}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NTkzMQ==", "bodyText": "The exception message probably can be shortened like \"Unable to unwrap SSL data:\".", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421165931", "createdAt": "2020-05-07T00:19:03Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private ReadableByteChannel consumedChannel;\n+\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    private ByteBuffer empty = ByteBuffer.allocate(0);\n+    private ByteBuffer readBuffer;\n+    private ByteBuffer writeBuffer;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        this.readBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+        this.writeBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        this(sslSocket, parent, parent.socket(), parent, parent, engine);\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        this(sslSocket, null, parentSocket, readChannel, writeChannel, engine);\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) throws IOException {\n+        if (consumed != null && consumed.available() > 0) {\n+            this.consumed = consumed;\n+            consumedChannel = Channels.newChannel(consumed);\n+        }\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        // When there's consumed data left to read, ensure we bound by the\n+        // amount available there before continuing.\n+        if (consumed != null && consumed.available() > 0) {\n+            return Math.min(consumed.available(), suggested);\n+        }\n+\n+        // By setting consumed = null when consumed no longer has bytes\n+        // available, we provide an easy check for which channel to read\n+        // from.\n+        consumed = null;\n+        consumedChannel = null;\n+\n+        // If its a non-blocking underlying socket, then return suggested;\n+        // it'll read as much as currently available.\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining cases (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather\n+            // return false than take too much time in this method.\n+            maxHandshakeAttempts = 10;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    // Write from an empty buffer to wrap.\n+                    write(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    // Read into an empty buffer to unwrap.\n+                    read(empty);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                SSLEngineResult.HandshakeStatus last_state = state;\n+                state = engine.getHandshakeStatus();\n+                handshakeAttempts += 1;\n+\n+                if (state == last_state) {\n+                    try {\n+                        // This sleep is necessary in order to wait for\n+                        // incoming data. If it turns out our\n+                        // NEED_UNWRAP is premature (and we're stuck in\n+                        // a blocking read() call because we issued a\n+                        // non-zero read!), we might cause the remote\n+                        // peer to timeout and send a CLOSE_NOTIFY\n+                        // alert. This wouldn't be good, so sleep\n+                        // instead. Use an exponential backoff in case\n+                        // the remote server is really slow.\n+                        Thread.sleep(handshakeAttempts * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (handshakeAttempts > maxHandshakeAttempts) {\n+                    if (!isBlocking()) {\n+                        // In the event we failed to connect under a\n+                        // non-blocking socket, return false rather than fail\n+                        // here. It could just be that we don't have enough\n+                        // data to continue. In that case, doHandshake() in\n+                        // JSSSocket will re-try until the connection succeeds.\n+                        return false;\n+                    }\n+\n+                    String msg = \"Error attempting to handshake: unable to \";\n+                    msg += \"complete handshake successfully in \";\n+                    msg += maxHandshakeAttempts + \" calls to wrap or unwrap. \";\n+                    msg += \"Connection stalled.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED && state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        sslSocket.notifyHandshakeCompletedListeners();\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (inboundClosed) {\n+            return -1;\n+        }\n+\n+        readBuffer.clear();\n+\n+        int buffer_size = boundRead(readBuffer.capacity());\n+        ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), 0, buffer_size);\n+\n+        long remoteRead = 0;\n+        if (consumed != null) {\n+            remoteRead = consumedChannel.read(src);\n+        } else {\n+            remoteRead = readChannel.read(src);\n+        }\n+\n+        if (remoteRead == 0) {\n+            return 0;\n+        }\n+\n+        src.flip();\n+\n+        long unwrapped = 0;\n+        long decrypted = 0;\n+\n+        try {\n+            do {\n+                SSLEngineResult result = engine.unwrap(src, dsts, offset, length);\n+                if (result.getStatus() != SSLEngineResult.Status.OK && result.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                }\n+\n+                unwrapped += result.bytesConsumed();\n+                decrypted += result.bytesProduced();\n+\n+                if (unwrapped < remoteRead && result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n+                    String msg = \"Error attempting to read from remote peer: \";\n+                    msg += \"calls to unwrap stalled, consuming and producing \";\n+                    msg += \"no data: unwrapped \" + unwrapped + \" bytes of \";\n+                    msg += remoteRead + \" bytes read from remote peer; got a \";\n+                    msg += \"decrypted size of \" + decrypted + \" bytes.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (unwrapped < remoteRead);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to read from remote peer: \";\n+            msg += \"got unexpected exception during unwrap call: \";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39"}, "originalPosition": 288}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2NzIxMA==", "bodyText": "This is a bit long as an exception message. I'm not sure the actual numbers would be useful for debugging. Should we just say something like \"Incomplete SSL unwrap\" instead?", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421167210", "createdAt": "2020-05-07T00:22:52Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private ReadableByteChannel consumedChannel;\n+\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    private ByteBuffer empty = ByteBuffer.allocate(0);\n+    private ByteBuffer readBuffer;\n+    private ByteBuffer writeBuffer;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        this.readBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+        this.writeBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        this(sslSocket, parent, parent.socket(), parent, parent, engine);\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        this(sslSocket, null, parentSocket, readChannel, writeChannel, engine);\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) throws IOException {\n+        if (consumed != null && consumed.available() > 0) {\n+            this.consumed = consumed;\n+            consumedChannel = Channels.newChannel(consumed);\n+        }\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        // When there's consumed data left to read, ensure we bound by the\n+        // amount available there before continuing.\n+        if (consumed != null && consumed.available() > 0) {\n+            return Math.min(consumed.available(), suggested);\n+        }\n+\n+        // By setting consumed = null when consumed no longer has bytes\n+        // available, we provide an easy check for which channel to read\n+        // from.\n+        consumed = null;\n+        consumedChannel = null;\n+\n+        // If its a non-blocking underlying socket, then return suggested;\n+        // it'll read as much as currently available.\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining cases (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather\n+            // return false than take too much time in this method.\n+            maxHandshakeAttempts = 10;\n+        }\n+\n+        // Attempt to handshake with the remote peer.\n+        try {\n+            do {\n+                if (state == SSLEngineResult.HandshakeStatus.NEED_WRAP) {\n+                    // Write from an empty buffer to wrap.\n+                    write(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n+                    // Read into an empty buffer to unwrap.\n+                    read(empty);\n+                } else {\n+                    String msg = \"Error attempting to handshake: unknown \";\n+                    msg += \"handshake status code `\" + state + \"`\";\n+                    throw new IOException(msg);\n+                }\n+\n+                SSLEngineResult.HandshakeStatus last_state = state;\n+                state = engine.getHandshakeStatus();\n+                handshakeAttempts += 1;\n+\n+                if (state == last_state) {\n+                    try {\n+                        // This sleep is necessary in order to wait for\n+                        // incoming data. If it turns out our\n+                        // NEED_UNWRAP is premature (and we're stuck in\n+                        // a blocking read() call because we issued a\n+                        // non-zero read!), we might cause the remote\n+                        // peer to timeout and send a CLOSE_NOTIFY\n+                        // alert. This wouldn't be good, so sleep\n+                        // instead. Use an exponential backoff in case\n+                        // the remote server is really slow.\n+                        Thread.sleep(handshakeAttempts * 10);\n+                    } catch (Exception e) {}\n+                }\n+\n+                if (handshakeAttempts > maxHandshakeAttempts) {\n+                    if (!isBlocking()) {\n+                        // In the event we failed to connect under a\n+                        // non-blocking socket, return false rather than fail\n+                        // here. It could just be that we don't have enough\n+                        // data to continue. In that case, doHandshake() in\n+                        // JSSSocket will re-try until the connection succeeds.\n+                        return false;\n+                    }\n+\n+                    String msg = \"Error attempting to handshake: unable to \";\n+                    msg += \"complete handshake successfully in \";\n+                    msg += maxHandshakeAttempts + \" calls to wrap or unwrap. \";\n+                    msg += \"Connection stalled.\";\n+                    throw new IOException(msg);\n+                }\n+            } while (state != SSLEngineResult.HandshakeStatus.FINISHED && state != SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING);\n+        } catch (SSLException ssle) {\n+            String msg = \"Error attempting to handshake with remote peer: \";\n+            msg += \"got unexpected exception: \" + ssle.getMessage();\n+            throw new IOException(msg, ssle);\n+        }\n+\n+        sslSocket.notifyHandshakeCompletedListeners();\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Compute the total size of a list of buffers from the specified offest\n+     * and length.\n+     */\n+    private static long computeSize(ByteBuffer[] buffers, int offset, int length) throws IOException {\n+        long result = 0;\n+\n+        if (buffers == null || buffers.length == 0) {\n+            return result;\n+        }\n+\n+        for (int rel_index = 0; rel_index < length; rel_index++) {\n+            int index = offset + rel_index;\n+            if (index >= buffers.length) {\n+                String msg = \"Offset (\" + offset + \" or length (\" + length;\n+                msg += \") exceeds contract based on number of buffers \";\n+                msg += \"given (\" + buffers.length + \")\";\n+                throw new IOException(msg);\n+            }\n+\n+            if (buffers[index] != null) {\n+                result += buffers[index].remaining();\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    public int read(ByteBuffer dst) throws IOException {\n+        return (int) read(new ByteBuffer[] { dst });\n+    }\n+\n+    public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws IOException {\n+        if (inboundClosed) {\n+            return -1;\n+        }\n+\n+        readBuffer.clear();\n+\n+        int buffer_size = boundRead(readBuffer.capacity());\n+        ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), 0, buffer_size);\n+\n+        long remoteRead = 0;\n+        if (consumed != null) {\n+            remoteRead = consumedChannel.read(src);\n+        } else {\n+            remoteRead = readChannel.read(src);\n+        }\n+\n+        if (remoteRead == 0) {\n+            return 0;\n+        }\n+\n+        src.flip();\n+\n+        long unwrapped = 0;\n+        long decrypted = 0;\n+\n+        try {\n+            do {\n+                SSLEngineResult result = engine.unwrap(src, dsts, offset, length);\n+                if (result.getStatus() != SSLEngineResult.Status.OK && result.getStatus() != SSLEngineResult.Status.CLOSED) {\n+                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                }\n+\n+                unwrapped += result.bytesConsumed();\n+                decrypted += result.bytesProduced();\n+\n+                if (unwrapped < remoteRead && result.bytesConsumed() == 0 && result.bytesProduced() == 0) {\n+                    String msg = \"Error attempting to read from remote peer: \";\n+                    msg += \"calls to unwrap stalled, consuming and producing \";\n+                    msg += \"no data: unwrapped \" + unwrapped + \" bytes of \";\n+                    msg += remoteRead + \" bytes read from remote peer; got a \";\n+                    msg += \"decrypted size of \" + decrypted + \" bytes.\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE2ODI3MQ==", "bodyText": "In the future we probably could change org.mozilla.jss.ssl.SSLSocket to extend JSSSocket, and eventually merge it into JSSSocket.", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421168271", "createdAt": "2020-05-07T00:26:17Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -0,0 +1,869 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+import javax.net.ssl.*;\n+\n+import org.mozilla.jss.pkcs11.PK11Cert;\n+import org.mozilla.jss.pkcs11.PK11PrivKey;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSTrustManager;\n+\n+/**\n+ * SSL-enabled socket following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * Most users will want to use the JSSSocketFactory provided by the Java\n+ * Provider interface instead of using this class directly.\n+ *\n+ * This SSLSocket implementation is a wrapped implementation. In particular, we\n+ * need to consume an existing Socket (via the consumeSocket(...) call) which\n+ * we actually send data over. When called from a socket factory, this\n+ * additional socket will be automatically created for the caller. This\n+ * is necessary because SSLSocketFactory includes a mode which wraps an\n+ * existing socket.\n+ *\n+ * All JSSSocket instances have a underlying SocketChannel, of type\n+ * JSSSocketChannel. Notably lacking is a javax.net.ssl.SSLSocketChannel type,\n+ * so JSSSocketChannel includes no additional SSL-specific options. However,\n+ * the core of the SSLEngine wrapping logic exists there.\n+ *\n+ * In order to interoperate with JSSEngine, many of the adjacent methods have\n+ * been included in this class as well.\n+ *\n+ * This socket can either be a client or a server, depending on how it was\n+ * created. For more information, see the javax.net.ssl.SSLSocket\n+ * documentation.\n+ *\n+ * To construct a (useful) new instance, the following calls must be made:\n+ *\n+ * - new JSSSocket();\n+ * - consumeSocket(inst);\n+ * - initSSLEngine(...);\n+ * - setKeyManagers(...);\n+ * - setTrustManagers(...);\n+ *\n+ * Optionally, setSSLContext(...) could be called to provide the SSLContext\n+ * from which the SSLEngine should be constructed. This should be called prior\n+ * to initSSLEngine(...) being called.\n+ */\n+public class JSSSocket extends SSLSocket {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTE3MDE0MA==", "bodyText": "Is this phrase correct?", "url": "https://github.com/dogtagpki/jss/pull/532#discussion_r421170140", "createdAt": "2020-05-07T00:32:09Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -0,0 +1,495 @@\n+package org.mozilla.jss.ssl.javax;\n+\n+import java.io.*;\n+import java.net.*;\n+import java.nio.ByteBuffer;\n+import java.nio.channels.*;\n+import java.security.*;\n+import java.util.*;\n+\n+import javax.net.ssl.*;\n+\n+/**\n+ * SSL-enabled SocketChannel following the javax.net.ssl.SSLSocket interface.\n+ *\n+ * This class should never be constructed directly and instead only accessed\n+ * once a Socket is wrapped in a JSSSocket.\n+ *\n+ * This class contains all low-level interactions with the underlying\n+ * SSLEngine and reading/writing to/from the underlying Socket.\n+ */\n+public class JSSSocketChannel extends SocketChannel {\n+    private JSSSocket sslSocket;\n+    private SocketChannel parent;\n+    private Socket parentSocket;\n+    private ReadableByteChannel readChannel;\n+    private WritableByteChannel writeChannel;\n+    private JSSEngine engine;\n+\n+    private InputStream consumed;\n+    private ReadableByteChannel consumedChannel;\n+\n+    private boolean autoClose = true;\n+\n+    private boolean inboundClosed = false;\n+    private boolean outboundClosed = false;\n+\n+    private ByteBuffer empty = ByteBuffer.allocate(0);\n+    private ByteBuffer readBuffer;\n+    private ByteBuffer writeBuffer;\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        super(null);\n+\n+        this.sslSocket = sslSocket;\n+        this.parent = parent;\n+        this.parentSocket = parentSocket;\n+        this.readChannel = readChannel;\n+        this.writeChannel = writeChannel;\n+        this.engine = engine;\n+\n+        this.readBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+        this.writeBuffer = ByteBuffer.allocate(engine.getSession().getApplicationBufferSize());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, SocketChannel parent, JSSEngine engine) throws IOException {\n+        this(sslSocket, parent, parent.socket(), parent, parent, engine);\n+\n+        // Copy the blocking mode from the parent channel.\n+        configureBlocking(parent.isBlocking());\n+    }\n+\n+    public JSSSocketChannel(JSSSocket sslSocket, Socket parentSocket, ReadableByteChannel readChannel, WritableByteChannel writeChannel, JSSEngine engine) throws IOException {\n+        this(sslSocket, null, parentSocket, readChannel, writeChannel, engine);\n+\n+        // When there is no parent channel, this channel must be in\n+        // blocking mode.\n+        configureBlocking(true);\n+    }\n+\n+    /**\n+     * Give data already consumed by a call to the underlying socket's read\n+     * method to this Socket, allowing it to be read by the SSLEngine.\n+     */\n+    public void setConsumedData(InputStream consumed) throws IOException {\n+        if (consumed != null && consumed.available() > 0) {\n+            this.consumed = consumed;\n+            consumedChannel = Channels.newChannel(consumed);\n+        }\n+    }\n+\n+    /**\n+     * Set whether or not to close the underlying Socket when the SSLSocket\n+     * or this channel is closed.\n+     */\n+    public void setAutoClose(boolean on) {\n+        autoClose = on;\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private int boundRead(int suggested) throws IOException {\n+        return (int) boundRead((long) suggested);\n+    }\n+\n+    /**\n+     * Internal helper to bound the size of a blocking read to the maximum\n+     * data available.\n+     */\n+    private long boundRead(long suggested) throws IOException {\n+        // When there's consumed data left to read, ensure we bound by the\n+        // amount available there before continuing.\n+        if (consumed != null && consumed.available() > 0) {\n+            return Math.min(consumed.available(), suggested);\n+        }\n+\n+        // By setting consumed = null when consumed no longer has bytes\n+        // available, we provide an easy check for which channel to read\n+        // from.\n+        consumed = null;\n+        consumedChannel = null;\n+\n+        // If its a non-blocking underlying socket, then return suggested;\n+        // it'll read as much as currently available.\n+        if (!isBlocking()) {\n+            return suggested;\n+        }\n+\n+        // In both remaining cases (no channel or channel is blocking), bound\n+        // the read above by the available data in the socket's input stream.\n+        int available = parentSocket.getInputStream().available();\n+        return Math.min(suggested, available);\n+    }\n+\n+    public boolean finishConnect() throws IOException {\n+        if (parent != null) {\n+            if (!parent.finishConnect()) {\n+                return false;\n+            }\n+        }\n+\n+        SSLEngineResult.HandshakeStatus state = engine.getHandshakeStatus();\n+        if (state == SSLEngineResult.HandshakeStatus.NOT_HANDSHAKING) {\n+            return true;\n+        }\n+\n+        int handshakeAttempts = 0;\n+        int maxHandshakeAttempts = 100;\n+\n+        if (!isBlocking()) {\n+            // When we're a non-blocking socket/channel, we'd farther rather", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe387f6c7febebfa788892a8852666f024f42f74", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/fe387f6c7febebfa788892a8852666f024f42f74", "committedDate": "2020-05-07T17:34:28Z", "message": "Provide JSSSocket for JSSContextSpi\n\nJSSSocket provides a way of utilizing JSSEngine over an existing Socket,\nthus utilizing NSS to provide TLS capabilities for this socket. Unlike\nthe existing org.mozilla.jss.ssl.SSLSocket, JSS socket complies with\nthe standard javax.net.ssl.SSLSocket interface, making it compatible\nwith existing applications and libraries expecting the SSLSocketFactory\nfrom SSLContext to provide SSLSocket instances. This is necessary as\nmany applications don't handle when SSLContext returns null from the\ngetSocketFactory() call.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "defd123758ba3b850d09b5bf095f70c586f48a39", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/defd123758ba3b850d09b5bf095f70c586f48a39", "committedDate": "2020-05-06T18:27:37Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "7d1e10e85abcc12558975f008f7e54caf4780ecf", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/7d1e10e85abcc12558975f008f7e54caf4780ecf", "committedDate": "2020-05-07T17:34:28Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c662aae47a82f4e54ce322cfff24903f436727a0", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/c662aae47a82f4e54ce322cfff24903f436727a0", "committedDate": "2020-05-07T18:00:56Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d1e10e85abcc12558975f008f7e54caf4780ecf", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/7d1e10e85abcc12558975f008f7e54caf4780ecf", "committedDate": "2020-05-07T17:34:28Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "c662aae47a82f4e54ce322cfff24903f436727a0", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/c662aae47a82f4e54ce322cfff24903f436727a0", "committedDate": "2020-05-07T18:00:56Z", "message": "Introduce JSSSocketChannel for JSSSocket\n\nUnder java.net.Socket semantics, non-blocking sockets have a\njava.nio.SocketChannel member exposed via getChannel(); the older\norg.mozilla.jss.ssl.SSLSocket implementation lacks this as it was\nimplemented over NSPR-backed sockets. However, java.nio.SocketChannel\nsemantics makes it easier to implement the core interactions with our\nJSSEngine. We chose to always expose a JSSSocketChannel instance, even\nwhen the underlying socket isn't explicitly configured as non-blocking.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3Nzk0MTc1", "url": "https://github.com/dogtagpki/jss/pull/532#pullrequestreview-407794175", "createdAt": "2020-05-07T20:01:30Z", "commit": {"oid": "c662aae47a82f4e54ce322cfff24903f436727a0"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1496, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}