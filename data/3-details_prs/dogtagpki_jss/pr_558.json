{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIwOTc0Njk1", "number": 558, "title": "Add SSLSocket benchmark", "bodyText": "This benchmark supports three providers:\n\norg.mozilla.jss.ssl.SSLSocket, named JSS.legacy\norg.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\nthe JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>\n\nThis is the results from siege [0] ran via:\n $ siege -c 100 -b -t 5m https://localhost:8443\nwith the benchmarker set to send a faked 1024-byte message:\n $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024\nThe server certificate is 4096-bits. The selection of cipher suite and\nprotocol is left at their defaults. This is on a Lenovo Thinkpad P50\nwith a Intel(R) Core(TM) i7-6820HQ CPU @ 2.70GHz and 32GB of RAM. Each\nrequest gets spun off and handled by a new thread.\nUsing the legacy org.mozilla.jss.ssl.SSLSocket (old NSS-based socket)\nmemory stays stable and under ~1-2% of total memory:\n{        \"transactions\":                       98588,\n        \"availability\":                        100.00,\n        \"elapsed_time\":                        299.43,\n        \"data_transferred\":                    96.28,\n        \"response_time\":                       0.30,\n        \"transaction_rate\":                    329.25,\n        \"throughput\":                          0.32,\n        \"concurrency\":                         99.80,\n        \"successful_transactions\":             98588,\n        \"failed_transactions\":                 0,\n        \"longest_transaction\":                 29.94,\n        \"shortest_transaction\":                0.04\n}\nUsing javax.net.ssl.SSLSocket provided by SunJSSE (but with JSS crypto\nand potentially random) and stays under 1-2% of total memory:\n{        \"transactions\":                       2417,\n        \"availability\":                        100.00,\n        \"elapsed_time\":                        299.36,\n        \"data_transferred\":                    2.36,\n        \"response_time\":                       12.12,\n        \"transaction_rate\":                    8.07,\n        \"throughput\":                          0.01,\n        \"concurrency\":                         97.82,\n        \"successful_transactions\":             2417,\n        \"failed_transactions\":                 0,\n        \"longest_transaction\":                 21.27,\n        \"shortest_transaction\":                1.63\n}\nNote that the above option was removed from the benchmark as it was significantly slower\nUsing javax.net.ssl.SSLSocket provided by SunJSSE (without JSS crypto,\nvia exporting to PKCS12 file) and stays under 8% of total memory:\n{        \"transactions\":                       93168,\n        \"availability\":                        100.00,\n        \"elapsed_time\":                        299.92,\n        \"data_transferred\":                    90.98,\n        \"response_time\":                       0.32,\n        \"transaction_rate\":                    310.64,\n        \"throughput\":                          0.30,\n        \"concurrency\":                         99.51,\n        \"successful_transactions\":             93168,\n        \"failed_transactions\":                 2,\n        \"longest_transaction\":                 15.81,\n        \"shortest_transaction\":                0.02\n}\nAnd javax.net.ssl.SSLSocket provided by Mozilla-JSS, backed by our slow\nJSSEngine (proposed for 8.3) -- memory grows to ~35% of total, which suggests\nthere's also at least one memory leak still...\n{        \"transactions\":                       87768,\n        \"availability\":                        100.00,\n        \"elapsed_time\":                        299.08,\n        \"data_transferred\":                    85.71,\n        \"response_time\":                       0.34,\n        \"transaction_rate\":                    293.46,\n        \"throughput\":                          0.29,\n        \"concurrency\":                         99.60,\n        \"successful_transactions\":             87768,\n        \"failed_transactions\":                 1,\n        \"longest_transaction\":                 16.05,\n        \"shortest_transaction\":                0.08\n}\nPrior to #553 (commit 1bd646a), the performance of Mozilla-JSS's SSLSocket was bad:\n{\t\"transactions\":\t\t\t        1551,\n\t\"availability\":\t\t\t       85.98,\n\t\"elapsed_time\":\t\t\t      299.53,\n\t\"data_transferred\":\t\t        1.51,\n\t\"response_time\":\t\t       13.02,\n\t\"transaction_rate\":\t\t        5.18,\n\t\"throughput\":\t\t\t        0.01,\n\t\"concurrency\":\t\t\t       67.42,\n\t\"successful_transactions\":\t        1551,\n\t\"failed_transactions\":\t\t         253,\n\t\"longest_transaction\":\t\t       78.01,\n\t\"shortest_transaction\":\t\t        0.50\n}\nAnd for comparison, nginx-1.18.0-1.fc32.x86_64, using the same cert from above (admittedly, it uses OpenSSL) and same siege output:\n{        \"transactions\":                       214725,\n        \"availability\":                        100.00,\n        \"elapsed_time\":                        299.05,\n        \"data_transferred\":                    209.90,\n        \"response_time\":                       0.14,\n        \"transaction_rate\":                    718.02,\n        \"throughput\":                          0.70,\n        \"concurrency\":                         99.40,\n        \"successful_transactions\":             214725,\n        \"failed_transactions\":                 0,\n        \"longest_transaction\":                 0.37,\n        \"shortest_transaction\":                0.07\n}", "createdAt": "2020-05-20T19:28:50Z", "url": "https://github.com/dogtagpki/jss/pull/558", "merged": true, "mergeCommit": {"oid": "5b5b1a64711c27b73e3c8fdcae8157c7d7666285"}, "closed": true, "closedAt": "2020-05-22T16:10:35Z", "author": {"login": "cipherboy"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcjOzregFqTQxNTY2Nzk3MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcj0E4zABqjMzNjUxOTUzMDc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE1NjY3OTcw", "url": "https://github.com/dogtagpki/jss/pull/558#pullrequestreview-415667970", "createdAt": "2020-05-20T19:55:56Z", "commit": {"oid": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQxOTo1NTo1NlrOGYbnlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMDowNjo0N1rOGYb95g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MTUxMQ==", "bodyText": "This is probably fine to compare blocking sockets (i.e. the legacy JSS socket, the new one, JSSE socket), but if we want to compare against NGINX we might want to use the non-blocking socket (with SocketChannel) with just 1 thread.", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428271511", "createdAt": "2020-05-20T19:55:56Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/tests/BenchmarkSSLSocket.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.mozilla.jss.tests;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.mozilla.jss.CryptoManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n+\n+/**\n+ * Utility for benchmarking the performance of SSLSocket implementations.\n+ *\n+ * This benchmark is a server-side SSLSocket benchmark for use with clients\n+ * which measure performance. This benchmark does not, itself, make any\n+ * performance measurements. For instance:\n+ * <pre>\n+ * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n+ * $ siege -c 100 -b -t 5m https://localhost:8443\n+ * $ kill %1\n+ * </pre>\n+ *\n+ * There are three supported SSLSocket implementations:\n+ *\n+ *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n+ *     name: JSS.legacy\n+ *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n+ *     name: JSS.SSLSocket\n+ *  3. sun.security's SSLSocketImpl from the current JDK.\n+ *     name: SunJSSE.SSLSocket\n+ *\n+ * It is suggested to disable all logging (for instance, via:\n+ * truncate -s 0 tools/logging.properties) in order have reproducible\n+ * results.\n+ *\n+ * This class takes four arguments when invoked:\n+ *\n+ *  1. The name of the implementation to benchmark, see above.\n+ *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n+ *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n+ *     implementations will utilize a nickname instead.\n+ *  3. The port to listen on.\n+ *  4. The size of the HTTP message to fake.\n+ *\n+ * Note that, when utilizing a JSS provider, JSS must be loaded via a\n+ * java.security. When utilizing SunJSSE, for best results, do not load\n+ * JSS via java.security.\n+ *\n+ * It is suggested to use run_test.sh from the build/ directory for this.\n+ */\n+public class BenchmarkSSLSocket {\n+    public String type;\n+    public int port;\n+    public int size;\n+    public String nickname;\n+\n+    public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n+    public String message;\n+\n+    public BenchmarkSSLSocket(String[] args) throws Exception {\n+        type = args[0];\n+        nickname = args[1];\n+        port = Integer.parseInt(args[2]);\n+        size = Integer.parseInt(args[3]);\n+\n+        headers = headers + \"Content-Length: \" + size + \"\\r\\n\";\n+\n+        StringBuilder sb = new StringBuilder(size);\n+        for (int i = 0; i < size; i++) {\n+            sb.append(\"a\");\n+        }\n+\n+        message = headers + \"\\r\\n\" + sb.toString();\n+    }\n+\n+    public ServerSocket getServerSocket() throws Exception {\n+        switch (type) {\n+            case \"JSS.legacy\": {\n+                org.mozilla.jss.ssl.SSLServerSocket sock = new org.mozilla.jss.ssl.SSLServerSocket(port);\n+                sock.setSoTimeout(0);\n+                org.mozilla.jss.ssl.SSLServerSocket.configServerSessionIDCache(0, 43200, 43200, null);\n+\n+                sock.setReuseAddress(true);\n+                sock.requestClientAuth(false);\n+                sock.requireClientAuth(org.mozilla.jss.ssl.SSLSocket.SSL_REQUIRE_NEVER);\n+                sock.setUseClientMode(false);\n+                sock.setServerCertNickname(nickname);\n+\n+                return sock;\n+            }\n+            case \"JSS.SSLSocket\": {\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NssX509\");\n+\n+                SSLContext ctx = SSLContext.getInstance(\"TLS\", \"Mozilla-JSS\");\n+                ctx.init(\n+                    kmf.getKeyManagers(),\n+                    new TrustManager[] { new JSSNativeTrustManager() },\n+                    null\n+                );\n+\n+                SSLServerSocketFactory factory = ctx.getServerSocketFactory();\n+                org.mozilla.jss.ssl.javax.JSSServerSocket sock = (org.mozilla.jss.ssl.javax.JSSServerSocket) factory.createServerSocket(port);\n+\n+                sock.setReuseAddress(true);\n+                sock.setWantClientAuth(false);\n+                sock.setNeedClientAuth(false);\n+                sock.setUseClientMode(false);\n+                sock.setCertFromAlias(nickname);\n+\n+                return sock;\n+            }\n+            case \"SunJSSE.SSLSocket\": {\n+                FileInputStream fis = new FileInputStream(nickname);\n+                KeyStore store = KeyStore.getInstance(\"PKCS12\");\n+                store.load(fis, \"m1oZilla\".toCharArray());\n+\n+                // Courtesy of https://stackoverflow.com/questions/537040/how-to-connect-to-a-secure-website-using-ssl-in-java-with-a-pkcs12-file\n+                KeyStore jks = KeyStore.getInstance(\"JKS\");\n+                jks.load(null);\n+\n+                KeyStore ks = store;\n+                for (java.util.Enumeration<String>t=ks.aliases();t.hasMoreElements();)\n+                {\n+                    String alias = t.nextElement();\n+                    System.out.println(\"@:\" + alias);\n+                    if (ks.isKeyEntry(alias)){\n+                        java.security.cert.Certificate[] a = ks.getCertificateChain(alias);\n+                        for (int i=0;i<a.length;i++)\n+                        {\n+                            java.security.cert.X509Certificate x509 = (java.security.cert.X509Certificate)a[i];\n+                            System.out.println(x509.getSubjectDN().toString());\n+                            if (i>0)\n+                                jks.setCertificateEntry(x509.getSubjectDN().toString(), x509);\n+                            System.out.println(ks.getCertificateAlias(x509));\n+                            System.out.println(\"ok\");\n+                        }\n+                    }\n+                }\n+\n+\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"SunX509\");\n+                kmf.init(store, \"m1oZilla\".toCharArray());\n+                TrustManagerFactory tmf = TrustManagerFactory.getInstance(\"SunX509\");\n+                tmf.init(store);\n+\n+                SSLContext ctx = SSLContext.getInstance(\"TLS\", \"SunJSSE\");\n+                ctx.init(\n+                    kmf.getKeyManagers(),\n+                    tmf.getTrustManagers(),\n+                    null\n+                );\n+\n+                SSLServerSocketFactory factory = ctx.getServerSocketFactory();\n+                javax.net.ssl.SSLServerSocket sock = (javax.net.ssl.SSLServerSocket) factory.createServerSocket(port);\n+\n+                sock.setReuseAddress(true);\n+                sock.setWantClientAuth(false);\n+                sock.setNeedClientAuth(false);\n+                sock.setUseClientMode(false);\n+\n+                return sock;\n+            }\n+            default:\n+                throw new RuntimeException(\"Unknown socket type: `\" + type + \"` -- expected one of `JSS.SSLSocket`, `JSS.legacy`, or `SunJSSE.SSLSocket`.\");\n+        }\n+    }\n+\n+    class PeerTask implements Runnable {\n+        Socket peer;\n+        byte[] message;\n+\n+        public PeerTask(Socket peer, String message) {\n+            this.peer = peer;\n+            this.message = message.getBytes();\n+        }\n+\n+        public void run() {\n+            try {\n+                try {\n+                    // First, force a handshake\n+                    if (peer instanceof org.mozilla.jss.ssl.SSLSocket) {\n+                        org.mozilla.jss.ssl.SSLSocket sock = (org.mozilla.jss.ssl.SSLSocket) peer;\n+                        sock.setUseClientMode(false);\n+                        sock.forceHandshake();\n+                    } else if (peer instanceof javax.net.ssl.SSLSocket) {\n+                        javax.net.ssl.SSLSocket sock = (javax.net.ssl.SSLSocket) peer;\n+                        sock.setUseClientMode(false);\n+                        sock.startHandshake();\n+                    }\n+\n+                    // Consume all input data.\n+                    InputStream is = peer.getInputStream();\n+                    byte[] in_data = new byte[is.available()];\n+                    is.read(in_data);\n+\n+                    // Send our message back.\n+                    OutputStream os = peer.getOutputStream();\n+                    os.write(message);\n+                } finally {\n+                    peer.close();\n+                }\n+            } catch (Exception e) {\n+                throw new RuntimeException(e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    public void run() throws Exception {\n+        try (\n+            ServerSocket server_socket = getServerSocket();\n+        ) {\n+            while (true) {\n+                Socket peer_socket = server_socket.accept();\n+                Runnable task = new PeerTask(peer_socket, message);\n+                Thread thread = new Thread(task);\n+                thread.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3MjgwNg==", "bodyText": "I think a class constructor should normally take named params, e.g.:\npublic BenchmarkSSLSocket(String type, String nickname, int port, int size) throws Exception {\n\nCLI argument parsing should be done in main().", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428272806", "createdAt": "2020-05-20T19:58:25Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/tests/BenchmarkSSLSocket.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.mozilla.jss.tests;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.mozilla.jss.CryptoManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n+\n+/**\n+ * Utility for benchmarking the performance of SSLSocket implementations.\n+ *\n+ * This benchmark is a server-side SSLSocket benchmark for use with clients\n+ * which measure performance. This benchmark does not, itself, make any\n+ * performance measurements. For instance:\n+ * <pre>\n+ * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n+ * $ siege -c 100 -b -t 5m https://localhost:8443\n+ * $ kill %1\n+ * </pre>\n+ *\n+ * There are three supported SSLSocket implementations:\n+ *\n+ *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n+ *     name: JSS.legacy\n+ *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n+ *     name: JSS.SSLSocket\n+ *  3. sun.security's SSLSocketImpl from the current JDK.\n+ *     name: SunJSSE.SSLSocket\n+ *\n+ * It is suggested to disable all logging (for instance, via:\n+ * truncate -s 0 tools/logging.properties) in order have reproducible\n+ * results.\n+ *\n+ * This class takes four arguments when invoked:\n+ *\n+ *  1. The name of the implementation to benchmark, see above.\n+ *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n+ *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n+ *     implementations will utilize a nickname instead.\n+ *  3. The port to listen on.\n+ *  4. The size of the HTTP message to fake.\n+ *\n+ * Note that, when utilizing a JSS provider, JSS must be loaded via a\n+ * java.security. When utilizing SunJSSE, for best results, do not load\n+ * JSS via java.security.\n+ *\n+ * It is suggested to use run_test.sh from the build/ directory for this.\n+ */\n+public class BenchmarkSSLSocket {\n+    public String type;\n+    public int port;\n+    public int size;\n+    public String nickname;\n+\n+    public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n+    public String message;\n+\n+    public BenchmarkSSLSocket(String[] args) throws Exception {\n+        type = args[0];\n+        nickname = args[1];\n+        port = Integer.parseInt(args[2]);\n+        size = Integer.parseInt(args[3]);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NjQ3Mw==", "bodyText": "It might be better to put the above doc in a Markdown page for better visibility.", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428276473", "createdAt": "2020-05-20T20:05:26Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/tests/BenchmarkSSLSocket.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.mozilla.jss.tests;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.mozilla.jss.CryptoManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n+\n+/**\n+ * Utility for benchmarking the performance of SSLSocket implementations.\n+ *\n+ * This benchmark is a server-side SSLSocket benchmark for use with clients\n+ * which measure performance. This benchmark does not, itself, make any\n+ * performance measurements. For instance:\n+ * <pre>\n+ * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n+ * $ siege -c 100 -b -t 5m https://localhost:8443\n+ * $ kill %1\n+ * </pre>\n+ *\n+ * There are three supported SSLSocket implementations:\n+ *\n+ *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n+ *     name: JSS.legacy\n+ *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n+ *     name: JSS.SSLSocket\n+ *  3. sun.security's SSLSocketImpl from the current JDK.\n+ *     name: SunJSSE.SSLSocket\n+ *\n+ * It is suggested to disable all logging (for instance, via:\n+ * truncate -s 0 tools/logging.properties) in order have reproducible\n+ * results.\n+ *\n+ * This class takes four arguments when invoked:\n+ *\n+ *  1. The name of the implementation to benchmark, see above.\n+ *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n+ *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n+ *     implementations will utilize a nickname instead.\n+ *  3. The port to listen on.\n+ *  4. The size of the HTTP message to fake.\n+ *\n+ * Note that, when utilizing a JSS provider, JSS must be loaded via a\n+ * java.security. When utilizing SunJSSE, for best results, do not load\n+ * JSS via java.security.\n+ *\n+ * It is suggested to use run_test.sh from the build/ directory for this.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODI3NzIyMg==", "bodyText": "The PKCS #12 password is hardcoded, so we should mention that in the doc as well, or provide a param to specify the password.", "url": "https://github.com/dogtagpki/jss/pull/558#discussion_r428277222", "createdAt": "2020-05-20T20:06:47Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/tests/BenchmarkSSLSocket.java", "diffHunk": "@@ -0,0 +1,245 @@\n+package org.mozilla.jss.tests;\n+\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.security.KeyStore;\n+import java.security.SecureRandom;\n+\n+import javax.net.ssl.KeyManager;\n+import javax.net.ssl.KeyManagerFactory;\n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.SSLServerSocketFactory;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.TrustManagerFactory;\n+import javax.net.ssl.X509ExtendedKeyManager;\n+\n+import org.mozilla.jss.CryptoManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSKeyManager;\n+import org.mozilla.jss.provider.javax.crypto.JSSNativeTrustManager;\n+\n+/**\n+ * Utility for benchmarking the performance of SSLSocket implementations.\n+ *\n+ * This benchmark is a server-side SSLSocket benchmark for use with clients\n+ * which measure performance. This benchmark does not, itself, make any\n+ * performance measurements. For instance:\n+ * <pre>\n+ * $ ./run_test.sh org.mozilla.jss.tests.BenchmarkSSLSocket JSS.legacy Server_RSA 8443 1024 &\n+ * $ siege -c 100 -b -t 5m https://localhost:8443\n+ * $ kill %1\n+ * </pre>\n+ *\n+ * There are three supported SSLSocket implementations:\n+ *\n+ *  1. org.mozilla.jss.ssl.SSLSocket, JSS's legacy implementation\n+ *     name: JSS.legacy\n+ *  2. org.mozilla.jss.ssl.javax.JSSSocket, JSS's new javax implementation\n+ *     name: JSS.SSLSocket\n+ *  3. sun.security's SSLSocketImpl from the current JDK.\n+ *     name: SunJSSE.SSLSocket\n+ *\n+ * It is suggested to disable all logging (for instance, via:\n+ * truncate -s 0 tools/logging.properties) in order have reproducible\n+ * results.\n+ *\n+ * This class takes four arguments when invoked:\n+ *\n+ *  1. The name of the implementation to benchmark, see above.\n+ *  2. An alias of the certificate or path to a PKCS#12 file. Only SunJSSE\n+ *     accepts a PKCS#12 as path -- the two JSS based SSLSocket\n+ *     implementations will utilize a nickname instead.\n+ *  3. The port to listen on.\n+ *  4. The size of the HTTP message to fake.\n+ *\n+ * Note that, when utilizing a JSS provider, JSS must be loaded via a\n+ * java.security. When utilizing SunJSSE, for best results, do not load\n+ * JSS via java.security.\n+ *\n+ * It is suggested to use run_test.sh from the build/ directory for this.\n+ */\n+public class BenchmarkSSLSocket {\n+    public String type;\n+    public int port;\n+    public int size;\n+    public String nickname;\n+\n+    public String headers = \"HTTP/1.1 200 OK\\r\\nConnection: Closed\\r\\n\";\n+    public String message;\n+\n+    public BenchmarkSSLSocket(String[] args) throws Exception {\n+        type = args[0];\n+        nickname = args[1];\n+        port = Integer.parseInt(args[2]);\n+        size = Integer.parseInt(args[3]);\n+\n+        headers = headers + \"Content-Length: \" + size + \"\\r\\n\";\n+\n+        StringBuilder sb = new StringBuilder(size);\n+        for (int i = 0; i < size; i++) {\n+            sb.append(\"a\");\n+        }\n+\n+        message = headers + \"\\r\\n\" + sb.toString();\n+    }\n+\n+    public ServerSocket getServerSocket() throws Exception {\n+        switch (type) {\n+            case \"JSS.legacy\": {\n+                org.mozilla.jss.ssl.SSLServerSocket sock = new org.mozilla.jss.ssl.SSLServerSocket(port);\n+                sock.setSoTimeout(0);\n+                org.mozilla.jss.ssl.SSLServerSocket.configServerSessionIDCache(0, 43200, 43200, null);\n+\n+                sock.setReuseAddress(true);\n+                sock.requestClientAuth(false);\n+                sock.requireClientAuth(org.mozilla.jss.ssl.SSLSocket.SSL_REQUIRE_NEVER);\n+                sock.setUseClientMode(false);\n+                sock.setServerCertNickname(nickname);\n+\n+                return sock;\n+            }\n+            case \"JSS.SSLSocket\": {\n+                KeyManagerFactory kmf = KeyManagerFactory.getInstance(\"NssX509\");\n+\n+                SSLContext ctx = SSLContext.getInstance(\"TLS\", \"Mozilla-JSS\");\n+                ctx.init(\n+                    kmf.getKeyManagers(),\n+                    new TrustManager[] { new JSSNativeTrustManager() },\n+                    null\n+                );\n+\n+                SSLServerSocketFactory factory = ctx.getServerSocketFactory();\n+                org.mozilla.jss.ssl.javax.JSSServerSocket sock = (org.mozilla.jss.ssl.javax.JSSServerSocket) factory.createServerSocket(port);\n+\n+                sock.setReuseAddress(true);\n+                sock.setWantClientAuth(false);\n+                sock.setNeedClientAuth(false);\n+                sock.setUseClientMode(false);\n+                sock.setCertFromAlias(nickname);\n+\n+                return sock;\n+            }\n+            case \"SunJSSE.SSLSocket\": {\n+                FileInputStream fis = new FileInputStream(nickname);\n+                KeyStore store = KeyStore.getInstance(\"PKCS12\");\n+                store.load(fis, \"m1oZilla\".toCharArray());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9"}, "originalPosition": 127}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7d0c15d791a452349eb62485fe33a2b8a7ee8be9", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/7d0c15d791a452349eb62485fe33a2b8a7ee8be9", "committedDate": "2020-05-20T19:26:45Z", "message": "Add SSLSocket benchmark\n\nThis benchmark supports three providers:\n\n 1. org.mozilla.jss.ssl.SSLSocket, named JSS.legacy\n 2. org.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\n 3. the JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "committedDate": "2020-05-21T17:19:16Z", "message": "Add SSLSocket benchmark\n\nThis benchmark supports three providers:\n\n 1. org.mozilla.jss.ssl.SSLSocket, named JSS.legacy\n 2. org.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\n 3. the JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nDocumentation for this benchmark is available under the docs/usage\nfolder.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "132d9dd9e3e2c72bffd57da24f13874967d258d3", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/132d9dd9e3e2c72bffd57da24f13874967d258d3", "committedDate": "2020-05-22T15:33:38Z", "message": "Add SSLSocket benchmark\n\nThis benchmark supports three providers:\n\n 1. org.mozilla.jss.ssl.SSLSocket, named JSS.legacy\n 2. org.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\n 3. the JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nDocumentation for this benchmark is available under the docs/usage\nfolder.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/e0f1bf8a4fa472529b4d7d4b9e4c5f9aa1c6ab02", "committedDate": "2020-05-21T17:19:16Z", "message": "Add SSLSocket benchmark\n\nThis benchmark supports three providers:\n\n 1. org.mozilla.jss.ssl.SSLSocket, named JSS.legacy\n 2. org.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\n 3. the JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nDocumentation for this benchmark is available under the docs/usage\nfolder.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "132d9dd9e3e2c72bffd57da24f13874967d258d3", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/132d9dd9e3e2c72bffd57da24f13874967d258d3", "committedDate": "2020-05-22T15:33:38Z", "message": "Add SSLSocket benchmark\n\nThis benchmark supports three providers:\n\n 1. org.mozilla.jss.ssl.SSLSocket, named JSS.legacy\n 2. org.mozilla.jss.ssl.javax.JSSSocket, named JSS.SSLSocket\n 3. the JDK's SunJSSE provider's SSLSocket, named SunJSSE.SSLSocket\n\nDocumentation for this benchmark is available under the docs/usage\nfolder.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1515, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}