{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxNDExODg5", "number": 562, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTozNToyOVrOD-pPIQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDoxNzo1NFrOD-vITg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDEzOTIxOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTozNToyOVrOGY3vuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNzowMzozN1rOGY7JAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMjM0NQ==", "bodyText": "Could we throw an SSLException instead and declare it in this method? The JSSEngineReferenceImpl.beginHandshake() should have declared an SSLException so we can just let it bubble up.\nGenerally I'd rather not create a RuntimeException as the initial exception unless we can't declare the exception in the method.", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428732345", "createdAt": "2020-05-21T15:35:29Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "diffHunk": "@@ -249,6 +259,20 @@ protected static String errorText(int error) {\n         }\n     }\n \n+    /**\n+     * Safely initializes the session cache if not already initialized.\n+     */\n+    public static void initializeSessionCache(\n+        int maxCacheEntries, long timeout, String directory)\n+    {\n+        if (sessionCacheInitialized.compareAndSet(false, true)) {\n+            if (SSL.ConfigServerSessionIDCache(maxCacheEntries, timeout, timeout, directory) == SSL.SECFailure) {\n+                String msg = \"Unable to configure server session cache: \";\n+                msg += errorText(PR.GetError());\n+                throw new RuntimeException(msg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0682ecb1630be759965ca104223c4b460ff7e77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc3Njk5MQ==", "bodyText": "Sure, I think that's possible. I think originally beginHandshake() was called from updateHandshakeState() which in turn is always called from getHandshakeStatus() -- the latter declares no exceptions.", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428776991", "createdAt": "2020-05-21T16:44:51Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "diffHunk": "@@ -249,6 +259,20 @@ protected static String errorText(int error) {\n         }\n     }\n \n+    /**\n+     * Safely initializes the session cache if not already initialized.\n+     */\n+    public static void initializeSessionCache(\n+        int maxCacheEntries, long timeout, String directory)\n+    {\n+        if (sessionCacheInitialized.compareAndSet(false, true)) {\n+            if (SSL.ConfigServerSessionIDCache(maxCacheEntries, timeout, timeout, directory) == SSL.SECFailure) {\n+                String msg = \"Unable to configure server session cache: \";\n+                msg += errorText(PR.GetError());\n+                throw new RuntimeException(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMjM0NQ=="}, "originalCommit": {"oid": "f0682ecb1630be759965ca104223c4b460ff7e77"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc4Nzk2OA==", "bodyText": "Yeah we just need to catch one location of SSLException and re-throw as RuntimeException, but otherwise we can handle that better now.", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428787968", "createdAt": "2020-05-21T17:03:37Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "diffHunk": "@@ -249,6 +259,20 @@ protected static String errorText(int error) {\n         }\n     }\n \n+    /**\n+     * Safely initializes the session cache if not already initialized.\n+     */\n+    public static void initializeSessionCache(\n+        int maxCacheEntries, long timeout, String directory)\n+    {\n+        if (sessionCacheInitialized.compareAndSet(false, true)) {\n+            if (SSL.ConfigServerSessionIDCache(maxCacheEntries, timeout, timeout, directory) == SSL.SECFailure) {\n+                String msg = \"Unable to configure server session cache: \";\n+                msg += errorText(PR.GetError());\n+                throw new RuntimeException(msg);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczMjM0NQ=="}, "originalCommit": {"oid": "f0682ecb1630be759965ca104223c4b460ff7e77"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDE1ODk4OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/SSLServerSocket.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTo0MDo0N1rOGY38NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTo0MDo0N1rOGY38NA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODczNTU0MA==", "bodyText": "I think this should catch SSLException. See my other comment.", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428735540", "createdAt": "2020-05-21T15:40:47Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/SSLServerSocket.java", "diffHunk": "@@ -266,9 +267,21 @@ public void close() throws IOException {\n      *  will contain the session cache. If null is passed, the server default\n      *  is used: <code>/tmp</code> on Unix and <code>\\\\temp</code> on Windows.\n      */\n-    public static native void configServerSessionIDCache(int maxSidEntries,\n-        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory)\n-        throws SocketException;\n+    public static void configServerSessionIDCache(int maxSidEntries,\n+        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory) throws SocketException {\n+        try {\n+            JSSEngine.initializeSessionCache(maxSidEntries, ssl3EntryTimeout, cacheFileDirectory);\n+        } catch (RuntimeException re) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0682ecb1630be759965ca104223c4b460ff7e77"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDIxMzI3OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTo1MDozN1rOGY4ewA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxNTo1MDozN1rOGY4ewA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODc0NDM4NA==", "bodyText": "The AtomicBoolean should work fine, but a regular boolean sessionCacheInitialized and a synchronized initializeSessionCache() probably would work as well. It's up to you, whichever simpler.", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428744384", "createdAt": "2020-05-21T15:50:37Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngine.java", "diffHunk": "@@ -176,6 +177,15 @@\n      */\n     protected static HashMap<PK11Cert, SSLFDProxy> serverTemplates = new HashMap<PK11Cert, SSLFDProxy>();\n \n+    /**\n+     * Whether or not the session cache has been initialized already.\n+     *\n+     * A session cache must always be created in order to utilize a\n+     * server-side JSSEngine. However, NSS isn't threadsafe when creating\n+     * such a cache, so synchronize it within JSSEngine.\n+     */\n+    private final static AtomicBoolean sessionCacheInitialized = new AtomicBoolean();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f0682ecb1630be759965ca104223c4b460ff7e77"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTEwMDU5OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDoxNjozMlrOGZBXRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDoxNjozMlrOGZBXRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg4OTkyNA==", "bodyText": "IllegalArgumentException is a RuntimeException so it doesn't have to be declared.", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428889924", "createdAt": "2020-05-21T20:16:32Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -196,31 +196,31 @@ private void createBufferFD() {\n         // Turn on SSL Alert Logging for the ssl_fd object.\n         int ret = SSL.EnableAlertLogging(ssl_fd);\n         if (ret == SSL.SECFailure) {\n-            throw new RuntimeException(\"JSSEngine.init(): Unable to enable SSL Alert Logging on this SSLFDProxy instance.\");\n+            throw new SSLException(\"Unable to enable SSL Alert Logging on this SSLFDProxy instance.\");\n         }\n \n         ret = SSL.EnableHandshakeCallback(ssl_fd);\n         if (ret == SSL.SECFailure) {\n-            throw new RuntimeException(\"JSSEngine.init(): Unable to enable SSL Handshake Callback on this SSLFDProxy instance.\");\n+            throw new SSLException(\"Unable to enable SSL Handshake Callback on this SSLFDProxy instance.\");\n         }\n \n         // Pass this ssl_fd to the session object so that we can use\n         // SSL methods to invalidate the session.\n     }\n \n-    private void initClient() {\n+    private void initClient() throws SSLException {\n         debug(\"JSSEngine: initClient()\");\n \n         if (cert != null && key != null) {\n             debug(\"JSSEngine.initClient(): Enabling client auth: \" + cert);\n             ssl_fd.SetClientCert(cert);\n             if (SSL.AttachClientCertCallback(ssl_fd) != SSL.SECSuccess) {\n-                throw new RuntimeException(\"JSSEngine.init(): Unable to attach client certificate auth callback.\");\n+                throw new SSLException(\"Unable to attach client certificate auth callback.\");\n             }\n         }\n     }\n \n-    private void initServer() {\n+    private void initServer() throws SSLException, IllegalArgumentException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4d6da1c9cf61d4031bbf53d60f02fc30720096"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MTEwNDc4OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/SSLServerSocket.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDoxNzo1NFrOGZBZ0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDoxNzo1NFrOGZBZ0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5MDU3Ng==", "bodyText": "It should say SSLException instead.", "url": "https://github.com/dogtagpki/jss/pull/562#discussion_r428890576", "createdAt": "2020-05-21T20:17:54Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/SSLServerSocket.java", "diffHunk": "@@ -266,9 +269,21 @@ public void close() throws IOException {\n      *  will contain the session cache. If null is passed, the server default\n      *  is used: <code>/tmp</code> on Unix and <code>\\\\temp</code> on Windows.\n      */\n-    public static native void configServerSessionIDCache(int maxSidEntries,\n-        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory)\n-        throws SocketException;\n+    public static void configServerSessionIDCache(int maxSidEntries,\n+        int ssl2EntryTimeout, int ssl3EntryTimeout, String cacheFileDirectory) throws SocketException {\n+        try {\n+            JSSEngine.initializeSessionCache(maxSidEntries, ssl3EntryTimeout, cacheFileDirectory);\n+        } catch (SSLException parent) {\n+            // Because JSSEngine.initializeSessionCache is utilized during\n+            // init of JSSengine implementations, it can only throw a\n+            // RuntimeException. However, in the event it fails, we should", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ae4d6da1c9cf61d4031bbf53d60f02fc30720096"}, "originalPosition": 28}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2644, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}