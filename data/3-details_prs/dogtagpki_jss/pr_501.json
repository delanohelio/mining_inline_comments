{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2ODI3MDUy", "number": 501, "title": "SSLEngine - Handle Large wrap/unwrap Calls", "bodyText": "One of the issues I identified when testing JSSEngine in IPA and PKI is handling of calls to wrap/unwrap with large wrap data. Here, large is defined as \"exceeding the size of the internal buffers\".\nThis PR is in three parts:\n\nAdd a test case for calls to wrap/unwrap with large buffers.\nAllow dummy PR.Write calls.\nFix wrapping/unwrapping with large buffers.\nFix calls to PR.Write when entire buffer isn't consumed.\n\nIn particular, this is consistent with Tomcat's OpenSSL native SSLEngine.\nNote that dummy PR.Write calls are consistent with what NSS does internally. Sometimes we need to force NSS to push data out but we have no more data to send -- it is already in NSS's internal buffers and needs to get written to our wrapped buffer-backed PRFileDesc *.", "createdAt": "2020-04-21T18:16:54Z", "url": "https://github.com/dogtagpki/jss/pull/501", "merged": true, "mergeCommit": {"oid": "e58cd6976f566b51d95e9db316e56cad9533484e"}, "closed": true, "closedAt": "2020-04-30T13:55:03Z", "author": {"login": "cipherboy"}, "timelineItems": {"totalCount": 21, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZ5Zu0gBqjMyNTc3MDcwMzc=", "endCursor": "Y3Vyc29yOnYyOpPPAAABccjKdmAFqTQwMzE1NDA3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a5ff6f9e6719ae08c7394652eff344d0bc1c1195", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/a5ff6f9e6719ae08c7394652eff344d0bc1c1195", "committedDate": "2020-04-21T16:55:00Z", "message": "Allow JSSEngine.wrap/unwrap of large buffers\n\nBecause JSSEngine wraps the native NSS, there are two places data can be\nbuffered:\n\n - Within JSSEngine's internal buffers,\n - Within NSS's internal buffers.\n\nWhen the handshake has completed, we need to ensure we always drain as\nmuch data as possible from these buffers into wrap/unwrap. This requires\nus to invoke multiple calls to PR.Read and PR.Write, until they\neventually return EWOULDBLOCK or 0 data written.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "57d8bfbe4051616f19a150bc9112e98fad7fcb1b", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/57d8bfbe4051616f19a150bc9112e98fad7fcb1b", "committedDate": "2020-04-21T20:06:45Z", "message": "Allow JSSEngine.wrap/unwrap of large buffers\n\nBecause JSSEngine wraps the native NSS, there are two places data can be\nbuffered:\n\n - Within JSSEngine's internal buffers,\n - Within NSS's internal buffers.\n\nWhen the handshake has completed, we need to ensure we always drain as\nmuch data as possible from these buffers into wrap/unwrap. This requires\nus to invoke multiple calls to PR.Read and PR.Write, until they\neventually return EWOULDBLOCK or 0 data written.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NjQ4MTc4", "url": "https://github.com/dogtagpki/jss/pull/501#pullrequestreview-397648178", "createdAt": "2020-04-21T20:24:57Z", "commit": {"oid": "a6a918f6a12dc7de43cc1e4f757ae7e83b23a725"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNDo1OFrOGJW-Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNDo1OFrOGJW-Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NjY5NA==", "bodyText": "This isn't actually correct.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412466694", "createdAt": "2020-04-21T20:24:58Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -790,58 +777,63 @@ public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int\n         // case no data would be written to dsts. Lastly, even if no new data\n         // from srcs, could still have residual data in read_buf, so we should\n         // attempt to read from the ssl_fd.\n+        //\n+        // In order to handle large buffer sizes, wrap everything in a\n+        // do-while loop.\n \n-        // When we have data from src, write it to read_buf.\n-        if (wire_data > 0) {\n-            byte[] wire_buffer = new byte[wire_data];\n-            src.get(wire_buffer);\n-            int written = (int) Buffer.Write(read_buf, wire_buffer);\n+        // wire_data is the number of bytes from src we've written into\n+        // read_buf. This is bounded above by src.capcity but also the\n+        // free space left in read_buf to write to. Allows us to size the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a918f6a12dc7de43cc1e4f757ae7e83b23a725"}, "originalPosition": 35}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a6a918f6a12dc7de43cc1e4f757ae7e83b23a725", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/a6a918f6a12dc7de43cc1e4f757ae7e83b23a725", "committedDate": "2020-04-21T20:22:11Z", "message": "Gate socket logging behind debug flag\n\nThis debug logging is broken for large messages because it timesout\ntrying to write data. Disable it by default unless explicitly recompiled\nwith support in the test suite.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "b128cfc14641f5bb63405439ef004701c5b55a25", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/b128cfc14641f5bb63405439ef004701c5b55a25", "committedDate": "2020-04-21T20:38:10Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b128cfc14641f5bb63405439ef004701c5b55a25", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/b128cfc14641f5bb63405439ef004701c5b55a25", "committedDate": "2020-04-21T20:38:10Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "20dc7decddd34dba3a288bc9c3451ad36ff8616a", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/20dc7decddd34dba3a288bc9c3451ad36ff8616a", "committedDate": "2020-04-21T20:41:35Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "20dc7decddd34dba3a288bc9c3451ad36ff8616a", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/20dc7decddd34dba3a288bc9c3451ad36ff8616a", "committedDate": "2020-04-21T20:41:35Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/6b9047b361886bdbaa0806c4107c01bf1d3b3833", "committedDate": "2020-04-21T20:43:48Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same size, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3NzE1MDMx", "url": "https://github.com/dogtagpki/jss/pull/501#pullrequestreview-397715031", "createdAt": "2020-04-21T22:16:26Z", "commit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjoxNjoyNlrOGJayaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjozNjowM1rOGJbVUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyOTI1Ng==", "bodyText": "Do we need a return statement after JSS_throwMsg()?", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412529256", "createdAt": "2020-04-21T22:16:26Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/PR.c", "diffHunk": "@@ -222,20 +224,31 @@ Java_org_mozilla_jss_nss_PR_Write(JNIEnv *env, jclass clazz, jobject fd,\n \n     PR_ASSERT(real_fd != NULL);\n \n-    real_length = (*env)->GetArrayLength(env, buf);\n-    if (real_length > INT_MAX) {\n-        max_length = INT_MAX;\n-    } else {\n-        max_length = (int)(real_length % INT_MAX);\n-    }\n+    if (buf != NULL) {\n+        real_length = (*env)->GetArrayLength(env, buf);\n+        if (real_length > INT_MAX) {\n+            max_length = INT_MAX;\n+        } else {\n+            max_length = (int)(real_length % INT_MAX);\n+        }\n \n-    buffer = (uint8_t*)((*env)->GetByteArrayElements(env, buf, NULL));\n-    if (buffer == NULL) {\n-        return 0;\n+        buffer = (uint8_t*)((*env)->GetByteArrayElements(env, buf, NULL));\n+        if (buffer == NULL && real_length == 0) {\n+            buffer = &dummy_buffer;\n+            max_length = 0;\n+        } else if (buffer == NULL && real_length > 0) {\n+            JSS_throwMsg(env, NULL_POINTER_EXCEPTION, \"Expected non-NULL byte array given non-zero length.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzNzgyMw==", "bodyText": "According to the doc, GetByteArrayElements() will only return NULL if it fails, so I think the code should terminate immediately if buffer is NULL.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412537823", "createdAt": "2020-04-21T22:35:17Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/PR.c", "diffHunk": "@@ -222,20 +224,31 @@ Java_org_mozilla_jss_nss_PR_Write(JNIEnv *env, jclass clazz, jobject fd,\n \n     PR_ASSERT(real_fd != NULL);\n \n-    real_length = (*env)->GetArrayLength(env, buf);\n-    if (real_length > INT_MAX) {\n-        max_length = INT_MAX;\n-    } else {\n-        max_length = (int)(real_length % INT_MAX);\n-    }\n+    if (buf != NULL) {\n+        real_length = (*env)->GetArrayLength(env, buf);\n+        if (real_length > INT_MAX) {\n+            max_length = INT_MAX;\n+        } else {\n+            max_length = (int)(real_length % INT_MAX);\n+        }\n \n-    buffer = (uint8_t*)((*env)->GetByteArrayElements(env, buf, NULL));\n-    if (buffer == NULL) {\n-        return 0;\n+        buffer = (uint8_t*)((*env)->GetByteArrayElements(env, buf, NULL));\n+        if (buffer == NULL && real_length == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzODE5NA==", "bodyText": "This is an existing code, but the max length of a Java array is 2^31-1 (i.e. Integer.MAX_VALUE), which is the same as INT_MAX in C, is that correct? So this could be simplified into:\nbuffer_length = (*env)->GetArrayLength(env, buf);\n\nNo need to use real_length and max_length.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412538194", "createdAt": "2020-04-21T22:36:03Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/PR.c", "diffHunk": "@@ -222,20 +224,31 @@ Java_org_mozilla_jss_nss_PR_Write(JNIEnv *env, jclass clazz, jobject fd,\n \n     PR_ASSERT(real_fd != NULL);\n \n-    real_length = (*env)->GetArrayLength(env, buf);\n-    if (real_length > INT_MAX) {\n-        max_length = INT_MAX;\n-    } else {\n-        max_length = (int)(real_length % INT_MAX);\n-    }\n+    if (buf != NULL) {\n+        real_length = (*env)->GetArrayLength(env, buf);\n+        if (real_length > INT_MAX) {\n+            max_length = INT_MAX;\n+        } else {\n+            max_length = (int)(real_length % INT_MAX);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833"}, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/6b9047b361886bdbaa0806c4107c01bf1d3b3833", "committedDate": "2020-04-21T20:43:48Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same size, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "30b0d7de968b513205614014a4e4b9e4a8d5dc4f", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/30b0d7de968b513205614014a4e4b9e4a8d5dc4f", "committedDate": "2020-04-22T13:23:52Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same size, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "30b0d7de968b513205614014a4e4b9e4a8d5dc4f", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/30b0d7de968b513205614014a4e4b9e4a8d5dc4f", "committedDate": "2020-04-22T13:23:52Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same size, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "b42e20a46991282db885a1ec209725dce0e6938e", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/b42e20a46991282db885a1ec209725dce0e6938e", "committedDate": "2020-04-23T17:34:04Z", "message": "Handle PR.Writes of smaller sizes in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b42e20a46991282db885a1ec209725dce0e6938e", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/b42e20a46991282db885a1ec209725dce0e6938e", "committedDate": "2020-04-23T17:34:04Z", "message": "Handle PR.Writes of smaller sizes in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "90742c49a66b515cd8d046fb7cd81fb42dfa6332", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/90742c49a66b515cd8d046fb7cd81fb42dfa6332", "committedDate": "2020-04-23T18:14:06Z", "message": "Handle PR.Writes of smaller sizes in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NDc0NjEz", "url": "https://github.com/dogtagpki/jss/pull/501#pullrequestreview-399474613", "createdAt": "2020-04-23T21:03:37Z", "commit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTowMzozN1rOGK8BVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTowMzozN1rOGK8BVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMjMyNQ==", "bodyText": "@edewata Can you think of anything more elegant for this? Or is adding a boolean flag and tracking it fine? Maybe I should split it into a updateHandshakePre() and a updateHandshakeState()? -- Pre only getting called once and State getting called only when actually handshaking? Hmm...", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r414122325", "createdAt": "2020-04-23T21:03:37Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -50,6 +50,7 @@\n \n     private int unknown_state_count;\n     private boolean step_handshake;\n+    private boolean returned_finished;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMTkyNzAy", "url": "https://github.com/dogtagpki/jss/pull/501#pullrequestreview-400192702", "createdAt": "2020-04-24T18:50:57Z", "commit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxODo1MDo1N1rOGLk3ug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxODo1MDo1N1rOGLk3ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MTYxMA==", "bodyText": "I don't really have an opinion on this. If it works then let's keep it :)\nWe can always refactor later if we find a better way.\nI've ACKed this PR, feel free to merge, but I'd prefer @jmagne to take a look at this as well, either before or after merging.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r414791610", "createdAt": "2020-04-24T18:50:57Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -50,6 +50,7 @@\n \n     private int unknown_state_count;\n     private boolean step_handshake;\n+    private boolean returned_finished;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMjMyNQ=="}, "originalCommit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNDQ0NTA0", "url": "https://github.com/dogtagpki/jss/pull/501#pullrequestreview-401444504", "createdAt": "2020-04-28T01:53:03Z", "commit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMTo1MzowM1rOGM_Ddw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMTo1MzowM1rOGM_Ddw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI2OTE3NQ==", "bodyText": "I\"m assuming that this_src_write and ths_dst_write will eventually become exactly zero?", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r416269175", "createdAt": "2020-04-28T01:53:03Z", "author": {"login": "jmagne"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -811,58 +817,68 @@ public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int\n         // case no data would be written to dsts. Lastly, even if no new data\n         // from srcs, could still have residual data in read_buf, so we should\n         // attempt to read from the ssl_fd.\n+        //\n+        // In order to handle large buffer sizes, wrap everything in a\n+        // do-while loop.\n \n-        // When we have data from src, write it to read_buf.\n-        if (wire_data > 0) {\n-            byte[] wire_buffer = new byte[wire_data];\n-            src.get(wire_buffer);\n-            int written = (int) Buffer.Write(read_buf, wire_buffer);\n+        // wire_data is the number of bytes from src we've written into\n+        // read_buf.\n+        int wire_data = 0;\n \n-            // For safety: ensure everything we thought we could write was\n-            // actually written. Otherwise, we've done something wrong.\n-            wire_data = Math.min(wire_data, written);\n+        // Actual amount of data written to the buffer.\n+        int app_data = 0;\n \n-            // TODO: Determine if we should write the trail of wire_buffer\n-            // back to the front of src... Seems like unnecessary work.\n-            debug(\"JSSEngine.unwrap(): Wrote \" + wire_data + \" bytes to read_buf.\");\n-        }\n+        int this_src_write;\n+        int this_dst_write;\n \n-        // In the above, we should always try to read and write data. Check to\n-        // see if we need to step our handshake process or not.\n-        updateHandshakeState();\n+        do {\n+            this_src_write = 0;\n+            this_dst_write = 0;\n \n-        // Actual amount of data written to the buffer.\n-        int app_data = 0;\n+            if (src != null) {\n+                this_src_write = Math.min((int) Buffer.WriteCapacity(read_buf), src.remaining());\n+\n+                // When we have data from src, write it to read_buf.\n+                if (this_src_write > 0) {\n+                    byte[] wire_buffer = new byte[this_src_write];\n+                    src.get(wire_buffer);\n \n-        // Maximum theoretical amount of data we could've written to the\n-        // destination. This is bounded by the lower of both the size of\n-        // our dsts and the maximum BUFFER_SIZE. Worst case, we'll be forced\n-        // to call unwrap(...) multiple times.\n-        int max_app_data = Math.min(computeSize(dsts, offset, length), BUFFER_SIZE);\n-\n-        // When we have app data to write over the network, go ahead and do\n-        // so. This involves reading from ssl_fd and writing to dsts. We don't\n-        // currently have a good proxy metric for \"can read from a ssl_fd\",\n-        // so always attempt it. In particular, even if the handshake isn't\n-        // finished, we still need to call PR.Read(...) or PR.Write(...) in\n-        // order to tell if an inbound alert was received.\n-        if (max_app_data > 0) {\n-            byte[] app_buffer = PR.Read(ssl_fd, max_app_data);\n-            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(PR.GetError()));\n+                    this_src_write = (int) Buffer.Write(read_buf, wire_buffer);\n+\n+                    wire_data += this_src_write;\n+                    debug(\"JSSEngine.unwrap(): Wrote \" + this_src_write + \" bytes to read_buf.\");\n+                }\n+            }\n+\n+            // In the above, we should always try to read and write data. Check to\n+            // see if we need to step our handshake process or not.\n+            updateHandshakeState();\n+\n+            int max_dst_size = computeSize(dsts, offset, length);\n+            byte[] app_buffer = PR.Read(ssl_fd, max_dst_size);\n+            int error = PR.GetError();\n+            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(error));\n             if (app_buffer != null) {\n-                app_data = putData(app_buffer, dsts, offset, length);\n-            } else {\n-                int error = PR.GetError();\n-                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR) {\n+                this_dst_write = putData(app_buffer, dsts, offset, length);\n+                app_data += this_dst_write;\n+            } else if (max_dst_size > 0) {\n+                // There are two scenarios we need to ignore here:\n+                //  1. WOULD_BLOCK_ERRORs are safe, because we're expecting\n+                //     not to block. Usually this means we don't have space\n+                //     to write any more data.\n+                //  2. SOCKET_SHUTDOWN_ERRORs are safe, because if the\n+                //     underling cause was fatal, we'd catch it after exiting\n+                //     the do-while loop, in checkSSLAlerts().\n+                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR && error != PRErrors.SOCKET_SHUTDOWN_ERROR) {\n                     ssl_exception = new SSLException(\"Unexpected return from PR.Read(): \" + errorText(error));\n                     seen_exception = true;\n                 }\n             }\n+        } while (this_src_write != 0 || this_dst_write != 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "originalPosition": 163}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ec4e28037301850c0f85dd7ef9fd78b83b4b4d17", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/ec4e28037301850c0f85dd7ef9fd78b83b4b4d17", "committedDate": "2020-04-29T18:56:07Z", "message": "Add test case for large wrap/unwrap\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "74b49b4988d61f6d815f3db6a950f4ea93025104", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/74b49b4988d61f6d815f3db6a950f4ea93025104", "committedDate": "2020-04-29T18:56:07Z", "message": "Allow dummy PR.Write with NULL buffer\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fbf48001b08635416c63576d2cb287466bca342", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/8fbf48001b08635416c63576d2cb287466bca342", "committedDate": "2020-04-29T18:56:07Z", "message": "Allow JSSEngine.wrap/unwrap of large buffers\n\nBecause JSSEngine wraps the native NSS, there are two places data can be\nbuffered:\n\n - Within JSSEngine's internal buffers,\n - Within NSS's internal buffers.\n\nWhen the handshake has completed, we need to ensure we always drain as\nmuch data as possible from these buffers into wrap/unwrap. This requires\nus to invoke multiple calls to PR.Read and PR.Write, until they\neventually return EWOULDBLOCK or 0 data written.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d011a6b781cf2caa6c8d170e13686dfffbb79c89", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/d011a6b781cf2caa6c8d170e13686dfffbb79c89", "committedDate": "2020-04-29T19:00:03Z", "message": "Gate socket logging behind debug flag\n\nThis debug logging is broken for large messages because it timesout\ntrying to write data. Disable it by default unless explicitly recompiled\nwith support in the test suite.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "10bb963bd26efe00a20bb06307a4cc7545929e79", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/10bb963bd26efe00a20bb06307a4cc7545929e79", "committedDate": "2020-04-29T19:00:03Z", "message": "Handle JSSEngine.putData(...) with large arrays\n\nWhen data and the destination buffer are roughly the same size, and both\nsuitably large, it makes more sense to use ByteBuffer.put(...) with\nthe source array (providing offset and lengths) rather than manually\nputting each byte into the buffer.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0f96bc35c22c22fc95d54779a2a746984e1122b", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/a0f96bc35c22c22fc95d54779a2a746984e1122b", "committedDate": "2020-04-29T19:00:03Z", "message": "Handle PR.Writes of smaller sizes in JSSEngine\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2509b454f0dcce7e77124916d03471ace0194426", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/2509b454f0dcce7e77124916d03471ace0194426", "committedDate": "2020-04-29T19:00:03Z", "message": "Return FINISHED status from JSSEngine.{un,}wrap\n\nWhen handling large messages, updateHandshakeState() gets called\nmultiple times during handshaking. If the handshake becomes FINISHED\nand data gets written to a buffer, we'll call updateHandshakeState()\nagain, resulting in it immediately moving to NOT_HANDSHAKING. Because\nclients expect a FINISHED message before NOT_HANDSHAKING, only step\nfurther after FINISHED has been returned from either wrap or unwrap.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2", "committedDate": "2020-04-23T19:33:55Z", "message": "Return FINISHED status from JSSEngine.{un,}wrap\n\nWhen handling large messages, updateHandshakeState() gets called\nmultiple times during handshaking. If the handshake becomes FINISHED\nand data gets written to a buffer, we'll call updateHandshakeState()\nagain, resulting in it immediately moving to NOT_HANDSHAKING. Because\nclients expect a FINISHED message before NOT_HANDSHAKING, only step\nfurther after FINISHED has been returned from either wrap or unwrap.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "2509b454f0dcce7e77124916d03471ace0194426", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/2509b454f0dcce7e77124916d03471ace0194426", "committedDate": "2020-04-29T19:00:03Z", "message": "Return FINISHED status from JSSEngine.{un,}wrap\n\nWhen handling large messages, updateHandshakeState() gets called\nmultiple times during handshaking. If the handshake becomes FINISHED\nand data gets written to a buffer, we'll call updateHandshakeState()\nagain, resulting in it immediately moving to NOT_HANDSHAKING. Because\nclients expect a FINISHED message before NOT_HANDSHAKING, only step\nfurther after FINISHED has been returned from either wrap or unwrap.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzMTU0MDcy", "url": "https://github.com/dogtagpki/jss/pull/501#pullrequestreview-403154072", "createdAt": "2020-04-30T01:54:04Z", "commit": {"oid": "2509b454f0dcce7e77124916d03471ace0194426"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1484, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}