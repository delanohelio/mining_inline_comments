{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4MTQ0OTkx", "number": 579, "title": "JSSEngine - External TrustManagers", "bodyText": "This PR adds support for external (non-native, whether that's NSS's default cert auth handler or JSS's native one from the older SSLSocket interface) TrustManagers. We use the standard JDK interfaces for X509TrustManager/X509ExtendedTrustManager and derive authType information for their consumption.\nWe do this via two mechanisms:\n\nAsynchronously if we're a client, using getDelegatedTask() to run the validation, or\nSynchronously, in case we're a server, because NSS doesn't support asynchronous (SECWouldBlock return code) in this case.", "createdAt": "2020-06-22T19:53:13Z", "url": "https://github.com/dogtagpki/jss/pull/579", "merged": true, "mergeCommit": {"oid": "775d588fe4ef28dcf539873c7b81445e12efb862"}, "closed": true, "closedAt": "2020-06-25T16:54:34Z", "author": {"login": "cipherboy"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABct2a50AFqTQzNTIyOTMxOQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcuxaIEgBqjM0ODMyMzk4NzA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MjI5MzE5", "url": "https://github.com/dogtagpki/jss/pull/579#pullrequestreview-435229319", "createdAt": "2020-06-22T19:56:56Z", "commit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1Njo1NlrOGnO4Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1Njo1NlrOGnO4Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5MTQxMA==", "bodyText": "Describe contract for async cert checking.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r443791410", "createdAt": "2020-06-22T19:56:56Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/SSL.java", "diffHunk": "@@ -421,14 +421,43 @@ public static int EnableAlertLogging(SSLFDProxy fd) {\n     private static native int EnableAlertLoggingNative(SSLFDProxy fd);\n \n     /**\n-     * Use the default JSS certificate checking handler (which understands CryptoManager\n-     * OCSP status).\n+     * Use the default JSS certificate checking handler (which understands\n+     * CryptoManager OCSP status).\n      *\n      * See also: SSL_AuthCertificateHook in /usr/include/nss3/ssl.h and\n      *           JSSL_DefaultCertAuthCallback in jss/ssl/callbacks.c\n      */\n     public static native int ConfigJSSDefaultCertAuthCallback(SSLFDProxy fd);\n \n+    /**\n+     * Use an asynchronous certificate checking handler which allows us to\n+     * invoke an arbitrary number of TrustManagers.\n+     *\n+     * See also: SSL_AuthCertificateHook in /usr/include/nss3/ssl.h and\n+     *           JSSL_SSLFDAsyncCertAuthCallback in jss/nss/SSLFDProxy.c\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MjMwMTk2", "url": "https://github.com/dogtagpki/jss/pull/579#pullrequestreview-435230196", "createdAt": "2020-06-22T19:58:12Z", "commit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1ODoxMlrOGnO6xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1ODoxMlrOGnO6xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5MjA3MA==", "bodyText": "Mention that we need to create it ahead of time though, rather than via checkNeedCertValidation", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r443792070", "createdAt": "2020-06-22T19:58:12Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -367,6 +375,25 @@ private void applyTrustManagers() throws SSLException {\n             if (SSL.ConfigJSSDefaultCertAuthCallback(ssl_fd) == SSL.SECFailure) {\n                 throw new SSLException(\"Unable to configure JSSNativeTrustManager on this JSSengine: \" + errorText(PR.GetError()));\n             }\n+            return;\n+        }\n+\n+        if (as_server) {\n+            // We need to manually invoke the async cert auth handler. However,\n+            // SSLFDProxy makes this easy for us: our CertAuthHandler derives\n+            // from Runnable, so we can reuse it here as well.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM1MjM1MzIx", "url": "https://github.com/dogtagpki/jss/pull/579#pullrequestreview-435235321", "createdAt": "2020-06-22T20:06:29Z", "commit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDowNjozMFrOGnPJ5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDowNjozMFrOGnPJ5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5NTk0MA==", "bodyText": "This can go away.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r443795940", "createdAt": "2020-06-22T20:06:30Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -531,16 +558,105 @@ public String getHostname() {\n     public Runnable getDelegatedTask() {\n         debug(\"JSSEngine: getDelegatedTask()\");\n \n-        // We fake being a non-blocking SSLEngine. In particular, we never\n-        // export tasks as delegated tasks (e.g., OCSP checking), so this\n-        // method will always return null.\n+        checkNeedCertValidation();\n \n-        return null;\n+        return task;\n+    }\n+\n+    private boolean checkNeedCertValidation() {\n+        debug(\"JSSEngine: checkNeedCertValidation()\");\n+        if (task != null) {\n+            if (!task.finished) {\n+                // Already created runnable task; exit with true status to\n+                // show it still needs to be run.\n+                debug(\"JSSEngine: checkNeedCertValidation() - task not done\");\n+                return true;\n+            }\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done with code \" + task.result);\n+\n+            // Since the task has finished, we now need to inform NSS about\n+            // the results of our certificate validation step.\n+            if (SSL.AuthCertificateComplete(ssl_fd, task.result) != SSL.SECSuccess) {\n+                String msg = \"Got unexpected failure finishing cert \";\n+                msg += \"authentication in NSS. Returned code \";\n+                msg += task.result;\n+                throw new RuntimeException(msg);\n+            }\n+\n+            // After checking certificates, our best guess will be that we\n+            // need to run wrap again. This is because we either need to\n+            // inform the caller of an error that occurred, or continue the\n+            // handshake. Worst case, we'll call updateHandshakeState() and\n+            // it'll correct our mmistake eventually.\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done, removing\");\n+\n+            task = null;\n+            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n+            ssl_fd.needCertValidation = false;\n+\n+            return false;\n+        }\n+\n+        if (ssl_fd == null) {\n+            // If we don't have a SSLFDProxy instance, nothing we can do but\n+            // skip checking if the task exists. Return false to show that\n+            // we don't yet have a runnable task.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no ssl_fd\");\n+            task = null;\n+            return false;\n+        }\n+\n+        if (!ssl_fd.needCertValidation) {\n+            // We don't yet need certificate validation. Don't create a\n+            // runnable task for now.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no need for cert validation\");\n+            task = null;\n+            return false;\n+        }\n+\n+        debug(\"JSSEngine: checkNeedCertValidation() - creating task\");\n+\n+        // OK, time to create our runnable task.\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "originalPosition": 130}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/44d2ed65f82625d79a48db27a84ae75d6bbbec1f", "committedDate": "2020-06-22T19:44:01Z", "message": "Add TrustManager validation support to JSSEngine\n\nThis implements external (to NSS) TrustManager validation in\nJSSEngineReferenceImpl, allowing validation of certs from\nTrustManagers provided by the caller. This works with both client and\nserver SSLEngines, though while the former delegates the task via\ngetDelegatedTask, the latter cannot and does it synchronously.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/75c65cc18de035aba42a35a8577de269a031bb05", "committedDate": "2020-06-23T00:12:07Z", "message": "Support NEED_TASK in SSLSocket\n\nNote that the JSSTrustManager doesn't give the same output as\nJSSNativeTrustManager so we cannot enable this in the BadSSL tests.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2ODY0MTc2", "url": "https://github.com/dogtagpki/jss/pull/579#pullrequestreview-436864176", "createdAt": "2020-06-24T17:36:11Z", "commit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzozNjoxMVrOGocUYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo0MToxNlrOGogdsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MDE5Mg==", "bodyText": "Ideally we should not rely on the exception message. Is the exception generated by Java or our code? Do we know the exception class?", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445060192", "createdAt": "2020-06-24T17:36:11Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/Cert.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.mozilla.jss.nss;\n+\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.CertificateParsingException;\n+import java.security.cert.CertificateRevokedException;\n+\n+public class Cert {\n+    public static int MatchExceptionToNSSError(Exception excpt) {\n+        if (excpt == null) {\n+            return 0;\n+        }\n+\n+        // Lower case, no spaces. Easier to find matches in\n+        // messy messages.\n+        String message = excpt.getMessage().toLowerCase().replaceAll(\"\\\\s+\",\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MjE3Ng==", "bodyText": "The 0 and false initializations are redundant too.. :)", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445062176", "createdAt": "2020-06-24T17:39:24Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/CertAuthHandler.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package org.mozilla.jss.nss;\n+\n+/**\n+ * CertAuthHandler interface enables arbitrary certificate authentication\n+ * from a NSS cert auth hook.\n+ *\n+ * Notably, the return code from check should be a PRErrorCode, else 0.\n+ * This will be used by NSS to determine the alert to send when closing\n+ * the connection (in the event of an error).\n+ *\n+ * The concern here is that, when this is invoked synchronously, we're\n+ * called from NSS as called by Java. Certain operations may or may not\n+ * succeed or work as expected (such as raising an exception, acquiring\n+ * locks already held, etc.).\n+ */\n+public abstract class CertAuthHandler implements Runnable {\n+    /**\n+     * When invoked via run(), the result of the check\n+     * operation.\n+     */\n+    public int result;\n+\n+    /**\n+     * Whether or not the check operation has been executed\n+     * yet, when invoked via run().\n+     */\n+    public boolean finished;\n+\n+    /**\n+     * SSLFDProxy instance.\n+     */\n+    private SSLFDProxy ssl_fd;\n+\n+    /**\n+     * Constructor to store SSLFDProxy information.\n+     *\n+     * This is useful for implementations which expect to be used\n+     * via the Runnable interface, instead of called via the\n+     * synchronous certificate authentication hook in NSS.\n+     */\n+    public CertAuthHandler(SSLFDProxy fd) {\n+        ssl_fd = fd;\n+        result = 0;\n+        finished = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NjQyNQ==", "bodyText": "Is this a special return value? Could we move it into a constant with a more descriptive name?", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445066425", "createdAt": "2020-06-24T17:47:01Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -46,4 +49,12 @@ protected synchronized void releaseNativeResources() throws Exception {\n             }\n         }\n     }\n+\n+    public int invokeCertAuthHandler() {\n+        if (handler == null) {\n+            return -5994;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NzM3NA==", "bodyText": "Redundant null initialization.. sorry, can't help it :)", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445067374", "createdAt": "2020-06-24T17:48:41Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -67,6 +69,8 @@\n     private String name;\n     private String prefix = \"\";\n \n+    private CertValidationTask task = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExNzYzOQ==", "bodyText": "Should this be a loop like in TestSSLEngine?", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445117639", "createdAt": "2020-06-24T19:20:46Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -147,6 +147,11 @@ public boolean finishConnect() throws IOException {\n                 } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                     // Read into an empty buffer to unwrap.\n                     read(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                    // Run the task, synchronously, because we're a mostly\n+                    // blocking SSLSocket.\n+                    Runnable task = engine.getDelegatedTask();\n+                    task.run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyODAxOA==", "bodyText": "I think task is guaranteed to be null by line 571 so this is redundant.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445128018", "createdAt": "2020-06-24T19:41:04Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -531,16 +561,87 @@ public String getHostname() {\n     public Runnable getDelegatedTask() {\n         debug(\"JSSEngine: getDelegatedTask()\");\n \n-        // We fake being a non-blocking SSLEngine. In particular, we never\n-        // export tasks as delegated tasks (e.g., OCSP checking), so this\n-        // method will always return null.\n+        checkNeedCertValidation();\n \n-        return null;\n+        return task;\n+    }\n+\n+    private boolean checkNeedCertValidation() {\n+        debug(\"JSSEngine: checkNeedCertValidation()\");\n+        if (task != null) {\n+            if (!task.finished) {\n+                // Already created runnable task; exit with true status to\n+                // show it still needs to be run.\n+                debug(\"JSSEngine: checkNeedCertValidation() - task not done\");\n+                return true;\n+            }\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done with code \" + task.result);\n+\n+            // Since the task has finished, we now need to inform NSS about\n+            // the results of our certificate validation step.\n+            if (SSL.AuthCertificateComplete(ssl_fd, task.result) != SSL.SECSuccess) {\n+                String msg = \"Got unexpected failure finishing cert \";\n+                msg += \"authentication in NSS. Returned code \";\n+                msg += task.result;\n+                throw new RuntimeException(msg);\n+            }\n+\n+            // After checking certificates, our best guess will be that we\n+            // need to run wrap again. This is because we either need to\n+            // inform the caller of an error that occurred, or continue the\n+            // handshake. Worst case, we'll call updateHandshakeState() and\n+            // it'll correct our mmistake eventually.\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done, removing\");\n+\n+            task = null;\n+            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n+            ssl_fd.needCertValidation = false;\n+\n+            return false;\n+        }\n+\n+        if (ssl_fd == null) {\n+            // If we don't have a SSLFDProxy instance, nothing we can do but\n+            // skip checking if the task exists. Return false to show that\n+            // we don't yet have a runnable task.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no ssl_fd\");\n+            task = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyODExNQ==", "bodyText": "I think task is guaranteed to be null by line 571 so this is redundant.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445128115", "createdAt": "2020-06-24T19:41:16Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -531,16 +561,87 @@ public String getHostname() {\n     public Runnable getDelegatedTask() {\n         debug(\"JSSEngine: getDelegatedTask()\");\n \n-        // We fake being a non-blocking SSLEngine. In particular, we never\n-        // export tasks as delegated tasks (e.g., OCSP checking), so this\n-        // method will always return null.\n+        checkNeedCertValidation();\n \n-        return null;\n+        return task;\n+    }\n+\n+    private boolean checkNeedCertValidation() {\n+        debug(\"JSSEngine: checkNeedCertValidation()\");\n+        if (task != null) {\n+            if (!task.finished) {\n+                // Already created runnable task; exit with true status to\n+                // show it still needs to be run.\n+                debug(\"JSSEngine: checkNeedCertValidation() - task not done\");\n+                return true;\n+            }\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done with code \" + task.result);\n+\n+            // Since the task has finished, we now need to inform NSS about\n+            // the results of our certificate validation step.\n+            if (SSL.AuthCertificateComplete(ssl_fd, task.result) != SSL.SECSuccess) {\n+                String msg = \"Got unexpected failure finishing cert \";\n+                msg += \"authentication in NSS. Returned code \";\n+                msg += task.result;\n+                throw new RuntimeException(msg);\n+            }\n+\n+            // After checking certificates, our best guess will be that we\n+            // need to run wrap again. This is because we either need to\n+            // inform the caller of an error that occurred, or continue the\n+            // handshake. Worst case, we'll call updateHandshakeState() and\n+            // it'll correct our mmistake eventually.\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done, removing\");\n+\n+            task = null;\n+            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n+            ssl_fd.needCertValidation = false;\n+\n+            return false;\n+        }\n+\n+        if (ssl_fd == null) {\n+            // If we don't have a SSLFDProxy instance, nothing we can do but\n+            // skip checking if the task exists. Return false to show that\n+            // we don't yet have a runnable task.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no ssl_fd\");\n+            task = null;\n+            return false;\n+        }\n+\n+        if (!ssl_fd.needCertValidation) {\n+            // We don't yet need certificate validation. Don't create a\n+            // runnable task for now.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no need for cert validation\");\n+            task = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 126}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d7c551d8aad79624fcc4b737c09c448e34cbb3e", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/6d7c551d8aad79624fcc4b737c09c448e34cbb3e", "committedDate": "2020-06-25T16:37:38Z", "message": "Support asynchronous certificate authentication\n\nThis exposes support for the SSL_AuthCertificateComplete API call, which\nallows us to create a SSL_AuthCertificateHook handler which returns\nSECWouldBlock. This returns control back to the caller, allowing them to\nexecute certificate authentication on their own, lazily. When the result\nis available, the Complete call can be performed with the result of the\ncheck. This will enable us to do external (non-native) X509TrustManager\nchecking in JSS's SSLEngine implementation in a Runnable, implementing\nthe DelegatedTask aspect.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ce9ccf05e799ab844bf0992a4cd360fe3b4cf2cd", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/ce9ccf05e799ab844bf0992a4cd360fe3b4cf2cd", "committedDate": "2020-06-25T16:37:38Z", "message": "Check whether DSS certificates are required\n\nAllow SSLCipher to check whether or not a DSS certificate is strictly\nrequired by the given cipher suite. This will be used in SSLEngine to\ndetermine the AuthType to pass to the X509TrustManager.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4d9826ab723ee8615747f120dfda17140a2c6c6", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/c4d9826ab723ee8615747f120dfda17140a2c6c6", "committedDate": "2020-06-25T16:37:38Z", "message": "Handle NSS/TLS SSLVersion identifiers\n\nNSS uses the TLS protocol version identifiers from the specs (two byte\nintegers, 0x0002 for SSLv2, 0x0300 for SSLv3, and 0x030{version+1} for\nTLSv1.0 -> TLSv1.3); when the caller forgets to convert the value to the\ninternal JSS enum index, they're left holding a NULL enum value.\nInstead, track the real NSS value and return the proper Enum for it.\nThis shouldn't be a problem as these values are mostly unique (sans a\nSSLv2 / SSL_ENABLE_TLS conflict with value 0x0002.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e078cbb4588c584366839b9f2965f06afc1c8f41", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/e078cbb4588c584366839b9f2965f06afc1c8f41", "committedDate": "2020-06-25T16:37:39Z", "message": "Map certificate exceptions to NSS error codes\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac79d5dd35cea87b50f904826431511061873eac", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/ac79d5dd35cea87b50f904826431511061873eac", "committedDate": "2020-06-25T16:40:22Z", "message": "Implement synchronous CertAuthHook for SSLFDProxy\n\nIn conjunction with the previous commit enabling asynchronous\ncertificate authentication, NSS as of v3.53 still doesn't support\nasynchronous certificate authentication on the server side of the\nhandshake. This implementation allows for easy implementation of both\nsynchronous and asynchronous certificate authentication handlers.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5dcb1384ef714eb154d03841ac940d667b7fc46", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/f5dcb1384ef714eb154d03841ac940d667b7fc46", "committedDate": "2020-06-25T16:40:23Z", "message": "Add TrustManager validation support to JSSEngine\n\nThis implements external (to NSS) TrustManager validation in\nJSSEngineReferenceImpl, allowing validation of certs from\nTrustManagers provided by the caller. This works with both client and\nserver SSLEngines, though while the former delegates the task via\ngetDelegatedTask, the latter cannot and does it synchronously.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "226b298ac516ba90439016af1ef421b7312f12c6", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/226b298ac516ba90439016af1ef421b7312f12c6", "committedDate": "2020-06-25T16:40:23Z", "message": "Support NEED_TASK in SSLSocket\n\nNote that the JSSTrustManager doesn't give the same output as\nJSSNativeTrustManager so we cannot enable this in the BadSSL tests.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/75c65cc18de035aba42a35a8577de269a031bb05", "committedDate": "2020-06-23T00:12:07Z", "message": "Support NEED_TASK in SSLSocket\n\nNote that the JSSTrustManager doesn't give the same output as\nJSSNativeTrustManager so we cannot enable this in the BadSSL tests.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "226b298ac516ba90439016af1ef421b7312f12c6", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/226b298ac516ba90439016af1ef421b7312f12c6", "committedDate": "2020-06-25T16:40:23Z", "message": "Support NEED_TASK in SSLSocket\n\nNote that the JSSTrustManager doesn't give the same output as\nJSSNativeTrustManager so we cannot enable this in the BadSSL tests.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1529, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}