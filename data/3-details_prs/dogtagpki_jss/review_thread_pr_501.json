{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2ODI3MDUy", "number": 501, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNDo1OFrOD0a8JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMTo1MzowM1rOD2-mCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjkzOTI1OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNDo1OFrOGJW-Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDoyNDo1OFrOGJW-Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ2NjY5NA==", "bodyText": "This isn't actually correct.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412466694", "createdAt": "2020-04-21T20:24:58Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -790,58 +777,63 @@ public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int\n         // case no data would be written to dsts. Lastly, even if no new data\n         // from srcs, could still have residual data in read_buf, so we should\n         // attempt to read from the ssl_fd.\n+        //\n+        // In order to handle large buffer sizes, wrap everything in a\n+        // do-while loop.\n \n-        // When we have data from src, write it to read_buf.\n-        if (wire_data > 0) {\n-            byte[] wire_buffer = new byte[wire_data];\n-            src.get(wire_buffer);\n-            int written = (int) Buffer.Write(read_buf, wire_buffer);\n+        // wire_data is the number of bytes from src we've written into\n+        // read_buf. This is bounded above by src.capcity but also the\n+        // free space left in read_buf to write to. Allows us to size the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6a918f6a12dc7de43cc1e4f757ae7e83b23a725"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzM2OTgwOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/PR.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjoxNjoyNlrOGJayaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjoxNjoyNlrOGJayaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUyOTI1Ng==", "bodyText": "Do we need a return statement after JSS_throwMsg()?", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412529256", "createdAt": "2020-04-21T22:16:26Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/PR.c", "diffHunk": "@@ -222,20 +224,31 @@ Java_org_mozilla_jss_nss_PR_Write(JNIEnv *env, jclass clazz, jobject fd,\n \n     PR_ASSERT(real_fd != NULL);\n \n-    real_length = (*env)->GetArrayLength(env, buf);\n-    if (real_length > INT_MAX) {\n-        max_length = INT_MAX;\n-    } else {\n-        max_length = (int)(real_length % INT_MAX);\n-    }\n+    if (buf != NULL) {\n+        real_length = (*env)->GetArrayLength(env, buf);\n+        if (real_length > INT_MAX) {\n+            max_length = INT_MAX;\n+        } else {\n+            max_length = (int)(real_length % INT_MAX);\n+        }\n \n-    buffer = (uint8_t*)((*env)->GetByteArrayElements(env, buf, NULL));\n-    if (buffer == NULL) {\n-        return 0;\n+        buffer = (uint8_t*)((*env)->GetByteArrayElements(env, buf, NULL));\n+        if (buffer == NULL && real_length == 0) {\n+            buffer = &dummy_buffer;\n+            max_length = 0;\n+        } else if (buffer == NULL && real_length > 0) {\n+            JSS_throwMsg(env, NULL_POINTER_EXCEPTION, \"Expected non-NULL byte array given non-zero length.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzQyOTMwOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/PR.c", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjozNToxN1rOGJbT3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjozNToxN1rOGJbT3w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzNzgyMw==", "bodyText": "According to the doc, GetByteArrayElements() will only return NULL if it fails, so I think the code should terminate immediately if buffer is NULL.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412537823", "createdAt": "2020-04-21T22:35:17Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/PR.c", "diffHunk": "@@ -222,20 +224,31 @@ Java_org_mozilla_jss_nss_PR_Write(JNIEnv *env, jclass clazz, jobject fd,\n \n     PR_ASSERT(real_fd != NULL);\n \n-    real_length = (*env)->GetArrayLength(env, buf);\n-    if (real_length > INT_MAX) {\n-        max_length = INT_MAX;\n-    } else {\n-        max_length = (int)(real_length % INT_MAX);\n-    }\n+    if (buf != NULL) {\n+        real_length = (*env)->GetArrayLength(env, buf);\n+        if (real_length > INT_MAX) {\n+            max_length = INT_MAX;\n+        } else {\n+            max_length = (int)(real_length % INT_MAX);\n+        }\n \n-    buffer = (uint8_t*)((*env)->GetByteArrayElements(env, buf, NULL));\n-    if (buffer == NULL) {\n-        return 0;\n+        buffer = (uint8_t*)((*env)->GetByteArrayElements(env, buf, NULL));\n+        if (buffer == NULL && real_length == 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzQzMjAzOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/PR.c", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMjozNjowM1rOGJbVUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzoyMjowMlrOGJ2HOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzODE5NA==", "bodyText": "This is an existing code, but the max length of a Java array is 2^31-1 (i.e. Integer.MAX_VALUE), which is the same as INT_MAX in C, is that correct? So this could be simplified into:\nbuffer_length = (*env)->GetArrayLength(env, buf);\n\nNo need to use real_length and max_length.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412538194", "createdAt": "2020-04-21T22:36:03Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/PR.c", "diffHunk": "@@ -222,20 +224,31 @@ Java_org_mozilla_jss_nss_PR_Write(JNIEnv *env, jclass clazz, jobject fd,\n \n     PR_ASSERT(real_fd != NULL);\n \n-    real_length = (*env)->GetArrayLength(env, buf);\n-    if (real_length > INT_MAX) {\n-        max_length = INT_MAX;\n-    } else {\n-        max_length = (int)(real_length % INT_MAX);\n-    }\n+    if (buf != NULL) {\n+        real_length = (*env)->GetArrayLength(env, buf);\n+        if (real_length > INT_MAX) {\n+            max_length = INT_MAX;\n+        } else {\n+            max_length = (int)(real_length % INT_MAX);\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk3Njk1NA==", "bodyText": "Ahh I was thinking jsize was #define ssize_t instead of jint.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r412976954", "createdAt": "2020-04-22T13:22:02Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/PR.c", "diffHunk": "@@ -222,20 +224,31 @@ Java_org_mozilla_jss_nss_PR_Write(JNIEnv *env, jclass clazz, jobject fd,\n \n     PR_ASSERT(real_fd != NULL);\n \n-    real_length = (*env)->GetArrayLength(env, buf);\n-    if (real_length > INT_MAX) {\n-        max_length = INT_MAX;\n-    } else {\n-        max_length = (int)(real_length % INT_MAX);\n-    }\n+    if (buf != NULL) {\n+        real_length = (*env)->GetArrayLength(env, buf);\n+        if (real_length > INT_MAX) {\n+            max_length = INT_MAX;\n+        } else {\n+            max_length = (int)(real_length % INT_MAX);\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUzODE5NA=="}, "originalCommit": {"oid": "6b9047b361886bdbaa0806c4107c01bf1d3b3833"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3Mzk5MDU2OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yM1QyMTowMzozN1rOGK8BVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxODo1MDo1N1rOGLk3ug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMjMyNQ==", "bodyText": "@edewata Can you think of anything more elegant for this? Or is adding a boolean flag and tracking it fine? Maybe I should split it into a updateHandshakePre() and a updateHandshakeState()? -- Pre only getting called once and State getting called only when actually handshaking? Hmm...", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r414122325", "createdAt": "2020-04-23T21:03:37Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -50,6 +50,7 @@\n \n     private int unknown_state_count;\n     private boolean step_handshake;\n+    private boolean returned_finished;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDc5MTYxMA==", "bodyText": "I don't really have an opinion on this. If it works then let's keep it :)\nWe can always refactor later if we find a better way.\nI've ACKed this PR, feel free to merge, but I'd prefer @jmagne to take a look at this as well, either before or after merging.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r414791610", "createdAt": "2020-04-24T18:50:57Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -50,6 +50,7 @@\n \n     private int unknown_state_count;\n     private boolean step_handshake;\n+    private boolean returned_finished;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDEyMjMyNQ=="}, "originalCommit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4OTc1MjQxOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMTo1MzowM1rOGM_Ddw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOFQwMzozMzoyOVrOGNBAbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI2OTE3NQ==", "bodyText": "I\"m assuming that this_src_write and ths_dst_write will eventually become exactly zero?", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r416269175", "createdAt": "2020-04-28T01:53:03Z", "author": {"login": "jmagne"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -811,58 +817,68 @@ public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int\n         // case no data would be written to dsts. Lastly, even if no new data\n         // from srcs, could still have residual data in read_buf, so we should\n         // attempt to read from the ssl_fd.\n+        //\n+        // In order to handle large buffer sizes, wrap everything in a\n+        // do-while loop.\n \n-        // When we have data from src, write it to read_buf.\n-        if (wire_data > 0) {\n-            byte[] wire_buffer = new byte[wire_data];\n-            src.get(wire_buffer);\n-            int written = (int) Buffer.Write(read_buf, wire_buffer);\n+        // wire_data is the number of bytes from src we've written into\n+        // read_buf.\n+        int wire_data = 0;\n \n-            // For safety: ensure everything we thought we could write was\n-            // actually written. Otherwise, we've done something wrong.\n-            wire_data = Math.min(wire_data, written);\n+        // Actual amount of data written to the buffer.\n+        int app_data = 0;\n \n-            // TODO: Determine if we should write the trail of wire_buffer\n-            // back to the front of src... Seems like unnecessary work.\n-            debug(\"JSSEngine.unwrap(): Wrote \" + wire_data + \" bytes to read_buf.\");\n-        }\n+        int this_src_write;\n+        int this_dst_write;\n \n-        // In the above, we should always try to read and write data. Check to\n-        // see if we need to step our handshake process or not.\n-        updateHandshakeState();\n+        do {\n+            this_src_write = 0;\n+            this_dst_write = 0;\n \n-        // Actual amount of data written to the buffer.\n-        int app_data = 0;\n+            if (src != null) {\n+                this_src_write = Math.min((int) Buffer.WriteCapacity(read_buf), src.remaining());\n+\n+                // When we have data from src, write it to read_buf.\n+                if (this_src_write > 0) {\n+                    byte[] wire_buffer = new byte[this_src_write];\n+                    src.get(wire_buffer);\n \n-        // Maximum theoretical amount of data we could've written to the\n-        // destination. This is bounded by the lower of both the size of\n-        // our dsts and the maximum BUFFER_SIZE. Worst case, we'll be forced\n-        // to call unwrap(...) multiple times.\n-        int max_app_data = Math.min(computeSize(dsts, offset, length), BUFFER_SIZE);\n-\n-        // When we have app data to write over the network, go ahead and do\n-        // so. This involves reading from ssl_fd and writing to dsts. We don't\n-        // currently have a good proxy metric for \"can read from a ssl_fd\",\n-        // so always attempt it. In particular, even if the handshake isn't\n-        // finished, we still need to call PR.Read(...) or PR.Write(...) in\n-        // order to tell if an inbound alert was received.\n-        if (max_app_data > 0) {\n-            byte[] app_buffer = PR.Read(ssl_fd, max_app_data);\n-            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(PR.GetError()));\n+                    this_src_write = (int) Buffer.Write(read_buf, wire_buffer);\n+\n+                    wire_data += this_src_write;\n+                    debug(\"JSSEngine.unwrap(): Wrote \" + this_src_write + \" bytes to read_buf.\");\n+                }\n+            }\n+\n+            // In the above, we should always try to read and write data. Check to\n+            // see if we need to step our handshake process or not.\n+            updateHandshakeState();\n+\n+            int max_dst_size = computeSize(dsts, offset, length);\n+            byte[] app_buffer = PR.Read(ssl_fd, max_dst_size);\n+            int error = PR.GetError();\n+            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(error));\n             if (app_buffer != null) {\n-                app_data = putData(app_buffer, dsts, offset, length);\n-            } else {\n-                int error = PR.GetError();\n-                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR) {\n+                this_dst_write = putData(app_buffer, dsts, offset, length);\n+                app_data += this_dst_write;\n+            } else if (max_dst_size > 0) {\n+                // There are two scenarios we need to ignore here:\n+                //  1. WOULD_BLOCK_ERRORs are safe, because we're expecting\n+                //     not to block. Usually this means we don't have space\n+                //     to write any more data.\n+                //  2. SOCKET_SHUTDOWN_ERRORs are safe, because if the\n+                //     underling cause was fatal, we'd catch it after exiting\n+                //     the do-while loop, in checkSSLAlerts().\n+                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR && error != PRErrors.SOCKET_SHUTDOWN_ERROR) {\n                     ssl_exception = new SSLException(\"Unexpected return from PR.Read(): \" + errorText(error));\n                     seen_exception = true;\n                 }\n             }\n+        } while (this_src_write != 0 || this_dst_write != 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjMwMTE2NA==", "bodyText": "Yeah, I need to update the docs pr (#428) with this. But the theory is this: Let's take wrap as an example. We need to take data from src and put it into dst if the handshake has finished. Otherwise if we're still handshaking we need to take whatever handshake data is made and puts it into dst.\nSo let's take the handshaking scenario:\n\nWe'll be ignoring src because PR.Write(...) will fail until the handshake is complete.\nSo UpdateHandshakeState() will write data into the write buffer.\nWe'll drain data from the read buffer and write it into dst.\n\nDuring this:\n\nthis_src_write will be 0 because PR.Write(...) returns 0 / PR_WOULD_BLOCK until handshake completes.\nWhile we're still handshaking in this step, UpdateHandshakeState() will write into the read buffer, which then goes into dst, incrementing this_dst_write.\nWhen we run out of handshake data to write, UpdateHandshakeState() will quit writing data (and return PR_WOULD_BLOCK) and this_dst_write will go to data as the write buffer will be empty.\n\n\nA similar thing applies when src is non-empty and we're not handshaking:\n\nWe'll be writing from src into the SSL PRFileDesc *. PR.Write(...) returns number of bytes written which ends up into this_src_write. As long as we're still writing data (and not getting an error / PR_WOULD_BLOCK), this'll be non-zero. It'll also continue being non-zero while there's space in the write buffer. However, this write buffer gets cleared out by the last step...\nUpdateHandshakeState() will return, a no-op because we're not handshaking.\nWhen there's src data and PR.Write() succeeds, there'll be data in the write buffer so we'll be able to put it in dst and this_dst_write will be non-zero. Otherwise, if src fails, this_src_write becomes 0 and there'll be nothing in the write buffer so this_dst_write will go to 0 as well.\n\n\nIn all helper methods, we guarantee that on error, 0 is returned instead of a less than zero value.\n\nIn both cases, when we run out of handshake and/or src data, we'll quit writing to the write buffer and this_dst_write will eventually go to 0 as well.", "url": "https://github.com/dogtagpki/jss/pull/501#discussion_r416301164", "createdAt": "2020-04-28T03:33:29Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -811,58 +817,68 @@ public SSLEngineResult unwrap(ByteBuffer src, ByteBuffer[] dsts, int offset, int\n         // case no data would be written to dsts. Lastly, even if no new data\n         // from srcs, could still have residual data in read_buf, so we should\n         // attempt to read from the ssl_fd.\n+        //\n+        // In order to handle large buffer sizes, wrap everything in a\n+        // do-while loop.\n \n-        // When we have data from src, write it to read_buf.\n-        if (wire_data > 0) {\n-            byte[] wire_buffer = new byte[wire_data];\n-            src.get(wire_buffer);\n-            int written = (int) Buffer.Write(read_buf, wire_buffer);\n+        // wire_data is the number of bytes from src we've written into\n+        // read_buf.\n+        int wire_data = 0;\n \n-            // For safety: ensure everything we thought we could write was\n-            // actually written. Otherwise, we've done something wrong.\n-            wire_data = Math.min(wire_data, written);\n+        // Actual amount of data written to the buffer.\n+        int app_data = 0;\n \n-            // TODO: Determine if we should write the trail of wire_buffer\n-            // back to the front of src... Seems like unnecessary work.\n-            debug(\"JSSEngine.unwrap(): Wrote \" + wire_data + \" bytes to read_buf.\");\n-        }\n+        int this_src_write;\n+        int this_dst_write;\n \n-        // In the above, we should always try to read and write data. Check to\n-        // see if we need to step our handshake process or not.\n-        updateHandshakeState();\n+        do {\n+            this_src_write = 0;\n+            this_dst_write = 0;\n \n-        // Actual amount of data written to the buffer.\n-        int app_data = 0;\n+            if (src != null) {\n+                this_src_write = Math.min((int) Buffer.WriteCapacity(read_buf), src.remaining());\n+\n+                // When we have data from src, write it to read_buf.\n+                if (this_src_write > 0) {\n+                    byte[] wire_buffer = new byte[this_src_write];\n+                    src.get(wire_buffer);\n \n-        // Maximum theoretical amount of data we could've written to the\n-        // destination. This is bounded by the lower of both the size of\n-        // our dsts and the maximum BUFFER_SIZE. Worst case, we'll be forced\n-        // to call unwrap(...) multiple times.\n-        int max_app_data = Math.min(computeSize(dsts, offset, length), BUFFER_SIZE);\n-\n-        // When we have app data to write over the network, go ahead and do\n-        // so. This involves reading from ssl_fd and writing to dsts. We don't\n-        // currently have a good proxy metric for \"can read from a ssl_fd\",\n-        // so always attempt it. In particular, even if the handshake isn't\n-        // finished, we still need to call PR.Read(...) or PR.Write(...) in\n-        // order to tell if an inbound alert was received.\n-        if (max_app_data > 0) {\n-            byte[] app_buffer = PR.Read(ssl_fd, max_app_data);\n-            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(PR.GetError()));\n+                    this_src_write = (int) Buffer.Write(read_buf, wire_buffer);\n+\n+                    wire_data += this_src_write;\n+                    debug(\"JSSEngine.unwrap(): Wrote \" + this_src_write + \" bytes to read_buf.\");\n+                }\n+            }\n+\n+            // In the above, we should always try to read and write data. Check to\n+            // see if we need to step our handshake process or not.\n+            updateHandshakeState();\n+\n+            int max_dst_size = computeSize(dsts, offset, length);\n+            byte[] app_buffer = PR.Read(ssl_fd, max_dst_size);\n+            int error = PR.GetError();\n+            debug(\"JSSEngine.unwrap() - \" + app_buffer + \" error=\" + errorText(error));\n             if (app_buffer != null) {\n-                app_data = putData(app_buffer, dsts, offset, length);\n-            } else {\n-                int error = PR.GetError();\n-                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR) {\n+                this_dst_write = putData(app_buffer, dsts, offset, length);\n+                app_data += this_dst_write;\n+            } else if (max_dst_size > 0) {\n+                // There are two scenarios we need to ignore here:\n+                //  1. WOULD_BLOCK_ERRORs are safe, because we're expecting\n+                //     not to block. Usually this means we don't have space\n+                //     to write any more data.\n+                //  2. SOCKET_SHUTDOWN_ERRORs are safe, because if the\n+                //     underling cause was fatal, we'd catch it after exiting\n+                //     the do-while loop, in checkSSLAlerts().\n+                if (error != 0 && error != PRErrors.WOULD_BLOCK_ERROR && error != PRErrors.SOCKET_SHUTDOWN_ERROR) {\n                     ssl_exception = new SSLException(\"Unexpected return from PR.Read(): \" + errorText(error));\n                     seen_exception = true;\n                 }\n             }\n+        } while (this_src_write != 0 || this_dst_write != 0);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjI2OTE3NQ=="}, "originalCommit": {"oid": "bebee6d0183a04f6118236b9bfdbd3c3e3aeefb2"}, "originalPosition": 163}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2621, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}