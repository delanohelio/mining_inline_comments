{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg0MTQxMjAw", "number": 633, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoxNTo0OVrOEiPJMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoxNTo0OVrOEiPJMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0MzM1MTUyOnYy", "diffSide": "RIGHT", "path": "docs/usage/cryptomanager.md", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQxODoxNTo0OVrOHQAHzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMFQyMDoyNzoxMVrOHQEipg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MTI2Mw==", "bodyText": "I'm thinking eventually we might do something like this:\nJSSProvider provider = (JSSProvider) Security.getProvider(\"Mozilla-JSS\");\nCryptoManager cm = provider.getCryptoManager();\n\nand deprecate/drop CryptoManager.getInstance(). Or maybe even replace CryptoManager with JSSProvider.", "url": "https://github.com/dogtagpki/jss/pull/633#discussion_r486541263", "createdAt": "2020-09-10T18:15:49Z", "author": {"login": "edewata"}, "path": "docs/usage/cryptomanager.md", "diffHunk": "@@ -0,0 +1,156 @@\n+# `CryptoManager`\n+\n+## Design\n+\n+### `CryptoManager`, `JSSProvider`, and `JSSLoader` interactions\n+\n+`CryptoManager` is the central singleton of JSS. It controls access to the\n+NSS database and an instance (available to developers via the\n+`CryptoManager.getInstance()` call) signals that both JSS and NSS are properly\n+initialized. The existing relationship between `CryptoManager` and\n+`JSSProvider` is that a single `CryptoManager` instance has a single\n+`JSSProvider` instance, and moreso that the reverse is also true: the\n+`JSSProvider` instance has a single `CryptoManager` instance. Currently the\n+code assumes that there is only ever one `CryptoManager` instance, making\n+both singletons.\n+\n+_Aside:_\n+\n+> Future work could be done to enable either multiple `CryptoManager` instances\n+> with separate NSS DBs, or to enable multiple `JSSProvider` instances to\n+> reference one or more `CryptoManager` instances during normal operation.\n+> This currently will require significant restructuring as many internal\n+> provider methods (such as `Cipher`, `Signature` and others) get the global\n+> singleton instance directly (via `CryptoManager.getInstance()`).\n+>\n+> Additionally, NSS provides the option to load multiple NSS DBs into the\n+> current instance, which might satisfy the use case of multiple\n+> `CryptoManager` instances as well.\n+\n+---\n+\n+However, the existence of `JSSLoader` and subsequently allowing JSS to load\n+via the standard provider `java.security` file has complicated this slightly,\n+to enable new use cases for JSS.\n+\n+Take the following code snippet for instance:\n+\n+```java\n+import org.mozilla.jss.CryptoManager;\n+\n+public class Example {\n+  public static void main(String[] args) throws Exception {\n+    CryptoManager cm = CryptoManager.getInstance();\n+    // Additional code elided.\n+  }\n+}\n+```\n+\n+When used with JSS loaded via `java.security` override, the developer would\n+rightly expect that JSS will load first, allowing `CryptoManager` to return\n+a valid instance.\n+\n+In order to facilitate this however, when the internal `instance` field is\n+`NULL`, JSS must first try to load itself via the Provider interface. That is,\n+it needs to do something akin to:\n+\n+```java\n+java.security.Provider p = Security.getProvider(\"Mozilla-JSS\");\n+```\n+\n+in order to force Java to attempt to load JSS. Any equivalent call into the\n+Java security interface would also suffice (such as\n+`Signature.getInstance(algo, \"Mozilla-JSS\")`), but this call limits the size\n+of the resulting object and makes clear the intent.\n+\n+_Aside:_\n+\n+> This becomes a touch tricky though. In particular, `CryptoManager.instance`\n+> access is usually locked, to prevent modification by one thread while\n+> another is reading it. This is locked at the class level (via a\n+> `synchronized (CryptoManager.class)` statement explicitly or implicitly\n+> in the synchronized `initialize()` method). So, inside `getInstance()`, we\n+> explicitly acquire the lock to check the value of `instance`, release it for\n+> the provider call -- in case it loads JSS from the provider interface --\n+> and then explicitly re-acquire it to return the value. This should help to\n+> prevent race conditions and returning a partially-initialized\n+> `CryptoManager` instance before it is fully ready.\n+\n+Otherwise, the call will fail and we'd require code changes, such as:\n+\n+```java\n+import java.security.*;\n+\n+import org.mozilla.jss.CryptoManager;\n+\n+public class Example {\n+  public static void main(String[] args) throws Exception {\n+    Provider p = Security.getProvider(\"Mozilla-JSS\");\n+    CryptoManager cm = CryptoManager.getInstance();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c2c44d557868c9356eaf508ab874bedc03a96bc8"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMjY3MA==", "bodyText": "I think neither of these are quite right. If I were to make these changes (they're big, time-consuming and not immediately clear what the benefit is), I'd probably:\n\nMake JSSProvider load out of a config file, keep state internally.\nMake CryptoManager an internal implementation detail and have it correlate to exactly one NSS DB. It will back-end the KeyStoreSpi and TrustStoreSpi code. Instances will be singleton-per-NSS-DB and stored/cached on the associated JSSProvider instance for use throughout the JCA.\nDrop all non-JCA interfaces when duplicated by JCA interfaces.\nMake JCA interfaces both compatible with SunJSSE/... and more compliant. I'd like to see keys &c interop when possible and other improvements.\nMake things like .p12 and java key bundles work and create a new temporary NSS DB which they get imported into.\n\nBut, who knows. :-)", "url": "https://github.com/dogtagpki/jss/pull/633#discussion_r486602670", "createdAt": "2020-09-10T20:05:36Z", "author": {"login": "cipherboy"}, "path": "docs/usage/cryptomanager.md", "diffHunk": "@@ -0,0 +1,156 @@\n+# `CryptoManager`\n+\n+## Design\n+\n+### `CryptoManager`, `JSSProvider`, and `JSSLoader` interactions\n+\n+`CryptoManager` is the central singleton of JSS. It controls access to the\n+NSS database and an instance (available to developers via the\n+`CryptoManager.getInstance()` call) signals that both JSS and NSS are properly\n+initialized. The existing relationship between `CryptoManager` and\n+`JSSProvider` is that a single `CryptoManager` instance has a single\n+`JSSProvider` instance, and moreso that the reverse is also true: the\n+`JSSProvider` instance has a single `CryptoManager` instance. Currently the\n+code assumes that there is only ever one `CryptoManager` instance, making\n+both singletons.\n+\n+_Aside:_\n+\n+> Future work could be done to enable either multiple `CryptoManager` instances\n+> with separate NSS DBs, or to enable multiple `JSSProvider` instances to\n+> reference one or more `CryptoManager` instances during normal operation.\n+> This currently will require significant restructuring as many internal\n+> provider methods (such as `Cipher`, `Signature` and others) get the global\n+> singleton instance directly (via `CryptoManager.getInstance()`).\n+>\n+> Additionally, NSS provides the option to load multiple NSS DBs into the\n+> current instance, which might satisfy the use case of multiple\n+> `CryptoManager` instances as well.\n+\n+---\n+\n+However, the existence of `JSSLoader` and subsequently allowing JSS to load\n+via the standard provider `java.security` file has complicated this slightly,\n+to enable new use cases for JSS.\n+\n+Take the following code snippet for instance:\n+\n+```java\n+import org.mozilla.jss.CryptoManager;\n+\n+public class Example {\n+  public static void main(String[] args) throws Exception {\n+    CryptoManager cm = CryptoManager.getInstance();\n+    // Additional code elided.\n+  }\n+}\n+```\n+\n+When used with JSS loaded via `java.security` override, the developer would\n+rightly expect that JSS will load first, allowing `CryptoManager` to return\n+a valid instance.\n+\n+In order to facilitate this however, when the internal `instance` field is\n+`NULL`, JSS must first try to load itself via the Provider interface. That is,\n+it needs to do something akin to:\n+\n+```java\n+java.security.Provider p = Security.getProvider(\"Mozilla-JSS\");\n+```\n+\n+in order to force Java to attempt to load JSS. Any equivalent call into the\n+Java security interface would also suffice (such as\n+`Signature.getInstance(algo, \"Mozilla-JSS\")`), but this call limits the size\n+of the resulting object and makes clear the intent.\n+\n+_Aside:_\n+\n+> This becomes a touch tricky though. In particular, `CryptoManager.instance`\n+> access is usually locked, to prevent modification by one thread while\n+> another is reading it. This is locked at the class level (via a\n+> `synchronized (CryptoManager.class)` statement explicitly or implicitly\n+> in the synchronized `initialize()` method). So, inside `getInstance()`, we\n+> explicitly acquire the lock to check the value of `instance`, release it for\n+> the provider call -- in case it loads JSS from the provider interface --\n+> and then explicitly re-acquire it to return the value. This should help to\n+> prevent race conditions and returning a partially-initialized\n+> `CryptoManager` instance before it is fully ready.\n+\n+Otherwise, the call will fail and we'd require code changes, such as:\n+\n+```java\n+import java.security.*;\n+\n+import org.mozilla.jss.CryptoManager;\n+\n+public class Example {\n+  public static void main(String[] args) throws Exception {\n+    Provider p = Security.getProvider(\"Mozilla-JSS\");\n+    CryptoManager cm = CryptoManager.getInstance();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MTI2Mw=="}, "originalCommit": {"oid": "c2c44d557868c9356eaf508ab874bedc03a96bc8"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMTk2NQ==", "bodyText": "Most of the magic also occurs in the \"more compliant\" and \"compatible\" steps -- which the rest isn't necessary for and could be done now. The benefit of the restructuring is that it would let us do the .p12/jks stuff, which isn't as likely to work well otherwise as you can't control where keys come from as easily. So I think it is unlikely this restructuring is likely to occur now.", "url": "https://github.com/dogtagpki/jss/pull/633#discussion_r486611965", "createdAt": "2020-09-10T20:24:03Z", "author": {"login": "cipherboy"}, "path": "docs/usage/cryptomanager.md", "diffHunk": "@@ -0,0 +1,156 @@\n+# `CryptoManager`\n+\n+## Design\n+\n+### `CryptoManager`, `JSSProvider`, and `JSSLoader` interactions\n+\n+`CryptoManager` is the central singleton of JSS. It controls access to the\n+NSS database and an instance (available to developers via the\n+`CryptoManager.getInstance()` call) signals that both JSS and NSS are properly\n+initialized. The existing relationship between `CryptoManager` and\n+`JSSProvider` is that a single `CryptoManager` instance has a single\n+`JSSProvider` instance, and moreso that the reverse is also true: the\n+`JSSProvider` instance has a single `CryptoManager` instance. Currently the\n+code assumes that there is only ever one `CryptoManager` instance, making\n+both singletons.\n+\n+_Aside:_\n+\n+> Future work could be done to enable either multiple `CryptoManager` instances\n+> with separate NSS DBs, or to enable multiple `JSSProvider` instances to\n+> reference one or more `CryptoManager` instances during normal operation.\n+> This currently will require significant restructuring as many internal\n+> provider methods (such as `Cipher`, `Signature` and others) get the global\n+> singleton instance directly (via `CryptoManager.getInstance()`).\n+>\n+> Additionally, NSS provides the option to load multiple NSS DBs into the\n+> current instance, which might satisfy the use case of multiple\n+> `CryptoManager` instances as well.\n+\n+---\n+\n+However, the existence of `JSSLoader` and subsequently allowing JSS to load\n+via the standard provider `java.security` file has complicated this slightly,\n+to enable new use cases for JSS.\n+\n+Take the following code snippet for instance:\n+\n+```java\n+import org.mozilla.jss.CryptoManager;\n+\n+public class Example {\n+  public static void main(String[] args) throws Exception {\n+    CryptoManager cm = CryptoManager.getInstance();\n+    // Additional code elided.\n+  }\n+}\n+```\n+\n+When used with JSS loaded via `java.security` override, the developer would\n+rightly expect that JSS will load first, allowing `CryptoManager` to return\n+a valid instance.\n+\n+In order to facilitate this however, when the internal `instance` field is\n+`NULL`, JSS must first try to load itself via the Provider interface. That is,\n+it needs to do something akin to:\n+\n+```java\n+java.security.Provider p = Security.getProvider(\"Mozilla-JSS\");\n+```\n+\n+in order to force Java to attempt to load JSS. Any equivalent call into the\n+Java security interface would also suffice (such as\n+`Signature.getInstance(algo, \"Mozilla-JSS\")`), but this call limits the size\n+of the resulting object and makes clear the intent.\n+\n+_Aside:_\n+\n+> This becomes a touch tricky though. In particular, `CryptoManager.instance`\n+> access is usually locked, to prevent modification by one thread while\n+> another is reading it. This is locked at the class level (via a\n+> `synchronized (CryptoManager.class)` statement explicitly or implicitly\n+> in the synchronized `initialize()` method). So, inside `getInstance()`, we\n+> explicitly acquire the lock to check the value of `instance`, release it for\n+> the provider call -- in case it loads JSS from the provider interface --\n+> and then explicitly re-acquire it to return the value. This should help to\n+> prevent race conditions and returning a partially-initialized\n+> `CryptoManager` instance before it is fully ready.\n+\n+Otherwise, the call will fail and we'd require code changes, such as:\n+\n+```java\n+import java.security.*;\n+\n+import org.mozilla.jss.CryptoManager;\n+\n+public class Example {\n+  public static void main(String[] args) throws Exception {\n+    Provider p = Security.getProvider(\"Mozilla-JSS\");\n+    CryptoManager cm = CryptoManager.getInstance();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MTI2Mw=="}, "originalCommit": {"oid": "c2c44d557868c9356eaf508ab874bedc03a96bc8"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYxMzY3MA==", "bodyText": "+1 to all of the above. There might be no major immediate benefit, but I think whenever we make modifications we should do it with these goals in mind. That way we won't accumulate a huge technical debt when we have an actual requirement that depends on this in the future.", "url": "https://github.com/dogtagpki/jss/pull/633#discussion_r486613670", "createdAt": "2020-09-10T20:27:11Z", "author": {"login": "edewata"}, "path": "docs/usage/cryptomanager.md", "diffHunk": "@@ -0,0 +1,156 @@\n+# `CryptoManager`\n+\n+## Design\n+\n+### `CryptoManager`, `JSSProvider`, and `JSSLoader` interactions\n+\n+`CryptoManager` is the central singleton of JSS. It controls access to the\n+NSS database and an instance (available to developers via the\n+`CryptoManager.getInstance()` call) signals that both JSS and NSS are properly\n+initialized. The existing relationship between `CryptoManager` and\n+`JSSProvider` is that a single `CryptoManager` instance has a single\n+`JSSProvider` instance, and moreso that the reverse is also true: the\n+`JSSProvider` instance has a single `CryptoManager` instance. Currently the\n+code assumes that there is only ever one `CryptoManager` instance, making\n+both singletons.\n+\n+_Aside:_\n+\n+> Future work could be done to enable either multiple `CryptoManager` instances\n+> with separate NSS DBs, or to enable multiple `JSSProvider` instances to\n+> reference one or more `CryptoManager` instances during normal operation.\n+> This currently will require significant restructuring as many internal\n+> provider methods (such as `Cipher`, `Signature` and others) get the global\n+> singleton instance directly (via `CryptoManager.getInstance()`).\n+>\n+> Additionally, NSS provides the option to load multiple NSS DBs into the\n+> current instance, which might satisfy the use case of multiple\n+> `CryptoManager` instances as well.\n+\n+---\n+\n+However, the existence of `JSSLoader` and subsequently allowing JSS to load\n+via the standard provider `java.security` file has complicated this slightly,\n+to enable new use cases for JSS.\n+\n+Take the following code snippet for instance:\n+\n+```java\n+import org.mozilla.jss.CryptoManager;\n+\n+public class Example {\n+  public static void main(String[] args) throws Exception {\n+    CryptoManager cm = CryptoManager.getInstance();\n+    // Additional code elided.\n+  }\n+}\n+```\n+\n+When used with JSS loaded via `java.security` override, the developer would\n+rightly expect that JSS will load first, allowing `CryptoManager` to return\n+a valid instance.\n+\n+In order to facilitate this however, when the internal `instance` field is\n+`NULL`, JSS must first try to load itself via the Provider interface. That is,\n+it needs to do something akin to:\n+\n+```java\n+java.security.Provider p = Security.getProvider(\"Mozilla-JSS\");\n+```\n+\n+in order to force Java to attempt to load JSS. Any equivalent call into the\n+Java security interface would also suffice (such as\n+`Signature.getInstance(algo, \"Mozilla-JSS\")`), but this call limits the size\n+of the resulting object and makes clear the intent.\n+\n+_Aside:_\n+\n+> This becomes a touch tricky though. In particular, `CryptoManager.instance`\n+> access is usually locked, to prevent modification by one thread while\n+> another is reading it. This is locked at the class level (via a\n+> `synchronized (CryptoManager.class)` statement explicitly or implicitly\n+> in the synchronized `initialize()` method). So, inside `getInstance()`, we\n+> explicitly acquire the lock to check the value of `instance`, release it for\n+> the provider call -- in case it loads JSS from the provider interface --\n+> and then explicitly re-acquire it to return the value. This should help to\n+> prevent race conditions and returning a partially-initialized\n+> `CryptoManager` instance before it is fully ready.\n+\n+Otherwise, the call will fail and we'd require code changes, such as:\n+\n+```java\n+import java.security.*;\n+\n+import org.mozilla.jss.CryptoManager;\n+\n+public class Example {\n+  public static void main(String[] args) throws Exception {\n+    Provider p = Security.getProvider(\"Mozilla-JSS\");\n+    CryptoManager cm = CryptoManager.getInstance();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU0MTI2Mw=="}, "originalCommit": {"oid": "c2c44d557868c9356eaf508ab874bedc03a96bc8"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2602, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}