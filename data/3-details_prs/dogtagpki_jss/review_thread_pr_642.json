{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMzc2MTU3", "number": 642, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjo1Njo1MlrOEsCVyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToxODowOFrOEygzzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjExMTQ0OnYy", "diffSide": "RIGHT", "path": "jss.spec", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjo1Njo1MlrOHfIjSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNToyNToxNlrOHfOmkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwODAxMQ==", "bodyText": "Please don't remove testing from jss.spec? :'(", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502408011", "createdAt": "2020-10-09T12:56:52Z", "author": {"login": "cipherboy"}, "path": "jss.spec", "diffHunk": "@@ -117,7 +117,7 @@ modutil -dbdir /etc/pki/nssdb -chkfips true | grep -q enabled && export FIPS_ENA\n cd %{_vpath_builddir}\n %{__make} all\n %{__make} javadoc\n-ctest --output-on-failure\n+#ctest --output-on-failure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUwNzE1Mw==", "bodyText": "Sorry, didn't mean to commit this - was just making the build speed up :-)", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502507153", "createdAt": "2020-10-09T15:25:16Z", "author": {"login": "frasertweedale"}, "path": "jss.spec", "diffHunk": "@@ -117,7 +117,7 @@ modutil -dbdir /etc/pki/nssdb -chkfips true | grep -q enabled && export FIPS_ENA\n cd %{_vpath_builddir}\n %{__make} all\n %{__make} javadoc\n-ctest --output-on-failure\n+#ctest --output-on-failure", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwODAxMQ=="}, "originalCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE0NjEzMzk4OnYy", "diffSide": "LEFT", "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMzowMzowN1rOHfIxWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxNTozNjoyNFrOHfPChA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQxMTYxMA==", "bodyText": "I wouldn't do this either.\nWe've discussed this with @edewata earlier. See #532, and #532 (comment).\nAs I understand more about this architecture... a Socket is either a blocking or non-blocking file descriptor, but a SocketChannel is non-blocking. Only in the event that a Socket is blocking will a SocketChannel be created.\nIn JSS we abuse this slightly. We use the JSSSocket as the front to SSL operations, but in order to \"do\" SSL, we use the JSSSocketChannel as an intermediary between the JSSSocket and the JSSEngine.\nNote that callers using a SocketChannel are mostly expected to do SSL operations themselves directly with a SSLEngine. There's no relevant methods in the standard to upcast a SocketChannel into a SSLSocketChannel.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502411610", "createdAt": "2020-10-09T13:03:07Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -234,10 +234,6 @@ public JSSEngine getEngine() {\n      * @see java.net.Socket#getChannel()\n      */\n     public JSSSocketChannel getChannel() {\n-        if (parent.getChannel() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUxMDYzNw==", "bodyText": "(IOW, it is tempting to grab the underlying JSSSocketChannel, but if you truly want non-blocking sockets, you should create a non-blocking socket to begin with...)", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502510637", "createdAt": "2020-10-09T15:30:21Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -234,10 +234,6 @@ public JSSEngine getEngine() {\n      * @see java.net.Socket#getChannel()\n      */\n     public JSSSocketChannel getChannel() {\n-        if (parent.getChannel() == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQxMTYxMA=="}, "originalCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjUxNDMwOA==", "bodyText": "OK, sure, I can drop this bit.  I added this because I first encountered this bug using the InputStream/OutputStream interface, then switched to channels to see if that helped (and that's when I made ^ that change).\nThe bug still occurs when using the InputStream/OutputStream because we hang those streams off the channel: https://github.com/dogtagpki/jss/blob/aa68098/org/mozilla/jss/ssl/javax/JSSSocket.java#L265-L284 :)", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502514308", "createdAt": "2020-10-09T15:36:24Z", "author": {"login": "frasertweedale"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -234,10 +234,6 @@ public JSSEngine getEngine() {\n      * @see java.net.Socket#getChannel()\n      */\n     public JSSSocketChannel getChannel() {\n-        if (parent.getChannel() == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQxMTYxMA=="}, "originalCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwMTE2NTMyOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1OToxMFrOHnWDBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQxNToyMDo0OFrOHnydJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNzczMg==", "bodyText": "I think the same applies for write, no? We should shutdown output if the engine reports closed?", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r511017732", "createdAt": "2020-10-23T16:59:10Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;\n+                    }\n                 }\n \n                 readBuffer.flip();\n \n-                SSLEngineResult result = engine.unwrap(readBuffer, dsts, offset, length);\n-                if (result.getStatus() != SSLEngineResult.Status.OK &&\n-                    result.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW &&\n-                    result.getStatus() != SSLEngineResult.Status.CLOSED) {\n-                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                result = engine.unwrap(readBuffer, dsts, offset, length);\n+                switch (result.getStatus()) {\n+                    case CLOSED:\n+                        shutdownInput();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTI2OTAyNA==", "bodyText": "@cipherboy probably?  Would you be willing to investigate and, if necessary, deal with that in a separate patch?", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r511269024", "createdAt": "2020-10-24T02:39:23Z", "author": {"login": "frasertweedale"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;\n+                    }\n                 }\n \n                 readBuffer.flip();\n \n-                SSLEngineResult result = engine.unwrap(readBuffer, dsts, offset, length);\n-                if (result.getStatus() != SSLEngineResult.Status.OK &&\n-                    result.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW &&\n-                    result.getStatus() != SSLEngineResult.Status.CLOSED) {\n-                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                result = engine.unwrap(readBuffer, dsts, offset, length);\n+                switch (result.getStatus()) {\n+                    case CLOSED:\n+                        shutdownInput();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNzczMg=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTQ4MzE3Mg==", "bodyText": "Sure, I can do that.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r511483172", "createdAt": "2020-10-24T15:20:48Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;\n+                    }\n                 }\n \n                 readBuffer.flip();\n \n-                SSLEngineResult result = engine.unwrap(readBuffer, dsts, offset, length);\n-                if (result.getStatus() != SSLEngineResult.Status.OK &&\n-                    result.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW &&\n-                    result.getStatus() != SSLEngineResult.Status.CLOSED) {\n-                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                result = engine.unwrap(readBuffer, dsts, offset, length);\n+                switch (result.getStatus()) {\n+                    case CLOSED:\n+                        shutdownInput();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNzczMg=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODExNDc4OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNDo1M1rOHoUbOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QwNzowNDo0MlrOHot0HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzOTczOQ==", "bodyText": "According to https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ReadableByteChannel.html, 0 is a valid return result and we should probably set consumed and consumedChannel to null in both cases.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512039739", "createdAt": "2020-10-26T15:14:53Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -86,33 +88,28 @@ public void setAutoClose(boolean on) {\n         autoClose = on;\n     }\n \n-    /**\n-     * Internal helper to bound the size of a blocking read to the maximum\n-     * data available.\n-     */\n-    private int boundRead(int suggested) throws IOException {\n-        // When there's consumed data left to read, ensure we bound by the\n-        // amount available there before continuing.\n-        if (consumed != null && consumed.available() > 0) {\n-            return Math.min(consumed.available(), suggested);\n-        }\n-\n-        // By setting consumed = null when consumed no longer has bytes\n-        // available, we provide an easy check for which channel to read\n-        // from.\n-        consumed = null;\n-        consumedChannel = null;\n-\n-        // If its a non-blocking underlying socket, then return suggested;\n-        // it'll read as much as currently available.\n-        if (!isBlocking()) {\n-            return suggested;\n+    private int remoteRead() throws IOException {\n+        if (consumed != null) {\n+            int n = consumedChannel.read(readBuffer);\n+            if (n < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ1NTcwOQ==", "bodyText": "0 is indeed a valid return value.  It means that zero bytes were read.  It doesn't mean end of stream was reached, so I think it's wrong to discard the consumedChannel in this case.\nBased on consumedChannel = Channels.newChannel(InputStream consumed), return value of 0 seems to be a \"can't happen\" and therefore your proposal is (vacuously) safe.  But I'd rather code to the interface than rely on these implementation details.\nIf you still feel strongly we sohuld change it, I will change it and add some commentary.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512455709", "createdAt": "2020-10-27T07:04:42Z", "author": {"login": "frasertweedale"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -86,33 +88,28 @@ public void setAutoClose(boolean on) {\n         autoClose = on;\n     }\n \n-    /**\n-     * Internal helper to bound the size of a blocking read to the maximum\n-     * data available.\n-     */\n-    private int boundRead(int suggested) throws IOException {\n-        // When there's consumed data left to read, ensure we bound by the\n-        // amount available there before continuing.\n-        if (consumed != null && consumed.available() > 0) {\n-            return Math.min(consumed.available(), suggested);\n-        }\n-\n-        // By setting consumed = null when consumed no longer has bytes\n-        // available, we provide an easy check for which channel to read\n-        // from.\n-        consumed = null;\n-        consumedChannel = null;\n-\n-        // If its a non-blocking underlying socket, then return suggested;\n-        // it'll read as much as currently available.\n-        if (!isBlocking()) {\n-            return suggested;\n+    private int remoteRead() throws IOException {\n+        if (consumed != null) {\n+            int n = consumedChannel.read(readBuffer);\n+            if (n < 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzOTczOQ=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwODIwMjkxOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozMjozOVrOHoVSTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDo0NTo0N1rOHptwRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg==", "bodyText": "I'm not sure I agree with this.\nWhen decrypted > 0, we obviously return decrypted.\nHowever, in the case where decrypted <= 0 (really, it must be 0), the contract of our read() call is the number of bytes decrypted, which is 0. It isn't the number of bytes read from the remote peer.\nThe best example of this is during handshake: read during handshake returns 0 if no data is present -- not because no wire data was transferred (there presumably might have been) -- but because none of it resulted in any decryptable data. (Ignoring 0RTT).\nIMO, since decrypted < 0 won't ever occur, it should be safe to return decrypted.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512053836", "createdAt": "2020-10-26T15:32:39Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjQ2MTgyMA==", "bodyText": "The goal here is to catch the case where remoteRead() < 0 indicating end of stream.  I think this can occur if the connection gets terminated abnormally, i.e. the TLS termination alerts didn't get sent/processed (which needs to happen so inboundClosed gets set).\nIf all streams get closed \"properly\" then I agree with your proposal.  But otherwise, I want to be very careful to avoid situations where JSSSocketChannel.read() could return 0 indefinitely.\nWhat do you think about this scenario @cipherboy?  Is there a better way to handle it?", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512461820", "createdAt": "2020-10-27T07:20:18Z", "author": {"login": "frasertweedale"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTU0OA==", "bodyText": "If remoteRead returns non-zero, shouldn't we just return remoteRead's value? When the underlying TCP connections terminate unexpectedly, IMO we should never attempt to wrap/unwrap, even if we had old or uncompacted data lying around. We should probably close the TLS SSLEngine's inbound and exit with -1, regardless of handshake status. I think then this entire nested if statement gets simplified and removed, replaced with one that always checks the remoteRead value.\nThis might require a little restructuring, as I think the close() handler doesn't yet understand that the inbound was already closed and to only close the outbound in that case (or visa-versa) but IMO it is a worthwhile improvement.\nAm I missing a case where this wouldn't be correct? I thought it was one of the core guarantees from TLS's RFC.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512961548", "createdAt": "2020-10-27T19:17:20Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE1MjkxMg==", "bodyText": "However, in the case where decrypted <= 0 (really, it must be 0), the contract of our read() call is the number of bytes decrypted, which is 0. It isn't the number of bytes read from the remote peer.\n\n\nIf remoteRead returns non-zero, shouldn't we just return remoteRead's value?\n\nThe return contract of SocketChannel.read() is number of bytes read (possibly 0) or -1 when this channel reaches end of stream.  If remoteRead() returns -1, there might still be data in readBuffer or in the engine's internal read buffer, so we can't return -1 until unwrap yields no more data.\n\nIMO we should never attempt to wrap/unwrap, even if we had old or uncompacted data lying around.\n\nDisagree.  Because there may be undecrypted data sitting in buffers waiting to be processed, we cannot even know if the closure of the parent socket's input stream is expected or abnormal.  Therefore even when remoteRead() returns -1, we have to wait until unwrap yields no more data before cleaning up and returning -1 from read().\n\nThis might require a little restructuring\n\nI'm sure the structure can be improved.  But... have I convinced you that the statements / expressions we're arguing about are at least not obviously wrong or harmful?  If so, could we merge this PR, add a regression test adapted from my test program, and go forward from there?\nOtherwise... could you write a program to demonstrate bug(s) in the code fragments we're arguing about.  I suggest it not because I'm sure my code is correct (I am not!), but because concrete demonstrations of issues provided a basis for fixing them (and then for regression tests).\ntl;dr this PR fixes some major issues (proven by the test program); there may well be problems with my approach but let's either make them concrete so I can understand and fix them, or merge this PR.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513152912", "createdAt": "2020-10-28T03:08:03Z", "author": {"login": "frasertweedale"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MDIxNA==", "bodyText": "Ah I'm with you now.\nI keep thinking -1 return value is only on an error -- i.e., stream incorrectly closed or was otherwise terminated.\nSince it returns -1 on mundane \"no more data for now\" things, yeah, I think this is a good. I'll go ahead and merge.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513460214", "createdAt": "2020-10-28T13:52:44Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUwMzMwMw==", "bodyText": "@cipherboy small correction: -1 means (or is supposed to mean) \"no more data ever\", which may or may not be mundane :)", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513503303", "createdAt": "2020-10-28T14:45:47Z", "author": {"login": "frasertweedale"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNDAxODA3OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToxODowOVrOHpMtxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMzo1Mzo1NFrOHprLSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTk4OQ==", "bodyText": "What was this failure, btw? Do you still happen to have the logs?", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512961989", "createdAt": "2020-10-27T19:18:09Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzE0NDc4Mg==", "bodyText": "The handshake never completes.  I am not sure the precise mechanism.  I will clarify the comment.  It may well be a bug, but I found this workaround and did not have time to investigate further.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513144782", "createdAt": "2020-10-28T02:38:18Z", "author": {"login": "frasertweedale"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTk4OQ=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MTA2NQ==", "bodyText": "Interesting. I'm fairly certain we test calling getHandshakeStatus() in a conditional in the existing test suite.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r513461065", "createdAt": "2020-10-28T13:53:54Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTk4OQ=="}, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2611, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}