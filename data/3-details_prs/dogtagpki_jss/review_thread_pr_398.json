{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNTE0MTky", "number": 398, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMTo1NToxMFrODcyfWA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjozNjozMVrODczMmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTEzOTQ0OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/SSLCipher.c", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMTo1NToxMFrOFlBUFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNDoxMzoxNlrOFlVbqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2MzE1Ng==", "bodyText": "Should we check allowed as soon as we get the value (i.e. move to line 65)?\nIn the original code the allowed will be ignored in FIPS mode, but now allowed != SSL_ALLOWED will override FIPS mode. Is this OK?", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374363156", "createdAt": "2020-02-03T21:55:10Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNjI0MA==", "bodyText": "This behavior is intentional.\nIf the policy doesn't allow a cipher suite (and in the unlikely case where the NSS DB is in FIPS mode but the system isn't), we shouldn't negotiate that cipher suite. There's a few overlapping items here that make this more comprehensive of a \"supported\" check:\n\nDoes local policy allow us to use this cipher?\nCan we use this cipher in FIPS mode (if the system or NSS DB is in it)?\nDo we have all of the mechanisms necessary to support this cipher?", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374426240", "createdAt": "2020-02-04T01:02:11Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2MzE1Ng=="}, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxODg3OA==", "bodyText": "OK.", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374518878", "createdAt": "2020-02-04T07:56:48Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2MzE1Ng=="}, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY5Mjc3Nw==", "bodyText": "I agree... I think we could move this up though.\nIn particular, if SSL_CipherPolicyGet fails, it shows that we've passed an invalid cipher suite (which shouldn't happen in most cases, unless we add a new one to the SSLCipher enum and the underlying NSS doesn't support it). We can then check allowed status and return JNI_FALSE if it isn't allowed at all. Then when SSL_GetCipherSuiteInfo is called -- the only failure case remaining is when the cipher_suite struct we pass exceeds the size of what the system NSS library supports. We can return JNI_TRUE instead of JNI_FALSE -- because it indicates an internal error and we can't get more precise information.", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374692777", "createdAt": "2020-02-04T14:13:16Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2MzE1Ng=="}, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjMxNTI1NTMwOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/SSLCipher.c", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjozNjozMVrOFlCakQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQxNToxMjo0OVrOFlXsVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM4MTIwMQ==", "bodyText": "According to this:\nCallers must ensure the application uses a version of NSS that\nisn't older than the version used at compile time.\n\nSo IIUC while this code might technically work with NSS older than the one used at build time, that is not something recommended by NSS.\nMy concern is actually more about the consistency of a particular JSS version. Imagine JSS x.y.z was built with an older NSS on platform A, and the same JSS version was built with NSS 3.43 on platform B. If later the NSS on platform A is upgraded to 3.43, the behavior of JSS on these platforms will be inconsistent although both platforms have the same JSS and NSS versions, and that will be harder to troubleshoot.\nSo I suggest we specify the NSS version that provides the feature we want to use in this particular JSS version by adding this to jss.spec:\nBuildRequires: nss >= 3.43\nRequires: nss >= 3.43\n\nI think in general the C macros should be used to resolve differences across platforms instead of introducing one. So if a platform does not provide the required NSS version, it should use an older JSS that does not require that feature, or we compensate for it in the newer JSS using the C macros if possible. What do you think?", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374381201", "createdAt": "2020-02-03T22:36:31Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }\n \n     /* Our NSS DB or application could've configured FIPS mode explicitly,\n      * even though the system might not be in FIPS mode. In that case,\n      * explicitly check that this allowed cipher is available in FIPS mode. */\n-    SSLCipherSuiteInfo info = { 0 };\n-    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess || info.length < sizeof(info)) {\n+    if (PK11_IsFIPS() && info.isFIPS == 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Our last checks are to make sure that, for all related mechanisms, we\n+     * have a token with this function. This is similar to the code in NSS's\n+     * ssl3_config_match_init(...). Note that this doesn't finish the work\n+     * of that function (by checking that the certificate matches the cipher\n+     * suite). */\n+    if (have_auth_type &&\n+            info.authType != ssl_auth_tls13_any &&\n+            info.authType != ssl_auth_null &&\n+            !PK11_TokenExists(auth_alg_defs[info.authType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    if (have_kea_type &&\n+            info.keaType != ssl_kea_null &&\n+            info.keaType != ssl_kea_tls13_any &&\n+            !PK11_TokenExists(kea_alg_defs[info.keaType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Only check if NSS >= 3.43. Note that when this condition holds at\n+     * compile time, and we're executing under an older NSS version, we're\n+     * safe as the length condition will fail to hold. */\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQyNTMyOA==", "bodyText": "It's tricky, but these aren't valid concerns. :-)\n\nAccording to this:\n\nCallers must ensure the application uses a version of NSS that\nisn't older than the version used at compile time.\n\nSo IIUC while this code might technically work with NSS older than the one used at build time, that is not something recommended by NSS.\n\nThe full context is important:\n\n/* On return, SSL_GetCipherSuitelInfo sets |length| to the smaller of\n * the |len| argument and the length of the struct used by NSS.\n * Callers must ensure the application uses a version of NSS that\n * isn't older than the version used at compile time. */\n\n\nStructures in C are essentially large blocks of contiguous memory. Accessing a value is done by going to a fixed offset in this memory block, according to the order and sizes of the fields.\nThis contract is saying that, if your NSS version is older than what you used to compile with (and the size of the SSLCipherSuiteInfo struct changes sizes), not all fields will be populated.\nThis is demonstrated by the actual NSS code for the function in question: it just does a memcpy!\nSo there's three cases:\n\nSizes are the same.\nJSS's compiled NSS is newer than system NSS.\nJSS's compiled NSS is older than system NSS.\n\n1 is trivial, it just works.\nWhen JSS's NSS exceeds the size of the system NSS (scenario 2 over a scenario where the size of the struct actually changes), NSS will bail out. I don't think there's really anything we can do here, so we have two options:\n\nDisallow the cipher suite. However, this is a global problem that affects every cipher suite. Disallowing all cipher suites indicates that there's a problem somewhere. We could alternatively raise an exception here.\nAllow the cipher suite and ignore these checks. It ignores the problem, and SSL handshake could fail (if we're doing something like the test suite where we're testing one suite at a time). It turns \"supported\" into a blunt instrument based only upon local policy.\n\nWhen JSS's compiled NSS is older than the system NSS, we'll get a partial struct, up to the amount of info we know about. Concretely, this means, if we don't know about kdfHash, we don't get it. (The rest of the fields that we calculate are really, really old).\nSo the question is: \"can we ignore kdfHash if it is missing\"? The answer is probably yes. System NSS supports TLSv1.3, but we don't necessarily know about it. That means we're unlikely to negotiate it, because we don't have the correct constant identifiers to name it. We'd have bounded the range by TLSv1.2.\nIs this something that should fail compilation? Nah. Should I change the behavior of item 2 above? Probably.", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374425328", "createdAt": "2020-02-04T00:58:26Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }\n \n     /* Our NSS DB or application could've configured FIPS mode explicitly,\n      * even though the system might not be in FIPS mode. In that case,\n      * explicitly check that this allowed cipher is available in FIPS mode. */\n-    SSLCipherSuiteInfo info = { 0 };\n-    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess || info.length < sizeof(info)) {\n+    if (PK11_IsFIPS() && info.isFIPS == 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Our last checks are to make sure that, for all related mechanisms, we\n+     * have a token with this function. This is similar to the code in NSS's\n+     * ssl3_config_match_init(...). Note that this doesn't finish the work\n+     * of that function (by checking that the certificate matches the cipher\n+     * suite). */\n+    if (have_auth_type &&\n+            info.authType != ssl_auth_tls13_any &&\n+            info.authType != ssl_auth_null &&\n+            !PK11_TokenExists(auth_alg_defs[info.authType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    if (have_kea_type &&\n+            info.keaType != ssl_kea_null &&\n+            info.keaType != ssl_kea_tls13_any &&\n+            !PK11_TokenExists(kea_alg_defs[info.keaType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Only check if NSS >= 3.43. Note that when this condition holds at\n+     * compile time, and we're executing under an older NSS version, we're\n+     * safe as the length condition will fail to hold. */\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM4MTIwMQ=="}, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUxNzI3MQ==", "bodyText": "It's not about buildability, but more about the relevancy of build time dependency. A version number of a package should normally reflect the functionality provided by the package. The runtime dependency may affect the availability of some functionality, but build time dependency usually should not be relevant.\nFor example, here's something that we might say in the release notes:\n\nJSS 4.6.3 supports TLSv1.3. NSS 3.43 or later is required in all cases.\nJSS 4.6.3 supports TLSv1.3 with NSS 3.43 or later. It can run with older NSS but it will be limited to TLSv1.2.\n\nBut probably not this:\n\nJSS 4.6.3 supports TLSv1.3 if it's built with NSS 3.43 or later. It's limited to TLSv1.2 if it was build with older NSS regardless of actual NSS used at runtime.\n\nThe first 2 cases will guarantee the availability of TLSv1.3 by installing JSS 4.6.3 and NSS 3.43 or later, which maybe useful for system administrators trying to meet system requirements. However, in the third case it may be difficult to figure out which NSS was used to build JSS because usually that information is not well published, so even if JSS 4.6.3 and NSS 3.43 were installed, there is no guarantee that TLSv1.3 will be available, which could be misleading.\n@jmagne, what's your take on this?", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374517271", "createdAt": "2020-02-04T07:52:16Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }\n \n     /* Our NSS DB or application could've configured FIPS mode explicitly,\n      * even though the system might not be in FIPS mode. In that case,\n      * explicitly check that this allowed cipher is available in FIPS mode. */\n-    SSLCipherSuiteInfo info = { 0 };\n-    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess || info.length < sizeof(info)) {\n+    if (PK11_IsFIPS() && info.isFIPS == 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Our last checks are to make sure that, for all related mechanisms, we\n+     * have a token with this function. This is similar to the code in NSS's\n+     * ssl3_config_match_init(...). Note that this doesn't finish the work\n+     * of that function (by checking that the certificate matches the cipher\n+     * suite). */\n+    if (have_auth_type &&\n+            info.authType != ssl_auth_tls13_any &&\n+            info.authType != ssl_auth_null &&\n+            !PK11_TokenExists(auth_alg_defs[info.authType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    if (have_kea_type &&\n+            info.keaType != ssl_kea_null &&\n+            info.keaType != ssl_kea_tls13_any &&\n+            !PK11_TokenExists(kea_alg_defs[info.keaType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Only check if NSS >= 3.43. Note that when this condition holds at\n+     * compile time, and we're executing under an older NSS version, we're\n+     * safe as the length condition will fail to hold. */\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM4MTIwMQ=="}, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDY3ODE0OQ==", "bodyText": "Keep in mind -- this \"supported\" check isn't a final whitelist / blacklist. It is a heuristic designed to inform our decision of SSLEngine.getSupportedCipherSuites(...). NSS is ultimately the one who chooses the negotiated cipher suite, based on whether or not the programmer calls SSLEngine.setEnabledCipherSuites(...) and what the peer sends in their cipher suite selection.\nWe just need to be reasonably sure that we could potentially negotiate these cipher suites, if we had to. So if we're to err, we should err on the side allowing too many ciphers than allowing too few (at the risk of having to blacklist them in the test suite).\nThis is complicated a little by the fact that Tomcat uses this as an absolute filter -- so if the cipher isn't reported in SSLEngine.getSupportedCipherSuites(...), Tomcat won't pass it to SSLEngine.setEnabledCipherSuites(...)", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374678149", "createdAt": "2020-02-04T13:47:03Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }\n \n     /* Our NSS DB or application could've configured FIPS mode explicitly,\n      * even though the system might not be in FIPS mode. In that case,\n      * explicitly check that this allowed cipher is available in FIPS mode. */\n-    SSLCipherSuiteInfo info = { 0 };\n-    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess || info.length < sizeof(info)) {\n+    if (PK11_IsFIPS() && info.isFIPS == 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Our last checks are to make sure that, for all related mechanisms, we\n+     * have a token with this function. This is similar to the code in NSS's\n+     * ssl3_config_match_init(...). Note that this doesn't finish the work\n+     * of that function (by checking that the certificate matches the cipher\n+     * suite). */\n+    if (have_auth_type &&\n+            info.authType != ssl_auth_tls13_any &&\n+            info.authType != ssl_auth_null &&\n+            !PK11_TokenExists(auth_alg_defs[info.authType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    if (have_kea_type &&\n+            info.keaType != ssl_kea_null &&\n+            info.keaType != ssl_kea_tls13_any &&\n+            !PK11_TokenExists(kea_alg_defs[info.keaType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Only check if NSS >= 3.43. Note that when this condition holds at\n+     * compile time, and we're executing under an older NSS version, we're\n+     * safe as the length condition will fail to hold. */\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM4MTIwMQ=="}, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDcyOTgxNA==", "bodyText": "I just tested building with NSS v3.42 (which has a smaller struct size). Then I rebuilt NSS to version v3.49 and tried running the tests again.\n58/72 Test #51: SSLEngine_RSA .....................................   Passed  105.50 sec\n70/72 Test #52: SSLEngine_ECDSA ...................................   Passed    8.56 sec\n......\n\nSo I think I agree with that last statement (\"JSS 4.6.3 supports TLSv1.3 if it's built with NSS 3.43 or later. It's limited to TLSv1.2 if it was build with older NSS regardless of actual NSS used at runtime.\") and I think it is desired.\nNamely, if you need TLSv1.3, you need a new enough NSS version which supports it -- both at build time and at run time. I don't think artificially inflating the build version to get TLSv1.3 support does much for us... ...because you'd have the same problem with the SSLSocket interface, in my opinion, and that doesn't have this artificial constraint.\n\nEdit @ 13:36 ET\nSorry, let me redo that. I built against the same NSS versions, but this time I've done it as this patch is rebased (see the changes I made w.r.t. your other comment). Now the test results are the same:\n      Start 51: SSLEngine_RSA\n51/72 Test #51: SSLEngine_RSA .....................................   Passed   99.19 sec\n      Start 52: SSLEngine_ECDSA\n52/72 Test #52: SSLEngine_ECDSA ...................................   Passed    9.25 sec\n\nBut now we have TLSv1.3! So I think this is the behavior that you'd prefer, right?\n\nJSS 4.6.3 supports TLSv1.3 with NSS 3.43 or later. It can run with older NSS but it will be limited to TLSv1.2.", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374729814", "createdAt": "2020-02-04T15:12:49Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }\n \n     /* Our NSS DB or application could've configured FIPS mode explicitly,\n      * even though the system might not be in FIPS mode. In that case,\n      * explicitly check that this allowed cipher is available in FIPS mode. */\n-    SSLCipherSuiteInfo info = { 0 };\n-    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess || info.length < sizeof(info)) {\n+    if (PK11_IsFIPS() && info.isFIPS == 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Our last checks are to make sure that, for all related mechanisms, we\n+     * have a token with this function. This is similar to the code in NSS's\n+     * ssl3_config_match_init(...). Note that this doesn't finish the work\n+     * of that function (by checking that the certificate matches the cipher\n+     * suite). */\n+    if (have_auth_type &&\n+            info.authType != ssl_auth_tls13_any &&\n+            info.authType != ssl_auth_null &&\n+            !PK11_TokenExists(auth_alg_defs[info.authType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    if (have_kea_type &&\n+            info.keaType != ssl_kea_null &&\n+            info.keaType != ssl_kea_tls13_any &&\n+            !PK11_TokenExists(kea_alg_defs[info.keaType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Only check if NSS >= 3.43. Note that when this condition holds at\n+     * compile time, and we're executing under an older NSS version, we're\n+     * safe as the length condition will fail to hold. */\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM4MTIwMQ=="}, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2661, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}