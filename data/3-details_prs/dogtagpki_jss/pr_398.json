{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzcwNTE0MTky", "number": 398, "title": "Advanced SSLCipher feature detection", "bodyText": "Mimic the behavior in NSS's ssl3_config_match_init to ensure we limit\nourselves to ciphers that NSS will actually negotiate. In particular,\nvalidate that there exists a token that could perform the given\nauthentication, hash, or key type if it was required of us.\nThis largely mimics code in NSS's ssl3con.c.\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>", "createdAt": "2020-02-03T20:44:21Z", "url": "https://github.com/dogtagpki/jss/pull/398", "merged": true, "mergeCommit": {"oid": "29dc4cba618fd76a759141a57d073badf32ab88c"}, "closed": true, "closedAt": "2020-02-04T20:47:14Z", "author": {"login": "cipherboy"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcA012jAFqTM1MjU5MDczMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBG6PVgFqTM1MzI1MDgxMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNTkwNzMx", "url": "https://github.com/dogtagpki/jss/pull/398#pullrequestreview-352590731", "createdAt": "2020-02-03T21:55:10Z", "commit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMTo1NToxMFrOFlBUFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wM1QyMjozNjozMVrOFlCakQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM2MzE1Ng==", "bodyText": "Should we check allowed as soon as we get the value (i.e. move to line 65)?\nIn the original code the allowed will be ignored in FIPS mode, but now allowed != SSL_ALLOWED will override FIPS mode. Is this OK?", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374363156", "createdAt": "2020-02-03T21:55:10Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM4MTIwMQ==", "bodyText": "According to this:\nCallers must ensure the application uses a version of NSS that\nisn't older than the version used at compile time.\n\nSo IIUC while this code might technically work with NSS older than the one used at build time, that is not something recommended by NSS.\nMy concern is actually more about the consistency of a particular JSS version. Imagine JSS x.y.z was built with an older NSS on platform A, and the same JSS version was built with NSS 3.43 on platform B. If later the NSS on platform A is upgraded to 3.43, the behavior of JSS on these platforms will be inconsistent although both platforms have the same JSS and NSS versions, and that will be harder to troubleshoot.\nSo I suggest we specify the NSS version that provides the feature we want to use in this particular JSS version by adding this to jss.spec:\nBuildRequires: nss >= 3.43\nRequires: nss >= 3.43\n\nI think in general the C macros should be used to resolve differences across platforms instead of introducing one. So if a platform does not provide the required NSS version, it should use an older JSS that does not require that feature, or we compensate for it in the newer JSS using the C macros if possible. What do you think?", "url": "https://github.com/dogtagpki/jss/pull/398#discussion_r374381201", "createdAt": "2020-02-03T22:36:31Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/SSLCipher.c", "diffHunk": "@@ -6,26 +6,112 @@\n \n #include \"_jni/org_mozilla_jss_ssl_SSLCipher.h\"\n \n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE auth_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_auth_null */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_decrypt */\n+    CKM_DSA, /* ? _SHA1 */ /* ssl_auth_dsa */\n+    CKM_INVALID_MECHANISM, /* ssl_auth_kea (unused) */\n+    CKM_ECDSA,             /* ssl_auth_ecdsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_rsa */\n+    CKM_ECDH1_DERIVE,      /* ssl_auth_ecdh_ecdsa */\n+    CKM_RSA_PKCS,          /* ssl_auth_rsa_sign */\n+    CKM_RSA_PKCS_PSS,      /* ssl_auth_rsa_pss */\n+    CKM_NSS_HKDF_SHA256,   /* ssl_auth_psk (just check for HKDF) */\n+    CKM_INVALID_MECHANISM  /* ssl_auth_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(auth_alg_defs) == ssl_auth_size);\n+\n+/* Copied from NSS's ssl3con.c. */\n+static const CK_MECHANISM_TYPE kea_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_kea_null */\n+    CKM_RSA_PKCS,          /* ssl_kea_rsa */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_fortezza (unused) */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh */\n+    CKM_ECDH1_DERIVE,      /* ssl_kea_ecdh_psk */\n+    CKM_DH_PKCS_DERIVE,    /* ssl_kea_dh_psk */\n+    CKM_INVALID_MECHANISM, /* ssl_kea_tls13_any */\n+};\n+PR_STATIC_ASSERT(PR_ARRAY_SIZE(kea_alg_defs) == ssl_kea_size);\n+\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)\n+/* Not present in ssl3con.c. */\n+static const CK_MECHANISM_TYPE hash_alg_defs[] = {\n+    CKM_INVALID_MECHANISM, /* ssl_hash_none */\n+    CKM_MD5,               /* ssl_hash_md5 */\n+    CKM_SHA_1,             /* ssl_hash_sha1 */\n+    CKM_SHA224,            /* ssl_hash_sha224 */\n+    CKM_SHA256,            /* ssl_hash_sha256 */\n+    CKM_SHA384,            /* ssl_hash_sha384 */\n+    CKM_SHA512,            /* ssl_hash_sha512 */\n+};\n+#endif\n+\n JNIEXPORT jboolean JNICALL\n Java_org_mozilla_jss_ssl_SSLCipher_checkSupportedStatus(JNIEnv *env, jclass clazz, jint cipher_suite)\n {\n     PRInt32 allowed;\n+    SSLCipherSuiteInfo info = { 0 };\n+    int have_auth_type;\n+    int have_kea_type;\n \n+    /* Fetch information about whether or not this cipher is allowed by local\n+     * policy. */\n     if (SSL_CipherPolicyGet(cipher_suite, &allowed) != SECSuccess) {\n         return JNI_FALSE;\n     }\n \n-    if (!PK11_IsFIPS() || allowed != SSL_ALLOWED) {\n-        return (allowed == SSL_ALLOWED) ? JNI_TRUE : JNI_FALSE;\n+    /* Fetch extended information about this particular cipher suite. */\n+    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess) {\n+        return JNI_FALSE;\n+    }\n+\n+    have_auth_type = info.length >= (((void *)&info.authType - (void *)&info) + sizeof(info.authType));\n+    have_kea_type = info.length >= (((void *)&info.keaType - (void *)&info) + sizeof(info.keaType));\n+\n+    if (allowed != SSL_ALLOWED) {\n+        /* If the cipher suite isn't allowed by policy, reject it early. */\n+        return JNI_FALSE;\n     }\n \n     /* Our NSS DB or application could've configured FIPS mode explicitly,\n      * even though the system might not be in FIPS mode. In that case,\n      * explicitly check that this allowed cipher is available in FIPS mode. */\n-    SSLCipherSuiteInfo info = { 0 };\n-    if (SSL_GetCipherSuiteInfo(cipher_suite, &info, sizeof(info)) != SECSuccess || info.length < sizeof(info)) {\n+    if (PK11_IsFIPS() && info.isFIPS == 0) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Our last checks are to make sure that, for all related mechanisms, we\n+     * have a token with this function. This is similar to the code in NSS's\n+     * ssl3_config_match_init(...). Note that this doesn't finish the work\n+     * of that function (by checking that the certificate matches the cipher\n+     * suite). */\n+    if (have_auth_type &&\n+            info.authType != ssl_auth_tls13_any &&\n+            info.authType != ssl_auth_null &&\n+            !PK11_TokenExists(auth_alg_defs[info.authType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    if (have_kea_type &&\n+            info.keaType != ssl_kea_null &&\n+            info.keaType != ssl_kea_tls13_any &&\n+            !PK11_TokenExists(kea_alg_defs[info.keaType])) {\n+        return JNI_FALSE;\n+    }\n+\n+    /* Only check if NSS >= 3.43. Note that when this condition holds at\n+     * compile time, and we're executing under an older NSS version, we're\n+     * safe as the length condition will fail to hold. */\n+#if (NSS_VMAJOR >= 3) && (NSS_VMINOR >= 43)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2"}, "originalPosition": 106}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0dea9050c958d7ade56ada372ac06a5b3b247c2", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/d0dea9050c958d7ade56ada372ac06a5b3b247c2", "committedDate": "2020-02-03T20:41:55Z", "message": "Advanced SSLCipher feature detection\n\nMimic the behavior in NSS's ssl3_config_match_init to ensure we limit\nourselves to ciphers that NSS will actually negotiate. In particular,\nvalidate that there exists a token that could perform the given\nauthentication, hash, or key type if it was required of us.\n\nThis largely mimics code in NSS's ssl3con.c.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "2d1da79d8187843221d6c48df6dc5a9fb9ac6618", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/2d1da79d8187843221d6c48df6dc5a9fb9ac6618", "committedDate": "2020-02-04T17:37:30Z", "message": "Advanced SSLCipher feature detection\n\nMimic the behavior in NSS's ssl3_config_match_init to ensure we limit\nourselves to ciphers that NSS will actually negotiate. In particular,\nvalidate that there exists a token that could perform the given\nauthentication, hash, or key type if it was required of us.\n\nThis largely mimics code in NSS's ssl3con.c.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2d1da79d8187843221d6c48df6dc5a9fb9ac6618", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/2d1da79d8187843221d6c48df6dc5a9fb9ac6618", "committedDate": "2020-02-04T17:37:30Z", "message": "Advanced SSLCipher feature detection\n\nMimic the behavior in NSS's ssl3_config_match_init to ensure we limit\nourselves to ciphers that NSS will actually negotiate. In particular,\nvalidate that there exists a token that could perform the given\nauthentication, hash, or key type if it was required of us.\n\nThis largely mimics code in NSS's ssl3con.c.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "6be863240a50e236f1833f39668a4cda9365ce95", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/6be863240a50e236f1833f39668a4cda9365ce95", "committedDate": "2020-02-04T17:45:37Z", "message": "Advanced SSLCipher feature detection\n\nMimic the behavior in NSS's ssl3_config_match_init to ensure we limit\nourselves to ciphers that NSS will actually negotiate. In particular,\nvalidate that there exists a token that could perform the given\nauthentication, hash, or key type if it was required of us.\n\nThis largely mimics code in NSS's ssl3con.c.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61a5bb3ea70996a5d2fd7d3d6226e8d685f01c88", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/61a5bb3ea70996a5d2fd7d3d6226e8d685f01c88", "committedDate": "2020-02-04T19:26:51Z", "message": "Advanced SSLCipher feature detection\n\nMimic the behavior in NSS's ssl3_config_match_init to ensure we limit\nourselves to ciphers that NSS will actually negotiate. In particular,\nvalidate that there exists a token that could perform the given\nauthentication, hash, or key type if it was required of us.\n\nThis largely mimics code in NSS's ssl3con.c.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6be863240a50e236f1833f39668a4cda9365ce95", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/6be863240a50e236f1833f39668a4cda9365ce95", "committedDate": "2020-02-04T17:45:37Z", "message": "Advanced SSLCipher feature detection\n\nMimic the behavior in NSS's ssl3_config_match_init to ensure we limit\nourselves to ciphers that NSS will actually negotiate. In particular,\nvalidate that there exists a token that could perform the given\nauthentication, hash, or key type if it was required of us.\n\nThis largely mimics code in NSS's ssl3con.c.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}, "afterCommit": {"oid": "61a5bb3ea70996a5d2fd7d3d6226e8d685f01c88", "author": {"user": {"login": "cipherboy", "name": "Alexander Scheel"}}, "url": "https://github.com/dogtagpki/jss/commit/61a5bb3ea70996a5d2fd7d3d6226e8d685f01c88", "committedDate": "2020-02-04T19:26:51Z", "message": "Advanced SSLCipher feature detection\n\nMimic the behavior in NSS's ssl3_config_match_init to ensure we limit\nourselves to ciphers that NSS will actually negotiate. In particular,\nvalidate that there exists a token that could perform the given\nauthentication, hash, or key type if it was required of us.\n\nThis largely mimics code in NSS's ssl3con.c.\n\nSigned-off-by: Alexander Scheel <ascheel@redhat.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzMjUwODEy", "url": "https://github.com/dogtagpki/jss/pull/398#pullrequestreview-353250812", "createdAt": "2020-02-04T19:43:03Z", "commit": {"oid": "6be863240a50e236f1833f39668a4cda9365ce95"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1535, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}