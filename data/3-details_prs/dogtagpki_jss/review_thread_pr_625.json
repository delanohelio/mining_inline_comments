{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc2NDg1NzI4", "number": 625, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDowNzo1NlrOEedJYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoyMDoyOFrOEedY-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzcwMjczOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/SSLFDProxy.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDowNzo1NlrOHKHfxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMToyOToyM1rOHKJ3Qg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MDYyOA==", "bodyText": "Just a note, the old public handler field is no longer available, so this is not a backward compatible change, but it probably doesn't matter assuming it's only used internally.", "url": "https://github.com/dogtagpki/jss/pull/625#discussion_r480370628", "createdAt": "2020-08-31T20:07:56Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -19,9 +19,12 @@\n     public int outboundOffset;\n \n     public boolean needCertValidation;\n+    public boolean needBadCertValidation;\n+    public int badCertError;\n     public boolean handshakeComplete;\n \n-    public CertAuthHandler handler;\n+    public CertAuthHandler certAuthHandler;\n+    public BadCertHandler badCertHandler;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c40aa4ed21899d789fcbf4d2179caad4c92aa67c"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQwOTQxMA==", "bodyText": "Yeah, nss/SSLFDProxy is used mostly internally. It has to be public as earlier discussed.", "url": "https://github.com/dogtagpki/jss/pull/625#discussion_r480409410", "createdAt": "2020-08-31T21:29:23Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -19,9 +19,12 @@\n     public int outboundOffset;\n \n     public boolean needCertValidation;\n+    public boolean needBadCertValidation;\n+    public int badCertError;\n     public boolean handshakeComplete;\n \n-    public CertAuthHandler handler;\n+    public CertAuthHandler certAuthHandler;\n+    public BadCertHandler badCertHandler;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3MDYyOA=="}, "originalCommit": {"oid": "c40aa4ed21899d789fcbf4d2179caad4c92aa67c"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzc0MjY3OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/SSL.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDoyMDoyOFrOHKH39g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQyMDo0ODozMFrOHKItbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjgyMg==", "bodyText": "When should we use ConfigAsyncBadCertCallback as opposed to ConfigSyncBadCertCallback?", "url": "https://github.com/dogtagpki/jss/pull/625#discussion_r480376822", "createdAt": "2020-08-31T20:20:28Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/SSL.java", "diffHunk": "@@ -471,10 +471,38 @@ public static int EnableAlertLogging(SSLFDProxy fd) {\n      */\n     public static native int ConfigSyncTrustManagerCertAuthCallback(SSLFDProxy fd);\n \n+    /**\n+     * Use an asynchronous bad certificate handler which allows us to approve\n+     * rejected certificates. This allows us to bypass the hostname check\n+     * failure caused by the Java socket having no knowledge of the hostname\n+     * we use for certificate validation; no HostnameVerifier is passed in.\n+     * As a result, NSS has no value for the hostname and validation will fail.\n+     *\n+     * Note: This does NOT work for server-side connections.\n+     *\n+     * See also: SSL_BadCertHook in /usr/include/nss3/ssl.h and\n+     *           JSSL_SSLFDAsyncBadCertCallback in jss/nss/SSLFDProxy.c\n+     */\n+    public static native int ConfigAsyncBadCertCallback(SSLFDProxy fd);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c40aa4ed21899d789fcbf4d2179caad4c92aa67c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5MDUwOA==", "bodyText": "Synchronous BadCertCallback is good when the validation is short. It also is the only method that works on both client-side and server-side connections.\nAsynchronous BadCertCallback is good when the validation takes a long time and/or invokes other network requests. It works only on client-side connections (which this is).\nBecause ours is short, I went with the former.\nThe same reasoning relates to CertAuthHandler, which is already present in JSSEngine. With user-supplied TrustManagers, we check whether or not we can be async and prefer that (issuing a DelegatedTask to actually run this validation).\nIn the future, since we might include other BadCert callback hooks, we might use async, so I added this too.", "url": "https://github.com/dogtagpki/jss/pull/625#discussion_r480390508", "createdAt": "2020-08-31T20:48:30Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/SSL.java", "diffHunk": "@@ -471,10 +471,38 @@ public static int EnableAlertLogging(SSLFDProxy fd) {\n      */\n     public static native int ConfigSyncTrustManagerCertAuthCallback(SSLFDProxy fd);\n \n+    /**\n+     * Use an asynchronous bad certificate handler which allows us to approve\n+     * rejected certificates. This allows us to bypass the hostname check\n+     * failure caused by the Java socket having no knowledge of the hostname\n+     * we use for certificate validation; no HostnameVerifier is passed in.\n+     * As a result, NSS has no value for the hostname and validation will fail.\n+     *\n+     * Note: This does NOT work for server-side connections.\n+     *\n+     * See also: SSL_BadCertHook in /usr/include/nss3/ssl.h and\n+     *           JSSL_SSLFDAsyncBadCertCallback in jss/nss/SSLFDProxy.c\n+     */\n+    public static native int ConfigAsyncBadCertCallback(SSLFDProxy fd);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM3NjgyMg=="}, "originalCommit": {"oid": "c40aa4ed21899d789fcbf4d2179caad4c92aa67c"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2597, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}