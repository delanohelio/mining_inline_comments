{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwMzc2MTU3", "number": 642, "title": "JSSSocketChannel.read(): deliver all data from buffer fd", "bodyText": "5e223293 (Fraser Tweedale, 17 minutes ago)\n   JSSSocketChannel.read(): deliver all data from buffer fd\n\n   JSSSocketChannel.read() returns 0 when the underlying socket does not yield\n   any new data.  But in the case of small output buffers, earlier invocations\n   of read() may result in more decrypted data sitting in the unwrapped side\n   of the j_buffer, never to be delievered to the application.\n\n   To resolve this issue, continue on to unwrap() even when the underlying\n   socket does not yield new data.\n\n   However, only do this after the handshake has been completed. Empirically,\n   calling unwrap() at early stages of the handshake with empty buffers breaks\n   /something/, causing no data to ever be read from the socket.  (I do not\n   understand the exact cause.)\n\n   As part of this change, also refactor how the remote read is handled.  The\n   choice of which channel to read and handling of blocking channels is now\n   abstracted behind the remoteRead() method, which subsumes boundRead().\n\n   This commit also addresses a subtle bug.  If the readBuffer contains more\n   data than the capacity of the j_buffer to which it is written, and if the\n   dst buffer(s) get filled, then JSSSocketChannel.read() can terminate with\n   leftover data in readBuffer.  Upon the next invocation of read(),\n   readBuffer.clear() is called, discarding those data.  This commit modifies\n   read() to ensure that leftover data in readBuffer are compacted and\n   preserved.\n\n778729ee (Fraser Tweedale, 20 minutes ago)\n   JSSSocket.getChannel(): always return channel\n\n   We can always init a channel regardless of whether the parent socket has a\n   channel or not.  Indeed, init() always creates a channel, so we can always\n   return a channel.", "createdAt": "2020-10-09T06:27:38Z", "url": "https://github.com/dogtagpki/jss/pull/642", "merged": true, "mergeCommit": {"oid": "65c27519abd45458d9aefc6baf3bf45fc274a454"}, "closed": true, "closedAt": "2020-10-28T13:56:52Z", "author": {"login": "frasertweedale"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdQwaXgABqjM4NTg2OTAzMDQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdW98vBgFqTUxODY4NDQ0OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5e223293af7779c2dd9745adfcd16b92070d982f", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/5e223293af7779c2dd9745adfcd16b92070d982f", "committedDate": "2020-10-09T06:24:29Z", "message": "JSSSocketChannel.read(): deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved."}, "afterCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/5546846ce77e6664562af6b1ebf28dbc8fe0e39e", "committedDate": "2020-10-09T06:43:53Z", "message": "JSSSocketChannel.read(): deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA1NjQ2MzE4", "url": "https://github.com/dogtagpki/jss/pull/642#pullrequestreview-505646318", "createdAt": "2020-10-09T12:56:52Z", "commit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMjo1Njo1MlrOHfIjSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0wOVQxMzowMzowN1rOHfIxWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQwODAxMQ==", "bodyText": "Please don't remove testing from jss.spec? :'(", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502408011", "createdAt": "2020-10-09T12:56:52Z", "author": {"login": "cipherboy"}, "path": "jss.spec", "diffHunk": "@@ -117,7 +117,7 @@ modutil -dbdir /etc/pki/nssdb -chkfips true | grep -q enabled && export FIPS_ENA\n cd %{_vpath_builddir}\n %{__make} all\n %{__make} javadoc\n-ctest --output-on-failure\n+#ctest --output-on-failure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjQxMTYxMA==", "bodyText": "I wouldn't do this either.\nWe've discussed this with @edewata earlier. See #532, and #532 (comment).\nAs I understand more about this architecture... a Socket is either a blocking or non-blocking file descriptor, but a SocketChannel is non-blocking. Only in the event that a Socket is blocking will a SocketChannel be created.\nIn JSS we abuse this slightly. We use the JSSSocket as the front to SSL operations, but in order to \"do\" SSL, we use the JSSSocketChannel as an intermediary between the JSSSocket and the JSSEngine.\nNote that callers using a SocketChannel are mostly expected to do SSL operations themselves directly with a SSLEngine. There's no relevant methods in the standard to upcast a SocketChannel into a SSLSocketChannel.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r502411610", "createdAt": "2020-10-09T13:03:07Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocket.java", "diffHunk": "@@ -234,10 +234,6 @@ public JSSEngine getEngine() {\n      * @see java.net.Socket#getChannel()\n      */\n     public JSSSocketChannel getChannel() {\n-        if (parent.getChannel() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e"}, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5546846ce77e6664562af6b1ebf28dbc8fe0e39e", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/5546846ce77e6664562af6b1ebf28dbc8fe0e39e", "committedDate": "2020-10-09T06:43:53Z", "message": "JSSSocketChannel.read(): deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved."}, "afterCommit": {"oid": "5fe5d4d3c57afc83f6d37911166cd87a8544ef3d", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/5fe5d4d3c57afc83f6d37911166cd87a8544ef3d", "committedDate": "2020-10-13T02:14:28Z", "message": "JSSSocketChannel.read(): deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5fe5d4d3c57afc83f6d37911166cd87a8544ef3d", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/5fe5d4d3c57afc83f6d37911166cd87a8544ef3d", "committedDate": "2020-10-13T02:14:28Z", "message": "JSSSocketChannel.read(): deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved."}, "afterCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/8ad41f9febcca7665d8d20873c19700ae4adfb20", "committedDate": "2020-10-13T12:35:15Z", "message": "JSSSocketChannel.read: record when input is closed\n\nWhen reading the socket channel, no special action is taken when the\nSSLEngine.unwrap() returns an SSLEngineResult with status CLOSED.\nAs a consequence, JSSSocketChannel.read() never returns -1, even\nafter the sender has closed their send end of the socket and the TLS\nclose_notify alert has been processed.  Programs that rely on the\nread() returning -1 to indicate end of data will loop forever.\n\nTo resolve, call shutdownInput() when unwrap() indicates that the\nread side of the socket is closed.  This idempotent action causes\nsubsequent invocations of read() to return -1, as required by the\nSocketChannel contract."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1ODQ3MTQy", "url": "https://github.com/dogtagpki/jss/pull/642#pullrequestreview-515847142", "createdAt": "2020-10-23T16:59:10Z", "commit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1OToxMFrOHnWDBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QxNjo1OToxMFrOHnWDBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTAxNzczMg==", "bodyText": "I think the same applies for write, no? We should shutdown output if the engine reports closed?", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r511017732", "createdAt": "2020-10-23T16:59:10Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;\n+                    }\n                 }\n \n                 readBuffer.flip();\n \n-                SSLEngineResult result = engine.unwrap(readBuffer, dsts, offset, length);\n-                if (result.getStatus() != SSLEngineResult.Status.OK &&\n-                    result.getStatus() != SSLEngineResult.Status.BUFFER_UNDERFLOW &&\n-                    result.getStatus() != SSLEngineResult.Status.CLOSED) {\n-                    throw new IOException(\"Unexpected status from unwrap: \" + result);\n+                result = engine.unwrap(readBuffer, dsts, offset, length);\n+                switch (result.getStatus()) {\n+                    case CLOSED:\n+                        shutdownInput();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 131}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE2ODgzMTYy", "url": "https://github.com/dogtagpki/jss/pull/642#pullrequestreview-516883162", "createdAt": "2020-10-26T15:14:53Z", "commit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNToxNDo1M1rOHoUbOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxNTozMjozOVrOHoVSTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAzOTczOQ==", "bodyText": "According to https://docs.oracle.com/javase/8/docs/api/java/nio/channels/ReadableByteChannel.html, 0 is a valid return result and we should probably set consumed and consumedChannel to null in both cases.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512039739", "createdAt": "2020-10-26T15:14:53Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -86,33 +88,28 @@ public void setAutoClose(boolean on) {\n         autoClose = on;\n     }\n \n-    /**\n-     * Internal helper to bound the size of a blocking read to the maximum\n-     * data available.\n-     */\n-    private int boundRead(int suggested) throws IOException {\n-        // When there's consumed data left to read, ensure we bound by the\n-        // amount available there before continuing.\n-        if (consumed != null && consumed.available() > 0) {\n-            return Math.min(consumed.available(), suggested);\n-        }\n-\n-        // By setting consumed = null when consumed no longer has bytes\n-        // available, we provide an easy check for which channel to read\n-        // from.\n-        consumed = null;\n-        consumedChannel = null;\n-\n-        // If its a non-blocking underlying socket, then return suggested;\n-        // it'll read as much as currently available.\n-        if (!isBlocking()) {\n-            return suggested;\n+    private int remoteRead() throws IOException {\n+        if (consumed != null) {\n+            int n = consumedChannel.read(readBuffer);\n+            if (n < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjA1MzgzNg==", "bodyText": "I'm not sure I agree with this.\nWhen decrypted > 0, we obviously return decrypted.\nHowever, in the case where decrypted <= 0 (really, it must be 0), the contract of our read() call is the number of bytes decrypted, which is 0. It isn't the number of bytes read from the remote peer.\nThe best example of this is during handshake: read during handshake returns 0 if no data is present -- not because no wire data was transferred (there presumably might have been) -- but because none of it resulted in any decryptable data. (Ignoring 0RTT).\nIMO, since decrypted < 0 won't ever occur, it should be safe to return decrypted.", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512053836", "createdAt": "2020-10-26T15:32:39Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform\n+                    // this check; it is NOT a passive routine and reading it\n+                    // early actually causes the same breakage.\n+                    //\n+                    if (!handshakeCompleted) {\n+                        return decrypted > 0 ? decrypted : n;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 117}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MDU3MDM0", "url": "https://github.com/dogtagpki/jss/pull/642#pullrequestreview-518057034", "createdAt": "2020-10-27T19:18:08Z", "commit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToxODowOVrOHpMtxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yN1QxOToxODowOVrOHpMtxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjk2MTk4OQ==", "bodyText": "What was this failure, btw? Do you still happen to have the logs?", "url": "https://github.com/dogtagpki/jss/pull/642#discussion_r512961989", "createdAt": "2020-10-27T19:18:09Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -242,53 +240,54 @@ public synchronized long read(ByteBuffer[] dsts, int offset, int length) throws\n             return -1;\n         }\n \n-        readBuffer.clear();\n-\n-        long remoteRead = 0;\n         long unwrapped = 0;\n         long decrypted = 0;\n \n         try {\n+            SSLEngineResult result;\n             do {\n-                int buffer_size = boundRead(readBuffer.remaining());\n-                ByteBuffer src = ByteBuffer.wrap(readBuffer.array(), readBuffer.position(), buffer_size);\n-\n-                int this_read = 0;\n-                if (consumed != null) {\n-                    this_read += consumedChannel.read(src);\n-                } else {\n-                    this_read += readChannel.read(src);\n-                }\n-\n-                readBuffer.position(readBuffer.position() + this_read);\n-                remoteRead += this_read;\n-\n-                if (remoteRead == 0) {\n-                    return 0;\n+                int n = remoteRead();\n+\n+                if (readBuffer.position() == 0) {\n+                    // We didn't read anything and there is no left-over data.\n+                    // If handshake already completed, we can continue because\n+                    // there may be data in the unwrapped buffer FD that has yet\n+                    // to be delivered to the application.\n+                    //\n+                    // But if we did not finish the handshake and there were no\n+                    // new data, we have to return here.  Calling unwrap() with\n+                    // no data, prior to handshake completion, breaks something.\n+                    //\n+                    // Note we cannot call engine.getHandshakeStatus() to perform", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20"}, "originalPosition": 112}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d25e12e66fcc99ba002f8bc7819bdeb8b1b1ba2f", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/d25e12e66fcc99ba002f8bc7819bdeb8b1b1ba2f", "committedDate": "2020-10-28T03:09:25Z", "message": "JSSSocketChannel.read: deliver all data from buffer fd\n\nJSSSocketChannel.read() returns 0 when the underlying socket does\nnot yield any new data.  But in the case of small output buffers,\nearlier invocations of read() may result in more decrypted data\nsitting in the unwrapped side of the j_buffer, never to be\ndelievered to the application.\n\nTo resolve this issue, continue on to unwrap() even when the\nunderlying socket does not yield new data.\n\nHowever, only do this after the handshake has been completed.\nEmpirically, calling unwrap() at early stages of the handshake with\nempty buffers breaks /something/, causing no data to ever be read\nfrom the socket.  (I do not understand the exact cause.)\n\nAs part of this change, also refactor how the remote read is\nhandled.  The choice of which channel to read and handling of\nblocking channels is now abstracted behind the remoteRead() method,\nwhich subsumes boundRead().\n\nThis commit also addresses a subtle bug.  If the readBuffer contains\nmore data than the capacity of the j_buffer to which it is written,\nand if the dst buffer(s) get filled, then JSSSocketChannel.read()\ncan terminate with leftover data in readBuffer.  Upon the next\ninvocation of read(), readBuffer.clear() is called, discarding those\ndata.  This commit modifies read() to ensure that leftover data in\nreadBuffer are compacted and preserved."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "905718f2a8fb441825b51fae0f2481965456a160", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/905718f2a8fb441825b51fae0f2481965456a160", "committedDate": "2020-10-28T03:09:25Z", "message": "PR.Read: return data when end of stream reached\n\nCommit 424d55639c51bca18110dcff51fb5df2e2e35a41 introduced a\nworkaround in PR.Read for a bug in NSS' PR_Read that occurs on some\nplatforms.  The bug can cause PR_Read to return a smaller amount\nthan requested, even when more data is available.  The workaround is\nto loop until we have either read the requested amount, or we\nencounter PR_WOULD_BLOCK_ERROR.\n\nUnfortunatley there is a bug in the workaround: the end of stream\ncase was not considered.  In this case, the first PR_Read reads less\nthan the requested amount, and we loop.  The next PR_Read returns 0,\nbut the \"not an error\" condition\n\n    PR_GetError() == PR_WOULD_BLOCK_ERROR && read_amount > 0\n\ndoes not admit the end of stream case (PR_GetError() == 0).  As a\nconsequence, PR.Read returns an empty byte[] and the data from the\nfinal read before end of stream are lost.\n\nTo resolve this issue, break the loop when PR_Read returns <= 0 but\nPR_GetError() returns 0."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1efe2b3ca51cb9c323a5fd809b1d5617621b34dc", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/1efe2b3ca51cb9c323a5fd809b1d5617621b34dc", "committedDate": "2020-10-28T03:09:25Z", "message": "JSSSocketChannel.read: record when input is closed\n\nWhen reading the socket channel, no special action is taken when the\nSSLEngine.unwrap() returns an SSLEngineResult with status CLOSED.\nAs a consequence, JSSSocketChannel.read() never returns -1, even\nafter the sender has closed their send end of the socket and the TLS\nclose_notify alert has been processed.  Programs that rely on the\nread() returning -1 to indicate end of data will loop forever.\n\nTo resolve, call shutdownInput() when unwrap() indicates that the\nread side of the socket is closed.  This idempotent action causes\nsubsequent invocations of read() to return -1, as required by the\nSocketChannel contract."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8ad41f9febcca7665d8d20873c19700ae4adfb20", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/8ad41f9febcca7665d8d20873c19700ae4adfb20", "committedDate": "2020-10-13T12:35:15Z", "message": "JSSSocketChannel.read: record when input is closed\n\nWhen reading the socket channel, no special action is taken when the\nSSLEngine.unwrap() returns an SSLEngineResult with status CLOSED.\nAs a consequence, JSSSocketChannel.read() never returns -1, even\nafter the sender has closed their send end of the socket and the TLS\nclose_notify alert has been processed.  Programs that rely on the\nread() returning -1 to indicate end of data will loop forever.\n\nTo resolve, call shutdownInput() when unwrap() indicates that the\nread side of the socket is closed.  This idempotent action causes\nsubsequent invocations of read() to return -1, as required by the\nSocketChannel contract."}, "afterCommit": {"oid": "1efe2b3ca51cb9c323a5fd809b1d5617621b34dc", "author": {"user": {"login": "frasertweedale", "name": "Fraser Tweedale"}}, "url": "https://github.com/dogtagpki/jss/commit/1efe2b3ca51cb9c323a5fd809b1d5617621b34dc", "committedDate": "2020-10-28T03:09:25Z", "message": "JSSSocketChannel.read: record when input is closed\n\nWhen reading the socket channel, no special action is taken when the\nSSLEngine.unwrap() returns an SSLEngineResult with status CLOSED.\nAs a consequence, JSSSocketChannel.read() never returns -1, even\nafter the sender has closed their send end of the socket and the TLS\nclose_notify alert has been processed.  Programs that rely on the\nread() returning -1 to indicate end of data will loop forever.\n\nTo resolve, call shutdownInput() when unwrap() indicates that the\nread side of the socket is closed.  This idempotent action causes\nsubsequent invocations of read() to return -1, as required by the\nSocketChannel contract."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4Njg0NDQ5", "url": "https://github.com/dogtagpki/jss/pull/642#pullrequestreview-518684449", "createdAt": "2020-10-28T13:54:07Z", "commit": {"oid": "1efe2b3ca51cb9c323a5fd809b1d5617621b34dc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1473, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}