{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4MTQ0OTkx", "number": 579, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1Njo1NlrOEHtZYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo0MToxNlrOEIgM8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTE5MjY0OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/SSL.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1Njo1NlrOGnO4Mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1Njo1NlrOGnO4Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5MTQxMA==", "bodyText": "Describe contract for async cert checking.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r443791410", "createdAt": "2020-06-22T19:56:56Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/SSL.java", "diffHunk": "@@ -421,14 +421,43 @@ public static int EnableAlertLogging(SSLFDProxy fd) {\n     private static native int EnableAlertLoggingNative(SSLFDProxy fd);\n \n     /**\n-     * Use the default JSS certificate checking handler (which understands CryptoManager\n-     * OCSP status).\n+     * Use the default JSS certificate checking handler (which understands\n+     * CryptoManager OCSP status).\n      *\n      * See also: SSL_AuthCertificateHook in /usr/include/nss3/ssl.h and\n      *           JSSL_DefaultCertAuthCallback in jss/ssl/callbacks.c\n      */\n     public static native int ConfigJSSDefaultCertAuthCallback(SSLFDProxy fd);\n \n+    /**\n+     * Use an asynchronous certificate checking handler which allows us to\n+     * invoke an arbitrary number of TrustManagers.\n+     *\n+     * See also: SSL_AuthCertificateHook in /usr/include/nss3/ssl.h and\n+     *           JSSL_SSLFDAsyncCertAuthCallback in jss/nss/SSLFDProxy.c\n+     */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTE5NjgzOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1ODoxMlrOGnO6xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxOTo1ODoxMlrOGnO6xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5MjA3MA==", "bodyText": "Mention that we need to create it ahead of time though, rather than via checkNeedCertValidation", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r443792070", "createdAt": "2020-06-22T19:58:12Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -367,6 +375,25 @@ private void applyTrustManagers() throws SSLException {\n             if (SSL.ConfigJSSDefaultCertAuthCallback(ssl_fd) == SSL.SECFailure) {\n                 throw new SSLException(\"Unable to configure JSSNativeTrustManager on this JSSengine: \" + errorText(PR.GetError()));\n             }\n+            return;\n+        }\n+\n+        if (as_server) {\n+            // We need to manually invoke the async cert auth handler. However,\n+            // SSLFDProxy makes this easy for us: our CertAuthHandler derives\n+            // from Runnable, so we can reuse it here as well.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NTIyMDE4OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDowNjozMFrOGnPJ5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQyMDowNjozMFrOGnPJ5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mzc5NTk0MA==", "bodyText": "This can go away.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r443795940", "createdAt": "2020-06-22T20:06:30Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -531,16 +558,105 @@ public String getHostname() {\n     public Runnable getDelegatedTask() {\n         debug(\"JSSEngine: getDelegatedTask()\");\n \n-        // We fake being a non-blocking SSLEngine. In particular, we never\n-        // export tasks as delegated tasks (e.g., OCSP checking), so this\n-        // method will always return null.\n+        checkNeedCertValidation();\n \n-        return null;\n+        return task;\n+    }\n+\n+    private boolean checkNeedCertValidation() {\n+        debug(\"JSSEngine: checkNeedCertValidation()\");\n+        if (task != null) {\n+            if (!task.finished) {\n+                // Already created runnable task; exit with true status to\n+                // show it still needs to be run.\n+                debug(\"JSSEngine: checkNeedCertValidation() - task not done\");\n+                return true;\n+            }\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done with code \" + task.result);\n+\n+            // Since the task has finished, we now need to inform NSS about\n+            // the results of our certificate validation step.\n+            if (SSL.AuthCertificateComplete(ssl_fd, task.result) != SSL.SECSuccess) {\n+                String msg = \"Got unexpected failure finishing cert \";\n+                msg += \"authentication in NSS. Returned code \";\n+                msg += task.result;\n+                throw new RuntimeException(msg);\n+            }\n+\n+            // After checking certificates, our best guess will be that we\n+            // need to run wrap again. This is because we either need to\n+            // inform the caller of an error that occurred, or continue the\n+            // handshake. Worst case, we'll call updateHandshakeState() and\n+            // it'll correct our mmistake eventually.\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done, removing\");\n+\n+            task = null;\n+            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n+            ssl_fd.needCertValidation = false;\n+\n+            return false;\n+        }\n+\n+        if (ssl_fd == null) {\n+            // If we don't have a SSLFDProxy instance, nothing we can do but\n+            // skip checking if the task exists. Return false to show that\n+            // we don't yet have a runnable task.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no ssl_fd\");\n+            task = null;\n+            return false;\n+        }\n+\n+        if (!ssl_fd.needCertValidation) {\n+            // We don't yet need certificate validation. Don't create a\n+            // runnable task for now.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no need for cert validation\");\n+            task = null;\n+            return false;\n+        }\n+\n+        debug(\"JSSEngine: checkNeedCertValidation() - creating task\");\n+\n+        // OK, time to create our runnable task.\n+        try {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44d2ed65f82625d79a48db27a84ae75d6bbbec1f"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzA5OTM2OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/Cert.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzozNjoxMVrOGocUYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTo1NzozN1rOGokjKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MDE5Mg==", "bodyText": "Ideally we should not rely on the exception message. Is the exception generated by Java or our code? Do we know the exception class?", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445060192", "createdAt": "2020-06-24T17:36:11Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/Cert.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.mozilla.jss.nss;\n+\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.CertificateParsingException;\n+import java.security.cert.CertificateRevokedException;\n+\n+public class Cert {\n+    public static int MatchExceptionToNSSError(Exception excpt) {\n+        if (excpt == null) {\n+            return 0;\n+        }\n+\n+        // Lower case, no spaces. Easier to find matches in\n+        // messy messages.\n+        String message = excpt.getMessage().toLowerCase().replaceAll(\"\\\\s+\",\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0NjY2NA==", "bodyText": "No, we don't and that is a problem.\nSo this goes back to the earlier problems we had with the non-native (JSS) X509TrustManager when combined with the SunJSSE SSLEngine. QE expects us to send a reasonable TLS alert, though this isn't strictly required by TLS specification. Non-JDK X509TrustManagers wrap everything in a CertificateException; it isn't well documented that SunJSSE, when an X509ExtendedTrustManager is used, will actually support querying the internal exception for a status code. This was also part of the discussion I had with the JDK team. In order to send the right alert type, we need to know the correct NSS status code. JSSNativeTrustManager gets around this by using NSS's native cert checking and never entering Java. We need to support arbitrary X509TrustManagers, which raise arbitrary classes or a single class with messages.\nTake BouncyCastle for instance as an example of an existing non-JSS TrustManager: it uses the base CertificateException class with only a message parameter. There's no reliable way (except substring matching) to get a reasonable NSS exception code out of it. We'd have the same problem here potentially: how does a custom extension to JSSTrustManager know what exception to return? We check a few common ones, but there's no CertificateException subclass for say, OCSP revocation (CertificateRevokedException could apply to both CRL or OCSP). Nor is there one for an untrusted issuer.\nSo, we use messages and exceptions and hope for the best, unless you have a better plan. :)", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445146664", "createdAt": "2020-06-24T20:17:15Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/Cert.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.mozilla.jss.nss;\n+\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.CertificateParsingException;\n+import java.security.cert.CertificateRevokedException;\n+\n+public class Cert {\n+    public static int MatchExceptionToNSSError(Exception excpt) {\n+        if (excpt == null) {\n+            return 0;\n+        }\n+\n+        // Lower case, no spaces. Easier to find matches in\n+        // messy messages.\n+        String message = excpt.getMessage().toLowerCase().replaceAll(\"\\\\s+\",\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MDE5Mg=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5NTA1MQ==", "bodyText": "Yeah, I didn't think there's going to be a better solution. I just wanted to know how bad the situation is. Thanks!", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445195051", "createdAt": "2020-06-24T21:57:37Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/Cert.java", "diffHunk": "@@ -0,0 +1,58 @@\n+package org.mozilla.jss.nss;\n+\n+import java.security.cert.CertificateException;\n+import java.security.cert.CertificateEncodingException;\n+import java.security.cert.CertificateExpiredException;\n+import java.security.cert.CertificateNotYetValidException;\n+import java.security.cert.CertificateParsingException;\n+import java.security.cert.CertificateRevokedException;\n+\n+public class Cert {\n+    public static int MatchExceptionToNSSError(Exception excpt) {\n+        if (excpt == null) {\n+            return 0;\n+        }\n+\n+        // Lower case, no spaces. Easier to find matches in\n+        // messy messages.\n+        String message = excpt.getMessage().toLowerCase().replaceAll(\"\\\\s+\",\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MDE5Mg=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzExMTU1OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/CertAuthHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzozOToyNFrOGoccIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzozOToyNFrOGoccIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2MjE3Ng==", "bodyText": "The 0 and false initializations are redundant too.. :)", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445062176", "createdAt": "2020-06-24T17:39:24Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/CertAuthHandler.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package org.mozilla.jss.nss;\n+\n+/**\n+ * CertAuthHandler interface enables arbitrary certificate authentication\n+ * from a NSS cert auth hook.\n+ *\n+ * Notably, the return code from check should be a PRErrorCode, else 0.\n+ * This will be used by NSS to determine the alert to send when closing\n+ * the connection (in the event of an error).\n+ *\n+ * The concern here is that, when this is invoked synchronously, we're\n+ * called from NSS as called by Java. Certain operations may or may not\n+ * succeed or work as expected (such as raising an exception, acquiring\n+ * locks already held, etc.).\n+ */\n+public abstract class CertAuthHandler implements Runnable {\n+    /**\n+     * When invoked via run(), the result of the check\n+     * operation.\n+     */\n+    public int result;\n+\n+    /**\n+     * Whether or not the check operation has been executed\n+     * yet, when invoked via run().\n+     */\n+    public boolean finished;\n+\n+    /**\n+     * SSLFDProxy instance.\n+     */\n+    private SSLFDProxy ssl_fd;\n+\n+    /**\n+     * Constructor to store SSLFDProxy information.\n+     *\n+     * This is useful for implementations which expect to be used\n+     * via the Runnable interface, instead of called via the\n+     * synchronous certificate authentication hook in NSS.\n+     */\n+    public CertAuthHandler(SSLFDProxy fd) {\n+        ssl_fd = fd;\n+        result = 0;\n+        finished = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzEzNzc5OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/nss/SSLFDProxy.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzo0NzowMVrOGocsuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNVQxNjo0MToxNFrOGpC_Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NjQyNQ==", "bodyText": "Is this a special return value? Could we move it into a constant with a more descriptive name?", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445066425", "createdAt": "2020-06-24T17:47:01Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -46,4 +49,12 @@ protected synchronized void releaseNativeResources() throws Exception {\n             }\n         }\n     }\n+\n+    public int invokeCertAuthHandler() {\n+        if (handler == null) {\n+            return -5994;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0Nzc5Mw==", "bodyText": "I'm thinking that if invokeCertHandler raises an exception, we should catch that in the JNI code:\nhttps://github.com/dogtagpki/jss/pull/579/files#diff-a977b6f7e7ac81cab2721a9b5333e64fR357\n    ret = (*env)->CallIntMethod(env, sslfd_proxy, certAuthHandlerMethod);\n    PR_SetError(ret, 0);\nPrior to PR_SetError, check if an exception occurred and set it there instead. Then we can use the constant name instead of the value. Thoughts?", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445147793", "createdAt": "2020-06-24T20:19:25Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -46,4 +49,12 @@ protected synchronized void releaseNativeResources() throws Exception {\n             }\n         }\n     }\n+\n+    public int invokeCertAuthHandler() {\n+        if (handler == null) {\n+            return -5994;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NjQyNQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NjUzMQ==", "bodyText": "That'll work, but are we going to throw a generic NPE or something more specific? Another option is to get the handler from the proxy, then call handler.check() directly. Something like this but using JNI:\nhandler = proxy.getHandler();\nif (handler == null) {\n    PR_SetError(-5994, 0);\n} else {\n    handler.check(proxy);\n}", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445186531", "createdAt": "2020-06-24T21:38:13Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -46,4 +49,12 @@ protected synchronized void releaseNativeResources() throws Exception {\n             }\n         }\n     }\n+\n+    public int invokeCertAuthHandler() {\n+        if (handler == null) {\n+            return -5994;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NjQyNQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4ODg2Nw==", "bodyText": "No, the NPE would be thrown by invokeCertAuthHandler when handler.check(this) fails because handler == null. We'd check whether any exception occurs and make sure to call PR_SetError(PR_UNKNOWN_ERROR, 0) when (*env)->ExceptionOccurred(env) != NULL. We wouldn't clear the exception, so when we get back to Java (on the other side of this NSS callback), it'd still have the Java exception and it'd indicate to NSS that cert isn't trusted.\nWe could do the same and allow check to throw an exception too I suppose. Though, this wouldn't work well with run() (since it cannot throw an exception either way).\nThoughts?", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445188867", "createdAt": "2020-06-24T21:43:35Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -46,4 +49,12 @@ protected synchronized void releaseNativeResources() throws Exception {\n             }\n         }\n     }\n+\n+    public int invokeCertAuthHandler() {\n+        if (handler == null) {\n+            return -5994;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NjQyNQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIyNDA5OQ==", "bodyText": "Not sure I understand. You said \"when we get back to Java ... it'd still have the Java exception\", could you show me how Java would catch the exception?\nRegardless, the original code was fine. I was just not clear what -5994 means, so if we can create a constant, or just add a comment describing the value that should be fine.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445224099", "createdAt": "2020-06-24T23:22:25Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -46,4 +49,12 @@ protected synchronized void releaseNativeResources() throws Exception {\n             }\n         }\n     }\n+\n+    public int invokeCertAuthHandler() {\n+        if (handler == null) {\n+            return -5994;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NjQyNQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY4NzA5NA==", "bodyText": "So the call stack looks like this:\n(during initialization, setup the sync cert handler)\n\n(some application using SSLEngine)\nSSLEngine.wrap()\nSSLEngine.updateHandshakeState()\nSSL.ForceHandshake(ssl_fd) =~ SSL_ForceHandshake(PRFileDesc *fd) (Java -> NSS via JNI)\n... nss internals ...\nNSS invokes ss->authCertificate() -- we've replace this with our synchronous cert auth handler during setup. So this is equivalent to invoking JSSL_SSLFDSyncCertAuthCallback.\nSSLFDProxy.invokeCertAuthHandler()\nSSLFDProxy.handler.check(this)\n... user code in Java to verify, perhaps using TrustManagers &c ...\n\nNow, say user code raises an exception or handler == null. In JSSL_SSLFDSyncCertAuthCallback, we can use (*env)->ExceptionOccurred(env) to ensure that ret = PR_UNKNOWN_ERROR. This will ensure that NSS knows an exception occurred and that the cert shouldn't be trusted, i.e., handshake should terminate. It'll eventually unravel until SSL.ForceHandshake(ssl_fd) returns, at which point the JNI layer will exit and we're back in pure Java land.\nWhen exiting from JNI layer, the exception raised from somewhere inside SSLFDProxy.invokeCertAuthHandler will still be thrown. We'll be able to either handle it (most likely, wrap it in a SSLException and re-trhow) or let it continue unrolling back to user code (if it is a RuntimeException). Likely this'd go back all the way to Tomcat/... and the app would quit handshaking, though something should've logged the exception.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445687094", "createdAt": "2020-06-25T16:30:28Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -46,4 +49,12 @@ protected synchronized void releaseNativeResources() throws Exception {\n             }\n         }\n     }\n+\n+    public int invokeCertAuthHandler() {\n+        if (handler == null) {\n+            return -5994;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NjQyNQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY5MzcwMg==", "bodyText": "JFTR, I took this approach. It means the NullPointerException will be preserved (and we won't artificially avoid it), and we can use the C PR_UNKNOWN_ERROR constant in the PR_SetError call.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445693702", "createdAt": "2020-06-25T16:41:14Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/nss/SSLFDProxy.java", "diffHunk": "@@ -46,4 +49,12 @@ protected synchronized void releaseNativeResources() throws Exception {\n             }\n         }\n     }\n+\n+    public int invokeCertAuthHandler() {\n+        if (handler == null) {\n+            return -5994;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NjQyNQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzE0MzIxOnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzo0ODo0MVrOGocwbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxNzo0ODo0MVrOGocwbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA2NzM3NA==", "bodyText": "Redundant null initialization.. sorry, can't help it :)", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445067374", "createdAt": "2020-06-24T17:48:41Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -67,6 +69,8 @@\n     private String name;\n     private String prefix = \"\";\n \n+    private CertValidationTask task = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzQ0OTQ2OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOToyMDo0NlrOGof0xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQyMTo0MDoyOVrOGokFhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExNzYzOQ==", "bodyText": "Should this be a loop like in TestSSLEngine?", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445117639", "createdAt": "2020-06-24T19:20:46Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -147,6 +147,11 @@ public boolean finishConnect() throws IOException {\n                 } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                     // Read into an empty buffer to unwrap.\n                     read(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                    // Run the task, synchronously, because we're a mostly\n+                    // blocking SSLSocket.\n+                    Runnable task = engine.getDelegatedTask();\n+                    task.run();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0OTMwNA==", "bodyText": "It is in a bigger loop. At each step, we either need TASK, WRAP, or UNWRAP. We run one task or perform one wrap at a time and step the outer loop. We don't run multiple tasks, and we leave it to read and write to handle the semantics of unwrap and wrap correctly. We could run it in a smaller loop, but why? The outer loop will suffice. :)\n\nAlso, JSSSocketChannel really only works with our particular SSLEngine. We have a single Runnable, which does all certificate validation (from all X509TrustManagers) at once. We don't have multiple Runnable tasks, in part because they can only happen during the handshake (and most of the handshake occurs inside NSS) -- not during the data transmission part.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445149304", "createdAt": "2020-06-24T20:22:22Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -147,6 +147,11 @@ public boolean finishConnect() throws IOException {\n                 } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                     // Read into an empty buffer to unwrap.\n                     read(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                    // Run the task, synchronously, because we're a mostly\n+                    // blocking SSLSocket.\n+                    Runnable task = engine.getDelegatedTask();\n+                    task.run();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExNzYzOQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1NzUzMg==", "bodyText": "As an aside, the reason why we have the inner loop in TestSSLEngine is because we're trying to get all client work done before bothering the server, and then again, get all server work done before trying to bother the client, in the next loop iteration. There's one outer loop for trying to make the two talk. Here, the other client is on the other side of the socket, so we just need one loop, to make this client talk.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445157532", "createdAt": "2020-06-24T20:38:07Z", "author": {"login": "cipherboy"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -147,6 +147,11 @@ public boolean finishConnect() throws IOException {\n                 } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                     // Read into an empty buffer to unwrap.\n                     read(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                    // Run the task, synchronously, because we're a mostly\n+                    // blocking SSLSocket.\n+                    Runnable task = engine.getDelegatedTask();\n+                    task.run();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExNzYzOQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4NzQ2MA==", "bodyText": "Sounds good.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445187460", "createdAt": "2020-06-24T21:40:29Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSSocketChannel.java", "diffHunk": "@@ -147,6 +147,11 @@ public boolean finishConnect() throws IOException {\n                 } else if (state == SSLEngineResult.HandshakeStatus.NEED_UNWRAP) {\n                     // Read into an empty buffer to unwrap.\n                     read(empty);\n+                } else if (state == SSLEngineResult.HandshakeStatus.NEED_TASK) {\n+                    // Run the task, synchronously, because we're a mostly\n+                    // blocking SSLSocket.\n+                    Runnable task = engine.getDelegatedTask();\n+                    task.run();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTExNzYzOQ=="}, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzUxNjA1OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo0MTowNFrOGogdUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo0MTowNFrOGogdUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyODAxOA==", "bodyText": "I think task is guaranteed to be null by line 571 so this is redundant.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445128018", "createdAt": "2020-06-24T19:41:04Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -531,16 +561,87 @@ public String getHostname() {\n     public Runnable getDelegatedTask() {\n         debug(\"JSSEngine: getDelegatedTask()\");\n \n-        // We fake being a non-blocking SSLEngine. In particular, we never\n-        // export tasks as delegated tasks (e.g., OCSP checking), so this\n-        // method will always return null.\n+        checkNeedCertValidation();\n \n-        return null;\n+        return task;\n+    }\n+\n+    private boolean checkNeedCertValidation() {\n+        debug(\"JSSEngine: checkNeedCertValidation()\");\n+        if (task != null) {\n+            if (!task.finished) {\n+                // Already created runnable task; exit with true status to\n+                // show it still needs to be run.\n+                debug(\"JSSEngine: checkNeedCertValidation() - task not done\");\n+                return true;\n+            }\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done with code \" + task.result);\n+\n+            // Since the task has finished, we now need to inform NSS about\n+            // the results of our certificate validation step.\n+            if (SSL.AuthCertificateComplete(ssl_fd, task.result) != SSL.SECSuccess) {\n+                String msg = \"Got unexpected failure finishing cert \";\n+                msg += \"authentication in NSS. Returned code \";\n+                msg += task.result;\n+                throw new RuntimeException(msg);\n+            }\n+\n+            // After checking certificates, our best guess will be that we\n+            // need to run wrap again. This is because we either need to\n+            // inform the caller of an error that occurred, or continue the\n+            // handshake. Worst case, we'll call updateHandshakeState() and\n+            // it'll correct our mmistake eventually.\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done, removing\");\n+\n+            task = null;\n+            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n+            ssl_fd.needCertValidation = false;\n+\n+            return false;\n+        }\n+\n+        if (ssl_fd == null) {\n+            // If we don't have a SSLFDProxy instance, nothing we can do but\n+            // skip checking if the task exists. Return false to show that\n+            // we don't yet have a runnable task.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no ssl_fd\");\n+            task = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 118}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3MzUxNjY1OnYy", "diffSide": "RIGHT", "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo0MToxNlrOGogdsw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxOTo0MToxNlrOGogdsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTEyODExNQ==", "bodyText": "I think task is guaranteed to be null by line 571 so this is redundant.", "url": "https://github.com/dogtagpki/jss/pull/579#discussion_r445128115", "createdAt": "2020-06-24T19:41:16Z", "author": {"login": "edewata"}, "path": "org/mozilla/jss/ssl/javax/JSSEngineReferenceImpl.java", "diffHunk": "@@ -531,16 +561,87 @@ public String getHostname() {\n     public Runnable getDelegatedTask() {\n         debug(\"JSSEngine: getDelegatedTask()\");\n \n-        // We fake being a non-blocking SSLEngine. In particular, we never\n-        // export tasks as delegated tasks (e.g., OCSP checking), so this\n-        // method will always return null.\n+        checkNeedCertValidation();\n \n-        return null;\n+        return task;\n+    }\n+\n+    private boolean checkNeedCertValidation() {\n+        debug(\"JSSEngine: checkNeedCertValidation()\");\n+        if (task != null) {\n+            if (!task.finished) {\n+                // Already created runnable task; exit with true status to\n+                // show it still needs to be run.\n+                debug(\"JSSEngine: checkNeedCertValidation() - task not done\");\n+                return true;\n+            }\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done with code \" + task.result);\n+\n+            // Since the task has finished, we now need to inform NSS about\n+            // the results of our certificate validation step.\n+            if (SSL.AuthCertificateComplete(ssl_fd, task.result) != SSL.SECSuccess) {\n+                String msg = \"Got unexpected failure finishing cert \";\n+                msg += \"authentication in NSS. Returned code \";\n+                msg += task.result;\n+                throw new RuntimeException(msg);\n+            }\n+\n+            // After checking certificates, our best guess will be that we\n+            // need to run wrap again. This is because we either need to\n+            // inform the caller of an error that occurred, or continue the\n+            // handshake. Worst case, we'll call updateHandshakeState() and\n+            // it'll correct our mmistake eventually.\n+\n+            debug(\"JSSEngine: checkNeedCertValidation() - task done, removing\");\n+\n+            task = null;\n+            handshake_state = SSLEngineResult.HandshakeStatus.NEED_WRAP;\n+            ssl_fd.needCertValidation = false;\n+\n+            return false;\n+        }\n+\n+        if (ssl_fd == null) {\n+            // If we don't have a SSLFDProxy instance, nothing we can do but\n+            // skip checking if the task exists. Return false to show that\n+            // we don't yet have a runnable task.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no ssl_fd\");\n+            task = null;\n+            return false;\n+        }\n+\n+        if (!ssl_fd.needCertValidation) {\n+            // We don't yet need certificate validation. Don't create a\n+            // runnable task for now.\n+            debug(\"JSSEngine: checkNeedCertValidation() - no need for cert validation\");\n+            task = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "75c65cc18de035aba42a35a8577de269a031bb05"}, "originalPosition": 126}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2657, "cost": 1, "resetAt": "2021-11-12T13:16:51Z"}}}