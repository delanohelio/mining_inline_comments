{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NDgwNTQw", "number": 1389, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1ODo0MFrODa4rQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDoxMTozNlrODa48bQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTE4MTQ0OnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1ODo0MVrOFiDhIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzoyMzo1NVrOFpTiHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzUzOQ==", "bodyText": "Each time a property container (i.e. an individual node is observed) we're looking at the constraints.   They'll never change, they should be examined once upfront and not every time we look at a node, because this will add unnecessary processing time.\nAdditionally -- a thing to be super careful of is that mandatory = true only when there is an existence constraint, not just any constraint.  If for example there is a uniqueness constraint, this will cause mandatory=true, which is wrong.   Here's an example of why:\nCREATE CONSTRAINT ON (f:Foo) ASSERT f.x is unique;\ncreate (:Foo { x: null });\ncreate (:Foo { x: null });\n\nThat works because null is never equal to itself in any database, and so they are unique.  But they don't exist.\nSo set mandatory=true only for existance constraints, and do it only once.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371253539", "createdAt": "2020-01-27T13:58:41Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg1NTk2NQ==", "bodyText": "Existence check was added a while ago, so this one is done!", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r378855965", "createdAt": "2020-02-13T13:23:55Z", "author": {"login": "neoarchitect"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzUzOQ=="}, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTE4ODIxOnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/meta/Tables4LabelsProfile.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowMDozOVrOFiDlPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzoyNDozOFrOFpTjnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NDU4OA==", "bodyText": "It's here, when all processing is completed -- that you should consider the constraints and do it only once.   Don't observe the constraints inside of the 'observe' method that will be called potentially millions of times.  It'll also help refactor that deeply nested loop below where your comments say there's a performance concern.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371254588", "createdAt": "2020-01-27T14:00:39Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/Tables4LabelsProfile.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package apoc.meta;\n+\n+import apoc.meta.tablesforlabels.PropertyContainerProfile;\n+import apoc.meta.tablesforlabels.OrderedLabels;\n+import apoc.meta.tablesforlabels.PropertyTracker;\n+import org.neo4j.graphdb.*;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+import org.neo4j.graphdb.schema.IndexDefinition;\n+import org.neo4j.graphdb.schema.*;\n+\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+public class Tables4LabelsProfile {\n+    Map<OrderedLabels, PropertyContainerProfile> labelMap;\n+    Map<String, PropertyContainerProfile> relMap;\n+    Map<OrderedLabels,Long> obsByNode;\n+    Map<String,Long> obsByRelType;\n+\n+    /**\n+     * DAO class that the stored procedure returns\n+     */\n+    public class NodeTypePropertiesEntry {\n+        public String nodeType;\n+        public List<String> nodeLabels;\n+        public String propertyName;\n+        public List<String> propertyTypes;\n+        public boolean mandatory;\n+        public long propertyObservations;\n+        public long totalObservations;\n+\n+        public NodeTypePropertiesEntry(String nodeType, List<String> nodeLabels, String propertyName, List<String>propertyTypes, boolean mandatory, long propertyObservations, long totalObservations) {\n+            this.nodeType = nodeType;\n+            this.nodeLabels = nodeLabels;\n+            this.propertyName = propertyName;\n+            this.propertyTypes = propertyTypes;\n+            this.mandatory = mandatory;\n+            this.propertyObservations = propertyObservations;\n+            this.totalObservations = totalObservations;\n+        }\n+    }\n+\n+    public class RelTypePropertiesEntry {\n+        public String relType;\n+        public List<String> sourceNodeLabels;\n+        public List<String> targetNodeLabels;\n+        public String propertyName;\n+        public List<String>propertyTypes;\n+        public boolean mandatory;\n+        public long propertyObservations;\n+        public long totalObservations;\n+\n+        public RelTypePropertiesEntry(String relType, List<String> sourceNodeLabels, List<String> targetNodeLabels, String propertyName, List<String>propertyTypes, boolean mandatory, long propertyObservations, long totalObservations) {\n+            this.relType = relType;\n+            this.sourceNodeLabels = sourceNodeLabels;\n+            this.targetNodeLabels = targetNodeLabels;\n+            this.propertyName = propertyName;\n+            this.propertyTypes = propertyTypes;\n+            this.mandatory = mandatory;\n+            this.propertyObservations = propertyObservations;\n+            this.totalObservations = totalObservations;\n+        }\n+    }\n+\n+    public Tables4LabelsProfile() {\n+        labelMap = new LinkedHashMap(100);\n+        relMap = new LinkedHashMap(100);\n+        obsByNode = new LinkedHashMap(100);\n+        obsByRelType = new LinkedHashMap(100);\n+    }\n+\n+    public void noteIndex(Label label, IndexDefinition id) {\n+\n+    }\n+\n+    public void noteConstraint(Label label, ConstraintDefinition cd) {\n+\n+    }\n+\n+    public PropertyContainerProfile getNodeProfile(OrderedLabels ol) {\n+        if (labelMap.containsKey(ol)) {\n+            return labelMap.get(ol);\n+        } else {\n+            PropertyContainerProfile p = new PropertyContainerProfile();\n+            labelMap.put(ol, p);\n+            return p;\n+        }\n+    }\n+\n+    public PropertyContainerProfile getRelProfile(String relType) {\n+        if (relMap.containsKey(relType)) {\n+            return relMap.get(relType);\n+        } else {\n+            PropertyContainerProfile p = new PropertyContainerProfile();\n+            relMap.put(relType, p);\n+            return p;\n+        }\n+    }\n+\n+    public Long sawNode(OrderedLabels labels) {\n+        if (obsByNode.containsKey(labels)) {\n+            Long val = obsByNode.get(labels) + 1;\n+            obsByNode.put(labels, val);\n+            return val;\n+        } else {\n+            obsByNode.put(labels, 1L);\n+            return 1L;\n+        }\n+    }\n+\n+    public Long sawRel(String typeName) {\n+        if (obsByRelType.containsKey(typeName)) {\n+            Long val = obsByRelType.get(typeName) + 1;\n+            obsByRelType.put(typeName, val);\n+            return val;\n+        } else {\n+            obsByRelType.put(typeName, 1L);\n+            return 1L;\n+        }\n+    }\n+\n+    public void observe(Node n, MetaConfig config, Iterable<ConstraintDefinition> constraints, Map<String, Iterable<ConstraintDefinition>> relConstraints) {\n+        OrderedLabels labels = new OrderedLabels(n.getLabels());\n+        PropertyContainerProfile localNodeProfile = getNodeProfile(labels);\n+\n+        Set<String> excludes = config.getExcludes();\n+        Set<String> includesRels = config.getIncludesRels();\n+\n+        // Only descend and look at properties if it's in our match list.\n+        if (config.matches(n.getLabels())) {\n+            sawNode(labels);\n+            localNodeProfile.observe(n, constraints, true, relConstraints, null, null);\n+        }\n+\n+        // Even if the node isn't in our match list, do rel processing.  This\n+        // is because our profiling is \"node-first\" to get to the relationships,\n+        // and if we don't do it this way, it's possible to blacklist nodes and\n+        // thereby miss relationships that were of interest.\n+        for (RelationshipType type : n.getRelationshipTypes()) {\n+            String typeName = type.name();\n+\n+            if (!config.matches(type)) { continue; }\n+\n+            int out = n.getDegree(type, Direction.OUTGOING);\n+            if (out == 0) continue;\n+\n+            long seenSoFar = sawRel(typeName);\n+\n+            if (seenSoFar > config.getMaxRels()) {\n+                // We've seen more than the maximum sample size for this rel, so\n+                // we don't need to keep looking.\n+                continue;\n+            }\n+\n+            PropertyContainerProfile localRelProfile = getRelProfile(typeName);\n+\n+            for(Relationship r : n.getRelationships(type, Direction.OUTGOING)) {\n+                Iterable<Label> relStartNode = r.getStartNode().getLabels();\n+                Iterable<Label> relEndNode = r.getEndNode().getLabels();\n+                boolean isNode = false;\n+                localRelProfile.observe(r, constraints, isNode, relConstraints, relStartNode, relEndNode);\n+            }\n+        }\n+    }\n+\n+    public Tables4LabelsProfile finished() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg1NjM0OA==", "bodyText": "Moved the check code to finished(), and cleaned up a lot of the passing around of constraint data.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r378856348", "createdAt": "2020-02-13T13:24:38Z", "author": {"login": "neoarchitect"}, "path": "src/main/java/apoc/meta/Tables4LabelsProfile.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package apoc.meta;\n+\n+import apoc.meta.tablesforlabels.PropertyContainerProfile;\n+import apoc.meta.tablesforlabels.OrderedLabels;\n+import apoc.meta.tablesforlabels.PropertyTracker;\n+import org.neo4j.graphdb.*;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+import org.neo4j.graphdb.schema.IndexDefinition;\n+import org.neo4j.graphdb.schema.*;\n+\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+public class Tables4LabelsProfile {\n+    Map<OrderedLabels, PropertyContainerProfile> labelMap;\n+    Map<String, PropertyContainerProfile> relMap;\n+    Map<OrderedLabels,Long> obsByNode;\n+    Map<String,Long> obsByRelType;\n+\n+    /**\n+     * DAO class that the stored procedure returns\n+     */\n+    public class NodeTypePropertiesEntry {\n+        public String nodeType;\n+        public List<String> nodeLabels;\n+        public String propertyName;\n+        public List<String> propertyTypes;\n+        public boolean mandatory;\n+        public long propertyObservations;\n+        public long totalObservations;\n+\n+        public NodeTypePropertiesEntry(String nodeType, List<String> nodeLabels, String propertyName, List<String>propertyTypes, boolean mandatory, long propertyObservations, long totalObservations) {\n+            this.nodeType = nodeType;\n+            this.nodeLabels = nodeLabels;\n+            this.propertyName = propertyName;\n+            this.propertyTypes = propertyTypes;\n+            this.mandatory = mandatory;\n+            this.propertyObservations = propertyObservations;\n+            this.totalObservations = totalObservations;\n+        }\n+    }\n+\n+    public class RelTypePropertiesEntry {\n+        public String relType;\n+        public List<String> sourceNodeLabels;\n+        public List<String> targetNodeLabels;\n+        public String propertyName;\n+        public List<String>propertyTypes;\n+        public boolean mandatory;\n+        public long propertyObservations;\n+        public long totalObservations;\n+\n+        public RelTypePropertiesEntry(String relType, List<String> sourceNodeLabels, List<String> targetNodeLabels, String propertyName, List<String>propertyTypes, boolean mandatory, long propertyObservations, long totalObservations) {\n+            this.relType = relType;\n+            this.sourceNodeLabels = sourceNodeLabels;\n+            this.targetNodeLabels = targetNodeLabels;\n+            this.propertyName = propertyName;\n+            this.propertyTypes = propertyTypes;\n+            this.mandatory = mandatory;\n+            this.propertyObservations = propertyObservations;\n+            this.totalObservations = totalObservations;\n+        }\n+    }\n+\n+    public Tables4LabelsProfile() {\n+        labelMap = new LinkedHashMap(100);\n+        relMap = new LinkedHashMap(100);\n+        obsByNode = new LinkedHashMap(100);\n+        obsByRelType = new LinkedHashMap(100);\n+    }\n+\n+    public void noteIndex(Label label, IndexDefinition id) {\n+\n+    }\n+\n+    public void noteConstraint(Label label, ConstraintDefinition cd) {\n+\n+    }\n+\n+    public PropertyContainerProfile getNodeProfile(OrderedLabels ol) {\n+        if (labelMap.containsKey(ol)) {\n+            return labelMap.get(ol);\n+        } else {\n+            PropertyContainerProfile p = new PropertyContainerProfile();\n+            labelMap.put(ol, p);\n+            return p;\n+        }\n+    }\n+\n+    public PropertyContainerProfile getRelProfile(String relType) {\n+        if (relMap.containsKey(relType)) {\n+            return relMap.get(relType);\n+        } else {\n+            PropertyContainerProfile p = new PropertyContainerProfile();\n+            relMap.put(relType, p);\n+            return p;\n+        }\n+    }\n+\n+    public Long sawNode(OrderedLabels labels) {\n+        if (obsByNode.containsKey(labels)) {\n+            Long val = obsByNode.get(labels) + 1;\n+            obsByNode.put(labels, val);\n+            return val;\n+        } else {\n+            obsByNode.put(labels, 1L);\n+            return 1L;\n+        }\n+    }\n+\n+    public Long sawRel(String typeName) {\n+        if (obsByRelType.containsKey(typeName)) {\n+            Long val = obsByRelType.get(typeName) + 1;\n+            obsByRelType.put(typeName, val);\n+            return val;\n+        } else {\n+            obsByRelType.put(typeName, 1L);\n+            return 1L;\n+        }\n+    }\n+\n+    public void observe(Node n, MetaConfig config, Iterable<ConstraintDefinition> constraints, Map<String, Iterable<ConstraintDefinition>> relConstraints) {\n+        OrderedLabels labels = new OrderedLabels(n.getLabels());\n+        PropertyContainerProfile localNodeProfile = getNodeProfile(labels);\n+\n+        Set<String> excludes = config.getExcludes();\n+        Set<String> includesRels = config.getIncludesRels();\n+\n+        // Only descend and look at properties if it's in our match list.\n+        if (config.matches(n.getLabels())) {\n+            sawNode(labels);\n+            localNodeProfile.observe(n, constraints, true, relConstraints, null, null);\n+        }\n+\n+        // Even if the node isn't in our match list, do rel processing.  This\n+        // is because our profiling is \"node-first\" to get to the relationships,\n+        // and if we don't do it this way, it's possible to blacklist nodes and\n+        // thereby miss relationships that were of interest.\n+        for (RelationshipType type : n.getRelationshipTypes()) {\n+            String typeName = type.name();\n+\n+            if (!config.matches(type)) { continue; }\n+\n+            int out = n.getDegree(type, Direction.OUTGOING);\n+            if (out == 0) continue;\n+\n+            long seenSoFar = sawRel(typeName);\n+\n+            if (seenSoFar > config.getMaxRels()) {\n+                // We've seen more than the maximum sample size for this rel, so\n+                // we don't need to keep looking.\n+                continue;\n+            }\n+\n+            PropertyContainerProfile localRelProfile = getRelProfile(typeName);\n+\n+            for(Relationship r : n.getRelationships(type, Direction.OUTGOING)) {\n+                Iterable<Label> relStartNode = r.getStartNode().getLabels();\n+                Iterable<Label> relEndNode = r.getEndNode().getLabels();\n+                boolean isNode = false;\n+                localRelProfile.observe(r, constraints, isNode, relConstraints, relStartNode, relEndNode);\n+            }\n+        }\n+    }\n+\n+    public Tables4LabelsProfile finished() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NDU4OA=="}, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 166}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTIwNjM0OnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowNjowNlrOFiDwQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzozMjozN1rOFpTzqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NzQxMQ==", "bodyText": "sourceNodeLabels and targetNodeLabels can be initialized with an argument 4 for initial size.  99.9999% of neo4j nodes don't have more than 4 labels for reasons we can discuss later if you're interested.\nAlso, you can save a lot of code and two while loops here by initializing your lists from your iterators in an easier way here:\nhttps://www.baeldung.com/java-convert-iterator-to-list#java8", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371257411", "createdAt": "2020-01-27T14:06:06Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {\n+                    for (String pk : cd.getPropertyKeys()) {\n+                        if (pk == propName) {\n+                            tracker.mandatory = true;\n+                        }\n+                    }\n+                }\n+            } else {\n+\n+                // Check for relationship constraints - NOTE: Could probably improve the efficiency here a bit. Too many nested loops.\n+\n+                List<String> sourceNodeLabels = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg2MDQ1OQ==", "bodyText": "This was entirely re-written in a previous update, so may not be relevant any more..", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r378860459", "createdAt": "2020-02-13T13:32:37Z", "author": {"login": "neoarchitect"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {\n+                    for (String pk : cd.getPropertyKeys()) {\n+                        if (pk == propName) {\n+                            tracker.mandatory = true;\n+                        }\n+                    }\n+                }\n+            } else {\n+\n+                // Check for relationship constraints - NOTE: Could probably improve the efficiency here a bit. Too many nested loops.\n+\n+                List<String> sourceNodeLabels = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NzQxMQ=="}, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTIxMDQyOnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowNzoxM1rOFiDyrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzozMTozOVrOFpTx0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1ODAyOA==", "bodyText": "See above comment.   This code should be in Tables4LabelsProfile#finished(), and you need to check only for existance constraints, not for any constraint (which includes uniqueness, which does not guarantee the property is mandatory)", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371258028", "createdAt": "2020-01-27T14:07:13Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {\n+                    for (String pk : cd.getPropertyKeys()) {\n+                        if (pk == propName) {\n+                            tracker.mandatory = true;\n+                        }\n+                    }\n+                }\n+            } else {\n+\n+                // Check for relationship constraints - NOTE: Could probably improve the efficiency here a bit. Too many nested loops.\n+\n+                List<String> sourceNodeLabels = new ArrayList<String>();\n+                List<String> targetNodeLabels = new ArrayList<String>();\n+\n+                Iterator<Label> rsn = relStartNode.iterator();\n+                Iterator<Label> ren = relEndNode.iterator();\n+\n+                while (rsn.hasNext()) {\n+                    sourceNodeLabels.add(rsn.next().name());\n+                }\n+\n+                while (ren.hasNext()) {\n+                    targetNodeLabels.add(ren.next().name());\n+                }\n+\n+                tracker.sourceNodeLabels = sourceNodeLabels;\n+                tracker.targetNodeLabels = targetNodeLabels;\n+                \n+                tracker.mandatory = false;\n+\n+                for (Map.Entry<String,Iterable<ConstraintDefinition>> entry : relConstraints.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg1OTk4NA==", "bodyText": "Moved to finished() as per previous comment!", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r378859984", "createdAt": "2020-02-13T13:31:39Z", "author": {"login": "neoarchitect"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {\n+                    for (String pk : cd.getPropertyKeys()) {\n+                        if (pk == propName) {\n+                            tracker.mandatory = true;\n+                        }\n+                    }\n+                }\n+            } else {\n+\n+                // Check for relationship constraints - NOTE: Could probably improve the efficiency here a bit. Too many nested loops.\n+\n+                List<String> sourceNodeLabels = new ArrayList<String>();\n+                List<String> targetNodeLabels = new ArrayList<String>();\n+\n+                Iterator<Label> rsn = relStartNode.iterator();\n+                Iterator<Label> ren = relEndNode.iterator();\n+\n+                while (rsn.hasNext()) {\n+                    sourceNodeLabels.add(rsn.next().name());\n+                }\n+\n+                while (ren.hasNext()) {\n+                    targetNodeLabels.add(ren.next().name());\n+                }\n+\n+                tracker.sourceNodeLabels = sourceNodeLabels;\n+                tracker.targetNodeLabels = targetNodeLabels;\n+                \n+                tracker.mandatory = false;\n+\n+                for (Map.Entry<String,Iterable<ConstraintDefinition>> entry : relConstraints.entrySet()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1ODAyOA=="}, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjI5NTIyNTQxOnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/meta/tablesforlabels/PropertyTracker.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDoxMTozNlrOFiD7sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xM1QxMzo1NTozOFrOFpUn1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MDMzNg==", "bodyText": "Prior to final approval, Shash please go through the types and ensure that we haven't missed anything there, or ideally make sure unit test coverage covers every possible type.\nSome type documentation (or the entry point to it) is here: https://neo4j.com/docs/cypher-manual/current/functions/temporal/\nThe original code was written under 3.5.   I'm about 80% sure that in Neo4j 4.0 we didn't introduce any new types, but we need to make sure we have total coverage.   For each type we also need to cover the corresponding array type.\nIf we miss one, then the code will report the type as string.  The driver will similarly coerce it to string, and we'll end up with a bug report so we need to be sure we're 100% complete.  If you've done the review or are satisfied the unit tests cover this, then just flag a follow-up comment saying you looked into it and this point is good to go.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371260336", "createdAt": "2020-01-27T14:11:36Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyTracker.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package apoc.meta.tablesforlabels;\n+import org.neo4j.graphdb.Label;\n+\n+import java.util.*;\n+\n+public class PropertyTracker {\n+    public String name;\n+    public Set<String> types;\n+    public List<String> sourceNodeLabels;\n+    public List<String> targetNodeLabels;\n+    public boolean mandatory;\n+    public long observations;\n+    public long nulls;\n+\n+    public PropertyTracker(String name) {\n+        this.name = name;\n+        sourceNodeLabels = new ArrayList<String>();\n+        targetNodeLabels = new ArrayList<String>();\n+        types = new HashSet<>(3);\n+        mandatory = true;\n+        observations = 0L;\n+        nulls = 0L;\n+    }\n+\n+    public void addObservation(Object value) {\n+        observations++;\n+\n+        if (value == null) { nulls++; }\n+\n+        this.mandatory = this.mandatory && (value != null);\n+        types.add(assignTypeName(value));\n+    }\n+\n+    private String assignTypeName(Object value) {\n+        String typeName = value.getClass().getCanonicalName();\n+        if (typeMappings.containsKey(typeName)) {\n+            return typeMappings.get(typeName);\n+        }\n+\n+        return typeName.replace(\"java.lang.\", \"\");\n+    }\n+\n+    public List<String> propertyTypes() {\n+        List<String> ret = new ArrayList<>(types);\n+        Collections.sort(ret);\n+        return ret;\n+    }\n+\n+    /** Call when completed with the total number of nodes observed */\n+    public void finished(long totalObservations) {\n+        // As a final step, a given property can be missing on some nodes.\n+        // If that occurred it wasn't tracked, and we need to mark it as optional\n+        // because while it may always be populated *when its present* it can be missing\n+        // from some nodes.\n+        if (totalObservations > observations) {\n+            mandatory = false;\n+        }\n+    }\n+\n+    public static final Map<String,String> typeMappings = new HashMap<String,String>();\n+    static {\n+        typeMappings.put(\"java.lang.String\", \"String\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODg3MzgxMg==", "bodyText": "As far as I can tell all types are accounted for as follows:\nString\nStringArray\nDouble\nDoubleArray\nInteger\nIntegerArray\nLong\nLongArray\nPoint\nPointArray\nDateTime\nDateTimeArray\nBoolean\nBooleanArray\nDate\nDateArray\nLocalDateTime\nLocalDateTimeArray\nLocalTime\nLocalTimeArray\nDuration\nDurationArray\nTime\nTimeArray", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r378873812", "createdAt": "2020-02-13T13:55:38Z", "author": {"login": "neoarchitect"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyTracker.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package apoc.meta.tablesforlabels;\n+import org.neo4j.graphdb.Label;\n+\n+import java.util.*;\n+\n+public class PropertyTracker {\n+    public String name;\n+    public Set<String> types;\n+    public List<String> sourceNodeLabels;\n+    public List<String> targetNodeLabels;\n+    public boolean mandatory;\n+    public long observations;\n+    public long nulls;\n+\n+    public PropertyTracker(String name) {\n+        this.name = name;\n+        sourceNodeLabels = new ArrayList<String>();\n+        targetNodeLabels = new ArrayList<String>();\n+        types = new HashSet<>(3);\n+        mandatory = true;\n+        observations = 0L;\n+        nulls = 0L;\n+    }\n+\n+    public void addObservation(Object value) {\n+        observations++;\n+\n+        if (value == null) { nulls++; }\n+\n+        this.mandatory = this.mandatory && (value != null);\n+        types.add(assignTypeName(value));\n+    }\n+\n+    private String assignTypeName(Object value) {\n+        String typeName = value.getClass().getCanonicalName();\n+        if (typeMappings.containsKey(typeName)) {\n+            return typeMappings.get(typeName);\n+        }\n+\n+        return typeName.replace(\"java.lang.\", \"\");\n+    }\n+\n+    public List<String> propertyTypes() {\n+        List<String> ret = new ArrayList<>(types);\n+        Collections.sort(ret);\n+        return ret;\n+    }\n+\n+    /** Call when completed with the total number of nodes observed */\n+    public void finished(long totalObservations) {\n+        // As a final step, a given property can be missing on some nodes.\n+        // If that occurred it wasn't tracked, and we need to mark it as optional\n+        // because while it may always be populated *when its present* it can be missing\n+        // from some nodes.\n+        if (totalObservations > observations) {\n+            mandatory = false;\n+        }\n+    }\n+\n+    public static final Map<String,String> typeMappings = new HashMap<String,String>();\n+    static {\n+        typeMappings.put(\"java.lang.String\", \"String\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MDMzNg=="}, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 62}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4342, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}