{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTA0NjUy", "number": 1462, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMjo1NDozNFrODseFbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNjo1OFrODvj4hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTU2ODQ1OnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/cypher/Cypher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMjo1NDozNFrOF9V5bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyMjowMVrOGCDQTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjIyMA==", "bodyText": "can this lead into being blocked forever? Shouldn't we take the timeout into account?\nint put and/or the whole method time?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866220", "createdAt": "2020-03-29T22:54:34Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -95,26 +112,47 @@\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n+        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n-        Util.inThread(() -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n+        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(queueCapacity);\n+        runInSeparateThreadAndSendTombstone(() -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runSchemaStatementsInTx(reader, queue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runDataStatementsInTx(reader, queue, params, addStatistics, timeout);\n             }\n-            queue.put(RowResult.TOMBSTONE);\n-            return null;\n-        });\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n+        }, queue, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard), false);\n+    }\n+\n+\n+    private <T> void runInSeparateThreadAndSendTombstone(Runnable action, BlockingQueue<T> queue, T tombstone) {\n+        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n+           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n+           wait in the pool's job queue.\n+         */\n+        new Thread(() -> {\n+            try {\n+                action.run();\n+            } finally {\n+                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n+                    try {\n+                        queue.put(tombstone);\n+                        return;\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwMzY2MA==", "bodyText": "Blocking forever?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404803660", "createdAt": "2020-04-07T13:22:01Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -95,26 +112,47 @@\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n+        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n-        Util.inThread(() -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n+        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(queueCapacity);\n+        runInSeparateThreadAndSendTombstone(() -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runSchemaStatementsInTx(reader, queue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runDataStatementsInTx(reader, queue, params, addStatistics, timeout);\n             }\n-            queue.put(RowResult.TOMBSTONE);\n-            return null;\n-        });\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n+        }, queue, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard), false);\n+    }\n+\n+\n+    private <T> void runInSeparateThreadAndSendTombstone(Runnable action, BlockingQueue<T> queue, T tombstone) {\n+        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n+           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n+           wait in the pool's job queue.\n+         */\n+        new Thread(() -> {\n+            try {\n+                action.run();\n+            } finally {\n+                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n+                    try {\n+                        queue.put(tombstone);\n+                        return;\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjIyMA=="}, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTU2OTM5OnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/cypher/Cypher.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMjo1NTo0NlrOF9V54g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QwOTo0NToyOFrOGB7nUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjMzOA==", "bodyText": "this is now blocking forever if the queue is full?\nexactly what we wanted to avoid with the timeout?\nthat was the reason we used offer in the first place ...", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866338", "createdAt": "2020-03-29T22:55:46Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -163,7 +203,7 @@ private Object executeStatement(BlockingQueue<RowResult> queue, String stmt, Map\n                 queue.put(new RowResult(row++, result.next()));\n             }\n             if (addStatistics) {\n-                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout,TimeUnit.SECONDS);\n+                queue.put(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDY3ODQ4Mg==", "bodyText": "Did you want to wrap this one too?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404678482", "createdAt": "2020-04-07T09:45:28Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -163,7 +203,7 @@ private Object executeStatement(BlockingQueue<RowResult> queue, String stmt, Map\n                 queue.put(new RowResult(row++, result.next()));\n             }\n             if (addStatistics) {\n-                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout,TimeUnit.SECONDS);\n+                queue.put(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjMzOA=="}, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTU3MzU2OnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMTowNlrOF9V8FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMTowNlrOF9V8FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjkwMA==", "bodyText": "this will now potentially block forever ...", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866900", "createdAt": "2020-03-29T23:01:06Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;\n-    }\n-\n-    private T poll() {\n+        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n         try {\n-            return queue.poll(timeout, SECONDS);\n+            T element = queue.take();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTU3Mzk0OnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMTo0MFrOF9V8Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMTo0MFrOF9V8Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2Njk1NQ==", "bodyText": "should this really return true if the tombstone was found?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866955", "createdAt": "2020-03-29T23:01:40Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;\n-    }\n-\n-    private T poll() {\n+        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n         try {\n-            return queue.poll(timeout, SECONDS);\n+            T element = queue.take();\n+            if (element.equals(tombstone)) {\n+                foundTombstone = true;\n+            } else {\n+                action.accept(element);\n+            }\n+            return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTU3NTE3OnYy", "diffSide": "LEFT", "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMzoyM1rOF9V8_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMzoyM1rOF9V8_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NzEzMg==", "bodyText": "it was null when the timeout hit, which now would block forever causing downstream processing being starved b/c the queue is no longer filled upstream ... (e.g. no threads available or other reasons)", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399867132", "createdAt": "2020-03-29T23:03:23Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTU3NzMwOnYy", "diffSide": "RIGHT", "path": "src/test/java/apoc/cypher/CypherTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowNTozNlrOF9V-GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowNTozNlrOF9V-GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NzQxNw==", "bodyText": "does this have any data to run on?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399867417", "createdAt": "2020-03-29T23:05:36Z", "author": {"login": "jexp"}, "path": "src/test/java/apoc/cypher/CypherTest.java", "diffHunk": "@@ -463,4 +478,20 @@ public void testRunFileWithEmptyFile() throws Exception {\n         testResult(db, \"CALL apoc.cypher.runFile('src/test/resources/empty.cypher')\",\n                 r -> assertFalse(\"should be empty\", r.hasNext()));\n     }\n+\n+    @Test\n+    public void lengthyRunManyShouldTerminate() {\n+        String repetetiveStatement= \"CALL apoc.cypher.runFile(\\\"src/test/resources/enrollment-incremental.cypher\\\",{parameters: {SubID: \\\"218598584\\\", Account_Number: \\\"\\\", AccountType: \\\"\\\",Source: \\\"VerizonMASnapshot\\\", MDN: \\\"\\\", Offering: \\\"\\\", Enroll_Date: \\\"\\\", Product_SKU: \\\"\\\", Device_Model: \\\"\\\", Device_Make: \\\"\\\", First_Name: \\\"\\\", Last_Name: \\\"\\\",Email1: \\\"\\\", Email2: \\\"\\\", Email3: \\\"\\\", Postal_CD: \\\"\\\", City: \\\"\\\", State: \\\"\\\", BillingStatus: \\\"\\\", ActionType: \\\"Drop\\\", Text_Date : \\\"2020-03-11\\\"}}) yield result return sum(result.total) as total;\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTk2OTQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/util/QueueUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNTozM1rOGCDaLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNTozM1rOGCDaLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjE4OA==", "bodyText": "we can compute  started + timeoutSeconds * 1000 here (in both methods)", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404806188", "createdAt": "2020-04-07T13:25:33Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTk3MTQwOnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/util/QueueUtil.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNjowMFrOGCDbhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoxNjowMlrOGCUaig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA==", "bodyText": "do we have to return something from this method? or can it be just void?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404806534", "createdAt": "2020-04-07T13:26:00Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4MTExMA==", "bodyText": "BlockingQueue.put doesn't return anything, therefore I choose void for the method signature. Since withHandlingInterrupted is using a generic return type, I have to return something - null in this case.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405081110", "createdAt": "2020-04-07T20:09:12Z", "author": {"login": "sarmbruster"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA=="}, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NDgxMA==", "bodyText": "I'm inlining that indirection anyway, see comment below.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405084810", "createdAt": "2020-04-07T20:16:02Z", "author": {"login": "sarmbruster"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA=="}, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxMTk3NTcyOnYy", "diffSide": "RIGHT", "path": "src/main/java/apoc/util/QueueUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNjo1OFrOGCDeQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QyMDoxNjo1N1rOGCUcfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNzIzMg==", "bodyText": "not sure it's worth the indirection.\nwhat about that Thread.currentThread().interrrupt()\nhandling? I always forget which one is right :)", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404807232", "createdAt": "2020-04-07T13:26:58Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;\n+                }\n+                checkDuringOffering.run();\n+            }\n+            if (failWithExecption) {\n+                throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n+            }\n+            return null;\n+        });\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#take}\n+     * @param queue\n+     * @param timeoutSeconds\n+     * @param checkDuringPolling a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     * @return\n+     */\n+    public static <T> T take(BlockingQueue<T> queue, long timeoutSeconds, Runnable checkDuringPolling) {\n+        return withHandlingInterrupted(\"Queue poll interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                T polled = queue.poll(WAIT, WAIT_UNIT);\n+                if (polled != null) {\n+                    return polled;\n+                }\n+                checkDuringPolling.run();\n+            }\n+            throw new RuntimeException(\"Error polling, timeout of \" + timeoutSeconds + \" seconds reached.\");\n+        });\n+    }\n+\n+    public static <T> T withHandlingInterrupted(String msg, ThrowingSupplier<T, InterruptedException> consumer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTA4NTMwOA==", "bodyText": "Gonna remove the indirection. I guess Thread.currentThread.interrupt() is not good here since I don't know what to return for take() in this case. So bubbling up the exception sounds more reasonable to me.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r405085308", "createdAt": "2020-04-07T20:16:57Z", "author": {"login": "sarmbruster"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;\n+                }\n+                checkDuringOffering.run();\n+            }\n+            if (failWithExecption) {\n+                throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n+            }\n+            return null;\n+        });\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#take}\n+     * @param queue\n+     * @param timeoutSeconds\n+     * @param checkDuringPolling a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     * @return\n+     */\n+    public static <T> T take(BlockingQueue<T> queue, long timeoutSeconds, Runnable checkDuringPolling) {\n+        return withHandlingInterrupted(\"Queue poll interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                T polled = queue.poll(WAIT, WAIT_UNIT);\n+                if (polled != null) {\n+                    return polled;\n+                }\n+                checkDuringPolling.run();\n+            }\n+            throw new RuntimeException(\"Error polling, timeout of \" + timeoutSeconds + \" seconds reached.\");\n+        });\n+    }\n+\n+    public static <T> T withHandlingInterrupted(String msg, ThrowingSupplier<T, InterruptedException> consumer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNzIzMg=="}, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 65}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4306, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}