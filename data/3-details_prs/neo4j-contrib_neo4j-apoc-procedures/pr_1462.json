{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MTA0NjUy", "number": 1462, "title": "fix deadlock situation in concurrent executions", "bodyText": "We did use the default thread pool for the thread sending eventually the tombstone object to a queue. If used in a nested way this could lead to a situation when default pool is full that the tombstone sending thread waits for the queue. Queue consumer waits as well -> deadlock situation.\nBy using a new thread instead we ensure that the tombstone is always sent correctly. Also QueueBasedSpliterator has been refactor and uses take instead of poll.", "createdAt": "2020-03-28T14:40:51Z", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462", "merged": true, "mergeCommit": {"oid": "c38364c0c954660fb0b14048bc2e3a0ba7f8adb0"}, "closed": true, "closedAt": "2020-04-10T10:20:46Z", "author": {"login": "sarmbruster"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcPOo3NgH2gAyMzk1MTA0NjUyOjQ1MjQ1NTM2ZWUwMWI3ODNjMDMzYjRmMWY2ZmZmNjE4MDgxODBmZmE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWOavtAFqTM5MTM3NDI5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "45245536ee01b783c033b4f1f6fff61808180ffa", "author": {"user": {"login": "sarmbruster", "name": "Stefan Armbruster"}}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/45245536ee01b783c033b4f1f6fff61808180ffa", "committedDate": "2020-03-19T16:38:15Z", "message": "ensure tombstone is sent, adding `queueCapacity` parameter"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8414e6a750a3bbe6c91d50f1a0b84808f9b50501", "author": {"user": {"login": "sarmbruster", "name": "Stefan Armbruster"}}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/8414e6a750a3bbe6c91d50f1a0b84808f9b50501", "committedDate": "2020-03-24T19:35:35Z", "message": "WIP - bookmark for delivered snapshot"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275", "author": {"user": {"login": "sarmbruster", "name": "Stefan Armbruster"}}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/0a16124b759d7511b6608ca769de5fb5ed764275", "committedDate": "2020-03-28T14:33:05Z", "message": "prevent QueueBasedSpliterator from waiting forever\n\nUsing a state variable QueueBasedSpliterator knows if it already has seen tombstone."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDY1NDkz", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-383465493", "createdAt": "2020-03-29T22:54:33Z", "commit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMjo1NDozNFrOF9V5bA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMjo1NDozNFrOF9V5bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjIyMA==", "bodyText": "can this lead into being blocked forever? Shouldn't we take the timeout into account?\nint put and/or the whole method time?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866220", "createdAt": "2020-03-29T22:54:34Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -95,26 +112,47 @@\n     public Stream<RowResult> runSchemaFiles(@Name(\"file\") List<String> fileNames, @Name(value = \"config\",defaultValue = \"{}\") Map<String,Object> config) {\n         boolean addStatistics = Util.toBoolean(config.getOrDefault(\"statistics\",true));\n         int timeout = Util.toInteger(config.getOrDefault(\"timeout\",10));\n+        int queueCapacity = Util.toInteger(config.getOrDefault(\"queueCapacity\",100));\n         List<RowResult> result = new ArrayList<>();\n         for (String f : fileNames) {\n-            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout).collect(Collectors.toList());\n+            List<RowResult> rowResults = runManyStatements(readerForFile(f), Collections.emptyMap(), true, addStatistics, timeout, queueCapacity).collect(Collectors.toList());\n             result.addAll(rowResults);\n         }\n         return result.stream();\n     }\n \n-    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout) {\n-        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(100);\n-        Util.inThread(() -> {\n+    private Stream<RowResult> runManyStatements(Reader reader, Map<String, Object> params, boolean schemaOperation, boolean addStatistics, int timeout, int queueCapacity) {\n+        BlockingQueue<RowResult> queue = new ArrayBlockingQueue<>(queueCapacity);\n+        runInSeparateThreadAndSendTombstone(() -> {\n             if (schemaOperation) {\n-                runSchemaStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runSchemaStatementsInTx(reader, queue, params, addStatistics, timeout);\n             } else {\n-                runDataStatementsInTx(reader, queue, params, addStatistics,timeout);\n+                runDataStatementsInTx(reader, queue, params, addStatistics, timeout);\n             }\n-            queue.put(RowResult.TOMBSTONE);\n-            return null;\n-        });\n-        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard, timeout), false);\n+        }, queue, RowResult.TOMBSTONE);\n+        return StreamSupport.stream(new QueueBasedSpliterator<>(queue, RowResult.TOMBSTONE, terminationGuard), false);\n+    }\n+\n+\n+    private <T> void runInSeparateThreadAndSendTombstone(Runnable action, BlockingQueue<T> queue, T tombstone) {\n+        /* NB: this must not be called via an existing thread pool - otherwise we could run into a deadlock\n+           other jobs using the same pool might completely exhaust at and the thread sending TOMBSTONE will\n+           wait in the pool's job queue.\n+         */\n+        new Thread(() -> {\n+            try {\n+                action.run();\n+            } finally {\n+                while (true) {  // ensure we send TOMBSTONE even if there's an InterruptedException\n+                    try {\n+                        queue.put(tombstone);\n+                        return;\n+                    } catch (InterruptedException e) {\n+                        Thread.currentThread().interrupt();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDY1NTky", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-383465592", "createdAt": "2020-03-29T22:55:45Z", "commit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMjo1NTo0NlrOF9V54g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMjo1NTo0NlrOF9V54g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjMzOA==", "bodyText": "this is now blocking forever if the queue is full?\nexactly what we wanted to avoid with the timeout?\nthat was the reason we used offer in the first place ...", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866338", "createdAt": "2020-03-29T22:55:46Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/cypher/Cypher.java", "diffHunk": "@@ -163,7 +203,7 @@ private Object executeStatement(BlockingQueue<RowResult> queue, String stmt, Map\n                 queue.put(new RowResult(row++, result.next()));\n             }\n             if (addStatistics) {\n-                queue.offer(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)), timeout,TimeUnit.SECONDS);\n+                queue.put(new RowResult(-1, toMap(result.getQueryStatistics(), System.currentTimeMillis() - time, row)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDY2MDc4", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-383466078", "createdAt": "2020-03-29T23:01:06Z", "commit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMTowNlrOF9V8FA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMTowNlrOF9V8FA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NjkwMA==", "bodyText": "this will now potentially block forever ...", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866900", "createdAt": "2020-03-29T23:01:06Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;\n-    }\n-\n-    private T poll() {\n+        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n         try {\n-            return queue.poll(timeout, SECONDS);\n+            T element = queue.take();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDY2MTI2", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-383466126", "createdAt": "2020-03-29T23:01:39Z", "commit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMTo0MFrOF9V8Sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMTo0MFrOF9V8Sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2Njk1NQ==", "bodyText": "should this really return true if the tombstone was found?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399866955", "createdAt": "2020-03-29T23:01:40Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;\n-    }\n-\n-    private T poll() {\n+        if (Util.transactionIsTerminated(terminationGuard) || foundTombstone) return false;\n         try {\n-            return queue.poll(timeout, SECONDS);\n+            T element = queue.take();\n+            if (element.equals(tombstone)) {\n+                foundTombstone = true;\n+            } else {\n+                action.accept(element);\n+            }\n+            return true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDY2Mjg4", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-383466288", "createdAt": "2020-03-29T23:03:23Z", "commit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMzoyM1rOF9V8_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowMzoyM1rOF9V8_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NzEzMg==", "bodyText": "it was null when the timeout hit, which now would block forever causing downstream processing being starved b/c the queue is no longer filled upstream ... (e.g. no threads available or other reasons)", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399867132", "createdAt": "2020-03-29T23:03:23Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueBasedSpliterator.java", "diffHunk": "@@ -6,49 +6,35 @@\n import java.util.concurrent.BlockingQueue;\n import java.util.function.Consumer;\n \n-import static java.util.concurrent.TimeUnit.SECONDS;\n-\n /**\n  * @author mh\n  * @since 06.12.17\n  */\n public class QueueBasedSpliterator<T> implements Spliterator<T> {\n     private final BlockingQueue<T> queue;\n     private T tombstone;\n-    private T entry;\n     private TerminationGuard terminationGuard;\n-    private final long timeout;\n+    private boolean foundTombstone = false;\n \n     public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard) {\n-        this(queue, tombstone, terminationGuard, 10);\n-    }\n-\n-    public QueueBasedSpliterator(BlockingQueue<T> queue, T tombstone, TerminationGuard terminationGuard, long timeout) {\n         this.queue = queue;\n         this.tombstone = tombstone;\n         this.terminationGuard = terminationGuard;\n-        this.timeout = timeout;\n-        entry = poll();\n     }\n \n     @Override\n     public boolean tryAdvance(Consumer<? super T> action) {\n-        if (Util.transactionIsTerminated(terminationGuard)) return false;\n-        if (isEnd()) return false;\n-        action.accept(entry);\n-        entry = poll();\n-        return !isEnd();\n-    }\n-\n-    private boolean isEnd() {\n-        return entry == null || entry == tombstone;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 40}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDY2NTEx", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-383466511", "createdAt": "2020-03-29T23:05:36Z", "commit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowNTozNlrOF9V-GQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yOVQyMzowNTozNlrOF9V-GQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTg2NzQxNw==", "bodyText": "does this have any data to run on?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r399867417", "createdAt": "2020-03-29T23:05:36Z", "author": {"login": "jexp"}, "path": "src/test/java/apoc/cypher/CypherTest.java", "diffHunk": "@@ -463,4 +478,20 @@ public void testRunFileWithEmptyFile() throws Exception {\n         testResult(db, \"CALL apoc.cypher.runFile('src/test/resources/empty.cypher')\",\n                 r -> assertFalse(\"should be empty\", r.hasNext()));\n     }\n+\n+    @Test\n+    public void lengthyRunManyShouldTerminate() {\n+        String repetetiveStatement= \"CALL apoc.cypher.runFile(\\\"src/test/resources/enrollment-incremental.cypher\\\",{parameters: {SubID: \\\"218598584\\\", Account_Number: \\\"\\\", AccountType: \\\"\\\",Source: \\\"VerizonMASnapshot\\\", MDN: \\\"\\\", Offering: \\\"\\\", Enroll_Date: \\\"\\\", Product_SKU: \\\"\\\", Device_Model: \\\"\\\", Device_Make: \\\"\\\", First_Name: \\\"\\\", Last_Name: \\\"\\\",Email1: \\\"\\\", Email2: \\\"\\\", Email3: \\\"\\\", Postal_CD: \\\"\\\", City: \\\"\\\", State: \\\"\\\", BillingStatus: \\\"\\\", ActionType: \\\"Drop\\\", Text_Date : \\\"2020-03-11\\\"}}) yield result return sum(result.total) as total;\\n\" +", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzNDY2NTkx", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-383466591", "createdAt": "2020-03-29T23:06:29Z", "commit": {"oid": "0a16124b759d7511b6608ca769de5fb5ed764275"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac", "author": {"user": {"login": "sarmbruster", "name": "Stefan Armbruster"}}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/de07980676970f5c00cc04ed5cc0670cd0a793ac", "committedDate": "2020-03-30T18:56:30Z", "message": "using poll/offer instead of put/take for queues"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTEyMTg0", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-389112184", "createdAt": "2020-04-07T13:25:33Z", "commit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNTozM1rOGCDaLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNTozM1rOGCDaLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjE4OA==", "bodyText": "we can compute  started + timeoutSeconds * 1000 here (in both methods)", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404806188", "createdAt": "2020-04-07T13:25:33Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTEyNjA2", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-389112606", "createdAt": "2020-04-07T13:26:00Z", "commit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNjowMFrOGCDbhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNjowMFrOGCDbhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNjUzNA==", "bodyText": "do we have to return something from this method? or can it be just void?", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404806534", "createdAt": "2020-04-07T13:26:00Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 32}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5MTEzNDky", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-389113492", "createdAt": "2020-04-07T13:26:58Z", "commit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNjo1OFrOGCDeQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wN1QxMzoyNjo1OFrOGCDeQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDgwNzIzMg==", "bodyText": "not sure it's worth the indirection.\nwhat about that Thread.currentThread().interrrupt()\nhandling? I always forget which one is right :)", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#discussion_r404807232", "createdAt": "2020-04-07T13:26:58Z", "author": {"login": "jexp"}, "path": "src/main/java/apoc/util/QueueUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package apoc.util;\n+\n+import org.neo4j.function.ThrowingSupplier;\n+\n+import java.util.concurrent.BlockingQueue;\n+import java.util.concurrent.TimeUnit;\n+\n+public class QueueUtil {\n+\n+    public static final int WAIT = 1;\n+    public static final TimeUnit WAIT_UNIT = TimeUnit.SECONDS;\n+\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds) {\n+        put(queue, item, timeoutSeconds, true, () -> {});\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#put}\n+     * @param queue\n+     * @param item\n+     * @param timeoutSeconds\n+     * @param failWithExecption true if a {@link RuntimeException} should be thrown in case we couldn't add item into the queue within timeframe\n+     * @param checkDuringOffering a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     */\n+    public static <T> void put(BlockingQueue<T> queue, T item, long timeoutSeconds, boolean failWithExecption, Runnable checkDuringOffering) {\n+        withHandlingInterrupted(\"Queue offer interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                boolean success = queue.offer(item, WAIT, WAIT_UNIT);\n+                if (success) {\n+                    return null;\n+                }\n+                checkDuringOffering.run();\n+            }\n+            if (failWithExecption) {\n+                throw new RuntimeException(\"Error queuing item before timeout of \" + timeoutSeconds + \" seconds\");\n+            }\n+            return null;\n+        });\n+    }\n+\n+    /**\n+     * to be used instead of {@link BlockingQueue#take}\n+     * @param queue\n+     * @param timeoutSeconds\n+     * @param checkDuringPolling a callback supposed to throw an exception to terminate\n+     * @param <T>\n+     * @return\n+     */\n+    public static <T> T take(BlockingQueue<T> queue, long timeoutSeconds, Runnable checkDuringPolling) {\n+        return withHandlingInterrupted(\"Queue poll interrupted before \" + timeoutSeconds + \" seconds\", () -> {\n+            long started = System.currentTimeMillis();\n+            while (started + timeoutSeconds * 1000 > System.currentTimeMillis()) {\n+                T polled = queue.poll(WAIT, WAIT_UNIT);\n+                if (polled != null) {\n+                    return polled;\n+                }\n+                checkDuringPolling.run();\n+            }\n+            throw new RuntimeException(\"Error polling, timeout of \" + timeoutSeconds + \" seconds reached.\");\n+        });\n+    }\n+\n+    public static <T> T withHandlingInterrupted(String msg, ThrowingSupplier<T, InterruptedException> consumer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de07980676970f5c00cc04ed5cc0670cd0a793ac"}, "originalPosition": 65}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98af0330559d6668f877756fa06e5941d3a3bbd3", "author": {"user": {"login": "sarmbruster", "name": "Stefan Armbruster"}}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/98af0330559d6668f877756fa06e5941d3a3bbd3", "committedDate": "2020-04-07T20:20:23Z", "message": "code review request"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzc0Mjk5", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1462#pullrequestreview-391374299", "createdAt": "2020-04-10T10:20:18Z", "commit": {"oid": "98af0330559d6668f877756fa06e5941d3a3bbd3"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 902, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}