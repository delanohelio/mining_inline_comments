{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NDgwNTQw", "number": 1389, "title": "Tables4Labels", "bodyText": "Fixes #1388\nFull list of features:\n\nTables4Labels. Base functionality to replace nodeTypeProperties() and relTypeProperties() with sampling versions.\nRelationships4Labels. Adds two columns to relTypeProperties() to show source and target labels for each relationship that has a valid property.\nMandatory handling functionality change. Forces \"mandatory\" flag to true only if a constraint exists for this property (only works for Enterprise Edition as constraints are a licensed function of Neo4J).\nAllow inclusion/exclusion of nodes by relationships. When calling nodeTypeProperties(), include/exclude a node if it has a specifically has/doesn't have a relationship type associated).\n\nWork-in-progress PR. Still requires:\n\nComplete unit tests (some are complete, some are not)\nDocumentation", "createdAt": "2020-01-27T13:07:28Z", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389", "merged": true, "mergeCommit": {"oid": "12b74f055c01ec47e0ccd075505f62c078b55835"}, "closed": true, "closedAt": "2020-02-17T07:10:21Z", "author": {"login": "neoarchitect"}, "timelineItems": {"totalCount": 30, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb9c3CZAH2gAyMzY3NDgwNTQwOjYwYmE3ZWJmODVmODczZDZhZTI0Y2MwZTMyZmU4ZjI1MGVlOTk2ODU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcEXv9lgH2gAyMzY3NDgwNTQwOmVmYzFiN2NkZTE2Mzk0MTczY2NlNTVkOWQ4MzliNzIyOGFiMjY5YjU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "60ba7ebf85f873d6ae24cc0e32fe8f250ee99685", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/60ba7ebf85f873d6ae24cc0e32fe8f250ee99685", "committedDate": "2020-01-24T11:01:46Z", "message": "Committing features:\n\n- Added config option \"excludeRels\" to ignore specific nodes that have specific relationships relationship when calling apoc.meta.nodeTypeProperties.\n- Added \"rels\" config option to work when calling apoc.meta.nodeTypeProperties. Previously \"rels\" would be ignored when querying for nodes. Now, if specified, the option will only return nodes that have matching relationships.\n- Added missing types \"LocalDateTime\", \"LocalTime\", \"Duration\", \"Time\".\n- Confirmed failing tests pass."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d2a2c42fb5dc3cdca86d2e051c3b5637faa51b1", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/6d2a2c42fb5dc3cdca86d2e051c3b5637faa51b1", "committedDate": "2020-01-24T11:57:24Z", "message": "Check-in tests for include/exclude nodes by relationship."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0451ce4dbf3f5d91ed88ab1805bd93f8512a587", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/a0451ce4dbf3f5d91ed88ab1805bd93f8512a587", "committedDate": "2020-01-24T16:53:10Z", "message": "Merged in new mandatory handling:\n\n- If a property on a Node or Relationship has a constraint, the mandatory flag is set to true. Otherwise it is set to false."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/0e30e308c391b371f45687963811b5fe38eae4bc", "committedDate": "2020-01-27T08:39:40Z", "message": "Adding feature Relationships 4 Labels (R4L). This adds an additional two columns to the relTypeProperties() call showing source and destination labels (sourceNodeLabels and targetNodeLabels), both as List<String> data types."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njc5Njk3", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#pullrequestreview-348679697", "createdAt": "2020-01-27T13:58:40Z", "commit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1ODo0MVrOFiDhIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxMzo1ODo0MVrOFiDhIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1MzUzOQ==", "bodyText": "Each time a property container (i.e. an individual node is observed) we're looking at the constraints.   They'll never change, they should be examined once upfront and not every time we look at a node, because this will add unnecessary processing time.\nAdditionally -- a thing to be super careful of is that mandatory = true only when there is an existence constraint, not just any constraint.  If for example there is a uniqueness constraint, this will cause mandatory=true, which is wrong.   Here's an example of why:\nCREATE CONSTRAINT ON (f:Foo) ASSERT f.x is unique;\ncreate (:Foo { x: null });\ncreate (:Foo { x: null });\n\nThat works because null is never equal to itself in any database, and so they are unique.  But they don't exist.\nSo set mandatory=true only for existance constraints, and do it only once.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371253539", "createdAt": "2020-01-27T13:58:41Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 49}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4NjgxMDk3", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#pullrequestreview-348681097", "createdAt": "2020-01-27T14:00:38Z", "commit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowMDozOVrOFiDlPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowMDozOVrOFiDlPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NDU4OA==", "bodyText": "It's here, when all processing is completed -- that you should consider the constraints and do it only once.   Don't observe the constraints inside of the 'observe' method that will be called potentially millions of times.  It'll also help refactor that deeply nested loop below where your comments say there's a performance concern.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371254588", "createdAt": "2020-01-27T14:00:39Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/Tables4LabelsProfile.java", "diffHunk": "@@ -0,0 +1,256 @@\n+package apoc.meta;\n+\n+import apoc.meta.tablesforlabels.PropertyContainerProfile;\n+import apoc.meta.tablesforlabels.OrderedLabels;\n+import apoc.meta.tablesforlabels.PropertyTracker;\n+import org.neo4j.graphdb.*;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+import org.neo4j.graphdb.schema.IndexDefinition;\n+import org.neo4j.graphdb.schema.*;\n+\n+import java.util.*;\n+import java.util.stream.Stream;\n+\n+public class Tables4LabelsProfile {\n+    Map<OrderedLabels, PropertyContainerProfile> labelMap;\n+    Map<String, PropertyContainerProfile> relMap;\n+    Map<OrderedLabels,Long> obsByNode;\n+    Map<String,Long> obsByRelType;\n+\n+    /**\n+     * DAO class that the stored procedure returns\n+     */\n+    public class NodeTypePropertiesEntry {\n+        public String nodeType;\n+        public List<String> nodeLabels;\n+        public String propertyName;\n+        public List<String> propertyTypes;\n+        public boolean mandatory;\n+        public long propertyObservations;\n+        public long totalObservations;\n+\n+        public NodeTypePropertiesEntry(String nodeType, List<String> nodeLabels, String propertyName, List<String>propertyTypes, boolean mandatory, long propertyObservations, long totalObservations) {\n+            this.nodeType = nodeType;\n+            this.nodeLabels = nodeLabels;\n+            this.propertyName = propertyName;\n+            this.propertyTypes = propertyTypes;\n+            this.mandatory = mandatory;\n+            this.propertyObservations = propertyObservations;\n+            this.totalObservations = totalObservations;\n+        }\n+    }\n+\n+    public class RelTypePropertiesEntry {\n+        public String relType;\n+        public List<String> sourceNodeLabels;\n+        public List<String> targetNodeLabels;\n+        public String propertyName;\n+        public List<String>propertyTypes;\n+        public boolean mandatory;\n+        public long propertyObservations;\n+        public long totalObservations;\n+\n+        public RelTypePropertiesEntry(String relType, List<String> sourceNodeLabels, List<String> targetNodeLabels, String propertyName, List<String>propertyTypes, boolean mandatory, long propertyObservations, long totalObservations) {\n+            this.relType = relType;\n+            this.sourceNodeLabels = sourceNodeLabels;\n+            this.targetNodeLabels = targetNodeLabels;\n+            this.propertyName = propertyName;\n+            this.propertyTypes = propertyTypes;\n+            this.mandatory = mandatory;\n+            this.propertyObservations = propertyObservations;\n+            this.totalObservations = totalObservations;\n+        }\n+    }\n+\n+    public Tables4LabelsProfile() {\n+        labelMap = new LinkedHashMap(100);\n+        relMap = new LinkedHashMap(100);\n+        obsByNode = new LinkedHashMap(100);\n+        obsByRelType = new LinkedHashMap(100);\n+    }\n+\n+    public void noteIndex(Label label, IndexDefinition id) {\n+\n+    }\n+\n+    public void noteConstraint(Label label, ConstraintDefinition cd) {\n+\n+    }\n+\n+    public PropertyContainerProfile getNodeProfile(OrderedLabels ol) {\n+        if (labelMap.containsKey(ol)) {\n+            return labelMap.get(ol);\n+        } else {\n+            PropertyContainerProfile p = new PropertyContainerProfile();\n+            labelMap.put(ol, p);\n+            return p;\n+        }\n+    }\n+\n+    public PropertyContainerProfile getRelProfile(String relType) {\n+        if (relMap.containsKey(relType)) {\n+            return relMap.get(relType);\n+        } else {\n+            PropertyContainerProfile p = new PropertyContainerProfile();\n+            relMap.put(relType, p);\n+            return p;\n+        }\n+    }\n+\n+    public Long sawNode(OrderedLabels labels) {\n+        if (obsByNode.containsKey(labels)) {\n+            Long val = obsByNode.get(labels) + 1;\n+            obsByNode.put(labels, val);\n+            return val;\n+        } else {\n+            obsByNode.put(labels, 1L);\n+            return 1L;\n+        }\n+    }\n+\n+    public Long sawRel(String typeName) {\n+        if (obsByRelType.containsKey(typeName)) {\n+            Long val = obsByRelType.get(typeName) + 1;\n+            obsByRelType.put(typeName, val);\n+            return val;\n+        } else {\n+            obsByRelType.put(typeName, 1L);\n+            return 1L;\n+        }\n+    }\n+\n+    public void observe(Node n, MetaConfig config, Iterable<ConstraintDefinition> constraints, Map<String, Iterable<ConstraintDefinition>> relConstraints) {\n+        OrderedLabels labels = new OrderedLabels(n.getLabels());\n+        PropertyContainerProfile localNodeProfile = getNodeProfile(labels);\n+\n+        Set<String> excludes = config.getExcludes();\n+        Set<String> includesRels = config.getIncludesRels();\n+\n+        // Only descend and look at properties if it's in our match list.\n+        if (config.matches(n.getLabels())) {\n+            sawNode(labels);\n+            localNodeProfile.observe(n, constraints, true, relConstraints, null, null);\n+        }\n+\n+        // Even if the node isn't in our match list, do rel processing.  This\n+        // is because our profiling is \"node-first\" to get to the relationships,\n+        // and if we don't do it this way, it's possible to blacklist nodes and\n+        // thereby miss relationships that were of interest.\n+        for (RelationshipType type : n.getRelationshipTypes()) {\n+            String typeName = type.name();\n+\n+            if (!config.matches(type)) { continue; }\n+\n+            int out = n.getDegree(type, Direction.OUTGOING);\n+            if (out == 0) continue;\n+\n+            long seenSoFar = sawRel(typeName);\n+\n+            if (seenSoFar > config.getMaxRels()) {\n+                // We've seen more than the maximum sample size for this rel, so\n+                // we don't need to keep looking.\n+                continue;\n+            }\n+\n+            PropertyContainerProfile localRelProfile = getRelProfile(typeName);\n+\n+            for(Relationship r : n.getRelationships(type, Direction.OUTGOING)) {\n+                Iterable<Label> relStartNode = r.getStartNode().getLabels();\n+                Iterable<Label> relEndNode = r.getEndNode().getLabels();\n+                boolean isNode = false;\n+                localRelProfile.observe(r, constraints, isNode, relConstraints, relStartNode, relEndNode);\n+            }\n+        }\n+    }\n+\n+    public Tables4LabelsProfile finished() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 166}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njg0OTE2", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#pullrequestreview-348684916", "createdAt": "2020-01-27T14:06:06Z", "commit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowNjowNlrOFiDwQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowNjowNlrOFiDwQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1NzQxMQ==", "bodyText": "sourceNodeLabels and targetNodeLabels can be initialized with an argument 4 for initial size.  99.9999% of neo4j nodes don't have more than 4 labels for reasons we can discuss later if you're interested.\nAlso, you can save a lot of code and two while loops here by initializing your lists from your iterators in an easier way here:\nhttps://www.baeldung.com/java-convert-iterator-to-list#java8", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371257411", "createdAt": "2020-01-27T14:06:06Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {\n+                    for (String pk : cd.getPropertyKeys()) {\n+                        if (pk == propName) {\n+                            tracker.mandatory = true;\n+                        }\n+                    }\n+                }\n+            } else {\n+\n+                // Check for relationship constraints - NOTE: Could probably improve the efficiency here a bit. Too many nested loops.\n+\n+                List<String> sourceNodeLabels = new ArrayList<String>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 60}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njg1Njk2", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#pullrequestreview-348685696", "createdAt": "2020-01-27T14:07:13Z", "commit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowNzoxM1rOFiDyrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDowNzoxM1rOFiDyrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI1ODAyOA==", "bodyText": "See above comment.   This code should be in Tables4LabelsProfile#finished(), and you need to check only for existance constraints, not for any constraint (which includes uniqueness, which does not guarantee the property is mandatory)", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371258028", "createdAt": "2020-01-27T14:07:13Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyContainerProfile.java", "diffHunk": "@@ -0,0 +1,98 @@\n+package apoc.meta.tablesforlabels;\n+\n+import org.neo4j.graphdb.Label;\n+import org.neo4j.graphdb.Node;\n+import org.neo4j.graphdb.PropertyContainer;\n+import org.neo4j.graphdb.schema.ConstraintDefinition;\n+\n+import java.util.*;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * A profile of a particular ordered label set (or relationship type) has a set of possible properties that can exist, and\n+ * stats about those properties.\n+ */\n+public class PropertyContainerProfile {\n+    public long observations;\n+    Map<String, PropertyTracker> profile;\n+\n+    public PropertyContainerProfile() {\n+        observations = 0;\n+        profile = new HashMap<>(3);\n+    }\n+\n+    public Set<String> propertyNames() { return profile.keySet(); }\n+    public PropertyTracker trackerFor(String propName) { return profile.get(propName); }\n+\n+    public void observe(PropertyContainer n, Iterable<ConstraintDefinition> constraints, boolean isNode, Map<String, Iterable<ConstraintDefinition>> relConstraints, Iterable<Label> relStartNode, Iterable<Label> relEndNode) {\n+        observations++;\n+\n+        for (String propName : n.getPropertyKeys()) {\n+            PropertyTracker tracker;\n+\n+            if (profile.containsKey(propName)) {\n+                tracker = profile.get(propName);\n+            } else {\n+                tracker = new PropertyTracker(propName);\n+                profile.put(propName, tracker);\n+            }\n+\n+            tracker.addObservation(n.getProperty(propName));\n+\n+            if (isNode) {\n+\n+                // Check for node constraints\n+\n+                tracker.mandatory = false;\n+                for (ConstraintDefinition cd : constraints) {\n+                    for (String pk : cd.getPropertyKeys()) {\n+                        if (pk == propName) {\n+                            tracker.mandatory = true;\n+                        }\n+                    }\n+                }\n+            } else {\n+\n+                // Check for relationship constraints - NOTE: Could probably improve the efficiency here a bit. Too many nested loops.\n+\n+                List<String> sourceNodeLabels = new ArrayList<String>();\n+                List<String> targetNodeLabels = new ArrayList<String>();\n+\n+                Iterator<Label> rsn = relStartNode.iterator();\n+                Iterator<Label> ren = relEndNode.iterator();\n+\n+                while (rsn.hasNext()) {\n+                    sourceNodeLabels.add(rsn.next().name());\n+                }\n+\n+                while (ren.hasNext()) {\n+                    targetNodeLabels.add(ren.next().name());\n+                }\n+\n+                tracker.sourceNodeLabels = sourceNodeLabels;\n+                tracker.targetNodeLabels = targetNodeLabels;\n+                \n+                tracker.mandatory = false;\n+\n+                for (Map.Entry<String,Iterable<ConstraintDefinition>> entry : relConstraints.entrySet()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 79}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4Njg4ODY3", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#pullrequestreview-348688867", "createdAt": "2020-01-27T14:11:36Z", "commit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDoxMTozNlrOFiD7sA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yN1QxNDoxMTozNlrOFiD7sA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTI2MDMzNg==", "bodyText": "Prior to final approval, Shash please go through the types and ensure that we haven't missed anything there, or ideally make sure unit test coverage covers every possible type.\nSome type documentation (or the entry point to it) is here: https://neo4j.com/docs/cypher-manual/current/functions/temporal/\nThe original code was written under 3.5.   I'm about 80% sure that in Neo4j 4.0 we didn't introduce any new types, but we need to make sure we have total coverage.   For each type we also need to cover the corresponding array type.\nIf we miss one, then the code will report the type as string.  The driver will similarly coerce it to string, and we'll end up with a bug report so we need to be sure we're 100% complete.  If you've done the review or are satisfied the unit tests cover this, then just flag a follow-up comment saying you looked into it and this point is good to go.", "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/pull/1389#discussion_r371260336", "createdAt": "2020-01-27T14:11:36Z", "author": {"login": "moxious"}, "path": "src/main/java/apoc/meta/tablesforlabels/PropertyTracker.java", "diffHunk": "@@ -0,0 +1,92 @@\n+package apoc.meta.tablesforlabels;\n+import org.neo4j.graphdb.Label;\n+\n+import java.util.*;\n+\n+public class PropertyTracker {\n+    public String name;\n+    public Set<String> types;\n+    public List<String> sourceNodeLabels;\n+    public List<String> targetNodeLabels;\n+    public boolean mandatory;\n+    public long observations;\n+    public long nulls;\n+\n+    public PropertyTracker(String name) {\n+        this.name = name;\n+        sourceNodeLabels = new ArrayList<String>();\n+        targetNodeLabels = new ArrayList<String>();\n+        types = new HashSet<>(3);\n+        mandatory = true;\n+        observations = 0L;\n+        nulls = 0L;\n+    }\n+\n+    public void addObservation(Object value) {\n+        observations++;\n+\n+        if (value == null) { nulls++; }\n+\n+        this.mandatory = this.mandatory && (value != null);\n+        types.add(assignTypeName(value));\n+    }\n+\n+    private String assignTypeName(Object value) {\n+        String typeName = value.getClass().getCanonicalName();\n+        if (typeMappings.containsKey(typeName)) {\n+            return typeMappings.get(typeName);\n+        }\n+\n+        return typeName.replace(\"java.lang.\", \"\");\n+    }\n+\n+    public List<String> propertyTypes() {\n+        List<String> ret = new ArrayList<>(types);\n+        Collections.sort(ret);\n+        return ret;\n+    }\n+\n+    /** Call when completed with the total number of nodes observed */\n+    public void finished(long totalObservations) {\n+        // As a final step, a given property can be missing on some nodes.\n+        // If that occurred it wasn't tracked, and we need to mark it as optional\n+        // because while it may always be populated *when its present* it can be missing\n+        // from some nodes.\n+        if (totalObservations > observations) {\n+            mandatory = false;\n+        }\n+    }\n+\n+    public static final Map<String,String> typeMappings = new HashMap<String,String>();\n+    static {\n+        typeMappings.put(\"java.lang.String\", \"String\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0e30e308c391b371f45687963811b5fe38eae4bc"}, "originalPosition": 62}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fca323dd5b2736e5e62f7ce79bf1103cc7129f2d", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/fca323dd5b2736e5e62f7ce79bf1103cc7129f2d", "committedDate": "2020-01-29T06:15:55Z", "message": "Multiple updates as follows:\n\n- Refactored R4L functionality (should now support non-existent properties, and improved performance)\n- Added checks to ensure that only NODE_PROPERTY_EXISTENCE and RELATIONSHIP_PROPERTY_EXISTENCE constraints are examined for mandatory field\n\nTODO:\n- Unit tests\n- Improve constraint performance (one-time check vs looped check)\n- asciidoc Documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d895bc5edd2862a412a5040d497e8633d48d293a", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/d895bc5edd2862a412a5040d497e8633d48d293a", "committedDate": "2020-01-29T06:45:11Z", "message": "Updated include/exclude parameters for consistency:\n\nincludeLabels - list of included labels\nincludeRels - list of includes rels\nexcludeLabels - list of excluded labels\nexcludeRels - list of excluded rels"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bf6bd7e66ff69fe129ac5eb5e8db0e0ee315386e", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/bf6bd7e66ff69fe129ac5eb5e8db0e0ee315386e", "committedDate": "2020-01-29T23:33:49Z", "message": "Fixes some issues with R4L property observations. Previously properties were coming back which weren't actually assigned due to the seperation of relType and source/target nodes. This fix combines all three parameters in to one identifier per relationship.\n\nNote: Observations are counted by label (not node) so if a node has multiple labels, the number of observations will be higher. This should not affect the accuracy of data, but may have a slight performance affect that could become a bigger issue with large graphs that routinely use multiple labels per node. This issue is scheduled to be resolved in a future version."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "25e2b31bac3f7526706b796b3f3061d6a441c7d4", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/25e2b31bac3f7526706b796b3f3061d6a441c7d4", "committedDate": "2020-01-31T12:52:50Z", "message": "The following changes were added:\n\n- To maintain backwards compatibility, re-added support for config options \"labels\", \"rels\" and \"excludes\" for \"includeLabels\", \"includeRels\" and \"excludeLabels\" respectively. Both old and new are available. Added the support for the old options for the meta.subGraph() function.\n- All tests should pass now."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a54a52694d12b15999e89c3103b7f66b405ffcb", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/6a54a52694d12b15999e89c3103b7f66b405ffcb", "committedDate": "2020-02-11T15:11:06Z", "message": "Fixed double underscore issue on node labels for relTypeProperties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06ebb0213f04f5fc3465185bdde9a652e173f514", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/06ebb0213f04f5fc3465185bdde9a652e173f514", "committedDate": "2020-02-13T09:27:58Z", "message": "Changes to error handling, etc, based on code review comments by sarmbruster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bd14e5d32d7dcf7372276e2302bd5d3a3ef2a844", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/bd14e5d32d7dcf7372276e2302bd5d3a3ef2a844", "committedDate": "2020-02-13T09:34:09Z", "message": "Committing features:\n\n- Added config option \"excludeRels\" to ignore specific nodes that have specific relationships relationship when calling apoc.meta.nodeTypeProperties.\n- Added \"rels\" config option to work when calling apoc.meta.nodeTypeProperties. Previously \"rels\" would be ignored when querying for nodes. Now, if specified, the option will only return nodes that have matching relationships.\n- Added missing types \"LocalDateTime\", \"LocalTime\", \"Duration\", \"Time\".\n- Confirmed failing tests pass."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81a18117298b59a3ee7106874e609bcee820249c", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/81a18117298b59a3ee7106874e609bcee820249c", "committedDate": "2020-02-13T09:34:09Z", "message": "Check-in tests for include/exclude nodes by relationship."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "538828ff1643fcd333a385f502a7b525b9ee4716", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/538828ff1643fcd333a385f502a7b525b9ee4716", "committedDate": "2020-02-13T09:34:09Z", "message": "Merged in new mandatory handling:\n\n- If a property on a Node or Relationship has a constraint, the mandatory flag is set to true. Otherwise it is set to false."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05a2238f85c17e74366049090bfa6813d5aabbcc", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/05a2238f85c17e74366049090bfa6813d5aabbcc", "committedDate": "2020-02-13T09:34:09Z", "message": "Adding feature Relationships 4 Labels (R4L). This adds an additional two columns to the relTypeProperties() call showing source and destination labels (sourceNodeLabels and targetNodeLabels), both as List<String> data types."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa96f841d8a961670f59de35739f231bfada3693", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/aa96f841d8a961670f59de35739f231bfada3693", "committedDate": "2020-02-13T09:34:09Z", "message": "Multiple updates as follows:\n\n- Refactored R4L functionality (should now support non-existent properties, and improved performance)\n- Added checks to ensure that only NODE_PROPERTY_EXISTENCE and RELATIONSHIP_PROPERTY_EXISTENCE constraints are examined for mandatory field\n\nTODO:\n- Unit tests\n- Improve constraint performance (one-time check vs looped check)\n- asciidoc Documentation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1b35c8631493fec34a42dd292029ec6b74725402", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/1b35c8631493fec34a42dd292029ec6b74725402", "committedDate": "2020-02-13T09:34:09Z", "message": "Updated include/exclude parameters for consistency:\n\nincludeLabels - list of included labels\nincludeRels - list of includes rels\nexcludeLabels - list of excluded labels\nexcludeRels - list of excluded rels"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7adeb4a5642db9e91d70e24cd380b2dbbbc76db", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/b7adeb4a5642db9e91d70e24cd380b2dbbbc76db", "committedDate": "2020-02-13T09:34:09Z", "message": "Fixes some issues with R4L property observations. Previously properties were coming back which weren't actually assigned due to the seperation of relType and source/target nodes. This fix combines all three parameters in to one identifier per relationship.\n\nNote: Observations are counted by label (not node) so if a node has multiple labels, the number of observations will be higher. This should not affect the accuracy of data, but may have a slight performance affect that could become a bigger issue with large graphs that routinely use multiple labels per node. This issue is scheduled to be resolved in a future version."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "521fd38ed837160fc1b883fae33136ecddcdc558", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/521fd38ed837160fc1b883fae33136ecddcdc558", "committedDate": "2020-02-13T09:34:09Z", "message": "The following changes were added:\n\n- To maintain backwards compatibility, re-added support for config options \"labels\", \"rels\" and \"excludes\" for \"includeLabels\", \"includeRels\" and \"excludeLabels\" respectively. Both old and new are available. Added the support for the old options for the meta.subGraph() function.\n- All tests should pass now."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "862ef402ba3d06a3ce12d099987adf382a8b1087", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/862ef402ba3d06a3ce12d099987adf382a8b1087", "committedDate": "2020-02-13T09:34:09Z", "message": "Fixed double underscore issue on node labels for relTypeProperties"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8c6a4a45d279247f24bd2fd1f33e1b96da41854e", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/8c6a4a45d279247f24bd2fd1f33e1b96da41854e", "committedDate": "2020-02-13T09:34:09Z", "message": "Changes to error handling, etc, based on code review comments by sarmbruster"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9469b23512bc9c5d15ecadbd829ba33b505688c9", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/9469b23512bc9c5d15ecadbd829ba33b505688c9", "committedDate": "2020-02-13T09:35:17Z", "message": "Merge branch '3.5-t4l' of https://github.com/neoarchitect/neo4j-apoc-procedures into 3.5-t4l"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa9454ade4a4e14c7b3e801d5dda84a2c917d208", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/fa9454ade4a4e14c7b3e801d5dda84a2c917d208", "committedDate": "2020-02-13T10:57:55Z", "message": "Added asciidoc documentation for new procedures"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45d5039bb9b4daeaaff45631f5b163e5df631f39", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/45d5039bb9b4daeaaff45631f5b163e5df631f39", "committedDate": "2020-02-13T13:19:42Z", "message": "Rewrite of constraint checking mechanism for performance in T4L"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "75cd7f7b7023aa83b1dacfff21eca9f7b81f4641", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/75cd7f7b7023aa83b1dacfff21eca9f7b81f4641", "committedDate": "2020-02-14T22:54:51Z", "message": "fixing leading whitespace issues"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "efc1b7cde16394173cce55d9d839b7228ab269b5", "author": {"user": null}, "url": "https://github.com/neo4j-contrib/neo4j-apoc-procedures/commit/efc1b7cde16394173cce55d9d839b7228ab269b5", "committedDate": "2020-02-14T23:01:59Z", "message": "Merge branch '3.5' into 3.5-t4l"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 941, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}