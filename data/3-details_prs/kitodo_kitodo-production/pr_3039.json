{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzYwMDM4NDk5", "number": 3039, "title": "Migrate serial publications", "bodyText": "This implements the migration of serial publications. For serial publications (series, multi-volume works), a parent process is created and the children found are linked to it. The METS structure is adjusted.", "createdAt": "2020-01-07T15:21:04Z", "url": "https://github.com/kitodo/kitodo-production/pull/3039", "merged": true, "mergeCommit": {"oid": "c5f37d04bde462cc98e2c7fff86cdcfc2f7b8f48"}, "closed": true, "closedAt": "2020-01-21T08:58:37Z", "author": {"login": "matthias-ronge"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb4Cer-gBqjI5MjgwMjU3MDI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABb48szqABqjI5MzgxODI0NDU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0c071244c76006d4acfa61f6392768ae7a5d8493", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/0c071244c76006d4acfa61f6392768ae7a5d8493", "committedDate": "2020-01-07T15:17:19Z", "message": "Fix bugs and code style"}, "afterCommit": {"oid": "9fe7dee8e1f216ede1f9e1df9cdaaa075eb8e918", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/9fe7dee8e1f216ede1f9e1df9cdaaa075eb8e918", "committedDate": "2020-01-07T15:26:17Z", "message": "Fix bugs and code style"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9fe7dee8e1f216ede1f9e1df9cdaaa075eb8e918", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/9fe7dee8e1f216ede1f9e1df9cdaaa075eb8e918", "committedDate": "2020-01-07T15:26:17Z", "message": "Fix bugs and code style"}, "afterCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/037955c6c5b8329e4eed5e196935580b5c1d4ba6", "committedDate": "2020-01-08T07:19:17Z", "message": "Fix bugs and code style"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQwNDQyMTE3", "url": "https://github.com/kitodo/kitodo-production/pull/3039#pullrequestreview-340442117", "createdAt": "2020-01-09T11:02:35Z", "commit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTowMjozNVrOFbyQ7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0wOVQxMTo1MjoxOFrOFbzdFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3OTQwNg==", "bodyText": "Missing Javadoc", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364679406", "createdAt": "2020-01-09T11:02:35Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/forms/MigrationForm.java", "diffHunk": "@@ -132,6 +133,11 @@ public void showAggregatedProcesses() {\n         processListRendered = true;\n     }\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MDU1MQ==", "bodyText": "please use lowecase", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364680551", "createdAt": "2020-01-09T11:05:31Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/resources/messages/messages_de.properties", "diffHunk": "@@ -426,6 +426,7 @@ granularity.years=Jahrg\\u00E4nge\n guessImages=gesch\\u00E4tzte Seitenanzahl\n help=Hilfe\n hideCorrectionTasks=Entferne Korrekturschritte\n+HierarchyMigrationTask=Migriere serielle Publikationen", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MDc1Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    URI yearFile = FileService.this.createAnchorFile(FileService.this.getMetadataFilePath(process, false, false));\n          \n          \n            \n                    URI yearFile = createAnchorFile(FileService.this.getMetadataFilePath(process, false, false));", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364680752", "createdAt": "2020-01-09T11:06:02Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/services/file/FileService.java", "diffHunk": "@@ -547,6 +547,20 @@ public void moveFile(URI sourceUri, URI targetUri) throws IOException {\n         fileManagementModule.move(sourceUri, targetUri);\n     }\n \n+    /**\n+     * Process owns anchor XML.\n+     *\n+     * @param process\n+     *            whose metadata file path to use\n+     * @return whether an anchor file was found\n+     * @throws IOException\n+     *             if Io failed\n+     */\n+    public boolean processOwnsAnchorXML(Process process) throws IOException {\n+        URI yearFile = FileService.this.createAnchorFile(FileService.this.getMetadataFilePath(process, false, false));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MDgyNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return FileService.this.fileExist(yearFile);\n          \n          \n            \n                    return fileExist(yearFile);", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364680827", "createdAt": "2020-01-09T11:06:14Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/services/file/FileService.java", "diffHunk": "@@ -547,6 +547,20 @@ public void moveFile(URI sourceUri, URI targetUri) throws IOException {\n         fileManagementModule.move(sourceUri, targetUri);\n     }\n \n+    /**\n+     * Process owns anchor XML.\n+     *\n+     * @param process\n+     *            whose metadata file path to use\n+     * @return whether an anchor file was found\n+     * @throws IOException\n+     *             if Io failed\n+     */\n+    public boolean processOwnsAnchorXML(Process process) throws IOException {\n+        URI yearFile = FileService.this.createAnchorFile(FileService.this.getMetadataFilePath(process, false, false));\n+        return FileService.this.fileExist(yearFile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4MjY5NQ==", "bodyText": "Parent Processes have already been created? Really? When?", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364682695", "createdAt": "2020-01-09T11:11:15Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY4ODI0Ng==", "bodyText": "Its not only in Database but in elasticsearch and Object level.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static void linkInDatabase(Process parentProcess, Process childProcess) throws DataException {\n          \n          \n            \n                private static void linkParentProcessWithChildProcess(Process parentProcess, Process childProcess) throws DataException {", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364688246", "createdAt": "2020-01-09T11:25:53Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the\n+     * value is the process ID, then the current numbers of child links.\n+     */\n+    private Map<String, List<Integer>> parentProcesses = new HashMap<>();\n+\n+    /**\n+     * List of all processes to migrate.\n+     */\n+    private List<Integer> processesList;\n+\n+    /**\n+     * All processes belong to a project.\n+     */\n+    private Collection<Project> projects;\n+\n+    /**\n+     * The progress, for the progress bar.\n+     */\n+    private int progress = 0;\n+\n+    public HierarchyMigrationTask(Collection<Project> projects) {\n+        super(projects.stream().map(Project::getTitle).collect(Collectors.joining(\", \")));\n+        this.projects = projects;\n+    }\n+\n+    /**\n+     * Clone constructor. Provides the ability to restart the task if it was\n+     * previously interrupted.\n+     *\n+     * @param source\n+     *            terminated thread\n+     */\n+    private HierarchyMigrationTask(HierarchyMigrationTask source) {\n+        super(source);\n+        this.processesList = source.processesList;\n+        this.projects = source.projects;\n+        this.progress = source.progress;\n+    }\n+\n+    /**\n+     * Defines the display name of the task in the task manager.\n+     */\n+    @Override\n+    public String getDisplayName() {\n+        return Helper.getTranslation(\"HierarchyMigrationTask\");\n+    }\n+\n+    /**\n+     * The {@code run()} method is called when the thread starts. It initializes\n+     * the process list (if this has not already been done), processes it and\n+     * updates the progress display in the screen output.\n+     */\n+    @Override\n+    public void run() {\n+        try {\n+            if (Objects.isNull(processesList)) {\n+                processesList = projects.parallelStream().flatMap(project -> project.getProcesses().parallelStream())\n+                        .map(Process::getId).collect(Collectors.toList());\n+            }\n+\n+            while (progress < processesList.size()) {\n+                Process process = processService.getById(processesList.get(progress));\n+                if (fileService.processOwnsAnchorXML(process) && !fileService.processOwnsYearXML(process)) {\n+                    setWorkDetail(process.getTitle());\n+                    migrate(process);\n+                }\n+                super.setProgress(++progress / processesList.size());\n+                if (Thread.currentThread().isInterrupted()) {\n+                    return;\n+                }\n+            }\n+        } catch (IOException | DAOException | ProcessGenerationException | DataException e) {\n+            setException(e);\n+        }\n+    }\n+\n+    /**\n+     * This function does the actual work and migrates exactly one process.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void migrate(Process process) throws IOException, ProcessGenerationException, DataException, DAOException {\n+        logger.info(\"Starting to convert process {} (ID {})...\", process.getTitle(), process.getId());\n+        long begin = System.nanoTime();\n+        migrateMetadataFiles(process);\n+        Optional<String> parentId = getParentRecordId(process);\n+        if (parentId.isPresent()) {\n+            if (parentProcesses.containsKey(parentId.get())) {\n+                linkProcessInParent(process, parentProcesses.get(parentId.get()));\n+            } else {\n+                parentProcesses.put(parentId.get(), createParentProcess(process));\n+            }\n+            renameAnchorFile(process);\n+        } else {\n+            logger.warn(\"Process {} (ID {}): Parent has no identifier! Cannot create parent process.\",\n+                process.getTitle(), process.getId());\n+        }\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Converting {} took {} ms.\", process.getTitle(),\n+                TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin));\n+        }\n+    }\n+\n+    /**\n+     * The metadata file and the anchor file are converted to the new internal\n+     * format using XSLT.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private static void migrateMetadataFiles(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        dataEditorService.readData(metadataFilePath);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        dataEditorService.readData(anchorFilePath);\n+    }\n+\n+    /**\n+     * Reads the parent record identifier from the anchor file.\n+     */\n+    private static Optional<String> getParentRecordId(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        Workpiece anchorWorkpiece = metsService.loadWorkpiece(anchorFilePath);\n+        Optional<String> parentRecordId = anchorWorkpiece.getRootElement().getMetadata().parallelStream()\n+                .filter(metadata -> metadata.getKey().equals(\"CatalogIDDigital\"))\n+                .filter(MetadataEntry.class::isInstance).map(MetadataEntry.class::cast).map(MetadataEntry::getValue)\n+                .findFirst();\n+        return parentRecordId;\n+    }\n+\n+    /**\n+     * Creates a new parent process. The process is created in the database, the\n+     * process folder is created on the file system and the METS file is\n+     * written. The METS file of the child process is migrated and a link\n+     * between the processes is written in the database.\n+     *\n+     * @param childProcess\n+     *            process to migrate\n+     * @return a data object with the ID of the created parent process and the\n+     *         current number of the child process\n+     */\n+    private List<Integer> createParentProcess(Process childProcess)\n+            throws ProcessGenerationException, IOException, DataException {\n+\n+        processGenerator.generateProcess(childProcess.getTemplate().getId(), childProcess.getProject().getId());\n+        Process parentProcess = processGenerator.getGeneratedProcess();\n+        processService.save(parentProcess);\n+        fileService.createProcessLocation(parentProcess);\n+        createParentMetsFile(childProcess);\n+        ArrayList<Integer> parentData = new ArrayList<>();\n+        parentData.add(parentProcess.getId());\n+        URI metadataFilePath = fileService.getMetadataFilePath(childProcess);\n+        parentData.add(convertChildMetsFile(metadataFilePath));\n+        linkInDatabase(parentProcess, childProcess);\n+        return parentData;\n+    }\n+\n+    /**\n+     * Links parent process and child process in the database. The processes are\n+     * saved.\n+     *\n+     * @param parentProcess\n+     *            parent process to link\n+     * @param childProcess\n+     *            child process to link\n+     */\n+    private static void linkInDatabase(Process parentProcess, Process childProcess) throws DataException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 244}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTE0Nw==", "bodyText": "You are mixing up purposes of integers in the List.\nWhy not using the process ID as a key instead of the String?\nShouldn't the list of childs also be found in the Database?", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364691147", "createdAt": "2020-01-09T11:32:38Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the\n+     * value is the process ID, then the current numbers of child links.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 77}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5MTc5Mg==", "bodyText": "What does currentNO stands for in the metadata?\nPlease give a more explicit description", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364691792", "createdAt": "2020-01-09T11:34:21Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the\n+     * value is the process ID, then the current numbers of child links.\n+     */\n+    private Map<String, List<Integer>> parentProcesses = new HashMap<>();\n+\n+    /**\n+     * List of all processes to migrate.\n+     */\n+    private List<Integer> processesList;\n+\n+    /**\n+     * All processes belong to a project.\n+     */\n+    private Collection<Project> projects;\n+\n+    /**\n+     * The progress, for the progress bar.\n+     */\n+    private int progress = 0;\n+\n+    public HierarchyMigrationTask(Collection<Project> projects) {\n+        super(projects.stream().map(Project::getTitle).collect(Collectors.joining(\", \")));\n+        this.projects = projects;\n+    }\n+\n+    /**\n+     * Clone constructor. Provides the ability to restart the task if it was\n+     * previously interrupted.\n+     *\n+     * @param source\n+     *            terminated thread\n+     */\n+    private HierarchyMigrationTask(HierarchyMigrationTask source) {\n+        super(source);\n+        this.processesList = source.processesList;\n+        this.projects = source.projects;\n+        this.progress = source.progress;\n+    }\n+\n+    /**\n+     * Defines the display name of the task in the task manager.\n+     */\n+    @Override\n+    public String getDisplayName() {\n+        return Helper.getTranslation(\"HierarchyMigrationTask\");\n+    }\n+\n+    /**\n+     * The {@code run()} method is called when the thread starts. It initializes\n+     * the process list (if this has not already been done), processes it and\n+     * updates the progress display in the screen output.\n+     */\n+    @Override\n+    public void run() {\n+        try {\n+            if (Objects.isNull(processesList)) {\n+                processesList = projects.parallelStream().flatMap(project -> project.getProcesses().parallelStream())\n+                        .map(Process::getId).collect(Collectors.toList());\n+            }\n+\n+            while (progress < processesList.size()) {\n+                Process process = processService.getById(processesList.get(progress));\n+                if (fileService.processOwnsAnchorXML(process) && !fileService.processOwnsYearXML(process)) {\n+                    setWorkDetail(process.getTitle());\n+                    migrate(process);\n+                }\n+                super.setProgress(++progress / processesList.size());\n+                if (Thread.currentThread().isInterrupted()) {\n+                    return;\n+                }\n+            }\n+        } catch (IOException | DAOException | ProcessGenerationException | DataException e) {\n+            setException(e);\n+        }\n+    }\n+\n+    /**\n+     * This function does the actual work and migrates exactly one process.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void migrate(Process process) throws IOException, ProcessGenerationException, DataException, DAOException {\n+        logger.info(\"Starting to convert process {} (ID {})...\", process.getTitle(), process.getId());\n+        long begin = System.nanoTime();\n+        migrateMetadataFiles(process);\n+        Optional<String> parentId = getParentRecordId(process);\n+        if (parentId.isPresent()) {\n+            if (parentProcesses.containsKey(parentId.get())) {\n+                linkProcessInParent(process, parentProcesses.get(parentId.get()));\n+            } else {\n+                parentProcesses.put(parentId.get(), createParentProcess(process));\n+            }\n+            renameAnchorFile(process);\n+        } else {\n+            logger.warn(\"Process {} (ID {}): Parent has no identifier! Cannot create parent process.\",\n+                process.getTitle(), process.getId());\n+        }\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Converting {} took {} ms.\", process.getTitle(),\n+                TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin));\n+        }\n+    }\n+\n+    /**\n+     * The metadata file and the anchor file are converted to the new internal\n+     * format using XSLT.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private static void migrateMetadataFiles(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        dataEditorService.readData(metadataFilePath);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        dataEditorService.readData(anchorFilePath);\n+    }\n+\n+    /**\n+     * Reads the parent record identifier from the anchor file.\n+     */\n+    private static Optional<String> getParentRecordId(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        Workpiece anchorWorkpiece = metsService.loadWorkpiece(anchorFilePath);\n+        Optional<String> parentRecordId = anchorWorkpiece.getRootElement().getMetadata().parallelStream()\n+                .filter(metadata -> metadata.getKey().equals(\"CatalogIDDigital\"))\n+                .filter(MetadataEntry.class::isInstance).map(MetadataEntry.class::cast).map(MetadataEntry::getValue)\n+                .findFirst();\n+        return parentRecordId;\n+    }\n+\n+    /**\n+     * Creates a new parent process. The process is created in the database, the\n+     * process folder is created on the file system and the METS file is\n+     * written. The METS file of the child process is migrated and a link\n+     * between the processes is written in the database.\n+     *\n+     * @param childProcess\n+     *            process to migrate\n+     * @return a data object with the ID of the created parent process and the\n+     *         current number of the child process\n+     */\n+    private List<Integer> createParentProcess(Process childProcess)\n+            throws ProcessGenerationException, IOException, DataException {\n+\n+        processGenerator.generateProcess(childProcess.getTemplate().getId(), childProcess.getProject().getId());\n+        Process parentProcess = processGenerator.getGeneratedProcess();\n+        processService.save(parentProcess);\n+        fileService.createProcessLocation(parentProcess);\n+        createParentMetsFile(childProcess);\n+        ArrayList<Integer> parentData = new ArrayList<>();\n+        parentData.add(parentProcess.getId());\n+        URI metadataFilePath = fileService.getMetadataFilePath(childProcess);\n+        parentData.add(convertChildMetsFile(metadataFilePath));\n+        linkInDatabase(parentProcess, childProcess);\n+        return parentData;\n+    }\n+\n+    /**\n+     * Links parent process and child process in the database. The processes are\n+     * saved.\n+     *\n+     * @param parentProcess\n+     *            parent process to link\n+     * @param childProcess\n+     *            child process to link\n+     */\n+    private static void linkInDatabase(Process parentProcess, Process childProcess) throws DataException {\n+        parentProcess.getChildren().add(childProcess);\n+        childProcess.setParent(parentProcess);\n+        processService.save(childProcess);\n+    }\n+\n+    /**\n+     * Generates the METS file for the parent process from the process anchor\n+     * file.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void createParentMetsFile(Process process) throws IOException {\n+        URI metadataFileUri = fileService.getMetadataFilePath(process);\n+        URI anchorFileUri = fileService.createAnchorFile(metadataFileUri);\n+        Workpiece workpiece = metsService.loadWorkpiece(anchorFileUri);\n+        LinkedMetsResource link = workpiece.getRootElement().getChildren().get(0).getLink();\n+        link.setLoctype(\"Kitodo.Production\");\n+        link.setUri(processService.getProcessURI(process));\n+        URI parentMetadataFileUri = fileService.getMetadataFilePath(processGenerator.getGeneratedProcess(), false,\n+            false);\n+        metsService.saveWorkpiece(workpiece, parentMetadataFileUri);\n+    }\n+\n+    /**\n+     * Changes the METS file of the child process.\n+     *\n+     * @param metadataFilePath\n+     *            URI of the metadata file\n+     * @return the current number, may be {@code null}\n+     */\n+    private static Integer convertChildMetsFile(URI metadataFilePath) throws IOException {\n+        Workpiece workpiece = metsService.loadWorkpiece(metadataFilePath);\n+        IncludedStructuralElement childStructureRoot = workpiece.getRootElement().getChildren().get(0);\n+        workpiece.setRootElement(childStructureRoot);\n+        metsService.saveWorkpiece(workpiece, metadataFilePath);\n+        return getCurrentNo(childStructureRoot);\n+    }\n+\n+    /**\n+     * Extracts the CurrentNo from the metadata.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY5ODkwMQ==", "bodyText": "Is kitodo still working with this renamed anchor file?\n@henning-gerhardt  what do you think?", "url": "https://github.com/kitodo/kitodo-production/pull/3039#discussion_r364698901", "createdAt": "2020-01-09T11:52:18Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/helper/tasks/HierarchyMigrationTask.java", "diffHunk": "@@ -0,0 +1,358 @@\n+/*\n+ * (c) Kitodo. Key to digital objects e. V. <contact@kitodo.org>\n+ *\n+ * This file is part of the Kitodo project.\n+ *\n+ * It is licensed under GNU General Public License version 3 or later.\n+ *\n+ * For the full copyright and license information, please read the\n+ * GPL3-License.txt file that was distributed with this source code.\n+ */\n+\n+package org.kitodo.production.helper.tasks;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.kitodo.api.MetadataEntry;\n+import org.kitodo.api.dataformat.IncludedStructuralElement;\n+import org.kitodo.api.dataformat.Workpiece;\n+import org.kitodo.api.dataformat.mets.LinkedMetsResource;\n+import org.kitodo.data.database.beans.Process;\n+import org.kitodo.data.database.beans.Project;\n+import org.kitodo.data.database.exceptions.DAOException;\n+import org.kitodo.data.exceptions.DataException;\n+import org.kitodo.exceptions.ProcessGenerationException;\n+import org.kitodo.production.helper.Helper;\n+import org.kitodo.production.metadata.MetadataEditor;\n+import org.kitodo.production.process.ProcessGenerator;\n+import org.kitodo.production.services.ServiceManager;\n+import org.kitodo.production.services.data.ProcessService;\n+import org.kitodo.production.services.dataeditor.DataEditorService;\n+import org.kitodo.production.services.dataformat.MetsService;\n+import org.kitodo.production.services.file.FileService;\n+\n+public class HierarchyMigrationTask extends EmptyTask {\n+    private static final Logger logger = LogManager.getLogger(HierarchyMigrationTask.class);\n+\n+    /**\n+     * Service that contains the meta-data editor.\n+     */\n+    private static final DataEditorService dataEditorService = ServiceManager.getDataEditorService();\n+\n+    /**\n+     * Service to access files on the storage.\n+     */\n+    private static final FileService fileService = ServiceManager.getFileService();\n+\n+    /**\n+     * Service to read and write METS file format.\n+     */\n+    private static final MetsService metsService = ServiceManager.getMetsService();\n+\n+    /**\n+     * Service to generate processes.\n+     */\n+    private final ProcessGenerator processGenerator = new ProcessGenerator();\n+\n+    /**\n+     * Service to read and write Process objects in the database or search\n+     * engine index.\n+     */\n+    private static final ProcessService processService = ServiceManager.getProcessService();\n+\n+    /**\n+     * Parent processes have already been created. Key is the identifier, the\n+     * value is the process ID, then the current numbers of child links.\n+     */\n+    private Map<String, List<Integer>> parentProcesses = new HashMap<>();\n+\n+    /**\n+     * List of all processes to migrate.\n+     */\n+    private List<Integer> processesList;\n+\n+    /**\n+     * All processes belong to a project.\n+     */\n+    private Collection<Project> projects;\n+\n+    /**\n+     * The progress, for the progress bar.\n+     */\n+    private int progress = 0;\n+\n+    public HierarchyMigrationTask(Collection<Project> projects) {\n+        super(projects.stream().map(Project::getTitle).collect(Collectors.joining(\", \")));\n+        this.projects = projects;\n+    }\n+\n+    /**\n+     * Clone constructor. Provides the ability to restart the task if it was\n+     * previously interrupted.\n+     *\n+     * @param source\n+     *            terminated thread\n+     */\n+    private HierarchyMigrationTask(HierarchyMigrationTask source) {\n+        super(source);\n+        this.processesList = source.processesList;\n+        this.projects = source.projects;\n+        this.progress = source.progress;\n+    }\n+\n+    /**\n+     * Defines the display name of the task in the task manager.\n+     */\n+    @Override\n+    public String getDisplayName() {\n+        return Helper.getTranslation(\"HierarchyMigrationTask\");\n+    }\n+\n+    /**\n+     * The {@code run()} method is called when the thread starts. It initializes\n+     * the process list (if this has not already been done), processes it and\n+     * updates the progress display in the screen output.\n+     */\n+    @Override\n+    public void run() {\n+        try {\n+            if (Objects.isNull(processesList)) {\n+                processesList = projects.parallelStream().flatMap(project -> project.getProcesses().parallelStream())\n+                        .map(Process::getId).collect(Collectors.toList());\n+            }\n+\n+            while (progress < processesList.size()) {\n+                Process process = processService.getById(processesList.get(progress));\n+                if (fileService.processOwnsAnchorXML(process) && !fileService.processOwnsYearXML(process)) {\n+                    setWorkDetail(process.getTitle());\n+                    migrate(process);\n+                }\n+                super.setProgress(++progress / processesList.size());\n+                if (Thread.currentThread().isInterrupted()) {\n+                    return;\n+                }\n+            }\n+        } catch (IOException | DAOException | ProcessGenerationException | DataException e) {\n+            setException(e);\n+        }\n+    }\n+\n+    /**\n+     * This function does the actual work and migrates exactly one process.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void migrate(Process process) throws IOException, ProcessGenerationException, DataException, DAOException {\n+        logger.info(\"Starting to convert process {} (ID {})...\", process.getTitle(), process.getId());\n+        long begin = System.nanoTime();\n+        migrateMetadataFiles(process);\n+        Optional<String> parentId = getParentRecordId(process);\n+        if (parentId.isPresent()) {\n+            if (parentProcesses.containsKey(parentId.get())) {\n+                linkProcessInParent(process, parentProcesses.get(parentId.get()));\n+            } else {\n+                parentProcesses.put(parentId.get(), createParentProcess(process));\n+            }\n+            renameAnchorFile(process);\n+        } else {\n+            logger.warn(\"Process {} (ID {}): Parent has no identifier! Cannot create parent process.\",\n+                process.getTitle(), process.getId());\n+        }\n+        if (logger.isTraceEnabled()) {\n+            logger.trace(\"Converting {} took {} ms.\", process.getTitle(),\n+                TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin));\n+        }\n+    }\n+\n+    /**\n+     * The metadata file and the anchor file are converted to the new internal\n+     * format using XSLT.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private static void migrateMetadataFiles(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        dataEditorService.readData(metadataFilePath);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        dataEditorService.readData(anchorFilePath);\n+    }\n+\n+    /**\n+     * Reads the parent record identifier from the anchor file.\n+     */\n+    private static Optional<String> getParentRecordId(Process process) throws IOException {\n+        URI metadataFilePath = fileService.getMetadataFilePath(process);\n+        URI anchorFilePath = fileService.createAnchorFile(metadataFilePath);\n+        Workpiece anchorWorkpiece = metsService.loadWorkpiece(anchorFilePath);\n+        Optional<String> parentRecordId = anchorWorkpiece.getRootElement().getMetadata().parallelStream()\n+                .filter(metadata -> metadata.getKey().equals(\"CatalogIDDigital\"))\n+                .filter(MetadataEntry.class::isInstance).map(MetadataEntry.class::cast).map(MetadataEntry::getValue)\n+                .findFirst();\n+        return parentRecordId;\n+    }\n+\n+    /**\n+     * Creates a new parent process. The process is created in the database, the\n+     * process folder is created on the file system and the METS file is\n+     * written. The METS file of the child process is migrated and a link\n+     * between the processes is written in the database.\n+     *\n+     * @param childProcess\n+     *            process to migrate\n+     * @return a data object with the ID of the created parent process and the\n+     *         current number of the child process\n+     */\n+    private List<Integer> createParentProcess(Process childProcess)\n+            throws ProcessGenerationException, IOException, DataException {\n+\n+        processGenerator.generateProcess(childProcess.getTemplate().getId(), childProcess.getProject().getId());\n+        Process parentProcess = processGenerator.getGeneratedProcess();\n+        processService.save(parentProcess);\n+        fileService.createProcessLocation(parentProcess);\n+        createParentMetsFile(childProcess);\n+        ArrayList<Integer> parentData = new ArrayList<>();\n+        parentData.add(parentProcess.getId());\n+        URI metadataFilePath = fileService.getMetadataFilePath(childProcess);\n+        parentData.add(convertChildMetsFile(metadataFilePath));\n+        linkInDatabase(parentProcess, childProcess);\n+        return parentData;\n+    }\n+\n+    /**\n+     * Links parent process and child process in the database. The processes are\n+     * saved.\n+     *\n+     * @param parentProcess\n+     *            parent process to link\n+     * @param childProcess\n+     *            child process to link\n+     */\n+    private static void linkInDatabase(Process parentProcess, Process childProcess) throws DataException {\n+        parentProcess.getChildren().add(childProcess);\n+        childProcess.setParent(parentProcess);\n+        processService.save(childProcess);\n+    }\n+\n+    /**\n+     * Generates the METS file for the parent process from the process anchor\n+     * file.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private void createParentMetsFile(Process process) throws IOException {\n+        URI metadataFileUri = fileService.getMetadataFilePath(process);\n+        URI anchorFileUri = fileService.createAnchorFile(metadataFileUri);\n+        Workpiece workpiece = metsService.loadWorkpiece(anchorFileUri);\n+        LinkedMetsResource link = workpiece.getRootElement().getChildren().get(0).getLink();\n+        link.setLoctype(\"Kitodo.Production\");\n+        link.setUri(processService.getProcessURI(process));\n+        URI parentMetadataFileUri = fileService.getMetadataFilePath(processGenerator.getGeneratedProcess(), false,\n+            false);\n+        metsService.saveWorkpiece(workpiece, parentMetadataFileUri);\n+    }\n+\n+    /**\n+     * Changes the METS file of the child process.\n+     *\n+     * @param metadataFilePath\n+     *            URI of the metadata file\n+     * @return the current number, may be {@code null}\n+     */\n+    private static Integer convertChildMetsFile(URI metadataFilePath) throws IOException {\n+        Workpiece workpiece = metsService.loadWorkpiece(metadataFilePath);\n+        IncludedStructuralElement childStructureRoot = workpiece.getRootElement().getChildren().get(0);\n+        workpiece.setRootElement(childStructureRoot);\n+        metsService.saveWorkpiece(workpiece, metadataFilePath);\n+        return getCurrentNo(childStructureRoot);\n+    }\n+\n+    /**\n+     * Extracts the CurrentNo from the metadata.\n+     *\n+     * @param includedStructualElement\n+     *            outline element with metadata\n+     * @return the CurrentNo, or {@code null}\n+     */\n+    private static Integer getCurrentNo(IncludedStructuralElement includedStructualElement) {\n+        Integer currentNo = includedStructualElement.getMetadata().parallelStream()\n+                .filter(metadata -> metadata.getKey().equals(\"CurrentNo\")).filter(MetadataEntry.class::isInstance)\n+                .map(MetadataEntry.class::cast).map(MetadataEntry::getValue).map(Integer::valueOf).findFirst()\n+                .orElse(null);\n+        return currentNo;\n+    }\n+\n+    /**\n+     * Links a child process in an existing parent process.\n+     *\n+     * @param childProcess\n+     *            child process to link\n+     * @param parentData\n+     *            a data object with the ID of the parent process and the\n+     *            current numbers of the child processes already linked with the\n+     *            parent\n+     */\n+    private static void linkProcessInParent(Process childProcess, List<Integer> parentData)\n+            throws IOException, DAOException, DataException {\n+\n+        URI metadataFilePath = fileService.getMetadataFilePath(childProcess);\n+        Integer currentNo = convertChildMetsFile(metadataFilePath);\n+        Process parentProcess = processService.getById(parentData.get(0));\n+        int insertionPosition = calculateInsertionPosition(parentData, currentNo);\n+        MetadataEditor.addLink(parentProcess, Integer.toString(insertionPosition), childProcess.getId());\n+        parentData.add(insertionPosition + 1, currentNo);\n+        linkInDatabase(parentProcess, childProcess);\n+    }\n+\n+    /**\n+     * Calculates the point at which the child process must be inserted in the\n+     * parent hierarchy.\n+     *\n+     * @param parentData\n+     *            a data object with the ID of the parent process (here unused)\n+     *            and the current numbers of the child processes already linked\n+     *            with the parent, which may be {@code null}\n+     * @param currentNo\n+     *            the current number of the child process to link, may be\n+     *            {@code null}\n+     * @return the insertion position\n+     */\n+    private static int calculateInsertionPosition(List<Integer> parentData, Integer currentNo) {\n+        int currentNumber = Objects.isNull(currentNo) ? Integer.MIN_VALUE : currentNo;\n+        int insertionPosition = 0;\n+        for (int index = 1; index < parentData.size(); index++) {\n+            int comparee = Objects.isNull(parentData.get(index)) ? Integer.MIN_VALUE : parentData.get(index);\n+            if (currentNumber >= comparee) {\n+                insertionPosition++;\n+            } else {\n+                break;\n+            }\n+        }\n+        return insertionPosition;\n+    }\n+\n+    /**\n+     * Renames the anchor file. It is clear that this has been migrated.\n+     *\n+     * @param process\n+     *            process to migrate\n+     */\n+    private static void renameAnchorFile(Process process) throws IOException {\n+        URI anchorFile = fileService.createAnchorFile(fileService.getMetadataFilePath(process));\n+        fileService.renameFile(anchorFile, \"meta_anchor.migrated\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6"}, "originalPosition": 356}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9701bf91fa92b8f7c911c27458624d1a5592782d", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/9701bf91fa92b8f7c911c27458624d1a5592782d", "committedDate": "2020-01-10T09:59:08Z", "message": "Implement migration of serial processes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ed36d3df1391ddc9a7dcd1486694428eb0848bd", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/0ed36d3df1391ddc9a7dcd1486694428eb0848bd", "committedDate": "2020-01-10T09:59:09Z", "message": "Fix bugs and code style"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb4cb1449ce733688d54821e44e891269af971b0", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/bb4cb1449ce733688d54821e44e891269af971b0", "committedDate": "2020-01-10T10:04:13Z", "message": "Use lowercase"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c1d890e2662d45c4dd66e71cbd81caa14855464c", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/c1d890e2662d45c4dd66e71cbd81caa14855464c", "committedDate": "2020-01-10T10:44:05Z", "message": "Apply suggested changes"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "037955c6c5b8329e4eed5e196935580b5c1d4ba6", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/037955c6c5b8329e4eed5e196935580b5c1d4ba6", "committedDate": "2020-01-08T07:19:17Z", "message": "Fix bugs and code style"}, "afterCommit": {"oid": "e38c0c0973314982b87a1c23daf9232874540130", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/e38c0c0973314982b87a1c23daf9232874540130", "committedDate": "2020-01-10T10:44:15Z", "message": "Improve Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ce164113a995b629ba8ace9237782a7ed0215b0", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/2ce164113a995b629ba8ace9237782a7ed0215b0", "committedDate": "2020-01-10T10:53:14Z", "message": "Improve Javadoc"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e38c0c0973314982b87a1c23daf9232874540130", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/e38c0c0973314982b87a1c23daf9232874540130", "committedDate": "2020-01-10T10:44:15Z", "message": "Improve Javadoc"}, "afterCommit": {"oid": "2ce164113a995b629ba8ace9237782a7ed0215b0", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/2ce164113a995b629ba8ace9237782a7ed0215b0", "committedDate": "2020-01-10T10:53:14Z", "message": "Improve Javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1aa07e987d3f9b041ff9cd6a0f7c59d8173ecb5d", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/1aa07e987d3f9b041ff9cd6a0f7c59d8173ecb5d", "committedDate": "2020-01-10T11:17:25Z", "message": "Use lowercase: consistent naming of task threads"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8cd469becbc634cab8db1fd02e907e37f36fe21f", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/8cd469becbc634cab8db1fd02e907e37f36fe21f", "committedDate": "2020-01-10T11:15:56Z", "message": "Use lowercase: consistent naming of task threads"}, "afterCommit": {"oid": "1aa07e987d3f9b041ff9cd6a0f7c59d8173ecb5d", "author": {"user": null}, "url": "https://github.com/kitodo/kitodo-production/commit/1aa07e987d3f9b041ff9cd6a0f7c59d8173ecb5d", "committedDate": "2020-01-10T11:17:25Z", "message": "Use lowercase: consistent naming of task threads"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2757, "cost": 1, "resetAt": "2021-11-01T16:19:10Z"}}}