{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5NDk1OTQy", "number": 3227, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNDo0N1rODiuJJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMzozNzozOFrODlzHJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzM0MTgzOnYy", "diffSide": "RIGHT", "path": "Kitodo/src/main/java/org/kitodo/production/forms/createprocess/CreateProcessForm.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNDo0OFrOFuH_mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDoyNDo0OFrOFuH_mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwOTc4NA==", "bodyText": "why aren't you using a forEach loop?", "url": "https://github.com/kitodo/kitodo-production/pull/3227#discussion_r383909784", "createdAt": "2020-02-25T14:24:48Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/forms/createprocess/CreateProcessForm.java", "diffHunk": "@@ -354,17 +363,33 @@ private void createProcessHierarchy() throws DataException, ProcessGenerationExc\n                 && !this.titleRecordLinkTab.getSelectedInsertionPosition().isEmpty()) {\n             this.processes = new LinkedList<>(Collections.singletonList(this.processes.get(0)));\n         }\n-        processProcessHierarchy();\n+        processAncestors();\n+        processChildren();\n+        // main process and it's ancestors need to be saved so they have IDs before creating their process directories\n         ServiceManager.getProcessService().save(getMainProcess());\n-        if (!createProcessesLocation()) {\n+        if (!createProcessesLocation(this.processes)) {\n             throw new IOException(\"Unable to create directories for process hierarchy!\");\n         }\n \n+        if (this.importTab.isImportChildren() && !createProcessesLocation(this.childProcesses)) {\n+            throw new IOException(\"Unable to create directories for child processes!\");\n+        }\n+\n         saveProcessHierarchyMetadata();\n-        if (ensureNonEmptyTitles()) {\n+\n+        // TODO: do the same 'ensureNonEmptyTitles' for child processes?\n+        if (ImportService.ensureNonEmptyTitles(this.processes)) {\n+            // saving the main process automatically saves it's parent and ancestor processes as well!\n             ServiceManager.getProcessService().save(getMainProcess());\n         }\n \n+        // add links between child processes and main process\n+        for (int i = 0; i < childProcesses.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47efc5b2c8e0128e95ca43a56b563efc7a61f1d8"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM3NzM2NjE4OnYy", "diffSide": "RIGHT", "path": "Kitodo/src/main/java/org/kitodo/production/services/data/ImportService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMDo1NVrOFuIO4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNVQxNDozMDo1NVrOFuIO4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMzY5OA==", "bodyText": "Why aren't you using a ForEach loop?", "url": "https://github.com/kitodo/kitodo-production/pull/3227#discussion_r383913698", "createdAt": "2020-02-25T14:30:55Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/services/data/ImportService.java", "diffHunk": "@@ -679,4 +755,239 @@ private Process loadParentProcess(HashMap<String, String> parentIDMetadata, int\n         }\n         return parentProcess;\n     }\n+\n+    /**\n+     * Check and return whether 'parentElement' has been configured for OPAC with name 'catalogName'.\n+     *\n+     * @param catalogName name of the OPAC to check\n+     * @return whether 'parentElement has been configured or not\n+     * @throws ConfigException thrown if configuration for OPAC 'catalogName' could not be found\n+     */\n+    public boolean isParentElementConfigured(String catalogName) throws ConfigException {\n+        loadOpacConfiguration(catalogName);\n+        return Objects.nonNull(OPACConfig.getParentIDElement(catalogName));\n+    }\n+\n+    /**\n+     * Create and return a List of ProcessDetail objects for the given TempProcess 'tempProcess'.\n+     *\n+     * @param tempProcess the TempProcess for which the List of ProcessDetail objects is created\n+     * @param managementInterface RulesetManagementInterface used to create the metadata of the process\n+     * @param acquisitionStage String containing the acquisitionStage\n+     * @param priorityList List of LanguageRange objects used as priority list\n+     * @return List of ProcessDetail objects\n+     * @throws InvalidMetadataValueException thrown if TempProcess contains invalid metadata\n+     * @throws NoSuchMetadataFieldException thrown if TempProcess contains undefined metadata\n+     */\n+    public static List<ProcessDetail> transformToProcessDetails(TempProcess tempProcess,\n+                                                         RulesetManagementInterface managementInterface,\n+                                                         String acquisitionStage,\n+                                                         List<Locale.LanguageRange> priorityList)\n+            throws InvalidMetadataValueException, NoSuchMetadataFieldException {\n+        ProcessFieldedMetadata metadata = initializeProcessDetails(tempProcess.getWorkpiece().getRootElement(),\n+                managementInterface, acquisitionStage, priorityList);\n+        metadata.setMetadata(ImportService.importMetadata(tempProcess.getMetadataNodes(), MdSec.DMD_SEC));\n+        metadata.preserve();\n+        return metadata.getRows();\n+    }\n+\n+    /**\n+     * Create a process title for the given TempProcess using the provided parameters.\n+     *\n+     * @param tempProcess the TempProcess for which the TifHeader is created\n+     * @param rulesetManagementInterface RulesetManagementInterface used to create TifHeader\n+     * @param acquisitionStage String containing name of acquisitionStage\n+     * @param priorityList List of LanguageRange objects used as priority list\n+     * @param processDetails List of ProcessDetail objects containing the metadata of the process\n+     * @throws ProcessGenerationException thrown if generating the Process title or the TifHeader fails\n+     */\n+    public static void createProcessTitle(TempProcess tempProcess,\n+                                            RulesetManagementInterface rulesetManagementInterface,\n+                                            String acquisitionStage, List<Locale.LanguageRange> priorityList,\n+                                            List<ProcessDetail> processDetails)\n+            throws ProcessGenerationException {\n+        String docType = tempProcess.getWorkpiece().getRootElement().getType();\n+        StructuralElementViewInterface docTypeView = rulesetManagementInterface\n+                .getStructuralElementView(docType, acquisitionStage, priorityList);\n+        String processTitle = docTypeView.getProcessTitle().orElse(\"\");\n+        ProcessService.generateProcessTitle(\"\", processDetails,\n+                processTitle, tempProcess.getProcess());\n+    }\n+\n+    /**\n+     * Create and return an instance of 'ProcessFieldedMetadata' for the given IncludedStructuralElement 'structure',\n+     * RulesetManagementInterface 'managementInterface', acquisition stage String 'stage' and List of LanguageRange\n+     * 'priorityList'.\n+     *\n+     * @param structure IncludedStructuralElement for which to create a ProcessFieldedMetadata\n+     * @param managementInterface RulesetManagementInterface used to create ProcessFieldedMetadata\n+     * @param stage String containing acquisition stage used to create ProcessFieldedMetadata\n+     * @param priorityList List of LanguageRange objects used to create ProcessFieldedMetadata\n+     * @return the created ProcessFieldedMetadata\n+     */\n+    public static ProcessFieldedMetadata initializeProcessDetails(IncludedStructuralElement structure,\n+                                                                  RulesetManagementInterface managementInterface,\n+                                                                  String stage,\n+                                                                  List<Locale.LanguageRange> priorityList) {\n+        StructuralElementViewInterface divisionView = managementInterface.getStructuralElementView(structure.getType(),\n+                stage, priorityList);\n+        return new ProcessFieldedMetadata(structure, divisionView);\n+    }\n+\n+    /**\n+     * Ensure all processes in given list 'tempProcesses' have a non empty title.\n+     *\n+     * @param tempProcesses list of TempProcesses to be checked\n+     * @return whether a title was changed or not\n+     * @throws IOException if the meta.xml file of a process could not be loaded\n+     */\n+    public static boolean ensureNonEmptyTitles(LinkedList<TempProcess> tempProcesses) throws IOException {\n+        boolean changedTitle = false;\n+        for (TempProcess tempProcess : tempProcesses) {\n+            Process process = tempProcess.getProcess();\n+            if (Objects.nonNull(process) && StringUtils.isEmpty(process.getTitle())) {\n+                // FIXME:\n+                //  if metadataFileUri is null or no meta.xml can be found, the tempProcess has not\n+                //  yet been saved to disk and contains the workpiece directly, instead!\n+                URI metadataFileUri = ServiceManager.getProcessService().getMetadataFileUri(process);\n+                Workpiece workpiece = ServiceManager.getMetsService().loadWorkpiece(metadataFileUri);\n+                Collection<Metadata> metadata = workpiece.getRootElement().getMetadata();\n+                String processTitle = \"[\" + Helper.getTranslation(\"process\") + \" \" + process.getId() + \"]\";\n+                for (Metadata metadatum : metadata) {\n+                    if (CATALOG_IDENTIFIER.equals(metadatum.getKey())) {\n+                        processTitle = ((MetadataEntry) metadatum).getValue();\n+                    }\n+                }\n+                process.setTitle(processTitle);\n+                changedTitle = true;\n+            }\n+        }\n+        return changedTitle;\n+    }\n+\n+    /**\n+     * Process list of child processes.\n+     *\n+     * @param mainProcess main process to which list of child processes are attached\n+     * @param childProcesses list of child processes that are attached to the main process\n+     * @throws DataException thrown if saving a process fails\n+     * @throws InvalidMetadataValueException thrown if process workpiece contains invalid metadata\n+     * @throws NoSuchMetadataFieldException thrown if process workpiece contains undefined metadata\n+     * @throws ProcessGenerationException thrown if process title cannot be created\n+     */\n+    public static void processProcessChildren(Process mainProcess, LinkedList<TempProcess> childProcesses,\n+                                              Template template, RulesetManagementInterface managementInterface,\n+                                              String acquisitionStage, List<Locale.LanguageRange> priorityList)\n+            throws DataException, InvalidMetadataValueException, NoSuchMetadataFieldException,\n+            ProcessGenerationException {\n+        for (int i = 0; i < childProcesses.size(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "47efc5b2c8e0128e95ca43a56b563efc7a61f1d8"}, "originalPosition": 385}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQwOTYxMzE4OnYy", "diffSide": "RIGHT", "path": "Kitodo/src/main/java/org/kitodo/production/services/data/ImportService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMzozNzozOFrOFy48Lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMzozNzozOFrOFy48Lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkwNjAzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private SearchResult searchChildRecords(String opac, String parentId, int numberOfrows) {\n          \n          \n            \n                    loadOpacConfiguration(opac);\n          \n          \n            \n                    String parenIDSearchField = OPACConfig.getParentIDElement(opac);\n          \n          \n            \n                    if (Objects.isNull(parenIDSearchField)) {\n          \n          \n            \n                        throw new ConfigException(\"Unable to find parent ID search field for catalog '\" + opac + \"'!\");\n          \n          \n            \n                    }\n          \n          \n            \n                    return performSearch(parenIDSearchField, parentId, opac, 0, numberOfrows);\n          \n          \n            \n                private SearchResult searchChildRecords(String opac, String parentId, int numberOfRows) {\n          \n          \n            \n                    loadOpacConfiguration(opac);\n          \n          \n            \n                    String parenIDSearchField = OPACConfig.getParentIDElement(opac);\n          \n          \n            \n                    if (Objects.isNull(parenIDSearchField)) {\n          \n          \n            \n                        throw new ConfigException(\"Unable to find parent ID search field for catalog '\" + opac + \"'!\");\n          \n          \n            \n                    }\n          \n          \n            \n                    return performSearch(parenIDSearchField, parentId, opac, 0, numberOfRows);", "url": "https://github.com/kitodo/kitodo-production/pull/3227#discussion_r388906030", "createdAt": "2020-03-06T13:37:38Z", "author": {"login": "Kathrin-Huber"}, "path": "Kitodo/src/main/java/org/kitodo/production/services/data/ImportService.java", "diffHunk": "@@ -409,7 +432,64 @@ private String importProcessAndReturnParentID(String recordId, LinkedList<TempPr\n         return processes;\n     }\n \n-    private DataRecord importRecord(String opac, String identifier, boolean extractExemplars) throws NoRecordFoundException,\n+    private SearchResult searchChildRecords(String opac, String parentId, int numberOfrows) {\n+        loadOpacConfiguration(opac);\n+        String parenIDSearchField = OPACConfig.getParentIDElement(opac);\n+        if (Objects.isNull(parenIDSearchField)) {\n+            throw new ConfigException(\"Unable to find parent ID search field for catalog '\" + opac + \"'!\");\n+        }\n+        return performSearch(parenIDSearchField, parentId, opac, 0, numberOfrows);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "94b2e4f7ad8b0380e108adb165b09b86adc9ec50"}, "originalPosition": 153}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3999, "cost": 1, "resetAt": "2021-11-12T20:44:06Z"}}}