{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA0NjcwMTI1", "number": 562, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODoyOTo1M1rOEuXdUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwOTowNjoxNFrOEvN5uA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDU0Mjg5OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODoyOTo1M1rOHiuGyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoxNDo0M1rOHi5WUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2OTAzMw==", "bodyText": "Seems like this Javadoc belongs to the previous implementation of the interface", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506169033", "createdAt": "2020-10-16T08:29:53Z", "author": {"login": "temanbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "diffHunk": "@@ -14,14 +14,32 @@\n  */\n package com.broadcom.lsp.cobol.service;\n \n+import com.broadcom.lsp.cobol.core.model.CopybookModel;\n import com.broadcom.lsp.cobol.domain.event.api.EventObserver;\n import com.broadcom.lsp.cobol.domain.event.model.DataEvent;\n \n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n /**\n  * Provide API definition to search for copybooks files and define the workspace folder opened in\n  * the client when the LSP server triggered.\n  */\n public interface CopybookService extends EventObserver<DataEvent> {\n   /** Remove all the stored copybook names and URIs. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM1MzIzNQ==", "bodyText": "You are right.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506353235", "createdAt": "2020-10-16T12:14:43Z", "author": {"login": "grianbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "diffHunk": "@@ -14,14 +14,32 @@\n  */\n package com.broadcom.lsp.cobol.service;\n \n+import com.broadcom.lsp.cobol.core.model.CopybookModel;\n import com.broadcom.lsp.cobol.domain.event.api.EventObserver;\n import com.broadcom.lsp.cobol.domain.event.model.DataEvent;\n \n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n /**\n  * Provide API definition to search for copybooks files and define the workspace folder opened in\n  * the client when the LSP server triggered.\n  */\n public interface CopybookService extends EventObserver<DataEvent> {\n   /** Remove all the stored copybook names and URIs. */", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE2OTAzMw=="}, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDU2NTk5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/com/broadcom/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODozNDoxMlrOHiuV2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoxNjo0MFrOHi5beA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mjg4OQ==", "bodyText": "Isn't it replaceable with an arrow notation?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506172889", "createdAt": "2020-10-16T08:34:12Z", "author": {"login": "temanbrcom"}, "path": "server/src/test/java/com/broadcom/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -198,12 +197,14 @@ public static AnalysisResult analyze(\n       String text,\n       List<CobolText> copybooks,\n       CopybookProcessingMode copybookProcessingMode) {\n-    Injector injector = Guice.createInjector(new EngineModule(), new DatabusModule());\n-\n-    DataBusBroker<FetchedCopybookEvent, RequiredCopybookEvent> broker =\n-        injector.getInstance(DataBusBroker.class);\n-\n-    MockCopybookService mockCopybookService = new MockCopybookServiceImpl(broker);\n+    Injector injector = Guice.createInjector(new EngineModule(), new DatabusModule(), new AbstractModule() {\n+      @Override\n+      protected void configure() {\n+        bind(CopybookService.class).to(MockCopybookServiceImpl.class);\n+      }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM1NDU1Mg==", "bodyText": "I would love to but looks like there is no way to do it.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506354552", "createdAt": "2020-10-16T12:16:40Z", "author": {"login": "grianbrcom"}, "path": "server/src/test/java/com/broadcom/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -198,12 +197,14 @@ public static AnalysisResult analyze(\n       String text,\n       List<CobolText> copybooks,\n       CopybookProcessingMode copybookProcessingMode) {\n-    Injector injector = Guice.createInjector(new EngineModule(), new DatabusModule());\n-\n-    DataBusBroker<FetchedCopybookEvent, RequiredCopybookEvent> broker =\n-        injector.getInstance(DataBusBroker.class);\n-\n-    MockCopybookService mockCopybookService = new MockCopybookServiceImpl(broker);\n+    Injector injector = Guice.createInjector(new EngineModule(), new DatabusModule(), new AbstractModule() {\n+      @Override\n+      protected void configure() {\n+        bind(CopybookService.class).to(MockCopybookServiceImpl.class);\n+      }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE3Mjg4OQ=="}, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MDY2NzIwOnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQwODo1NjozMFrOHivVJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjoyMzowNlrOHi5uMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4OTA5Mg==", "bodyText": "Isn't it checked in the GrammarPreprocessorListenerImpl?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506189092", "createdAt": "2020-10-16T08:56:30Z", "author": {"login": "temanbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +47,110 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CompletableFuture<CopybookModel>> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n-  @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  @Nullable\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    if (!copybookProcessingMode.analyze) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM1OTM0NA==", "bodyText": "Agree. Analyze flag has nothing to do with the resolve process.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506359344", "createdAt": "2020-10-16T12:23:06Z", "author": {"login": "grianbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +47,110 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CompletableFuture<CopybookModel>> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n-  @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  @Nullable\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    if (!copybookProcessingMode.analyze) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjE4OTA5Mg=="}, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTA1MDE3OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMDowNzo0OFrOHizQKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjozMDoyNFrOHi6Dkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1MzM1NQ==", "bodyText": "is it possible to return return new CopybookModel(copybookName, null, null); instead of null as like other places?\nOtherwise Optional object", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506253355", "createdAt": "2020-10-16T10:07:48Z", "author": {"login": "asatklichov"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +47,110 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CompletableFuture<CopybookModel>> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n-  @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  @Nullable\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    if (!copybookProcessingMode.analyze) {\n+      return new CopybookModel(copybookName, null, null);\n+    }\n+    boolean firstRequest = false;\n+    CompletableFuture<CopybookModel> futureModel;\n+    synchronized (this) {\n+      futureModel = copybookCache.getIfPresent(copybookName);\n+      if (futureModel == null) {\n+        futureModel = new CompletableFuture<>();\n+        firstRequest = true;\n+        copybookCache.put(copybookName, futureModel);\n+      }\n+    }\n+    try {\n+      if (firstRequest) {\n+        CopybookModel copybookModel = resolveSync(copybookName, documentUri, copybookProcessingMode);\n+        futureModel.complete(copybookModel);\n+        return copybookModel;\n+      } else {\n+        return futureModel.get(30, TimeUnit.SECONDS);\n+      }\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      LOG.error(\"Can't resolve copybook '{}'.\", copybookName, e);\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI2MzkwNg==", "bodyText": "I agree, returning optional would be a good idea here", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506263906", "createdAt": "2020-10-16T10:22:40Z", "author": {"login": "temanbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +47,110 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CompletableFuture<CopybookModel>> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n-  @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  @Nullable\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    if (!copybookProcessingMode.analyze) {\n+      return new CopybookModel(copybookName, null, null);\n+    }\n+    boolean firstRequest = false;\n+    CompletableFuture<CopybookModel> futureModel;\n+    synchronized (this) {\n+      futureModel = copybookCache.getIfPresent(copybookName);\n+      if (futureModel == null) {\n+        futureModel = new CompletableFuture<>();\n+        firstRequest = true;\n+        copybookCache.put(copybookName, futureModel);\n+      }\n+    }\n+    try {\n+      if (firstRequest) {\n+        CopybookModel copybookModel = resolveSync(copybookName, documentUri, copybookProcessingMode);\n+        futureModel.complete(copybookModel);\n+        return copybookModel;\n+      } else {\n+        return futureModel.get(30, TimeUnit.SECONDS);\n+      }\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      LOG.error(\"Can't resolve copybook '{}'.\", copybookName, e);\n+      return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1MzM1NQ=="}, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM2NDgxOA==", "bodyText": "Yes, makes sense.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506364818", "createdAt": "2020-10-16T12:30:24Z", "author": {"login": "grianbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +47,110 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CompletableFuture<CopybookModel>> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n-  @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  @Nullable\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    if (!copybookProcessingMode.analyze) {\n+      return new CopybookModel(copybookName, null, null);\n+    }\n+    boolean firstRequest = false;\n+    CompletableFuture<CopybookModel> futureModel;\n+    synchronized (this) {\n+      futureModel = copybookCache.getIfPresent(copybookName);\n+      if (futureModel == null) {\n+        futureModel = new CompletableFuture<>();\n+        firstRequest = true;\n+        copybookCache.put(copybookName, futureModel);\n+      }\n+    }\n+    try {\n+      if (firstRequest) {\n+        CopybookModel copybookModel = resolveSync(copybookName, documentUri, copybookProcessingMode);\n+        futureModel.complete(copybookModel);\n+        return copybookModel;\n+      } else {\n+        return futureModel.get(30, TimeUnit.SECONDS);\n+      }\n+    } catch (InterruptedException | ExecutionException | TimeoutException e) {\n+      LOG.error(\"Can't resolve copybook '{}'.\", copybookName, e);\n+      return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1MzM1NQ=="}, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 123}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3MTA2NDQ5OnYy", "diffSide": "RIGHT", "path": "server/src/test/java/com/broadcom/lsp/cobol/domain/databus/impl/DataBusUnSubscribeTest.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMDoxMTozNFrOHizZLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xNlQxMjozODo1MFrOHi6aHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1NTY2Mw==", "bodyText": "Can we define a meaningful const for why we are waiting,  5000 is hardcoded multiple times as well. I know old code ;)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506255663", "createdAt": "2020-10-16T10:11:34Z", "author": {"login": "asatklichov"}, "path": "server/src/test/java/com/broadcom/lsp/cobol/domain/databus/impl/DataBusUnSubscribeTest.java", "diffHunk": "@@ -52,14 +50,12 @@ void subscribe() {\n         TimeoutException.class,\n         () -> {\n           // Subscribe\n-          Object subscriber = databus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-          databus.postData(\n-              RequiredCopybookEvent.builder().name(\"CPYBUILD_SUBSCRIPTION TEST\").build());\n+          Object subscriber = databus.subscribe(DataEventType.RUN_ANALYSIS_EVENT, this);\n+          databus.postData(new RunAnalysisEvent());\n           waiter.await(5000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjM3MDU5MA==", "bodyText": "Why not? It is refactoring!", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r506370590", "createdAt": "2020-10-16T12:38:50Z", "author": {"login": "grianbrcom"}, "path": "server/src/test/java/com/broadcom/lsp/cobol/domain/databus/impl/DataBusUnSubscribeTest.java", "diffHunk": "@@ -52,14 +50,12 @@ void subscribe() {\n         TimeoutException.class,\n         () -> {\n           // Subscribe\n-          Object subscriber = databus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-          databus.postData(\n-              RequiredCopybookEvent.builder().name(\"CPYBUILD_SUBSCRIPTION TEST\").build());\n+          Object subscriber = databus.subscribe(DataEventType.RUN_ANALYSIS_EVENT, this);\n+          databus.postData(new RunAnalysisEvent());\n           waiter.await(5000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjI1NTY2Mw=="}, "originalCommit": {"oid": "8db1519ff0ced6cb100ab0b7bd80e250c0631121"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3OTQyNzg0OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwODo1Nzo0MFrOHkEbmg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDo0MDowOVrOHkIRJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4MzM4Ng==", "bodyText": "Seems like now EventObserver is not a necessary part of CopybookService anymore. I think you may implement this interface directly in the CopybookServiceImpl", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507583386", "createdAt": "2020-10-19T08:57:40Z", "author": {"login": "temanbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "diffHunk": "@@ -14,14 +14,38 @@\n  */\n package com.broadcom.lsp.cobol.service;\n \n+import com.broadcom.lsp.cobol.core.model.CopybookModel;\n import com.broadcom.lsp.cobol.domain.event.api.EventObserver;\n import com.broadcom.lsp.cobol.domain.event.model.DataEvent;\n \n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n /**\n- * Provide API definition to search for copybooks files and define the workspace folder opened in\n- * the client when the LSP server triggered.\n+ * Provide API definition to search for copybooks files.\n+ * The service also caches copybook to reduce filesystem load.\n  */\n public interface CopybookService extends EventObserver<DataEvent> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "627377db960b7e555c7861207d73b69f5aa8bfb5"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0MTk0MQ==", "bodyText": "Sorry, not. We still need an observer because CopybookService waits for AnalysisFinishedEvent for sending downloading request to middleware.\nI leave EventObserver<DataEvent> as is because in Databus refactoring I plan to get rid of EventObserver.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507641941", "createdAt": "2020-10-19T10:32:36Z", "author": {"login": "grianbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "diffHunk": "@@ -14,14 +14,38 @@\n  */\n package com.broadcom.lsp.cobol.service;\n \n+import com.broadcom.lsp.cobol.core.model.CopybookModel;\n import com.broadcom.lsp.cobol.domain.event.api.EventObserver;\n import com.broadcom.lsp.cobol.domain.event.model.DataEvent;\n \n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n /**\n- * Provide API definition to search for copybooks files and define the workspace folder opened in\n- * the client when the LSP server triggered.\n+ * Provide API definition to search for copybooks files.\n+ * The service also caches copybook to reduce filesystem load.\n  */\n public interface CopybookService extends EventObserver<DataEvent> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4MzM4Ng=="}, "originalCommit": {"oid": "627377db960b7e555c7861207d73b69f5aa8bfb5"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0NjI0Nw==", "bodyText": "Ok, makes sense", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507646247", "createdAt": "2020-10-19T10:40:09Z", "author": {"login": "temanbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookService.java", "diffHunk": "@@ -14,14 +14,38 @@\n  */\n package com.broadcom.lsp.cobol.service;\n \n+import com.broadcom.lsp.cobol.core.model.CopybookModel;\n import com.broadcom.lsp.cobol.domain.event.api.EventObserver;\n import com.broadcom.lsp.cobol.domain.event.model.DataEvent;\n \n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n /**\n- * Provide API definition to search for copybooks files and define the workspace folder opened in\n- * the client when the LSP server triggered.\n+ * Provide API definition to search for copybooks files.\n+ * The service also caches copybook to reduce filesystem load.\n  */\n public interface CopybookService extends EventObserver<DataEvent> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4MzM4Ng=="}, "originalCommit": {"oid": "627377db960b7e555c7861207d73b69f5aa8bfb5"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE3OTQ2Mjk2OnYy", "diffSide": "RIGHT", "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQwOTowNjoxNFrOHkExNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xOVQxMDo0NToyMFrOHkIb5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4ODkxNg==", "bodyText": "Seems like it may be collapsed", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507588916", "createdAt": "2020-10-19T09:06:14Z", "author": {"login": "temanbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +51,95 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CopybookModel> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    try {\n+      return copybookCache.get(copybookName, () -> resolveSync(copybookName, documentUri, copybookProcessingMode));\n+    } catch (ExecutionException e) {\n+      LOG.error(\"Can't resolve copybook '{}'.\", copybookName, e);\n+      return new CopybookModel(copybookName, null, null);\n+    }\n+  }\n+\n   @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  public void store(CopybookModel copybookModel) {\n+    copybookCache.put(copybookModel.getName(), copybookModel);\n+  }\n+\n+  private CopybookModel resolveSync(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) throws ExecutionException, InterruptedException {\n+    String cobolFileName = files.getNameFromURI(documentUri);\n+    String uri = retrieveURI(\n+        settingsService.getConfiguration(COPYBOOK_RESOLVE.label, cobolFileName, copybookName).get());\n+    if (uri.isEmpty()) {\n+      if (copybookProcessingMode.download) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "627377db960b7e555c7861207d73b69f5aa8bfb5"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0NDgwNw==", "bodyText": "I can't collapse it. Here I need to manage three cases:\nURI is present => read copybook from filesystem\nURI is empty and we downloading (DidOpen case) => add copybook for downloading, return stub.\nURI is empty and we don't download (DidChange case) => just return stub.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507644807", "createdAt": "2020-10-19T10:37:39Z", "author": {"login": "grianbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +51,95 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CopybookModel> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    try {\n+      return copybookCache.get(copybookName, () -> resolveSync(copybookName, documentUri, copybookProcessingMode));\n+    } catch (ExecutionException e) {\n+      LOG.error(\"Can't resolve copybook '{}'.\", copybookName, e);\n+      return new CopybookModel(copybookName, null, null);\n+    }\n+  }\n+\n   @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  public void store(CopybookModel copybookModel) {\n+    copybookCache.put(copybookModel.getName(), copybookModel);\n+  }\n+\n+  private CopybookModel resolveSync(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) throws ExecutionException, InterruptedException {\n+    String cobolFileName = files.getNameFromURI(documentUri);\n+    String uri = retrieveURI(\n+        settingsService.getConfiguration(COPYBOOK_RESOLVE.label, cobolFileName, copybookName).get());\n+    if (uri.isEmpty()) {\n+      if (copybookProcessingMode.download) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4ODkxNg=="}, "originalCommit": {"oid": "627377db960b7e555c7861207d73b69f5aa8bfb5"}, "originalPosition": 127}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzY0ODk5Ng==", "bodyText": "Yeah, you are right", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/562#discussion_r507648996", "createdAt": "2020-10-19T10:45:20Z", "author": {"login": "temanbrcom"}, "path": "server/src/main/java/com/broadcom/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -47,77 +51,95 @@\n   private final SettingsService settingsService;\n   private final FileSystemService files;\n \n-  private final Map<String, Path> copybookPaths = new ConcurrentHashMap<>(8, 0.9f, 1);\n   private final Map<String, Set<String>> copybooksForDownloading =\n       new ConcurrentHashMap<>(8, 0.9f, 1);\n \n+  private final Cache<String, CopybookModel> copybookCache;\n+\n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n+      DataBusBroker dataBus,\n+      SettingsService settingsService,\n+      FileSystemService files,\n+      @Named(\"CACHE-MAX-SIZE\") int cacheSize,\n+      @Named(\"CACHE-DURATION\") int duration,\n+      @Named(\"CACHE-TIME-UNIT\") String timeUnitName) {\n     this.dataBus = dataBus;\n     this.settingsService = settingsService;\n     this.files = files;\n-\n-    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n+    copybookCache = CacheBuilder.newBuilder()\n+        .expireAfterWrite(duration, TimeUnit.valueOf(timeUnitName))\n+        .maximumSize(cacheSize)\n+        .build();\n     dataBus.subscribe(ANALYSIS_FINISHED_EVENT, this);\n   }\n \n   @Override\n-  public void invalidateURICache() {\n-    copybookPaths.clear();\n+  public void invalidateCache() {\n     copybooksForDownloading.clear();\n+    copybookCache.invalidateAll();\n   }\n \n   /**\n-   * Depends on DataEvent type it will be handled with appropriate handler: {@link\n-   * #handleRequiredCopybookEvent} or {@link #handleAnalysisFinishedEvent}.\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * Resolving works in synchronous way. Resolutions with different copybook names will not block each other.\n    *\n-   * @param event the instance of {@link RequiredCopybookEvent} or {@link AnalysisFinishedEvent}\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param copybookProcessingMode - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content\n    */\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) {\n+    try {\n+      return copybookCache.get(copybookName, () -> resolveSync(copybookName, documentUri, copybookProcessingMode));\n+    } catch (ExecutionException e) {\n+      LOG.error(\"Can't resolve copybook '{}'.\", copybookName, e);\n+      return new CopybookModel(copybookName, null, null);\n+    }\n+  }\n+\n   @Override\n-  public void observerCallback(DataEvent event) {\n-    if (event instanceof RequiredCopybookEvent) {\n-      handleRequiredCopybookEvent((RequiredCopybookEvent) event);\n-    } else if (event instanceof AnalysisFinishedEvent) {\n-      handleAnalysisFinishedEvent((AnalysisFinishedEvent) event);\n+  public void store(CopybookModel copybookModel) {\n+    copybookCache.put(copybookModel.getName(), copybookModel);\n+  }\n+\n+  private CopybookModel resolveSync(\n+      @Nonnull String copybookName,\n+      @Nonnull String documentUri,\n+      @Nonnull CopybookProcessingMode copybookProcessingMode) throws ExecutionException, InterruptedException {\n+    String cobolFileName = files.getNameFromURI(documentUri);\n+    String uri = retrieveURI(\n+        settingsService.getConfiguration(COPYBOOK_RESOLVE.label, cobolFileName, copybookName).get());\n+    if (uri.isEmpty()) {\n+      if (copybookProcessingMode.download) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzU4ODkxNg=="}, "originalCommit": {"oid": "627377db960b7e555c7861207d73b69f5aa8bfb5"}, "originalPosition": 127}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3795, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}