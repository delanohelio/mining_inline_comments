{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NDgxMjc3", "number": 376, "reviewThreads": {"totalCount": 43, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0Mzo1OFrOECCeyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoyMTowNlrOECQAhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTczMjU2OnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/package.json", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0Mzo1OFrOGeP7EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0Mzo1OFrOGeP7EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3MTM0NQ==", "bodyText": "Those thing should be removed because are part of the first POC, I'll assign to myself this double check to verify that we didn't lose the latest version of package.json", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434371345", "createdAt": "2020-06-03T07:43:58Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/package.json", "diffHunk": "@@ -56,6 +56,14 @@\n             {\n                 \"command\": \"broadcom-cobol-lsp.cpy-manager.resolve-local-copybooks\",\n                 \"title\": \"Resolve Local Copybooks\"\n+            },\n+            {\n+                \"command\": \"broadcom-cobol-lsp.cpy-manager.resolve-git-copybooks\",\n+                \"title\": \"Resolve Local 2\"\n+            },\n+            {\n+                \"command\": \"broadcom-cobol-lsp.cpy-manager.resolve-git-copybooks-2\",\n+                \"title\": \"Get local copybooks\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTc0MzUxOnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0NzowNlrOGeQBzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0NzowNlrOGeQBzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3MzA2OA==", "bodyText": "@zacanbrcom remove this comment and verify that handleQueue() is correctly engaged from the start() method", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434373068", "createdAt": "2020-06-03T07:47:06Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "diffHunk": "@@ -103,10 +113,12 @@ export class CopybooksDownloader implements vscode.Disposable {\n         this.queue.stop();\n     }\n \n+    //TODO: NO INVOKED IN THE CODE BUT USED BY UNIT TEST\n+    //TODO: VERIFY ZOWE ERRORS ARE STILL SUPPORTED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 125}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNTc5MjIwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/ClientService.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwODowMTowOFrOGeQgqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoyNDo0MlrOGeVrnA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA==", "bodyText": "@grianbrcom it's time to get rid of this TODO", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434380968", "createdAt": "2020-06-03T08:01:08Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/ClientService.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.ca.lsp.cobol.service;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface ClientService {\n+  // TODO:provide more descriptive name for this class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0NTYzOQ==", "bodyText": "Let's discuss it. Basically it should be \"SettingsService\". With method name \"getConfiguration\".\nAnd we use the class for reading the settings.\nBut we also use it for generating URI on the fly in the Middleware. Do we need to take it into account?\nSo, my proposal is SettingsService::getConfiguration.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434445639", "createdAt": "2020-06-03T09:48:38Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/ClientService.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.ca.lsp.cobol.service;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface ClientService {\n+  // TODO:provide more descriptive name for this class", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA=="}, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1MTE3MA==", "bodyText": "for me sounds ok because the LSP server doesn't know anything about middleware, he just asked for some properties from settings and getConfiguration looks appropriate to me", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434451170", "createdAt": "2020-06-03T09:58:11Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/ClientService.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.ca.lsp.cobol.service;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface ClientService {\n+  // TODO:provide more descriptive name for this class", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA=="}, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTY5Mg==", "bodyText": "I agree, sounds good", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434465692", "createdAt": "2020-06-03T10:24:42Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/ClientService.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.ca.lsp.cobol.service;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface ClientService {\n+  // TODO:provide more descriptive name for this class", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA=="}, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjE3MTc3OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTo0NDowMVrOGeUSuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowODoxMlrOGeY2ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw==", "bodyText": "is result null-safe ?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434442937", "createdAt": "2020-06-03T09:44:01Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,117 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final ClientService clientService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+      DataBusBroker dataBus, ClientService clientService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.clientService = clientService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n   /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n    *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n-  @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      clientService\n+          .callClient(\"copybook\", cobolFileName, requiredCopybookName)\n+          .thenAccept(sendResponse(requiredCopybookName));\n     } else {\n-      publishOnDatabus(requiredCopybookName);\n+      sendResponse(requiredCopybookName, null, null);\n     }\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName, String content, Path path) {\n+  private Consumer<List<Object>> sendResponse(String requiredCopybookName) {\n+    return result -> dataBus.postData(fetchCopybook(requiredCopybookName, retrieveURI(result)));\n+  }\n+\n+  private void sendResponse(String requiredCopybookName, String content, Path path) {\n     dataBus.postData(\n         FetchedCopybookEvent.builder()\n             .name(requiredCopybookName)\n-            .uri(Optional.ofNullable(path).map(Path::toUri).map(URI::toString).orElse(null))\n+            .uri(toURI(path))\n             .content(content)\n             .build());\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName) {\n-    dataBus.postData(FetchedCopybookEvent.builder().name(requiredCopybookName).build());\n+  private FetchedCopybookEvent fetchCopybook(String requiredCopybookName, String uri) {\n+    if (uri.isEmpty()) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    Path file = files.getPathFromURI(uri);\n+    if (file == null) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    copybookPath.put(requiredCopybookName, file);\n+\n+    return FetchedCopybookEvent.builder()\n+        .name(requiredCopybookName)\n+        .uri(toURI(file))\n+        .content(files.getContentByPath(file))\n+        .build();\n+  }\n+\n+  private String toURI(Path file) {\n+    return ofNullable(file).map(Path::toUri).map(URI::toString).orElse(null);\n+  }\n+\n+  private String retrieveURI(List<Object> result) {\n+    return result.isEmpty() ? \"\" : ((JsonPrimitive) result.get(0)).getAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6948538f01f06238c1de7b912f057d84122c6574"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NDUyOQ==", "bodyText": "Good catch! So if LSP sends us NULL we will have null here.\nIt's not clear from LSP spec is it possible or not.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434464529", "createdAt": "2020-06-03T10:22:30Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,117 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final ClientService clientService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+      DataBusBroker dataBus, ClientService clientService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.clientService = clientService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n   /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n    *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n-  @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      clientService\n+          .callClient(\"copybook\", cobolFileName, requiredCopybookName)\n+          .thenAccept(sendResponse(requiredCopybookName));\n     } else {\n-      publishOnDatabus(requiredCopybookName);\n+      sendResponse(requiredCopybookName, null, null);\n     }\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName, String content, Path path) {\n+  private Consumer<List<Object>> sendResponse(String requiredCopybookName) {\n+    return result -> dataBus.postData(fetchCopybook(requiredCopybookName, retrieveURI(result)));\n+  }\n+\n+  private void sendResponse(String requiredCopybookName, String content, Path path) {\n     dataBus.postData(\n         FetchedCopybookEvent.builder()\n             .name(requiredCopybookName)\n-            .uri(Optional.ofNullable(path).map(Path::toUri).map(URI::toString).orElse(null))\n+            .uri(toURI(path))\n             .content(content)\n             .build());\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName) {\n-    dataBus.postData(FetchedCopybookEvent.builder().name(requiredCopybookName).build());\n+  private FetchedCopybookEvent fetchCopybook(String requiredCopybookName, String uri) {\n+    if (uri.isEmpty()) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    Path file = files.getPathFromURI(uri);\n+    if (file == null) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    copybookPath.put(requiredCopybookName, file);\n+\n+    return FetchedCopybookEvent.builder()\n+        .name(requiredCopybookName)\n+        .uri(toURI(file))\n+        .content(files.getContentByPath(file))\n+        .build();\n+  }\n+\n+  private String toURI(Path file) {\n+    return ofNullable(file).map(Path::toUri).map(URI::toString).orElse(null);\n+  }\n+\n+  private String retrieveURI(List<Object> result) {\n+    return result.isEmpty() ? \"\" : ((JsonPrimitive) result.get(0)).getAsString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw=="}, "originalCommit": {"oid": "6948538f01f06238c1de7b912f057d84122c6574"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NjI5OA==", "bodyText": "It should not send null, but we also shouldn't trust the client", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434466298", "createdAt": "2020-06-03T10:25:52Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,117 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final ClientService clientService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+      DataBusBroker dataBus, ClientService clientService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.clientService = clientService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n   /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n    *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n-  @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      clientService\n+          .callClient(\"copybook\", cobolFileName, requiredCopybookName)\n+          .thenAccept(sendResponse(requiredCopybookName));\n     } else {\n-      publishOnDatabus(requiredCopybookName);\n+      sendResponse(requiredCopybookName, null, null);\n     }\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName, String content, Path path) {\n+  private Consumer<List<Object>> sendResponse(String requiredCopybookName) {\n+    return result -> dataBus.postData(fetchCopybook(requiredCopybookName, retrieveURI(result)));\n+  }\n+\n+  private void sendResponse(String requiredCopybookName, String content, Path path) {\n     dataBus.postData(\n         FetchedCopybookEvent.builder()\n             .name(requiredCopybookName)\n-            .uri(Optional.ofNullable(path).map(Path::toUri).map(URI::toString).orElse(null))\n+            .uri(toURI(path))\n             .content(content)\n             .build());\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName) {\n-    dataBus.postData(FetchedCopybookEvent.builder().name(requiredCopybookName).build());\n+  private FetchedCopybookEvent fetchCopybook(String requiredCopybookName, String uri) {\n+    if (uri.isEmpty()) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    Path file = files.getPathFromURI(uri);\n+    if (file == null) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    copybookPath.put(requiredCopybookName, file);\n+\n+    return FetchedCopybookEvent.builder()\n+        .name(requiredCopybookName)\n+        .uri(toURI(file))\n+        .content(files.getContentByPath(file))\n+        .build();\n+  }\n+\n+  private String toURI(Path file) {\n+    return ofNullable(file).map(Path::toUri).map(URI::toString).orElse(null);\n+  }\n+\n+  private String retrieveURI(List<Object> result) {\n+    return result.isEmpty() ? \"\" : ((JsonPrimitive) result.get(0)).getAsString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw=="}, "originalCommit": {"oid": "6948538f01f06238c1de7b912f057d84122c6574"}, "originalPosition": 232}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNzY2Nw==", "bodyText": "I agree with Andrei, plus I think at initialize handshake server receives null", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434517667", "createdAt": "2020-06-03T12:08:12Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,117 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final ClientService clientService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+      DataBusBroker dataBus, ClientService clientService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.clientService = clientService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n   /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n    *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n-  @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      clientService\n+          .callClient(\"copybook\", cobolFileName, requiredCopybookName)\n+          .thenAccept(sendResponse(requiredCopybookName));\n     } else {\n-      publishOnDatabus(requiredCopybookName);\n+      sendResponse(requiredCopybookName, null, null);\n     }\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName, String content, Path path) {\n+  private Consumer<List<Object>> sendResponse(String requiredCopybookName) {\n+    return result -> dataBus.postData(fetchCopybook(requiredCopybookName, retrieveURI(result)));\n+  }\n+\n+  private void sendResponse(String requiredCopybookName, String content, Path path) {\n     dataBus.postData(\n         FetchedCopybookEvent.builder()\n             .name(requiredCopybookName)\n-            .uri(Optional.ofNullable(path).map(Path::toUri).map(URI::toString).orElse(null))\n+            .uri(toURI(path))\n             .content(content)\n             .build());\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName) {\n-    dataBus.postData(FetchedCopybookEvent.builder().name(requiredCopybookName).build());\n+  private FetchedCopybookEvent fetchCopybook(String requiredCopybookName, String uri) {\n+    if (uri.isEmpty()) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    Path file = files.getPathFromURI(uri);\n+    if (file == null) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    copybookPath.put(requiredCopybookName, file);\n+\n+    return FetchedCopybookEvent.builder()\n+        .name(requiredCopybookName)\n+        .uri(toURI(file))\n+        .content(files.getContentByPath(file))\n+        .build();\n+  }\n+\n+  private String toURI(Path file) {\n+    return ofNullable(file).map(Path::toUri).map(URI::toString).orElse(null);\n+  }\n+\n+  private String retrieveURI(List<Object> result) {\n+    return result.isEmpty() ? \"\" : ((JsonPrimitive) result.get(0)).getAsString();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw=="}, "originalCommit": {"oid": "6948538f01f06238c1de7b912f057d84122c6574"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjIzMDIzOnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/Middleware.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMDoyNFrOGeU34w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowNTo1OVrOGeVEEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1MjQ1MQ==", "bodyText": "header is missing - guys double check if you have configured the IDE to generate header every time you create a new file :)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434452451", "createdAt": "2020-06-03T10:00:24Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/Middleware.ts", "diffHunk": "@@ -0,0 +1,32 @@\n+import {CancellationToken} from \"vscode\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1NTU3MQ==", "bodyText": "Yes, I've configured it in IDEA, but not in VSCode. I'll fix it.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434455571", "createdAt": "2020-06-03T10:05:59Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/Middleware.ts", "diffHunk": "@@ -0,0 +1,32 @@\n+import {CancellationToken} from \"vscode\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1MjQ1MQ=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjI3ODE5OnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/extension.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoxNDoyOFrOGeVWJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjo0NDoxNlrOGeaFcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2MDE5OA==", "bodyText": "would be better if we have same formatting", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434460198", "createdAt": "2020-06-03T10:14:28Z", "author": {"login": "asatklichov"}, "path": "clients/cobol-lsp-vscode-extension/src/extension.ts", "diffHunk": "@@ -13,25 +13,24 @@\n  */\n \n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n+\n import { changeDefaultZoweProfile } from \"./commands/ChangeDefaultZoweProfile\";\n import { editDatasetPaths } from \"./commands/EditDatasetPaths\";\n import { fetchCopybookCommand } from \"./commands/FetchCopybookCommand\";\n-import { C4Z_FOLDER, DEPENDENCIES_FOLDER, GITIGNORE_FILE, REASON_MSG } from \"./constants\";\n+import { C4Z_FOLDER, GITIGNORE_FILE} from \"./constants\";\n import { LANGUAGE_ID, SETTINGS_SECTION } from \"./constants\";\n import { CopybookFix } from \"./services/CopybookFix\";\n import { CopybooksCodeActionProvider } from \"./services/CopybooksCodeActionProvider\";\n import { CopybooksDownloader } from \"./services/CopybooksDownloader\";\n import { CopybooksPathGenerator } from \"./services/CopybooksPathGenerator\";\n import { initializeSettings, createFileWithGivenPath } from \"./services/Settings\";\n \n-import {resolveLocalCopybooksCommand} from \"./commands/ResolveLocalCopybooksCommand\";\n-import { LanguageClientService } from \"./services/LanguageClientService\";\n-import { PathsService } from \"./services/PathsService\";\n-import { ProfileService } from \"./services/ProfileService\";\n-import {CopybookResolver} from \"./services/settings/CopybookResolver\";\n-import {LocalCopybookResolver} from \"./services/settings/LocalCopybookResolver\";\n-import { ZoweApi } from \"./services/ZoweApi\";\n+import {CopybookURI} from \"./services/CopybookURI\";\n+import {LanguageClientService} from \"./services/LanguageClientService\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzNzg0Mg==", "bodyText": "Looks like the new format works correctly, for example:\nimport {ZoweApi} from \"./services/ZoweApi\";\n\nis better than the prev version:\nimport { ZoweApi } from \"./services/ZoweApi\";", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434537842", "createdAt": "2020-06-03T12:44:16Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/extension.ts", "diffHunk": "@@ -13,25 +13,24 @@\n  */\n \n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n+\n import { changeDefaultZoweProfile } from \"./commands/ChangeDefaultZoweProfile\";\n import { editDatasetPaths } from \"./commands/EditDatasetPaths\";\n import { fetchCopybookCommand } from \"./commands/FetchCopybookCommand\";\n-import { C4Z_FOLDER, DEPENDENCIES_FOLDER, GITIGNORE_FILE, REASON_MSG } from \"./constants\";\n+import { C4Z_FOLDER, GITIGNORE_FILE} from \"./constants\";\n import { LANGUAGE_ID, SETTINGS_SECTION } from \"./constants\";\n import { CopybookFix } from \"./services/CopybookFix\";\n import { CopybooksCodeActionProvider } from \"./services/CopybooksCodeActionProvider\";\n import { CopybooksDownloader } from \"./services/CopybooksDownloader\";\n import { CopybooksPathGenerator } from \"./services/CopybooksPathGenerator\";\n import { initializeSettings, createFileWithGivenPath } from \"./services/Settings\";\n \n-import {resolveLocalCopybooksCommand} from \"./commands/ResolveLocalCopybooksCommand\";\n-import { LanguageClientService } from \"./services/LanguageClientService\";\n-import { PathsService } from \"./services/PathsService\";\n-import { ProfileService } from \"./services/ProfileService\";\n-import {CopybookResolver} from \"./services/settings/CopybookResolver\";\n-import {LocalCopybookResolver} from \"./services/settings/LocalCopybookResolver\";\n-import { ZoweApi } from \"./services/ZoweApi\";\n+import {CopybookURI} from \"./services/CopybookURI\";\n+import {LanguageClientService} from \"./services/LanguageClientService\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2MDE5OA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjMwODMwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/SettingsParametersEnum.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoyMzozNVrOGeVpSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDozMToyNVrOGeV5UQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTA5OA==", "bodyText": "Is DATASETS used?  If yes, we can still alphabetize.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434465098", "createdAt": "2020-06-03T10:23:35Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/SettingsParametersEnum.java", "diffHunk": "@@ -20,7 +20,9 @@\n  */\n public enum SettingsParametersEnum {\n   CPY_MANAGER(\"cpy-manager\"),\n-  LSP_PREFIX(\"broadcom-cobol-lsp\");\n+  LSP_PREFIX(\"broadcom-cobol-lsp\"),\n+  LOCAL_PATHS(\"cpy-manager.paths.local\"),\n+  DATASETS(\"cpy-manager.paths.dsn\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NzQwNg==", "bodyText": "We don't use it on the server, but it is a value that we support on the client. I would prefer to leave it here to keep consistency.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434467406", "createdAt": "2020-06-03T10:28:00Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/SettingsParametersEnum.java", "diffHunk": "@@ -20,7 +20,9 @@\n  */\n public enum SettingsParametersEnum {\n   CPY_MANAGER(\"cpy-manager\"),\n-  LSP_PREFIX(\"broadcom-cobol-lsp\");\n+  LSP_PREFIX(\"broadcom-cobol-lsp\"),\n+  LOCAL_PATHS(\"cpy-manager.paths.local\"),\n+  DATASETS(\"cpy-manager.paths.dsn\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTA5OA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2OTIwMQ==", "bodyText": "Then let's alphabetize the enum-list", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434469201", "createdAt": "2020-06-03T10:31:25Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/SettingsParametersEnum.java", "diffHunk": "@@ -20,7 +20,9 @@\n  */\n public enum SettingsParametersEnum {\n   CPY_MANAGER(\"cpy-manager\"),\n-  LSP_PREFIX(\"broadcom-cobol-lsp\");\n+  LSP_PREFIX(\"broadcom-cobol-lsp\"),\n+  LOCAL_PATHS(\"cpy-manager.paths.local\"),\n+  DATASETS(\"cpy-manager.paths.dsn\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTA5OA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjM2NTU2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0MTo0M1rOGeWN9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0MTo0M1rOGeWN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NDQ4NQ==", "bodyText": "return null? Optional will help also get-rid off null-checks.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434474485", "createdAt": "2020-06-03T10:41:43Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 193}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjM2NjI2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0MTo1NFrOGeWOVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTowODozOFrOGegXaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NDU4MQ==", "bodyText": "same", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434474581", "createdAt": "2020-06-03T10:41:54Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0MDc0NA==", "bodyText": "There is a logic related to null, I don't want to refactor it now", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434640744", "createdAt": "2020-06-03T15:08:38Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NDU4MQ=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 204}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjM2ODg3OnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/__tests__/SettingsTest.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0Mjo0OVrOGeWQCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0Njo0M1rOGeWXpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTAxNg==", "bodyText": "You check if filePath exists but delete wsPath.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434475016", "createdAt": "2020-06-03T10:42:49Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/__tests__/SettingsTest.ts", "diffHunk": "@@ -18,31 +11,40 @@ import {SettingsUtils} from \"../services/settings/util/SettingsUtils\";\n  * Contributors:\n  *   Broadcom, Inc. - initial API and implementation\n  */\n+import * as fs from \"fs-extra\";\n+import * as path from \"path\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, GITIGNORE_FILE} from \"../constants\";\n+import {createFileWithGivenPath, initializeSettings} from \"../services/Settings\";\n+import {SettingsUtils} from \"../services/settings/util/SettingsUtils\";\n \n-const fsPath = \"/ws-vscode\";\n-const c4zFolder = \".c4z\";\n-const fileName = \".gitignore\";\n+const fsPath = \"tmp-ws\";\n+const scheme = \"file\";\n+let wsPath: string;\n+let c4zPath: string;\n let filePath: string;\n \n beforeAll(() => {\n-    vscode.workspace.workspaceFolders = [{ uri: { fsPath } } as any];\n-    filePath = path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, c4zFolder, fileName);\n+    vscode.workspace.workspaceFolders = [{uri: {fsPath}} as any];\n+    wsPath = path.join(vscode.workspace.workspaceFolders[0].uri.fsPath);\n+    c4zPath = path.join(wsPath, C4Z_FOLDER);\n+    filePath = path.join(c4zPath, GITIGNORE_FILE);\n });\n \n afterAll(() => {\n-        if (fs.existsSync(filePath)) {\n-            fs.unlinkSync(filePath);\n-        }\n+    if (fs.existsSync(filePath)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3Njk2NA==", "bodyText": "It is recursive, so starts deleting all including wsPath", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434476964", "createdAt": "2020-06-03T10:46:43Z", "author": {"login": "asatklichov"}, "path": "clients/cobol-lsp-vscode-extension/src/__tests__/SettingsTest.ts", "diffHunk": "@@ -18,31 +11,40 @@ import {SettingsUtils} from \"../services/settings/util/SettingsUtils\";\n  * Contributors:\n  *   Broadcom, Inc. - initial API and implementation\n  */\n+import * as fs from \"fs-extra\";\n+import * as path from \"path\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, GITIGNORE_FILE} from \"../constants\";\n+import {createFileWithGivenPath, initializeSettings} from \"../services/Settings\";\n+import {SettingsUtils} from \"../services/settings/util/SettingsUtils\";\n \n-const fsPath = \"/ws-vscode\";\n-const c4zFolder = \".c4z\";\n-const fileName = \".gitignore\";\n+const fsPath = \"tmp-ws\";\n+const scheme = \"file\";\n+let wsPath: string;\n+let c4zPath: string;\n let filePath: string;\n \n beforeAll(() => {\n-    vscode.workspace.workspaceFolders = [{ uri: { fsPath } } as any];\n-    filePath = path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, c4zFolder, fileName);\n+    vscode.workspace.workspaceFolders = [{uri: {fsPath}} as any];\n+    wsPath = path.join(vscode.workspace.workspaceFolders[0].uri.fsPath);\n+    c4zPath = path.join(wsPath, C4Z_FOLDER);\n+    filePath = path.join(c4zPath, GITIGNORE_FILE);\n });\n \n afterAll(() => {\n-        if (fs.existsSync(filePath)) {\n-            fs.unlinkSync(filePath);\n-        }\n+    if (fs.existsSync(filePath)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTAxNg=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjM3NDE1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0NDozNFrOGeWTcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoxMTo1NVrOGedxKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA==", "bodyText": "pattern should be in argument", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434475890", "createdAt": "2020-06-03T10:44:34Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMTI4NA==", "bodyText": "What pattern? The dot?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434521284", "createdAt": "2020-06-03T12:15:04Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMTgzNg==", "bodyText": "What pattern? The dot?\n\nYes, what is searched.  e.g.  String searchTxt", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434531836", "createdAt": "2020-06-03T12:34:01Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NDk3Nw==", "bodyText": "Maybe it will be good to have a constant instead of an argument.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434564977", "createdAt": "2020-06-03T13:27:13Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3Mzg0OQ==", "bodyText": "Constant can be used during call to this method. My point is we need to make method reusable with any searchTxt", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434573849", "createdAt": "2020-06-03T13:39:48Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5MjE1Nw==", "bodyText": "I disagree. We have a specific logic here and it doesn't make sense to check with other patterns", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434592157", "createdAt": "2020-06-03T14:03:55Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5ODE4NA==", "bodyText": "hard-coded  search makes this method non re-usable", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434598184", "createdAt": "2020-06-03T14:11:55Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjM5MjcxOnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo1MDo0MFrOGeWfEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTozMzoxNFrOGehepA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3ODg2NQ==", "bodyText": "The LocalCopybookResolver doesn't have any internal state. Is it necessary to create an instance?\nCould resolve be a static utility method?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434478865", "createdAt": "2020-06-03T10:50:40Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU0MDI0NA==", "bodyText": "I will take a look at that", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434540244", "createdAt": "2020-06-03T12:48:19Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3ODg2NQ=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1ODk4MA==", "bodyText": "The idea is to apply chain of responsability pattern there and leave to the appropriate derivatives the effort to resolve the copybook (local or endevor or zowe).\nI will implement this enhancement later on.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434658980", "createdAt": "2020-06-03T15:33:14Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3ODg2NQ=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjQxODUzOnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo1ODo0NlrOGeWvSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTozMzozMlrOGehfdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4MzAxNw==", "bodyText": "In case when we have many extensions we will do many calls to FS to check the file existing state. Things will go harder in a case when we also want to support case insensitive scenario.\nI think what is possible to take a list of files from the folder once and then work with that list.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434483017", "createdAt": "2020-06-03T10:58:46Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwODYyMg==", "bodyText": "Also, this check is case-sensitive", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434508622", "createdAt": "2020-06-03T11:51:11Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4MzAxNw=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2Mjk2NA==", "bodyText": "In case when we have many extensions we will do many calls to FS to check the file existing state. Things will go harder in a case when we also want to support case insensitive scenario.\nI think what is possible to take a list of files from the folder once and then work with that list.\n\nWell.. to be honest I am not expecting to have more than 3 elements (cpy, CPY, Cpy) so I don't really see the value to create a more expensive operation\n\nAlso, this check is case-sensitive\nTrue - I will fix this immediately :)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434562964", "createdAt": "2020-06-03T13:24:14Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4MzAxNw=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY1OTE5MA==", "bodyText": "I will fix it", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434659190", "createdAt": "2020-06-03T15:33:32Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4MzAxNw=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjQyNTQ1OnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTowMDo1OFrOGeWzng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTowMDo1OFrOGeWzng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4NDEyNg==", "bodyText": "If it is not ...", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434484126", "createdAt": "2020-06-03T11:00:58Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {\n+                    return uri;\n+                }\n+            }\n+        }\n+    }\n+\n+    constructor(private profileService: ProfileService, private copybooksDownloader: CopybooksDownloader) {\n+    }\n+\n+    /**\n+     * This function will try to resolve a given copybook name applying a two-step search strategy:\n+     * - search it on folders provided by the user in the setting.json\n+     * - search in the folder where the extension download copybooks from MF (.copybooks)\n+     * If is not found in the previous steps than the user is notified and needs to download it from MF", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjQ5MTQ5OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WatcherServiceImplTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMToyMzoxNFrOGeXdXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozNzozNVrOGeZ15A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5NDgxNA==", "bodyText": "I suggest start using, in next time,  \"org.hamcrest.core\" assertThat  instead of Assert methods. We can look at it once we discuss in deep about TDD/BDD.\ne.g.\nassertThat(1, is(params.getRegistrations().size()));\nassertThat(registration.getId(), notNullValue());", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434494814", "createdAt": "2020-06-03T11:23:14Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WatcherServiceImplTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.providers.ClientProvider;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * This class is a unit test for the {@link WatcherServiceImpl} and asserts that it creates correct\n+ * JSON object structures on each watching request.\n+ */\n+public class WatcherServiceImplTest {\n+\n+  @Test\n+  public void watchConfigurationChange() {\n+    LanguageClient client = mock(LanguageClient.class);\n+    ClientProvider provider = new ClientProvider();\n+    provider.set(client);\n+    ArgumentCaptor<RegistrationParams> captor = forClass(RegistrationParams.class);\n+    WatcherService watcherService = new WatcherServiceImpl(provider);\n+\n+    watcherService.watchConfigurationChange();\n+\n+    verify(client).registerCapability(captor.capture());\n+\n+    RegistrationParams params = captor.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMTIyMQ==", "bodyText": "It depends on if we have TPSR and IP checks for that", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434531221", "createdAt": "2020-06-03T12:32:51Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WatcherServiceImplTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.providers.ClientProvider;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * This class is a unit test for the {@link WatcherServiceImpl} and asserts that it creates correct\n+ * JSON object structures on each watching request.\n+ */\n+public class WatcherServiceImplTest {\n+\n+  @Test\n+  public void watchConfigurationChange() {\n+    LanguageClient client = mock(LanguageClient.class);\n+    ClientProvider provider = new ClientProvider();\n+    provider.set(client);\n+    ArgumentCaptor<RegistrationParams> captor = forClass(RegistrationParams.class);\n+    WatcherService watcherService = new WatcherServiceImpl(provider);\n+\n+    watcherService.watchConfigurationChange();\n+\n+    verify(client).registerCapability(captor.capture());\n+\n+    RegistrationParams params = captor.getValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5NDgxNA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMzg2MA==", "bodyText": "It depends on if we have TPSR and IP checks for that\n\nWe have it already, I even tested, it works fine.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434533860", "createdAt": "2020-06-03T12:37:35Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WatcherServiceImplTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.providers.ClientProvider;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * This class is a unit test for the {@link WatcherServiceImpl} and asserts that it creates correct\n+ * JSON object structures on each watching request.\n+ */\n+public class WatcherServiceImplTest {\n+\n+  @Test\n+  public void watchConfigurationChange() {\n+    LanguageClient client = mock(LanguageClient.class);\n+    ClientProvider provider = new ClientProvider();\n+    provider.set(client);\n+    ArgumentCaptor<RegistrationParams> captor = forClass(RegistrationParams.class);\n+    WatcherService watcherService = new WatcherServiceImpl(provider);\n+\n+    watcherService.watchConfigurationChange();\n+\n+    verify(client).registerCapability(captor.capture());\n+\n+    RegistrationParams params = captor.getValue();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5NDgxNA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjUzODM1OnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTozODo0M1rOGeX6mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODoyODowOFrOGe7P0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMjI5Ng==", "bodyText": "I would prefer to avoid using -er endings in class names", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434502296", "createdAt": "2020-06-03T11:38:43Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "diffHunk": "@@ -14,15 +14,21 @@\n \n import * as fs from \"fs\";\n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n-import { loadDepFile, DependenciesDesc } from \"./DependencyService\";\n-import { C4Z_FOLDER, DEPENDENCIES_FOLDER, PROCESS_DOWNLOAD_ERROR_MSG, DSN_NOT_FOUND_ERROR_MSG, INVALID_CREDENTIALS_ERROR_MSG, DSN_PLACEHOLDER, PROFILE_NAME_PLACEHOLDER, CONN_REFUSED_ERROR_MSG, NO_PASSWORD_ERROR_MSG } from \"../constants\";\n-import { CopybookFix } from \"./CopybookFix\";\n-import { CopybooksPathGenerator, createDatasetPath, createCopybookPath, checkWorkspace } from \"./CopybooksPathGenerator\";\n-import { CopybookProfile, DownloadQueue } from \"./DownloadQueue\";\n-import { ProfileService } from \"./ProfileService\";\n-import { ZoweApi } from \"./ZoweApi\";\n-import { Type, ZoweError } from \"./ZoweError\";\n+import {\n+    CONN_REFUSED_ERROR_MSG,\n+    DSN_NOT_FOUND_ERROR_MSG,\n+    DSN_PLACEHOLDER,\n+    INVALID_CREDENTIALS_ERROR_MSG,\n+    NO_PASSWORD_ERROR_MSG,\n+    PROCESS_DOWNLOAD_ERROR_MSG,\n+    PROFILE_NAME_PLACEHOLDER,\n+} from \"../constants\";\n+import {CopybookFix} from \"./CopybookFix\";\n+import {checkWorkspace, CopybooksPathGenerator, createCopybookPath, createDatasetPath} from \"./CopybooksPathGenerator\";\n+import {CopybookProfile, DownloadQueue} from \"./DownloadQueue\";\n+import {ProfileService} from \"./ProfileService\";\n+import {ZoweApi} from \"./ZoweApi\";\n+import {Type, ZoweError} from \"./ZoweError\";\n \n export class CopybooksDownloader implements vscode.Disposable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3NzYyNw==", "bodyText": "Main convention is class names should be noun. But any alternative name can be preferable, e.g.  CopybooksDownloadService or  CopybooksDownloadManager", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434577627", "createdAt": "2020-06-03T13:44:37Z", "author": {"login": "asatklichov"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "diffHunk": "@@ -14,15 +14,21 @@\n \n import * as fs from \"fs\";\n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n-import { loadDepFile, DependenciesDesc } from \"./DependencyService\";\n-import { C4Z_FOLDER, DEPENDENCIES_FOLDER, PROCESS_DOWNLOAD_ERROR_MSG, DSN_NOT_FOUND_ERROR_MSG, INVALID_CREDENTIALS_ERROR_MSG, DSN_PLACEHOLDER, PROFILE_NAME_PLACEHOLDER, CONN_REFUSED_ERROR_MSG, NO_PASSWORD_ERROR_MSG } from \"../constants\";\n-import { CopybookFix } from \"./CopybookFix\";\n-import { CopybooksPathGenerator, createDatasetPath, createCopybookPath, checkWorkspace } from \"./CopybooksPathGenerator\";\n-import { CopybookProfile, DownloadQueue } from \"./DownloadQueue\";\n-import { ProfileService } from \"./ProfileService\";\n-import { ZoweApi } from \"./ZoweApi\";\n-import { Type, ZoweError } from \"./ZoweError\";\n+import {\n+    CONN_REFUSED_ERROR_MSG,\n+    DSN_NOT_FOUND_ERROR_MSG,\n+    DSN_PLACEHOLDER,\n+    INVALID_CREDENTIALS_ERROR_MSG,\n+    NO_PASSWORD_ERROR_MSG,\n+    PROCESS_DOWNLOAD_ERROR_MSG,\n+    PROFILE_NAME_PLACEHOLDER,\n+} from \"../constants\";\n+import {CopybookFix} from \"./CopybookFix\";\n+import {checkWorkspace, CopybooksPathGenerator, createCopybookPath, createDatasetPath} from \"./CopybooksPathGenerator\";\n+import {CopybookProfile, DownloadQueue} from \"./DownloadQueue\";\n+import {ProfileService} from \"./ProfileService\";\n+import {ZoweApi} from \"./ZoweApi\";\n+import {Type, ZoweError} from \"./ZoweError\";\n \n export class CopybooksDownloader implements vscode.Disposable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMjI5Ng=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0NDI0Nw==", "bodyText": "Yes, CopybookDownloadService would be better", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434644247", "createdAt": "2020-06-03T15:13:33Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "diffHunk": "@@ -14,15 +14,21 @@\n \n import * as fs from \"fs\";\n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n-import { loadDepFile, DependenciesDesc } from \"./DependencyService\";\n-import { C4Z_FOLDER, DEPENDENCIES_FOLDER, PROCESS_DOWNLOAD_ERROR_MSG, DSN_NOT_FOUND_ERROR_MSG, INVALID_CREDENTIALS_ERROR_MSG, DSN_PLACEHOLDER, PROFILE_NAME_PLACEHOLDER, CONN_REFUSED_ERROR_MSG, NO_PASSWORD_ERROR_MSG } from \"../constants\";\n-import { CopybookFix } from \"./CopybookFix\";\n-import { CopybooksPathGenerator, createDatasetPath, createCopybookPath, checkWorkspace } from \"./CopybooksPathGenerator\";\n-import { CopybookProfile, DownloadQueue } from \"./DownloadQueue\";\n-import { ProfileService } from \"./ProfileService\";\n-import { ZoweApi } from \"./ZoweApi\";\n-import { Type, ZoweError } from \"./ZoweError\";\n+import {\n+    CONN_REFUSED_ERROR_MSG,\n+    DSN_NOT_FOUND_ERROR_MSG,\n+    DSN_PLACEHOLDER,\n+    INVALID_CREDENTIALS_ERROR_MSG,\n+    NO_PASSWORD_ERROR_MSG,\n+    PROCESS_DOWNLOAD_ERROR_MSG,\n+    PROFILE_NAME_PLACEHOLDER,\n+} from \"../constants\";\n+import {CopybookFix} from \"./CopybookFix\";\n+import {checkWorkspace, CopybooksPathGenerator, createCopybookPath, createDatasetPath} from \"./CopybooksPathGenerator\";\n+import {CopybookProfile, DownloadQueue} from \"./DownloadQueue\";\n+import {ProfileService} from \"./ProfileService\";\n+import {ZoweApi} from \"./ZoweApi\";\n+import {Type, ZoweError} from \"./ZoweError\";\n \n export class CopybooksDownloader implements vscode.Disposable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMjI5Ng=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4MTE3MQ==", "bodyText": "OK", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r435081171", "createdAt": "2020-06-04T08:28:08Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "diffHunk": "@@ -14,15 +14,21 @@\n \n import * as fs from \"fs\";\n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n-import { loadDepFile, DependenciesDesc } from \"./DependencyService\";\n-import { C4Z_FOLDER, DEPENDENCIES_FOLDER, PROCESS_DOWNLOAD_ERROR_MSG, DSN_NOT_FOUND_ERROR_MSG, INVALID_CREDENTIALS_ERROR_MSG, DSN_PLACEHOLDER, PROFILE_NAME_PLACEHOLDER, CONN_REFUSED_ERROR_MSG, NO_PASSWORD_ERROR_MSG } from \"../constants\";\n-import { CopybookFix } from \"./CopybookFix\";\n-import { CopybooksPathGenerator, createDatasetPath, createCopybookPath, checkWorkspace } from \"./CopybooksPathGenerator\";\n-import { CopybookProfile, DownloadQueue } from \"./DownloadQueue\";\n-import { ProfileService } from \"./ProfileService\";\n-import { ZoweApi } from \"./ZoweApi\";\n-import { Type, ZoweError } from \"./ZoweError\";\n+import {\n+    CONN_REFUSED_ERROR_MSG,\n+    DSN_NOT_FOUND_ERROR_MSG,\n+    DSN_PLACEHOLDER,\n+    INVALID_CREDENTIALS_ERROR_MSG,\n+    NO_PASSWORD_ERROR_MSG,\n+    PROCESS_DOWNLOAD_ERROR_MSG,\n+    PROFILE_NAME_PLACEHOLDER,\n+} from \"../constants\";\n+import {CopybookFix} from \"./CopybookFix\";\n+import {checkWorkspace, CopybooksPathGenerator, createCopybookPath, createDatasetPath} from \"./CopybooksPathGenerator\";\n+import {CopybookProfile, DownloadQueue} from \"./DownloadQueue\";\n+import {ProfileService} from \"./ProfileService\";\n+import {ZoweApi} from \"./ZoweApi\";\n+import {Type, ZoweError} from \"./ZoweError\";\n \n export class CopybooksDownloader implements vscode.Disposable {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMjI5Ng=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYwOTM3OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowMDo0OFrOGeYnlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowMDo0OFrOGeYnlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxMzgxMw==", "bodyText": "\"copybooks\" may be defined as an element of SettingsParametersEnum", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434513813", "createdAt": "2020-06-03T12:00:48Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,122 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final SettingsService settingsService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+          DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.settingsService = settingsService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n-  /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n-   *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n   @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n+  public void invalidateURICache() {\n+    copybookPath.clear();\n   }\n \n   /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n+   *\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      settingsService\n+          .getConfiguration(\"copybook\", cobolFileName, requiredCopybookName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 188}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYyMTcwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNDo1OVrOGeYvwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNDo1OVrOGeYvwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNTkwNA==", "bodyText": "Missing Override annotation", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434515904", "createdAt": "2020-06-03T12:04:59Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYyNDc5OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNTo1NVrOGeYxuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNTo1NVrOGeYxuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjQwOA==", "bodyText": "Not descriptive var name", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434516408", "createdAt": "2020-06-03T12:05:55Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {\n+    register(\n+        paths.stream()\n+            .map(\n+                it -> {\n+                  folderWatchers.add(it);\n+                  return new Registration(\n+                      it,\n+                      WATCH_FILES,\n+                      new DidChangeWatchedFilesRegistrationOptions(\n+                          singletonList(\n+                              new FileSystemWatcher(\"**/\" + it + \"/**/*\", WATCH_ALL_KIND))));\n+                })\n+            .collect(toList()));\n+  }\n+\n+  @Override\n+  public void removeWatchers(@Nonnull List<String> paths) {\n+    List<String> collect = paths.stream().filter(folderWatchers::remove).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYyODA5OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNzowMFrOGeYz4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowNzowMFrOGeYz4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjk2MQ==", "bodyText": "\"**/\" + it + \"/**/*\" is on a lower abstracion layer and should be exctracted", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434516961", "createdAt": "2020-06-03T12:07:00Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {\n+    register(\n+        paths.stream()\n+            .map(\n+                it -> {\n+                  folderWatchers.add(it);\n+                  return new Registration(\n+                      it,\n+                      WATCH_FILES,\n+                      new DidChangeWatchedFilesRegistrationOptions(\n+                          singletonList(\n+                              new FileSystemWatcher(\"**/\" + it + \"/**/*\", WATCH_ALL_KIND))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 90}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjYzODAzOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowOTo1NlrOGeY6OA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjowOTo1NlrOGeY6OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODU4NA==", "bodyText": "Outdated javadoc. Probably, the whole method may be removed", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434518584", "createdAt": "2020-06-03T12:09:56Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.utils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+\n+/** This interface represents API for low-level file systems access */\n+public interface FileSystemService {\n+  /**\n+   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n+   * the FileSystemService, example: [input:\n+   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n+   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n+   *\n+   * @param uri URI string representation of a file\n+   * @return the {@link Path} representation of the given URI in input\n+   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n+   */\n+  @Nullable\n+  Path getPathFromURI(@Nonnull String uri);\n+\n+  /**\n+   * This method extracts the name of a file from a valid {@link URI} and return the name back to\n+   * the client as String or null in case of error.\n+   *\n+   * @param uri the reference of the file from where extract the name\n+   * @return the String representation of the file name or null if any {@link URISyntaxException} is\n+   *     caught.\n+   */\n+  @Nullable\n+  String getNameFromURI(@Nonnull String uri);\n+\n+  /**\n+   * Retrieve the content of the file as a string.\n+   *\n+   * @param file URI from where extract the content\n+   * @return content of the file as String representation\n+   */\n+  @Nullable\n+  String getContentByPath(@Nonnull Path file);\n+\n+  /**\n+   * Check if the file with the given path exists\n+   *\n+   * @param file NIO path of the file to check\n+   * @return true if the path represent a valid file, false otherwise\n+   */\n+  boolean fileExists(@Nullable Path file);\n+\n+  /**\n+   * Replace special chars (as parenthesis, spaces and so on) that are encoded by the LSP protocol\n+   * on the client side. Needs to be encoded in order to display to the user the uri correctly.\n+   *\n+   * @param uri provided by the {@link org.eclipse.lsp4j.services.TextDocumentService}\n+   * @return a new String decoded with UTF8\n+   */\n+  @Nonnull\n+  String decodeURI(@Nonnull String uri);\n+\n+  /**\n+   * Retrieve the content of a dependency file and return it back to the callee.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjY1MzAxOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxNDoyN1rOGeZDiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxNDoyN1rOGeZDiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMDk3MQ==", "bodyText": "Incorrect method javadoc pattern - should start with a verb in the active voice", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434520971", "createdAt": "2020-06-03T12:14:27Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 224}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjcwNzM1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CobolWorkspaceServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozMDowM1rOGeZldw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMTozMVrOGebgRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyOTY1NQ==", "bodyText": "The method called asynchronously. Inside we add and remove watchers. It could cause us an issue if this method will be called in two threads. Is it make sense to use a synchronized method here?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434529655", "createdAt": "2020-06-03T12:30:03Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CobolWorkspaceServiceImpl.java", "diffHunk": "@@ -67,66 +76,72 @@ public CobolWorkspaceServiceImpl(DataBusBroker dataBus, Provider<LanguageClient>\n   @Nonnull\n   @Override\n   public CompletableFuture<Object> executeCommand(@Nonnull ExecuteCommandParams params) {\n+    runAsync(executeCopybookFix(params)).whenComplete(reportExceptionIfFound(params));\n+\n     return completedFuture(null);\n   }\n \n+  private Runnable executeCopybookFix(@Nonnull ExecuteCommandParams params) {\n+    return () -> {\n+      if (MISSING_COPYBOOK.name().equals(params.getCommand())) {\n+        rerunAnalysis();\n+      }\n+    };\n+  }\n+\n   /**\n-   * This is a notification triggered automatically when the user modify configuration settings in\n-   * the client\n+   * Process changed configuration on the client state. This notification triggered automatically\n+   * when the user modify configuration settings in the client. Invalidate all the caches to avoid\n+   * dirty state.\n    *\n    * @param params - LSPSpecification -> The actual changed settings; Actually -> null all the time.\n    */\n   @Override\n   public void didChangeConfiguration(DidChangeConfigurationParams params) {\n-    try {\n-\n-      // invalidate cache to avoid false positive\n-      dataBus.invalidateCache();\n-      fetchSettings(LSP_PREFIX.label + \".\" + CPY_MANAGER.label, null)\n-          .thenAccept(e -> dataBus.postData(FetchedSettingsEvent.builder().content(e).build()));\n-    } catch (RuntimeException e) {\n-      log.error(e.getMessage());\n-    }\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> acceptSettingsChange(toStrings(it)));\n   }\n \n-  /**\n-   * After client notifies the server that there is a setting change we need to request the client\n-   * those changing by sending a workspace/configuration JSON request\n-   *\n-   * @param section - The configuration section asked for.\n-   * @param scope - The scope to get the configuration section for.\n-   * @return - CompletedFuture which contains an object with the settings asked for.\n-   */\n-  private CompletableFuture<List<Object>> fetchSettings(String section, String scope) {\n-    ConfigurationParams params =\n-        new ConfigurationParams(provideConfigurationItemList(section, scope));\n-    return clientProvider.get().configuration(params);\n+  private void acceptSettingsChange(List<String> localFolders) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MTA5NA==", "bodyText": "I think it is better to mark WatcherServiceImpl#addWatchers and WatcherServiceImpl#removeWatchers as synchronized to reduce the sync area", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434561094", "createdAt": "2020-06-03T13:21:31Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CobolWorkspaceServiceImpl.java", "diffHunk": "@@ -67,66 +76,72 @@ public CobolWorkspaceServiceImpl(DataBusBroker dataBus, Provider<LanguageClient>\n   @Nonnull\n   @Override\n   public CompletableFuture<Object> executeCommand(@Nonnull ExecuteCommandParams params) {\n+    runAsync(executeCopybookFix(params)).whenComplete(reportExceptionIfFound(params));\n+\n     return completedFuture(null);\n   }\n \n+  private Runnable executeCopybookFix(@Nonnull ExecuteCommandParams params) {\n+    return () -> {\n+      if (MISSING_COPYBOOK.name().equals(params.getCommand())) {\n+        rerunAnalysis();\n+      }\n+    };\n+  }\n+\n   /**\n-   * This is a notification triggered automatically when the user modify configuration settings in\n-   * the client\n+   * Process changed configuration on the client state. This notification triggered automatically\n+   * when the user modify configuration settings in the client. Invalidate all the caches to avoid\n+   * dirty state.\n    *\n    * @param params - LSPSpecification -> The actual changed settings; Actually -> null all the time.\n    */\n   @Override\n   public void didChangeConfiguration(DidChangeConfigurationParams params) {\n-    try {\n-\n-      // invalidate cache to avoid false positive\n-      dataBus.invalidateCache();\n-      fetchSettings(LSP_PREFIX.label + \".\" + CPY_MANAGER.label, null)\n-          .thenAccept(e -> dataBus.postData(FetchedSettingsEvent.builder().content(e).build()));\n-    } catch (RuntimeException e) {\n-      log.error(e.getMessage());\n-    }\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> acceptSettingsChange(toStrings(it)));\n   }\n \n-  /**\n-   * After client notifies the server that there is a setting change we need to request the client\n-   * those changing by sending a workspace/configuration JSON request\n-   *\n-   * @param section - The configuration section asked for.\n-   * @param scope - The scope to get the configuration section for.\n-   * @return - CompletedFuture which contains an object with the settings asked for.\n-   */\n-  private CompletableFuture<List<Object>> fetchSettings(String section, String scope) {\n-    ConfigurationParams params =\n-        new ConfigurationParams(provideConfigurationItemList(section, scope));\n-    return clientProvider.get().configuration(params);\n+  private void acceptSettingsChange(List<String> localFolders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyOTY1NQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 119}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjczMTg1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozNzoxM1rOGeZ1EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozNzoxM1rOGeZ1EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMzY0OQ==", "bodyText": "The same as CobolWorkspaceServiceImpl#toString. I think that it could be a method of SettingsService.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434533649", "createdAt": "2020-06-03T12:37:13Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "diffHunk": "@@ -162,10 +106,23 @@ void retrieveAndStoreConfiguration() {\n         new WorkspaceServerCapabilities(workspaceFoldersOptions);\n     capabilities.setWorkspace(workspaceServiceCapabilities);\n \n-    copybookService.setWorkspaceFolders(params.getWorkspaceFolders());\n     return supplyAsync(() -> new InitializeResult(capabilities));\n   }\n \n+  private void addLocalFilesWatcher() {\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> watchingService.addWatchers(toStrings(it)));\n+  }\n+\n+  private List<String> toStrings(List<Object> it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg0NTQ3OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowNzoxMlrOGea8dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowNzoxMlrOGea8dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MTkyNw==", "bodyText": "This line doesn't cover all cases. It converts Unix separators to Windows, but leave Windows separators unchanged for Unix.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434551927", "createdAt": "2020-06-03T13:07:12Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg1MjI0OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowOTowMlrOGebA0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoxMTozNVrOGedwPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MzA0MQ==", "bodyText": "Not sure that it will be safe to delete \" symbol.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434553041", "createdAt": "2020-06-03T13:09:02Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5Nzk0OA==", "bodyText": "Seems like we may drop this entire method, It was used to process URIs with profile and DS name", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434597948", "createdAt": "2020-06-03T14:11:35Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MzA0MQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 87}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg2NDU5OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxMjoxNFrOGebIxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxMjoxNFrOGebIxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NTA3Ng==", "bodyText": "It creates the file only if needed. Could it be renamed like ensureFile?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434555076", "createdAt": "2020-06-03T13:12:14Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 132}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg3MjUwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNDoxMlrOGebN9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNDoxMlrOGebN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NjQwNQ==", "bodyText": "We could use System.lineSeparator() here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434556405", "createdAt": "2020-06-03T13:14:12Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 174}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg3MzMwOnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNDoyNVrOGebOiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzozNzozN1rOGecLpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NjU1NQ==", "bodyText": "I think there is no need to wrap this into else block due to the first if contains an early-return.\nAlso, is it guaranteed that something will be returned in any case?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434556555", "createdAt": "2020-06-03T13:14:25Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {\n+                    return uri;\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU3MjE5Ng==", "bodyText": "Well technically yes because programmatically we added the valid extension related to copybooks", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434572196", "createdAt": "2020-06-03T13:37:37Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {\n+                    return uri;\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NjU1NQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 72}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg3OTM2OnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNTo1OVrOGebSjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNTo1OVrOGebSjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NzU4MQ==", "bodyText": "Non-alphabetical order", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434557581", "createdAt": "2020-06-03T13:15:59Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "diffHunk": "@@ -15,26 +15,26 @@\n import * as fs from \"fs\";\n import * as net from \"net\";\n import * as vscode from \"vscode\";\n-import { LANGUAGE_ID } from \"../constants\";\n-import {CancellationToken, ConfigurationParams, ConfigurationRequest, LanguageClient, LanguageClientOptions, StreamInfo} from \"vscode-languageclient\";\n+import { LanguageClient, LanguageClientOptions, StreamInfo, ConfigurationRequest, ConfigurationParams} from \"vscode-languageclient\";\n import { ConfigurationWorkspaceMiddleware } from \"vscode-languageclient/lib/configuration\";\n-import { CopybooksPathGenerator } from \"./CopybooksPathGenerator\";\n+import { LANGUAGE_ID } from \"../constants\";\n import { JavaCheck } from \"./JavaCheck\";\n+import { Middleware } from \"./Middleware\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg4NDM5OnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNzoyMlrOGebV3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwODozODowNlrOGe7oCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1ODQzMA==", "bodyText": "The line indent not adjusted", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434558430", "createdAt": "2020-06-03T13:17:22Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "diffHunk": "@@ -49,22 +49,21 @@ export class LanguageClientService {\n     private createClientOptions(): LanguageClientOptions {\n         const signatureFunc: ConfigurationRequest.MiddlewareSignature = async (\n             params: ConfigurationParams,\n-            token: CancellationToken,\n+            token: vscode.CancellationToken,\n             next: ConfigurationRequest.HandlerSignature) => {\n-\n-            // TODO if request params are right\n-            return (await this.copybooksPathGenerator.listUris()).map(uri => uri.toString());\n-            // TODO else return next(params, token);\n+                return await this.middleware.handleConfigurationRequest(params, token, next);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA4NzM3MQ==", "bodyText": "I don't see any problem about indentation in my editor", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r435087371", "createdAt": "2020-06-04T08:38:06Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "diffHunk": "@@ -49,22 +49,21 @@ export class LanguageClientService {\n     private createClientOptions(): LanguageClientOptions {\n         const signatureFunc: ConfigurationRequest.MiddlewareSignature = async (\n             params: ConfigurationParams,\n-            token: CancellationToken,\n+            token: vscode.CancellationToken,\n             next: ConfigurationRequest.HandlerSignature) => {\n-\n-            // TODO if request params are right\n-            return (await this.copybooksPathGenerator.listUris()).map(uri => uri.toString());\n-            // TODO else return next(params, token);\n+                return await this.middleware.handleConfigurationRequest(params, token, next);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1ODQzMA=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg4NTI5OnYy", "diffSide": "RIGHT", "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNzozNVrOGebWbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNzozNVrOGebWbg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1ODU3NA==", "bodyText": "Extra line", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434558574", "createdAt": "2020-06-03T13:17:35Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "diffHunk": "@@ -49,22 +49,21 @@ export class LanguageClientService {\n     private createClientOptions(): LanguageClientOptions {\n         const signatureFunc: ConfigurationRequest.MiddlewareSignature = async (\n             params: ConfigurationParams,\n-            token: CancellationToken,\n+            token: vscode.CancellationToken,\n             next: ConfigurationRequest.HandlerSignature) => {\n-\n-            // TODO if request params are right\n-            return (await this.copybooksPathGenerator.listUris()).map(uri => uri.toString());\n-            // TODO else return next(params, token);\n+                return await this.middleware.handleConfigurationRequest(params, token, next);\n         };\n         const configurationMiddleware: ConfigurationWorkspaceMiddleware = {\n             configuration: signatureFunc,\n         };\n \n         return {\n             documentSelector: [LANGUAGE_ID],\n-            middleware: { workspace: configurationMiddleware }\n+            middleware: { workspace: configurationMiddleware },\n         };\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjg5NDcxOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMDowM1rOGebcgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzo1NTozNlrOGedBKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDEyOQ==", "bodyText": "It makes sense to use Set here instead of List.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434560129", "createdAt": "2020-06-03T13:20:03Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU4NTg5Nw==", "bodyText": "depends on caseinsensitive, or  equalsIgnoreCase  usage", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434585897", "createdAt": "2020-06-03T13:55:36Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDEyOQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 213}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjkwNTEyOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMjo0MVrOGebjRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMjo0MVrOGebjRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MTg2Mw==", "bodyText": "This check is useless. The file couldn't be a file and a directory at the same time.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434561863", "createdAt": "2020-06-03T13:22:41Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 233}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjkyMzA2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WorkspaceServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyNjo1M1rOGebugw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyNjo1M1rOGebugw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NDczOQ==", "bodyText": "Probably, some forgotten code", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434564739", "createdAt": "2020-06-03T13:26:53Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WorkspaceServiceTest.java", "diffHunk": "@@ -47,48 +51,171 @@\n  * implementation.\n  */\n @Slf4j\n+@SuppressWarnings(\"unchecked\")\n public class WorkspaceServiceTest {\n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n-   * not recognized.\n+   * Test of the workspace/executeCommand entry point. Assert that on a MISSING_COPYBOOK the {@link\n+   * RequiredCopybookEvent} fired.\n    */\n   @Test\n-  public void testExecuteNonExistingCommand() {\n+  public void testExecuteCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    String copybookName = \"COPYBOOK\";\n+\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n+        service.executeCommand(\n+            new ExecuteCommandParams(\n+                MISSING_COPYBOOK.name(),\n+                asList(new JsonPrimitive(copybookName), new JsonPrimitive(DOCUMENT_URI))));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, timeout(1000).times(0)).postData(any());\n+    verify(broker, timeout(10000)).invalidateCache();\n+    verify(broker, timeout(10000)).postData(any(RunAnalysisEvent.class));\n   }\n \n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the argument\n-   * list is incomplete.\n+   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n+   * not recognized.\n    */\n   @Test\n-  public void testExecuteCommandIncorrectArguments() {\n+  public void testExecuteNonExistingCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(\n-            new ExecuteCommandParams(\n-                MISSING_COPYBOOK.name(), singletonList(new JsonPrimitive(DOCUMENT_URI))));\n+        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, never()).postData(any());\n+    verify(broker, timeout(1000).times(0)).postData(any());\n+  }\n+\n+  /** Test a new watcher created when a new path add in setting.json */\n+  @Test\n+  public void testChangeConfigurationNewPath() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(watcherCaptor.capture());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path list not changed */\n+  @Test\n+  public void testChangeConfigurationNoChangesInPaths() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n   }\n+\n+  /** Test an existing watcher removed when its path doesn't exist in setting.json */\n+  @Test\n+  public void testChangeConfigurationPathRemoved() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(watcherCaptor.capture());\n+    verify(copybookService).invalidateURICache();\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path is empty */\n+  @Test\n+  public void testChangeConfigurationNoPathToRegister() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+  }\n+\n+  /**\n+   * This test verifies that the Workspace Service reacts on the file created watcher's\n+   * notifications\n+   */\n+  @Test\n+  public void testDidChangeWatchedFilesExistingFileCreated() {\n+    log.error(\"asdd\", new Error());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNjkzOTU2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzozMDo0NlrOGeb4-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDowODozN1rOGednRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NzQxOQ==", "bodyText": "hasFileValidExtension function use equalsIgnoreCase, we can drop .toLowerCase() here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434567419", "createdAt": "2020-06-03T13:30:46Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")\n+        && FilenameUtils.getBaseName(currentFile.getName()).equalsIgnoreCase(requiredName)\n+        && hasFileValidExtension(currentFile.getAbsoluteFile().toString().toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU5NTY1Mw==", "bodyText": "Good catch, I agree", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434595653", "createdAt": "2020-06-03T14:08:37Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")\n+        && FilenameUtils.getBaseName(currentFile.getName()).equalsIgnoreCase(requiredName)\n+        && hasFileValidExtension(currentFile.getAbsoluteFile().toString().toLowerCase());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NzQxOQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzIwMzc5OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyNzo1N1rOGeegxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyNzo1N1rOGeegxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMDM3NQ==", "bodyText": "I would suggest to make it plural", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434610375", "createdAt": "2020-06-03T14:27:57Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,122 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final SettingsService settingsService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+          DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.settingsService = settingsService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n-  /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n-   *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n   @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n+  public void invalidateURICache() {\n+    copybookPath.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzIxMDk2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WorkspaceServiceTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyOTozMVrOGeelaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyOTozMVrOGeelaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMTU2MA==", "bodyText": "Do we really need this message?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434611560", "createdAt": "2020-06-03T14:29:31Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WorkspaceServiceTest.java", "diffHunk": "@@ -47,48 +51,171 @@\n  * implementation.\n  */\n @Slf4j\n+@SuppressWarnings(\"unchecked\")\n public class WorkspaceServiceTest {\n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n-   * not recognized.\n+   * Test of the workspace/executeCommand entry point. Assert that on a MISSING_COPYBOOK the {@link\n+   * RequiredCopybookEvent} fired.\n    */\n   @Test\n-  public void testExecuteNonExistingCommand() {\n+  public void testExecuteCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    String copybookName = \"COPYBOOK\";\n+\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n+        service.executeCommand(\n+            new ExecuteCommandParams(\n+                MISSING_COPYBOOK.name(),\n+                asList(new JsonPrimitive(copybookName), new JsonPrimitive(DOCUMENT_URI))));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, timeout(1000).times(0)).postData(any());\n+    verify(broker, timeout(10000)).invalidateCache();\n+    verify(broker, timeout(10000)).postData(any(RunAnalysisEvent.class));\n   }\n \n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the argument\n-   * list is incomplete.\n+   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n+   * not recognized.\n    */\n   @Test\n-  public void testExecuteCommandIncorrectArguments() {\n+  public void testExecuteNonExistingCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(\n-            new ExecuteCommandParams(\n-                MISSING_COPYBOOK.name(), singletonList(new JsonPrimitive(DOCUMENT_URI))));\n+        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, never()).postData(any());\n+    verify(broker, timeout(1000).times(0)).postData(any());\n+  }\n+\n+  /** Test a new watcher created when a new path add in setting.json */\n+  @Test\n+  public void testChangeConfigurationNewPath() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(watcherCaptor.capture());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path list not changed */\n+  @Test\n+  public void testChangeConfigurationNoChangesInPaths() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n   }\n+\n+  /** Test an existing watcher removed when its path doesn't exist in setting.json */\n+  @Test\n+  public void testChangeConfigurationPathRemoved() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(watcherCaptor.capture());\n+    verify(copybookService).invalidateURICache();\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path is empty */\n+  @Test\n+  public void testChangeConfigurationNoPathToRegister() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+  }\n+\n+  /**\n+   * This test verifies that the Workspace Service reacts on the file created watcher's\n+   * notifications\n+   */\n+  @Test\n+  public void testDidChangeWatchedFilesExistingFileCreated() {\n+    log.error(\"asdd\", new Error());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 211}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzIyMTIxOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozMTozMlrOGeerqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTo0MToxM1rOGeh0zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzE2MA==", "bodyText": "But this method is not returning a String but a List of strings.. I am not sure that is correct this name..", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434613160", "createdAt": "2020-06-03T14:31:32Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "diffHunk": "@@ -162,10 +106,23 @@ void retrieveAndStoreConfiguration() {\n         new WorkspaceServerCapabilities(workspaceFoldersOptions);\n     capabilities.setWorkspace(workspaceServiceCapabilities);\n \n-    copybookService.setWorkspaceFolders(params.getWorkspaceFolders());\n     return supplyAsync(() -> new InitializeResult(capabilities));\n   }\n \n+  private void addLocalFilesWatcher() {\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> watchingService.addWatchers(toStrings(it)));\n+  }\n+\n+  private List<String> toStrings(List<Object> it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 147}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2NDY1Mg==", "bodyText": "The name here is plural. In fact, this is kinda monade and toStrings sounds more or less functinal", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434664652", "createdAt": "2020-06-03T15:41:13Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "diffHunk": "@@ -162,10 +106,23 @@ void retrieveAndStoreConfiguration() {\n         new WorkspaceServerCapabilities(workspaceFoldersOptions);\n     capabilities.setWorkspace(workspaceServiceCapabilities);\n \n-    copybookService.setWorkspaceFolders(params.getWorkspaceFolders());\n     return supplyAsync(() -> new InitializeResult(capabilities));\n   }\n \n+  private void addLocalFilesWatcher() {\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> watchingService.addWatchers(toStrings(it)));\n+  }\n+\n+  private List<String> toStrings(List<Object> it) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzE2MA=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 147}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzIyMjQ4OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/actions/FindCopybookCommandTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozMTo1MlrOGeesfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTozNToyNlrOGehklA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzM3NQ==", "bodyText": "Newline here! Is it a time to enable static code checks as part of CI?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434613375", "createdAt": "2020-06-03T14:31:52Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/actions/FindCopybookCommandTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.actions;\n+\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static java.util.Collections.singletonList;\n+import static org.eclipse.lsp4j.CodeActionKind.QuickFix;\n+import static org.eclipse.lsp4j.DiagnosticSeverity.Error;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+/**\n+ * Test {@link FindCopybookCommand} code action provider that resolves diagnostics for missing\n+ * copybooks.\n+ */\n+public class FindCopybookCommandTest {\n+\n+    private static final String TITLE = \"Fetch copybook\";\n+    private static final String COPYBOOK_NAME = \"CPYNAME\";\n+\n+    private static final Range RANGE = new Range(new Position(0, 0), new Position(0, 1));\n+    private static final Diagnostic SYNTAX_ERROR =\n+            new Diagnostic(RANGE, \"Syntax error\", Error, null, null);\n+    private static final Diagnostic COPYBOOK_ERROR =\n+            new Diagnostic(\n+                    RANGE, COPYBOOK_NAME + \": Copybook not found\", Error, null, MISSING_COPYBOOK.name());\n+\n+    /** Test a code action to resolve the required copybook created for the missing copybook error. */\n+    @Test\n+    public void testCollectCommandsOrActionsPositive() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    /** Test nothing created for a syntax error. */\n+    @Test\n+    public void testCollectCommandsOrActionsNegative() {\n+\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(SYNTAX_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(0, actions.size());\n+    }\n+\n+    /** Test only correct errors processed. */\n+    @Test\n+    public void testCollectCommandsOrActionsMixed() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = Arrays.asList(SYNTAX_ERROR, COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    private void assertCorrectCodeAction(CodeAction action) {\n+        assertEquals(TITLE, action.getTitle());\n+        assertEquals(QuickFix, action.getKind());\n+        assertEquals(COPYBOOK_ERROR, action.getDiagnostics().get(0));\n+        assertNull(action.getEdit());\n+\n+        Command command = action.getCommand();\n+        assertEquals(TITLE, command.getTitle());\n+        assertEquals(MISSING_COPYBOOK.name(), command.getCommand());\n+\n+        List<Object> arguments = command.getArguments();\n+        assertEquals(2, arguments.size());\n+        assertEquals(COPYBOOK_NAME, arguments.get(0));\n+        assertEquals(DOCUMENT_URI, arguments.get(1));\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY0Nzk0Ng==", "bodyText": "well..I think that an IDE with configured google format enabled and reformat option after save should be enough", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434647946", "createdAt": "2020-06-03T15:18:27Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/actions/FindCopybookCommandTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.actions;\n+\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static java.util.Collections.singletonList;\n+import static org.eclipse.lsp4j.CodeActionKind.QuickFix;\n+import static org.eclipse.lsp4j.DiagnosticSeverity.Error;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+/**\n+ * Test {@link FindCopybookCommand} code action provider that resolves diagnostics for missing\n+ * copybooks.\n+ */\n+public class FindCopybookCommandTest {\n+\n+    private static final String TITLE = \"Fetch copybook\";\n+    private static final String COPYBOOK_NAME = \"CPYNAME\";\n+\n+    private static final Range RANGE = new Range(new Position(0, 0), new Position(0, 1));\n+    private static final Diagnostic SYNTAX_ERROR =\n+            new Diagnostic(RANGE, \"Syntax error\", Error, null, null);\n+    private static final Diagnostic COPYBOOK_ERROR =\n+            new Diagnostic(\n+                    RANGE, COPYBOOK_NAME + \": Copybook not found\", Error, null, MISSING_COPYBOOK.name());\n+\n+    /** Test a code action to resolve the required copybook created for the missing copybook error. */\n+    @Test\n+    public void testCollectCommandsOrActionsPositive() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    /** Test nothing created for a syntax error. */\n+    @Test\n+    public void testCollectCommandsOrActionsNegative() {\n+\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(SYNTAX_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(0, actions.size());\n+    }\n+\n+    /** Test only correct errors processed. */\n+    @Test\n+    public void testCollectCommandsOrActionsMixed() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = Arrays.asList(SYNTAX_ERROR, COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    private void assertCorrectCodeAction(CodeAction action) {\n+        assertEquals(TITLE, action.getTitle());\n+        assertEquals(QuickFix, action.getKind());\n+        assertEquals(COPYBOOK_ERROR, action.getDiagnostics().get(0));\n+        assertNull(action.getEdit());\n+\n+        Command command = action.getCommand();\n+        assertEquals(TITLE, command.getTitle());\n+        assertEquals(MISSING_COPYBOOK.name(), command.getCommand());\n+\n+        List<Object> arguments = command.getArguments();\n+        assertEquals(2, arguments.size());\n+        assertEquals(COPYBOOK_NAME, arguments.get(0));\n+        assertEquals(DOCUMENT_URI, arguments.get(1));\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzM3NQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 116}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2MDUwMA==", "bodyText": "Why not?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434660500", "createdAt": "2020-06-03T15:35:26Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/actions/FindCopybookCommandTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.actions;\n+\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static java.util.Collections.singletonList;\n+import static org.eclipse.lsp4j.CodeActionKind.QuickFix;\n+import static org.eclipse.lsp4j.DiagnosticSeverity.Error;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+/**\n+ * Test {@link FindCopybookCommand} code action provider that resolves diagnostics for missing\n+ * copybooks.\n+ */\n+public class FindCopybookCommandTest {\n+\n+    private static final String TITLE = \"Fetch copybook\";\n+    private static final String COPYBOOK_NAME = \"CPYNAME\";\n+\n+    private static final Range RANGE = new Range(new Position(0, 0), new Position(0, 1));\n+    private static final Diagnostic SYNTAX_ERROR =\n+            new Diagnostic(RANGE, \"Syntax error\", Error, null, null);\n+    private static final Diagnostic COPYBOOK_ERROR =\n+            new Diagnostic(\n+                    RANGE, COPYBOOK_NAME + \": Copybook not found\", Error, null, MISSING_COPYBOOK.name());\n+\n+    /** Test a code action to resolve the required copybook created for the missing copybook error. */\n+    @Test\n+    public void testCollectCommandsOrActionsPositive() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    /** Test nothing created for a syntax error. */\n+    @Test\n+    public void testCollectCommandsOrActionsNegative() {\n+\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(SYNTAX_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(0, actions.size());\n+    }\n+\n+    /** Test only correct errors processed. */\n+    @Test\n+    public void testCollectCommandsOrActionsMixed() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = Arrays.asList(SYNTAX_ERROR, COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    private void assertCorrectCodeAction(CodeAction action) {\n+        assertEquals(TITLE, action.getTitle());\n+        assertEquals(QuickFix, action.getKind());\n+        assertEquals(COPYBOOK_ERROR, action.getDiagnostics().get(0));\n+        assertNull(action.getEdit());\n+\n+        Command command = action.getCommand();\n+        assertEquals(TITLE, command.getTitle());\n+        assertEquals(MISSING_COPYBOOK.name(), command.getCommand());\n+\n+        List<Object> arguments = command.getArguments();\n+        assertEquals(2, arguments.size());\n+        assertEquals(COPYBOOK_NAME, arguments.get(0));\n+        assertEquals(DOCUMENT_URI, arguments.get(1));\n+    }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzM3NQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 116}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzI0NTE1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozNjozMFrOGee6hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNTozODo0OVrOGeht-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNjk2NQ==", "bodyText": "what about to introduce a small Facade that accept the mode (DID_OPEN or DID_CHANGE) and invoke the correct implementation? The thing that analyzeDocumentFirstTime could be executed when we need to use DID_OPEN mode could not be clear for the developer", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434616965", "createdAt": "2020-06-03T14:36:30Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "diffHunk": "@@ -195,7 +198,7 @@ public void didSave(DidSaveTextDocumentParams params) {\n \n   @Override\n   public void observerCallback(@Nonnull RunAnalysisEvent event) {\n-    docs.forEach((key, value) -> analyzeChanges(key, value.getText()));\n+    docs.forEach((key, value) -> analyzeDocumentFirstTime(key, value.getText()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY2MjkwNg==", "bodyText": "In fact, we just need to create a more descriptive name for these methods. Something like analyzeCompleteDocument and analyzeIncompleteDocument", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434662906", "createdAt": "2020-06-03T15:38:49Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "diffHunk": "@@ -195,7 +198,7 @@ public void didSave(DidSaveTextDocumentParams params) {\n \n   @Override\n   public void observerCallback(@Nonnull RunAnalysisEvent event) {\n-    docs.forEach((key, value) -> analyzeChanges(key, value.getText()));\n+    docs.forEach((key, value) -> analyzeDocumentFirstTime(key, value.getText()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNjk2NQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzk0NzIwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsService.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoyMDo0MFrOGel4hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOTo0OTozNVrOGe-Pzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTE0MQ==", "bodyText": "Better naming would be ClientSettingsService or LanguageClientSettingsService", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434731141", "createdAt": "2020-06-03T17:20:40Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsService.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ *\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEwODQ4MQ==", "bodyText": "As for me, the current name is descriptive enough", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r435108481", "createdAt": "2020-06-04T09:13:12Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsService.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ *\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTE0MQ=="}, "originalCommit": {"oid": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMDMxOQ==", "bodyText": "In server we use terms client provider and, client-language,  lsp4j uses the same approach client...  And we get client-configuration.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r435130319", "createdAt": "2020-06-04T09:49:35Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsService.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ *\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTE0MQ=="}, "originalCommit": {"oid": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjcwNzk0ODg3OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsServiceImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoyMTowNlrOGel5jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoyMTowNlrOGel5jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTQwNw==", "bodyText": "respective to above interface", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434731407", "createdAt": "2020-06-03T17:21:06Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsServiceImpl.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605"}, "originalPosition": 2}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4039, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}