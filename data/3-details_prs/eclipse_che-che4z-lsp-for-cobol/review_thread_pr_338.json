{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1OTYyMjgz", "number": 338, "reviewThreads": {"totalCount": 38, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Mjo0OFrOD7TLkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNDoxMDo0NlrOEZD_sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTA2ODMzOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Mjo0OFrOGTie6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Mjo0OFrOGTie6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0MTA5OA==", "bodyText": "To be refactored in #342", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423141098", "createdAt": "2020-05-11T15:52:48Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4482b739663663c61d6f040812ed278d8b08ba4f"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTA4MzU2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1NjoyMlrOGTioqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1NjoyMlrOGTioqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0MzU5NQ==", "bodyText": "The logic of calling this method is going to be changed in #340", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423143595", "createdAt": "2020-05-11T15:56:22Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4482b739663663c61d6f040812ed278d8b08ba4f"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzNTA4NTExOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Njo0NlrOGTiptg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Njo0NlrOGTiptg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0Mzg2Mg==", "bodyText": "To be used in #339", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423143862", "createdAt": "2020-05-11T15:56:46Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitStatement(StatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfThen(IfThenContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfElse(IfElseContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitPerformInlineStatement(PerformInlineStatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitSentence(SentenceContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIdentifier(IdentifierContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitEvaluateWhenOther(EvaluateWhenOtherContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n-  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n-    if (ctx.dataName() != null) {\n-      String variable = ctx.dataName().getText().toUpperCase();\n-      checkForVariable(\n-          variable,\n-          ctx.getStart().getLine(),\n-          ctx.dataName().getStart().getCharPositionInLine(),\n-          ctx);\n-    }\n+  public Class visitParagraphName(ParagraphNameContext ctx) {\n+    paragraphs.define(ctx.getText().toUpperCase(), ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  public Class visitDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (checkForVariable(\n-        ctx.getText(), ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine(), null)) {\n-      checkParentContainsChildren(ctx.getText(), child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitDataDescriptionEntryFormat1(DataDescriptionEntryFormat1Context ctx) {\n+\n+    String levelNumber = ctx.otherLevel().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInData(\n-      String child, int childStartLine, int childPositionInLine, InDataContext ctx) {\n-    checkForDataName2(ctx.dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat2(DataDescriptionEntryFormat2Context ctx) {\n+\n+    String levelNumber = ctx.LEVEL_NUMBER_66().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInTable(\n-      String child, int childStartLine, int childPositionInLine, InTableContext ctx) {\n-    checkForDataName2(ctx.tableCall().dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat3(DataDescriptionEntryFormat3Context ctx) {\n+    String levelNumber = ctx.LEVEL_NUMBER_88().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n+  private void defineVariable(String level, String name, Token token) {\n+    variables.define(new Variable(level, name), token);\n+  }\n+\n   @Override\n   public Class visitParagraphNameUsage(ParagraphNameUsageContext ctx) {\n-    addUsage(semanticContext.getParagraphs(), ctx);\n+    String name = ctx.getText().toUpperCase();\n+    addUsage(paragraphs, name, ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  private void checkForDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (ctx != null) {\n-      visitDataName2(ctx, child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n+    ofNullable(ctx.dataName())\n+        .map(it -> it.getText().toUpperCase())\n+        .ifPresent(variable -> checkForVariable(variable, ctx));\n+    return visitChildren(ctx);\n   }\n \n-  private void throwWarning(String wrongToken, int startLine, int charPositionInLine) {\n-    MisspelledKeywordDistance.calculateDistance(wrongToken.toUpperCase())\n-        .ifPresent(\n-            correctWord ->\n-                getSemanticError(wrongToken, startLine, charPositionInLine, correctWord));\n-  }\n+  @Override\n+  public Class visitTerminal(TerminalNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n \n-  private void throwSuggestion(String wrongToken, int startLine, int charPositionInLine) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"Invalid definition for: \" + wrongToken)\n-            .severity(INFO_LEVEL)\n-            .build());\n+    return super.visitTerminal(node);\n   }\n \n-  private void getSemanticError(\n-      String wrongToken, int startLine, int charPositionInLine, String correctWord) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"A misspelled word, maybe you want to put \" + correctWord)\n-            .severity(WARNING_LEVEL)\n-            .build());\n+  @Override\n+  public Class visitErrorNode(ErrorNode node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4482b739663663c61d6f040812ed278d8b08ba4f"}, "originalPosition": 324}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY0MTk4OTQ4OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODoxOToxM1rOGUmmtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODoxOToxM1rOGUmmtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzIwNQ==", "bodyText": "This may throw similar semantic errors for different reasons. To be fixed in #321", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r424257205", "createdAt": "2020-05-13T08:19:13Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitStatement(StatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfThen(IfThenContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfElse(IfElseContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitPerformInlineStatement(PerformInlineStatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitSentence(SentenceContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIdentifier(IdentifierContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitEvaluateWhenOther(EvaluateWhenOtherContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n-  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n-    if (ctx.dataName() != null) {\n-      String variable = ctx.dataName().getText().toUpperCase();\n-      checkForVariable(\n-          variable,\n-          ctx.getStart().getLine(),\n-          ctx.dataName().getStart().getCharPositionInLine(),\n-          ctx);\n-    }\n+  public Class visitParagraphName(ParagraphNameContext ctx) {\n+    paragraphs.define(ctx.getText().toUpperCase(), ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  public Class visitDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (checkForVariable(\n-        ctx.getText(), ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine(), null)) {\n-      checkParentContainsChildren(ctx.getText(), child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitDataDescriptionEntryFormat1(DataDescriptionEntryFormat1Context ctx) {\n+\n+    String levelNumber = ctx.otherLevel().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInData(\n-      String child, int childStartLine, int childPositionInLine, InDataContext ctx) {\n-    checkForDataName2(ctx.dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat2(DataDescriptionEntryFormat2Context ctx) {\n+\n+    String levelNumber = ctx.LEVEL_NUMBER_66().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInTable(\n-      String child, int childStartLine, int childPositionInLine, InTableContext ctx) {\n-    checkForDataName2(ctx.tableCall().dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat3(DataDescriptionEntryFormat3Context ctx) {\n+    String levelNumber = ctx.LEVEL_NUMBER_88().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n+  private void defineVariable(String level, String name, Token token) {\n+    variables.define(new Variable(level, name), token);\n+  }\n+\n   @Override\n   public Class visitParagraphNameUsage(ParagraphNameUsageContext ctx) {\n-    addUsage(semanticContext.getParagraphs(), ctx);\n+    String name = ctx.getText().toUpperCase();\n+    addUsage(paragraphs, name, ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  private void checkForDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (ctx != null) {\n-      visitDataName2(ctx, child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n+    ofNullable(ctx.dataName())\n+        .map(it -> it.getText().toUpperCase())\n+        .ifPresent(variable -> checkForVariable(variable, ctx));\n+    return visitChildren(ctx);\n   }\n \n-  private void throwWarning(String wrongToken, int startLine, int charPositionInLine) {\n-    MisspelledKeywordDistance.calculateDistance(wrongToken.toUpperCase())\n-        .ifPresent(\n-            correctWord ->\n-                getSemanticError(wrongToken, startLine, charPositionInLine, correctWord));\n-  }\n+  @Override\n+  public Class visitTerminal(TerminalNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n \n-  private void throwSuggestion(String wrongToken, int startLine, int charPositionInLine) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"Invalid definition for: \" + wrongToken)\n-            .severity(INFO_LEVEL)\n-            .build());\n+    return super.visitTerminal(node);\n   }\n \n-  private void getSemanticError(\n-      String wrongToken, int startLine, int charPositionInLine, String correctWord) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"A misspelled word, maybe you want to put \" + correctWord)\n-            .severity(WARNING_LEVEL)\n-            .build());\n+  @Override\n+  public Class visitErrorNode(ErrorNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n+\n+    return super.visitTerminal(node);\n   }\n \n-  private boolean checkForVariable(\n-      String variable, int startLine, int charPositionInLine, ParserRuleContext ctx) {\n-    if (!semanticContext.getVariables().contains(variable)) {\n-      throwSuggestion(variable, startLine, charPositionInLine);\n-      return false;\n-    } else if (ctx instanceof QualifiedDataNameFormat1Context\n-        && ((QualifiedDataNameFormat1Context) ctx).qualifiedInData() != null) {\n-      iterateOverQualifiedDataNames(\n-          (QualifiedDataNameFormat1Context) ctx, variable, startLine, charPositionInLine);\n-      addUsage(semanticContext.getVariables(), variable, ctx);\n+  private void checkForVariable(String variable, QualifiedDataNameFormat1Context ctx) {\n+    checkVariableDefinition(variable, ctx.getStart());\n+    addUsage(variables, variable, ctx.getStart());\n+\n+    if (ctx.qualifiedInData() != null) {\n+      iterateOverQualifiedDataNames(ctx, variable);\n     }\n-    return true;\n   }\n \n-  private void iterateOverQualifiedDataNames(\n-      QualifiedDataNameFormat1Context ctx, String variable, int startLine, int charPositionInLine) {\n+  private void iterateOverQualifiedDataNames(QualifiedDataNameFormat1Context ctx, String variable) {\n+    String child = variable;\n+    Token childToken = ctx.getStart();\n     for (QualifiedInDataContext node : ctx.qualifiedInData()) {\n-      if (node.inData() != null) {\n-        visitInData(variable, startLine, charPositionInLine, node.inData());\n-        DataName2Context context = node.inData().dataName2();\n-        variable = context.getText();\n-        addUsage(semanticContext.getVariables(), context);\n-      } else {\n-        visitInTable(variable, startLine, charPositionInLine, node.inTable());\n-        DataName2Context context = node.inTable().tableCall().dataName2();\n-        variable = context.getText();\n-        addUsage(semanticContext.getVariables(), context);\n-      }\n+\n+      DataName2Context context = getDataName2Context(node);\n+      String parent = context.getText().toUpperCase();\n+      Token parentToken = context.getStart();\n+\n+      checkVariableDefinition(parent, parentToken);\n+      checkVariableStructure(parent, child, childToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ff55efcc7856b814f7172cb17a3080fbbe8baf1"}, "originalPosition": 375}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjczNzgwMTI5OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/strategy/CobolErrorStrategy.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNToxOTo0OVrOGjH9XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNToxOTo0OVrOGjH9XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4Mzc0MQ==", "bodyText": "Don't ask, I know it is disgusting. To be rewritten later.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r439483741", "createdAt": "2020-06-12T15:19:49Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/strategy/CobolErrorStrategy.java", "diffHunk": "@@ -84,12 +77,32 @@ public void reportError(Parser recognizer, RecognitionException e) {\n     }\n   }\n \n+  @Override\n+  public void sync(Parser recognizer) {\n+    Token currentToken = recognizer.getCurrentToken();\n+    String terminal = currentToken.getText();\n+    // If the processing stopped at the copybook enter tag and cannot be recovered in place, it\n+    // means that there are, in fact, two affected tokens\n+    if (terminal.startsWith(\"*>CPYENTER\")) {\n+      int nextTokenType = recognizer.getInputStream().LA(3);\n+      IntervalSet expecting = getExpectedTokens(recognizer);\n+      if (expecting.contains(nextTokenType)) {\n+        // Move processing forward two times\n+        recognizer.consume();\n+        recognizer.consume();\n+      }\n+    }\n+    super.sync(recognizer);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTQ0MjgwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODo0NDoyMFrOGjoubA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMjowNTowNFrOGjvQGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA==", "bodyText": "Adjective is used for Interface naming  -  ResolvableCopybook", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440020588", "createdAt": "2020-06-15T08:44:20Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4NjQ0Ng==", "bodyText": "I disagree - this object is not a copybook itself, is just a helper for them", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440086446", "createdAt": "2020-06-15T10:40:34Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyMTg2OQ==", "bodyText": "@temanbrcom It is Java naming rule, existing even from Sun time.  CopybookResolution is  noun.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440121869", "createdAt": "2020-06-15T11:53:45Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyNzUxMg==", "bodyText": "Interface naming convention\nIn Java, interfaces names, generally, should be adjectives. Interfaces should be in titlecase with the first letter of each separate word capitalized. In same cases, interfaces can be nouns as well when they present a family of classes e.g. List and Map.\nsource\n\nHere, I recognize this interface as a representation of a family of classes", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440127512", "createdAt": "2020-06-15T12:05:04Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTU1MzEwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOToxMzowNlrOGjpxdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDo0OTozNFrOGjtArw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNzc0OQ==", "bodyText": "replaceable with reduce(0, Integer::sum)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440037749", "createdAt": "2020-06-15T09:13:06Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -14,130 +14,297 @@\n package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n \n import com.broadcom.lsp.domain.common.model.Position;\n-import com.ca.lsp.core.cobol.model.CopybookUsage;\n-import com.ca.lsp.core.cobol.model.SyntaxError;\n-import com.ca.lsp.core.cobol.model.Variable;\n+import com.ca.lsp.core.cobol.model.*;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n import com.ca.lsp.core.cobol.preprocessor.sub.document.CobolSemanticParserListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorStringUtils;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorCleanerServiceImpl;\n-import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n import org.antlr.v4.runtime.BufferedTokenStream;\n import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n import org.antlr.v4.runtime.tree.TerminalNode;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Consumer;\n+import java.util.*;\n \n-import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.COMMENT_TAG;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.convertTokensToPositions;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.retrieveTokens;\n+import static java.lang.String.format;\n import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n \n /**\n- * ANTLR visitor, which preprocesses a given COBOL program by executing COPY and REPLACE statements.\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n  */\n @Slf4j\n public class CobolSemanticParserListenerImpl extends CobolPreprocessorBaseListener\n     implements CobolSemanticParserListener {\n   private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n   private static final String COPYBOOK_OVER_8_CHARACTERS =\n       \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n \n   @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n \n-  private final PreprocessorCleanerServiceImpl preprocessorCleanerService;\n-  private final String documentUri;\n-  private final BufferedTokenStream tokens;\n-  private final SemanticContext semanticContext;\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n \n+  private PreprocessorCleanerServiceImpl cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+\n+  @Inject\n   CobolSemanticParserListenerImpl(\n-      String documentUri, BufferedTokenStream tokens, SemanticContext semanticContext) {\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerServiceImpl cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions) {\n     this.documentUri = documentUri;\n     this.tokens = tokens;\n-    this.semanticContext = semanticContext;\n-\n-    preprocessorCleanerService = new PreprocessorCleanerServiceImpl();\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n   }\n \n   @Nonnull\n   @Override\n-  public CobolDocumentContext context() {\n-    return preprocessorCleanerService.context();\n+  public String getResult() {\n+    return cleaner.peek().read();\n   }\n \n   @Override\n-  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // push a new context for the COMPILER OPTIONS terminals\n-    preprocessorCleanerService.push();\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n   }\n \n   @Override\n-  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterParagraphName(@Nonnull ParagraphNameContext ctx) {\n-    semanticContext.getParagraphs().define(ctx.getText().toUpperCase(), retrievePosition(ctx));\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // throw away COMPILER OPTIONS terminals\n-    preprocessorCleanerService.pop();\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat1(@Nonnull DataDescriptionEntryFormat1Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat2(@Nonnull DataDescriptionEntryFormat2Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat3(@Nonnull DataDescriptionEntryFormat3Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n   }\n \n   @Override\n   public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+\n+    // throw away COPY terminals\n+    cleaner.pop();\n+\n+    // a new context for the copy book content\n+    cleaner.peek().write(CPY_ENTER_TAG);\n     /*\n-     * define the copy book\n+     * copy the copy book\n      */\n-    CopySourceContext copySource = ctx.copySource();\n-    String copybookName = retrieveCopybookName(copySource);\n-    Position position = retrievePosition(copySource);\n-    defineCopybook(copybookName, position);\n+    String copybookName = retrieveCopybookName(ctx.copySource());\n+    Position position = retrievePosition(ctx.copySource());\n+\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String copybookContent = model.getContent();\n+\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, model.getUri());\n+\n+    List<ReplacingPhraseContext> replacingPhraseContexts = ctx.replacingPhrase();\n+    if (!replacingPhraseContexts.isEmpty()) {\n+      applyReplacing(copybookName, model.getUri(), copybookContent, replacingPhraseContexts);\n+    } else {\n+      writeCopybookContent(\"<URI>\" + model.getUri() + \"</URI>\", copybookContent);\n+    }\n+\n+    String content = cleaner.peek().read();\n+    cleaner.pop();\n+\n+    cleaner.peek().write(content);\n+  }\n+\n+  private void applyReplacing(\n+      String copybookName,\n+      String uri,\n+      String copybookContent,\n+      List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    String copybookWithReplacingName =\n+        getUniqueNameForReplacing(copybookName, replacingPhraseContexts);\n+\n+    cleaner.peek().write(\"<URI>\" + copybookWithReplacingName + \"</URI>. \");\n+    CobolDocumentContext documentContext = cleaner.push();\n+    replacingPhraseContexts.forEach(\n+        it -> documentContext.storeReplaceablesAndReplacements(it.replaceClause()));\n+\n+    documentContext.write(copybookContent);\n+    documentContext.replaceReplaceablesByReplacements(tokens);\n+\n+    documentMappings.put(\n+        copybookWithReplacingName,\n+        convertTokensToPositions(uri, retrieveTokens(documentContext.read())));\n+    documentContext.write(CPY_EXIT_TAG);\n+  }\n+\n+  private String getUniqueNameForReplacing(\n+      String copybookName, List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    return copybookName\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce((r1, r2) -> r1 + r2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA4NTMyOA==", "bodyText": "Why? r1 and r2 are strings", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440085328", "createdAt": "2020-06-15T10:38:16Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -14,130 +14,297 @@\n package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n \n import com.broadcom.lsp.domain.common.model.Position;\n-import com.ca.lsp.core.cobol.model.CopybookUsage;\n-import com.ca.lsp.core.cobol.model.SyntaxError;\n-import com.ca.lsp.core.cobol.model.Variable;\n+import com.ca.lsp.core.cobol.model.*;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n import com.ca.lsp.core.cobol.preprocessor.sub.document.CobolSemanticParserListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorStringUtils;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorCleanerServiceImpl;\n-import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n import org.antlr.v4.runtime.BufferedTokenStream;\n import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n import org.antlr.v4.runtime.tree.TerminalNode;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Consumer;\n+import java.util.*;\n \n-import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.COMMENT_TAG;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.convertTokensToPositions;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.retrieveTokens;\n+import static java.lang.String.format;\n import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n \n /**\n- * ANTLR visitor, which preprocesses a given COBOL program by executing COPY and REPLACE statements.\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n  */\n @Slf4j\n public class CobolSemanticParserListenerImpl extends CobolPreprocessorBaseListener\n     implements CobolSemanticParserListener {\n   private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n   private static final String COPYBOOK_OVER_8_CHARACTERS =\n       \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n \n   @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n \n-  private final PreprocessorCleanerServiceImpl preprocessorCleanerService;\n-  private final String documentUri;\n-  private final BufferedTokenStream tokens;\n-  private final SemanticContext semanticContext;\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n \n+  private PreprocessorCleanerServiceImpl cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+\n+  @Inject\n   CobolSemanticParserListenerImpl(\n-      String documentUri, BufferedTokenStream tokens, SemanticContext semanticContext) {\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerServiceImpl cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions) {\n     this.documentUri = documentUri;\n     this.tokens = tokens;\n-    this.semanticContext = semanticContext;\n-\n-    preprocessorCleanerService = new PreprocessorCleanerServiceImpl();\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n   }\n \n   @Nonnull\n   @Override\n-  public CobolDocumentContext context() {\n-    return preprocessorCleanerService.context();\n+  public String getResult() {\n+    return cleaner.peek().read();\n   }\n \n   @Override\n-  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // push a new context for the COMPILER OPTIONS terminals\n-    preprocessorCleanerService.push();\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n   }\n \n   @Override\n-  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterParagraphName(@Nonnull ParagraphNameContext ctx) {\n-    semanticContext.getParagraphs().define(ctx.getText().toUpperCase(), retrievePosition(ctx));\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // throw away COMPILER OPTIONS terminals\n-    preprocessorCleanerService.pop();\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat1(@Nonnull DataDescriptionEntryFormat1Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat2(@Nonnull DataDescriptionEntryFormat2Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat3(@Nonnull DataDescriptionEntryFormat3Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n   }\n \n   @Override\n   public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+\n+    // throw away COPY terminals\n+    cleaner.pop();\n+\n+    // a new context for the copy book content\n+    cleaner.peek().write(CPY_ENTER_TAG);\n     /*\n-     * define the copy book\n+     * copy the copy book\n      */\n-    CopySourceContext copySource = ctx.copySource();\n-    String copybookName = retrieveCopybookName(copySource);\n-    Position position = retrievePosition(copySource);\n-    defineCopybook(copybookName, position);\n+    String copybookName = retrieveCopybookName(ctx.copySource());\n+    Position position = retrievePosition(ctx.copySource());\n+\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String copybookContent = model.getContent();\n+\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, model.getUri());\n+\n+    List<ReplacingPhraseContext> replacingPhraseContexts = ctx.replacingPhrase();\n+    if (!replacingPhraseContexts.isEmpty()) {\n+      applyReplacing(copybookName, model.getUri(), copybookContent, replacingPhraseContexts);\n+    } else {\n+      writeCopybookContent(\"<URI>\" + model.getUri() + \"</URI>\", copybookContent);\n+    }\n+\n+    String content = cleaner.peek().read();\n+    cleaner.pop();\n+\n+    cleaner.peek().write(content);\n+  }\n+\n+  private void applyReplacing(\n+      String copybookName,\n+      String uri,\n+      String copybookContent,\n+      List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    String copybookWithReplacingName =\n+        getUniqueNameForReplacing(copybookName, replacingPhraseContexts);\n+\n+    cleaner.peek().write(\"<URI>\" + copybookWithReplacingName + \"</URI>. \");\n+    CobolDocumentContext documentContext = cleaner.push();\n+    replacingPhraseContexts.forEach(\n+        it -> documentContext.storeReplaceablesAndReplacements(it.replaceClause()));\n+\n+    documentContext.write(copybookContent);\n+    documentContext.replaceReplaceablesByReplacements(tokens);\n+\n+    documentMappings.put(\n+        copybookWithReplacingName,\n+        convertTokensToPositions(uri, retrieveTokens(documentContext.read())));\n+    documentContext.write(CPY_EXIT_TAG);\n+  }\n+\n+  private String getUniqueNameForReplacing(\n+      String copybookName, List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    return copybookName\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce((r1, r2) -> r1 + r2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNzc0OQ=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 269}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA5MDc5OQ==", "bodyText": "Sorry, I mean:  reduce(\"\", String::concat)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440090799", "createdAt": "2020-06-15T10:49:34Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -14,130 +14,297 @@\n package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n \n import com.broadcom.lsp.domain.common.model.Position;\n-import com.ca.lsp.core.cobol.model.CopybookUsage;\n-import com.ca.lsp.core.cobol.model.SyntaxError;\n-import com.ca.lsp.core.cobol.model.Variable;\n+import com.ca.lsp.core.cobol.model.*;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n import com.ca.lsp.core.cobol.preprocessor.sub.document.CobolSemanticParserListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorStringUtils;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorCleanerServiceImpl;\n-import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n import org.antlr.v4.runtime.BufferedTokenStream;\n import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n import org.antlr.v4.runtime.tree.TerminalNode;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Consumer;\n+import java.util.*;\n \n-import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.COMMENT_TAG;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.convertTokensToPositions;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.retrieveTokens;\n+import static java.lang.String.format;\n import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n \n /**\n- * ANTLR visitor, which preprocesses a given COBOL program by executing COPY and REPLACE statements.\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n  */\n @Slf4j\n public class CobolSemanticParserListenerImpl extends CobolPreprocessorBaseListener\n     implements CobolSemanticParserListener {\n   private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n   private static final String COPYBOOK_OVER_8_CHARACTERS =\n       \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n \n   @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n \n-  private final PreprocessorCleanerServiceImpl preprocessorCleanerService;\n-  private final String documentUri;\n-  private final BufferedTokenStream tokens;\n-  private final SemanticContext semanticContext;\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n \n+  private PreprocessorCleanerServiceImpl cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+\n+  @Inject\n   CobolSemanticParserListenerImpl(\n-      String documentUri, BufferedTokenStream tokens, SemanticContext semanticContext) {\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerServiceImpl cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions) {\n     this.documentUri = documentUri;\n     this.tokens = tokens;\n-    this.semanticContext = semanticContext;\n-\n-    preprocessorCleanerService = new PreprocessorCleanerServiceImpl();\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n   }\n \n   @Nonnull\n   @Override\n-  public CobolDocumentContext context() {\n-    return preprocessorCleanerService.context();\n+  public String getResult() {\n+    return cleaner.peek().read();\n   }\n \n   @Override\n-  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // push a new context for the COMPILER OPTIONS terminals\n-    preprocessorCleanerService.push();\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n   }\n \n   @Override\n-  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterParagraphName(@Nonnull ParagraphNameContext ctx) {\n-    semanticContext.getParagraphs().define(ctx.getText().toUpperCase(), retrievePosition(ctx));\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // throw away COMPILER OPTIONS terminals\n-    preprocessorCleanerService.pop();\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat1(@Nonnull DataDescriptionEntryFormat1Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat2(@Nonnull DataDescriptionEntryFormat2Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat3(@Nonnull DataDescriptionEntryFormat3Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n   }\n \n   @Override\n   public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+\n+    // throw away COPY terminals\n+    cleaner.pop();\n+\n+    // a new context for the copy book content\n+    cleaner.peek().write(CPY_ENTER_TAG);\n     /*\n-     * define the copy book\n+     * copy the copy book\n      */\n-    CopySourceContext copySource = ctx.copySource();\n-    String copybookName = retrieveCopybookName(copySource);\n-    Position position = retrievePosition(copySource);\n-    defineCopybook(copybookName, position);\n+    String copybookName = retrieveCopybookName(ctx.copySource());\n+    Position position = retrievePosition(ctx.copySource());\n+\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String copybookContent = model.getContent();\n+\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, model.getUri());\n+\n+    List<ReplacingPhraseContext> replacingPhraseContexts = ctx.replacingPhrase();\n+    if (!replacingPhraseContexts.isEmpty()) {\n+      applyReplacing(copybookName, model.getUri(), copybookContent, replacingPhraseContexts);\n+    } else {\n+      writeCopybookContent(\"<URI>\" + model.getUri() + \"</URI>\", copybookContent);\n+    }\n+\n+    String content = cleaner.peek().read();\n+    cleaner.pop();\n+\n+    cleaner.peek().write(content);\n+  }\n+\n+  private void applyReplacing(\n+      String copybookName,\n+      String uri,\n+      String copybookContent,\n+      List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    String copybookWithReplacingName =\n+        getUniqueNameForReplacing(copybookName, replacingPhraseContexts);\n+\n+    cleaner.peek().write(\"<URI>\" + copybookWithReplacingName + \"</URI>. \");\n+    CobolDocumentContext documentContext = cleaner.push();\n+    replacingPhraseContexts.forEach(\n+        it -> documentContext.storeReplaceablesAndReplacements(it.replaceClause()));\n+\n+    documentContext.write(copybookContent);\n+    documentContext.replaceReplaceablesByReplacements(tokens);\n+\n+    documentMappings.put(\n+        copybookWithReplacingName,\n+        convertTokensToPositions(uri, retrieveTokens(documentContext.read())));\n+    documentContext.write(CPY_EXIT_TAG);\n+  }\n+\n+  private String getUniqueNameForReplacing(\n+      String copybookName, List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    return copybookName\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce((r1, r2) -> r1 + r2)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNzc0OQ=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 269}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTc1Mjg2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDowODoxM1rOGjrugQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDowODoxM1rOGjrugQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2OTc2MQ==", "bodyText": "both by default null", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440069761", "createdAt": "2020-06-15T10:08:13Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTc4NDI1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/CobolVariableContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDoxNzo1MlrOGjsCiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMjowMDowMlrOGjvGow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3NDg4OQ==", "bodyText": "This if block can be removed, if rootVariable != null used, we have false return at the end.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440074889", "createdAt": "2020-06-15T10:17:52Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/CobolVariableContext.java", "diffHunk": "@@ -94,6 +92,10 @@ public Variable get(String name) {\n   public boolean parentContainsSpecificChild(String rootVariableName, String targetVariableName) {\n     Variable rootVariable = get(rootVariableName);\n \n+    if (rootVariable == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyNTA5MQ==", "bodyText": "Ok, it seems reasonable to refactor this method", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440125091", "createdAt": "2020-06-15T12:00:02Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/CobolVariableContext.java", "diffHunk": "@@ -94,6 +92,10 @@ public Variable get(String name) {\n   public boolean parentContainsSpecificChild(String rootVariableName, String targetVariableName) {\n     Variable rootVariable = get(rootVariableName);\n \n+    if (rootVariable == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3NDg4OQ=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 89}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTgwNDgyOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/NamedSubContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDoyNDozOFrOGjsQEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0NjozNFrOGrFbRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3ODM1Mw==", "bodyText": "Should be documented, not merging into one, but onto two different collections", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440078353", "createdAt": "2020-06-15T10:24:38Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/NamedSubContext.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.semantics;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import lombok.Getter;\n+\n+import java.util.Collection;\n+\n+public class NamedSubContext<T> implements SubContext<String, T> {\n+\n+  @Getter private final Multimap<String, T> definitions = HashMultimap.create();\n+\n+  @Getter private final Multimap<String, T> usages = HashMultimap.create();\n+\n+  @Override\n+  public void define(String name, T token) {\n+    definitions.put(name, token);\n+  }\n+\n+  @Override\n+  public void addUsage(String name, T token) {\n+    usages.put(name, token);\n+  }\n+\n+  @Override\n+  public Collection<String> getAll() {\n+    return definitions.keySet();\n+  }\n+\n+  @Override\n+  public boolean contains(String name) {\n+    return definitions.containsKey(name);\n+  }\n+\n+  @Override\n+  public void merge(SubContext<String, T> subContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyNDYzOQ==", "bodyText": "Agree, I'll update the documentation", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440124639", "createdAt": "2020-06-15T11:59:02Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/NamedSubContext.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.semantics;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import lombok.Getter;\n+\n+import java.util.Collection;\n+\n+public class NamedSubContext<T> implements SubContext<String, T> {\n+\n+  @Getter private final Multimap<String, T> definitions = HashMultimap.create();\n+\n+  @Getter private final Multimap<String, T> usages = HashMultimap.create();\n+\n+  @Override\n+  public void define(String name, T token) {\n+    definitions.put(name, token);\n+  }\n+\n+  @Override\n+  public void addUsage(String name, T token) {\n+    usages.put(name, token);\n+  }\n+\n+  @Override\n+  public Collection<String> getAll() {\n+    return definitions.keySet();\n+  }\n+\n+  @Override\n+  public boolean contains(String name) {\n+    return definitions.containsKey(name);\n+  }\n+\n+  @Override\n+  public void merge(SubContext<String, T> subContext) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3ODM1Mw=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDg1NA==", "bodyText": "Or just rename the method", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447830854", "createdAt": "2020-06-30T16:46:34Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/NamedSubContext.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.semantics;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import lombok.Getter;\n+\n+import java.util.Collection;\n+\n+public class NamedSubContext<T> implements SubContext<String, T> {\n+\n+  @Getter private final Multimap<String, T> definitions = HashMultimap.create();\n+\n+  @Getter private final Multimap<String, T> usages = HashMultimap.create();\n+\n+  @Override\n+  public void define(String name, T token) {\n+    definitions.put(name, token);\n+  }\n+\n+  @Override\n+  public void addUsage(String name, T token) {\n+    usages.put(name, token);\n+  }\n+\n+  @Override\n+  public Collection<String> getAll() {\n+    return definitions.keySet();\n+  }\n+\n+  @Override\n+  public boolean contains(String name) {\n+    return definitions.containsKey(name);\n+  }\n+\n+  @Override\n+  public void merge(SubContext<String, T> subContext) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3ODM1Mw=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTk2NTYyOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestCopybookCaching.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMToxNzoxNlrOGjt1QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMToxNzoxNlrOGjt1QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEwNDI1Ng==", "bodyText": "same, by default null", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440104256", "createdAt": "2020-06-15T11:17:16Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestCopybookCaching.java", "diffHunk": "@@ -24,64 +25,54 @@\n import com.ca.lsp.cobol.positive.CobolText;\n import com.ca.lsp.cobol.service.mocks.MockCopybookService;\n import com.ca.lsp.cobol.service.mocks.MockCopybookServiceImpl;\n-import com.ca.lsp.core.cobol.model.CopybookUsage;\n-import com.ca.lsp.core.cobol.model.PreprocessedInput;\n-import com.ca.lsp.core.cobol.model.ResultWithErrors;\n-import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n-import com.ca.lsp.core.cobol.preprocessor.sub.copybook.AnalyseCopybookTask;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.impl.CopybookResolutionProvider;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.MultiMapSerializableHelper;\n-import com.ca.lsp.core.cobol.semantics.SemanticContext;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n import com.google.inject.Guice;\n+import com.google.inject.Injector;\n import lombok.extern.slf4j.Slf4j;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n \n-import static java.util.Collections.emptyList;\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n import static java.util.Collections.singletonList;\n import static junit.framework.TestCase.assertTrue;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n \n /**\n- * This test checks the logic of caching logic performed by copybook analyzer. The cache invalidated\n- * before each test run. The runAnalysis() method starts the analyzing task synchronously, and after\n- * finish the content of the copybook should appear in cache managing by databus. After accessing\n- * the cache element its hit counter should increase to maintain the element persistence. Also, all\n- * the objects in cache expected to be serializable.\n+ * This test checks the caching logic performed by copybook resolution. The cache invalidated before\n+ * each test run. The runAnalysis() method starts the resolving task synchronously, and after finish\n+ * the content of the copybook should appear in cache managing by data bus. After accessing the\n+ * cache element its hit counter should increase to maintain the element persistence. Also, all the\n+ * objects in cache expected to be serializable.\n  */\n @Slf4j\n-public class AnalyzeCopybookCaching {\n+public class TestCopybookCaching {\n   private final String COPYBOOK_NAME = \"copy\";\n   private final String COPYBOOK_CONTENT = \"000230 77  REPORT-STATUS           PIC 99 VALUE ZERO.\";\n \n-  private final Position POSITION_FIRST_OCCURRENCE = new Position(null, 0, 0, 0, 0);\n-  private final Position POSITION_SECOND_OCCURRENCE = new Position(null, 10, 10, 10, 10);\n+  private final Position POSITION_FIRST_OCCURRENCE = new Position(null, 0, 0, 0, 0, null);\n+  private final Position POSITION_SECOND_OCCURRENCE = new Position(null, 10, 10, 10, 10, null);\n   private final Multimap<String, Position> paragraphDefinitions = HashMultimap.create();\n \n-  private final DataBusBroker databus =\n-      Guice.createInjector(new DatabusModule()).getInstance(DataBusBroker.class);\n-\n-  private CobolPreprocessor preprocessor = mock(CobolPreprocessor.class);\n+  private DataBusBroker databus = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 65}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MjA2MDA0OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "isResolved": true, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMTo0OTo1MlrOGjuxYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODo0Nzo1NFrOGyhQHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA==", "bodyText": "In many tests, there are similar/same testing steps with different value.\nIt would be perfect to extract it to a single method.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440119648", "createdAt": "2020-06-15T11:49:52Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * This test checks that document with multi-definitions parsed correctly and all the usages of\n+ * variables placed in one line found.\n+ */\n+public class TestVariableUsedSeveralTimesInOneStatement {\n+  private static final String TEXT =\n+      \"       Identification Division. \\n\"\n+          + \"       Program-id.    ProgramId.\\n\"\n+          + \"       Data Division.\\n\"\n+          + \"       Working-Storage Section.\\n\"\n+          + \"       01   PARENT1. \\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       01   PARENT2.\\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       Procedure Division.\\n\"\n+          + \"       000-Main-Logic.\\n\"\n+          + \"           MOVE CHILD IN PARENT1 TO CHILD IN PARENT2.\\n\"\n+          + \"       End program ProgramId.\";\n+\n+  private static final String CHILD = \"CHILD\";\n+  private static final String PARENT1 = \"PARENT1\";\n+  private static final String PARENT2 = \"PARENT2\";\n+  private static final String MAIN_LOGIC = \"000-MAIN-LOGIC\";\n+\n+  @Test\n+  public void test() {\n+    AnalysisResult result = analyze(TEXT);\n+    assertDiagnostics(result.getDiagnostics());\n+\n+    assertCopybookUsages(result.getCopybookUsages());\n+    assertCopybookDefinitions(result.getCopybookDefinitions());\n+\n+    assertVariableUsages(result.getVariableUsages());\n+    assertVariableDefinitions(result.getVariableDefinitions());\n+\n+    assertParagraphDefinitions(result.getParagraphDefinitions());\n+    assertParagraphUsages(result.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n+    long numberOfDiagnostics = diagnostics.values().stream().mapToLong(List::size).sum();\n+    assertEquals(\"Diagnostics: \" + diagnostics.toString(), 0, numberOfDiagnostics);\n+  }\n+\n+  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n+    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n+  }\n+\n+  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n+    assertNumberOfLocations(definitions, MAIN_LOGIC, 1);\n+    assertLocation(definitions, MAIN_LOGIC, DOCUMENT_URI, 9, 7);\n+  }\n+\n+  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n+    assertEquals(\n+        \"Copybook definitions: \" + copybookDefinitions.toString(), 0, copybookDefinitions.size());\n+  }\n+\n+  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n+    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 0, copybookUsages.size());\n+  }\n+\n+  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Variable definitions: \" + definitions.toString(), 3, definitions.size());\n+\n+    assertNumberOfLocations(definitions, PARENT1, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyNDA4NA==", "bodyText": "I agree, but I didn't find a way how to do it handily", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440124084", "createdAt": "2020-06-15T11:57:55Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * This test checks that document with multi-definitions parsed correctly and all the usages of\n+ * variables placed in one line found.\n+ */\n+public class TestVariableUsedSeveralTimesInOneStatement {\n+  private static final String TEXT =\n+      \"       Identification Division. \\n\"\n+          + \"       Program-id.    ProgramId.\\n\"\n+          + \"       Data Division.\\n\"\n+          + \"       Working-Storage Section.\\n\"\n+          + \"       01   PARENT1. \\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       01   PARENT2.\\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       Procedure Division.\\n\"\n+          + \"       000-Main-Logic.\\n\"\n+          + \"           MOVE CHILD IN PARENT1 TO CHILD IN PARENT2.\\n\"\n+          + \"       End program ProgramId.\";\n+\n+  private static final String CHILD = \"CHILD\";\n+  private static final String PARENT1 = \"PARENT1\";\n+  private static final String PARENT2 = \"PARENT2\";\n+  private static final String MAIN_LOGIC = \"000-MAIN-LOGIC\";\n+\n+  @Test\n+  public void test() {\n+    AnalysisResult result = analyze(TEXT);\n+    assertDiagnostics(result.getDiagnostics());\n+\n+    assertCopybookUsages(result.getCopybookUsages());\n+    assertCopybookDefinitions(result.getCopybookDefinitions());\n+\n+    assertVariableUsages(result.getVariableUsages());\n+    assertVariableDefinitions(result.getVariableDefinitions());\n+\n+    assertParagraphDefinitions(result.getParagraphDefinitions());\n+    assertParagraphUsages(result.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n+    long numberOfDiagnostics = diagnostics.values().stream().mapToLong(List::size).sum();\n+    assertEquals(\"Diagnostics: \" + diagnostics.toString(), 0, numberOfDiagnostics);\n+  }\n+\n+  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n+    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n+  }\n+\n+  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n+    assertNumberOfLocations(definitions, MAIN_LOGIC, 1);\n+    assertLocation(definitions, MAIN_LOGIC, DOCUMENT_URI, 9, 7);\n+  }\n+\n+  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n+    assertEquals(\n+        \"Copybook definitions: \" + copybookDefinitions.toString(), 0, copybookDefinitions.size());\n+  }\n+\n+  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n+    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 0, copybookUsages.size());\n+  }\n+\n+  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Variable definitions: \" + definitions.toString(), 3, definitions.size());\n+\n+    assertNumberOfLocations(definitions, PARENT1, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEyOTE4Ng==", "bodyText": "Most similar steps can be extracted into method via parameters, actually you have used such approaches already.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440129186", "createdAt": "2020-06-15T12:08:19Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * This test checks that document with multi-definitions parsed correctly and all the usages of\n+ * variables placed in one line found.\n+ */\n+public class TestVariableUsedSeveralTimesInOneStatement {\n+  private static final String TEXT =\n+      \"       Identification Division. \\n\"\n+          + \"       Program-id.    ProgramId.\\n\"\n+          + \"       Data Division.\\n\"\n+          + \"       Working-Storage Section.\\n\"\n+          + \"       01   PARENT1. \\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       01   PARENT2.\\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       Procedure Division.\\n\"\n+          + \"       000-Main-Logic.\\n\"\n+          + \"           MOVE CHILD IN PARENT1 TO CHILD IN PARENT2.\\n\"\n+          + \"       End program ProgramId.\";\n+\n+  private static final String CHILD = \"CHILD\";\n+  private static final String PARENT1 = \"PARENT1\";\n+  private static final String PARENT2 = \"PARENT2\";\n+  private static final String MAIN_LOGIC = \"000-MAIN-LOGIC\";\n+\n+  @Test\n+  public void test() {\n+    AnalysisResult result = analyze(TEXT);\n+    assertDiagnostics(result.getDiagnostics());\n+\n+    assertCopybookUsages(result.getCopybookUsages());\n+    assertCopybookDefinitions(result.getCopybookDefinitions());\n+\n+    assertVariableUsages(result.getVariableUsages());\n+    assertVariableDefinitions(result.getVariableDefinitions());\n+\n+    assertParagraphDefinitions(result.getParagraphDefinitions());\n+    assertParagraphUsages(result.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n+    long numberOfDiagnostics = diagnostics.values().stream().mapToLong(List::size).sum();\n+    assertEquals(\"Diagnostics: \" + diagnostics.toString(), 0, numberOfDiagnostics);\n+  }\n+\n+  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n+    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n+  }\n+\n+  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n+    assertNumberOfLocations(definitions, MAIN_LOGIC, 1);\n+    assertLocation(definitions, MAIN_LOGIC, DOCUMENT_URI, 9, 7);\n+  }\n+\n+  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n+    assertEquals(\n+        \"Copybook definitions: \" + copybookDefinitions.toString(), 0, copybookDefinitions.size());\n+  }\n+\n+  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n+    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 0, copybookUsages.size());\n+  }\n+\n+  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Variable definitions: \" + definitions.toString(), 3, definitions.size());\n+\n+    assertNumberOfLocations(definitions, PARENT1, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDE1NTQ5Nw==", "bodyText": "I'll suggest planning the activity regarding tests refactoring, maybe on the innovation week, because it is not the only problem here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440155497", "createdAt": "2020-06-15T12:56:27Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * This test checks that document with multi-definitions parsed correctly and all the usages of\n+ * variables placed in one line found.\n+ */\n+public class TestVariableUsedSeveralTimesInOneStatement {\n+  private static final String TEXT =\n+      \"       Identification Division. \\n\"\n+          + \"       Program-id.    ProgramId.\\n\"\n+          + \"       Data Division.\\n\"\n+          + \"       Working-Storage Section.\\n\"\n+          + \"       01   PARENT1. \\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       01   PARENT2.\\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       Procedure Division.\\n\"\n+          + \"       000-Main-Logic.\\n\"\n+          + \"           MOVE CHILD IN PARENT1 TO CHILD IN PARENT2.\\n\"\n+          + \"       End program ProgramId.\";\n+\n+  private static final String CHILD = \"CHILD\";\n+  private static final String PARENT1 = \"PARENT1\";\n+  private static final String PARENT2 = \"PARENT2\";\n+  private static final String MAIN_LOGIC = \"000-MAIN-LOGIC\";\n+\n+  @Test\n+  public void test() {\n+    AnalysisResult result = analyze(TEXT);\n+    assertDiagnostics(result.getDiagnostics());\n+\n+    assertCopybookUsages(result.getCopybookUsages());\n+    assertCopybookDefinitions(result.getCopybookDefinitions());\n+\n+    assertVariableUsages(result.getVariableUsages());\n+    assertVariableDefinitions(result.getVariableDefinitions());\n+\n+    assertParagraphDefinitions(result.getParagraphDefinitions());\n+    assertParagraphUsages(result.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n+    long numberOfDiagnostics = diagnostics.values().stream().mapToLong(List::size).sum();\n+    assertEquals(\"Diagnostics: \" + diagnostics.toString(), 0, numberOfDiagnostics);\n+  }\n+\n+  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n+    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n+  }\n+\n+  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n+    assertNumberOfLocations(definitions, MAIN_LOGIC, 1);\n+    assertLocation(definitions, MAIN_LOGIC, DOCUMENT_URI, 9, 7);\n+  }\n+\n+  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n+    assertEquals(\n+        \"Copybook definitions: \" + copybookDefinitions.toString(), 0, copybookDefinitions.size());\n+  }\n+\n+  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n+    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 0, copybookUsages.size());\n+  }\n+\n+  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Variable definitions: \" + definitions.toString(), 3, definitions.size());\n+\n+    assertNumberOfLocations(definitions, PARENT1, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNDI3NA==", "bodyText": "I am preparing some topics regarding this theme because I am focusing on testing for copybook replace in extended document.\nI skipped the static analysis of the code, but if u think that I could contribute on that as well let me know.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442724274", "createdAt": "2020-06-19T09:11:03Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * This test checks that document with multi-definitions parsed correctly and all the usages of\n+ * variables placed in one line found.\n+ */\n+public class TestVariableUsedSeveralTimesInOneStatement {\n+  private static final String TEXT =\n+      \"       Identification Division. \\n\"\n+          + \"       Program-id.    ProgramId.\\n\"\n+          + \"       Data Division.\\n\"\n+          + \"       Working-Storage Section.\\n\"\n+          + \"       01   PARENT1. \\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       01   PARENT2.\\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       Procedure Division.\\n\"\n+          + \"       000-Main-Logic.\\n\"\n+          + \"           MOVE CHILD IN PARENT1 TO CHILD IN PARENT2.\\n\"\n+          + \"       End program ProgramId.\";\n+\n+  private static final String CHILD = \"CHILD\";\n+  private static final String PARENT1 = \"PARENT1\";\n+  private static final String PARENT2 = \"PARENT2\";\n+  private static final String MAIN_LOGIC = \"000-MAIN-LOGIC\";\n+\n+  @Test\n+  public void test() {\n+    AnalysisResult result = analyze(TEXT);\n+    assertDiagnostics(result.getDiagnostics());\n+\n+    assertCopybookUsages(result.getCopybookUsages());\n+    assertCopybookDefinitions(result.getCopybookDefinitions());\n+\n+    assertVariableUsages(result.getVariableUsages());\n+    assertVariableDefinitions(result.getVariableDefinitions());\n+\n+    assertParagraphDefinitions(result.getParagraphDefinitions());\n+    assertParagraphUsages(result.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n+    long numberOfDiagnostics = diagnostics.values().stream().mapToLong(List::size).sum();\n+    assertEquals(\"Diagnostics: \" + diagnostics.toString(), 0, numberOfDiagnostics);\n+  }\n+\n+  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n+    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n+  }\n+\n+  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n+    assertNumberOfLocations(definitions, MAIN_LOGIC, 1);\n+    assertLocation(definitions, MAIN_LOGIC, DOCUMENT_URI, 9, 7);\n+  }\n+\n+  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n+    assertEquals(\n+        \"Copybook definitions: \" + copybookDefinitions.toString(), 0, copybookDefinitions.size());\n+  }\n+\n+  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n+    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 0, copybookUsages.size());\n+  }\n+\n+  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Variable definitions: \" + definitions.toString(), 3, definitions.size());\n+\n+    assertNumberOfLocations(definitions, PARENT1, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYyNjc4MQ==", "bodyText": "#427", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455626781", "createdAt": "2020-07-16T08:47:54Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * This test checks that document with multi-definitions parsed correctly and all the usages of\n+ * variables placed in one line found.\n+ */\n+public class TestVariableUsedSeveralTimesInOneStatement {\n+  private static final String TEXT =\n+      \"       Identification Division. \\n\"\n+          + \"       Program-id.    ProgramId.\\n\"\n+          + \"       Data Division.\\n\"\n+          + \"       Working-Storage Section.\\n\"\n+          + \"       01   PARENT1. \\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       01   PARENT2.\\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       Procedure Division.\\n\"\n+          + \"       000-Main-Logic.\\n\"\n+          + \"           MOVE CHILD IN PARENT1 TO CHILD IN PARENT2.\\n\"\n+          + \"       End program ProgramId.\";\n+\n+  private static final String CHILD = \"CHILD\";\n+  private static final String PARENT1 = \"PARENT1\";\n+  private static final String PARENT2 = \"PARENT2\";\n+  private static final String MAIN_LOGIC = \"000-MAIN-LOGIC\";\n+\n+  @Test\n+  public void test() {\n+    AnalysisResult result = analyze(TEXT);\n+    assertDiagnostics(result.getDiagnostics());\n+\n+    assertCopybookUsages(result.getCopybookUsages());\n+    assertCopybookDefinitions(result.getCopybookDefinitions());\n+\n+    assertVariableUsages(result.getVariableUsages());\n+    assertVariableDefinitions(result.getVariableDefinitions());\n+\n+    assertParagraphDefinitions(result.getParagraphDefinitions());\n+    assertParagraphUsages(result.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n+    long numberOfDiagnostics = diagnostics.values().stream().mapToLong(List::size).sum();\n+    assertEquals(\"Diagnostics: \" + diagnostics.toString(), 0, numberOfDiagnostics);\n+  }\n+\n+  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n+    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n+  }\n+\n+  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n+    assertNumberOfLocations(definitions, MAIN_LOGIC, 1);\n+    assertLocation(definitions, MAIN_LOGIC, DOCUMENT_URI, 9, 7);\n+  }\n+\n+  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n+    assertEquals(\n+        \"Copybook definitions: \" + copybookDefinitions.toString(), 0, copybookDefinitions.size());\n+  }\n+\n+  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n+    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 0, copybookUsages.size());\n+  }\n+\n+  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Variable definitions: \" + definitions.toString(), 3, definitions.size());\n+\n+    assertNumberOfLocations(definitions, PARENT1, 1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDQwNDM4OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwOTo1MDoyNFrOGloDCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQwODoxMzo0NFrOGmMPaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNjYzNA==", "bodyText": "Multimap goes on input and outputs Map. We could lose data here. Is it possible to have many tokens for one key in source?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442106634", "createdAt": "2020-06-18T09:50:24Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQwMjkwNw==", "bodyText": "Yes, there may be multiple variable definitions and usages. The output Map has Collection as a value type, so all the positions should be mapped, at least the tests passed well", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442402907", "createdAt": "2020-06-18T17:54:02Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNjYzNA=="}, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY5OTYyNQ==", "bodyText": "Indeed, the Map with Collection inside. You are right.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442699625", "createdAt": "2020-06-19T08:13:44Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNjYzNA=="}, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDQyODA2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwOTo1NzowOVrOGloSpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMToxODoxOFrOGm8XpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMDYyOA==", "bodyText": "You could use copy builder here like:\n    return err -> err.toBuilder()\n            .position(convertPositionRange(err.getStartToken(), err.getStopToken(), mapping))\n            .build();\n\nThe annotation for SyntaxError constructor must be changed to:\n  @Builder(builderMethodName = \"syntaxError\", toBuilder = true)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442110628", "createdAt": "2020-06-18T09:57:09Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()\n+        .collect(toMap(Map.Entry::getKey, mapPositions(mapping)));\n+  }\n+\n+  private Function<Map.Entry<String, Collection<Token>>, Collection<Position>> mapPositions(\n+      Map<Token, Position> mapping) {\n+    return it -> it.getValue().stream().map(mapping::get).collect(toSet());\n+  }\n+\n+  private List<SyntaxError> finalizeErrors(List<SyntaxError> errors, Map<Token, Position> mapping) {\n+    return errors.stream()\n+        .map(convertError(mapping))\n+        .filter(it -> it.getPosition() != null)\n+        .collect(toList());\n+  }\n+\n+  private Function<SyntaxError, SyntaxError> convertError(Map<Token, Position> mapping) {\n+    return err ->\n+        SyntaxError.syntaxError()\n+            .severity(err.getSeverity())\n+            .ruleStack(err.getRuleStack())\n+            .suggestion(err.getSuggestion())\n+            .errorCode(err.getErrorCode())\n+            .position(convertPositionRange(err.getStartToken(), err.getStopToken(), mapping))\n+            .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ4ODE2NA==", "bodyText": "Good idea, thanks!", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r443488164", "createdAt": "2020-06-22T11:18:18Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()\n+        .collect(toMap(Map.Entry::getKey, mapPositions(mapping)));\n+  }\n+\n+  private Function<Map.Entry<String, Collection<Token>>, Collection<Position>> mapPositions(\n+      Map<Token, Position> mapping) {\n+    return it -> it.getValue().stream().map(mapping::get).collect(toSet());\n+  }\n+\n+  private List<SyntaxError> finalizeErrors(List<SyntaxError> errors, Map<Token, Position> mapping) {\n+    return errors.stream()\n+        .map(convertError(mapping))\n+        .filter(it -> it.getPosition() != null)\n+        .collect(toList());\n+  }\n+\n+  private Function<SyntaxError, SyntaxError> convertError(Map<Token, Position> mapping) {\n+    return err ->\n+        SyntaxError.syntaxError()\n+            .severity(err.getSeverity())\n+            .ruleStack(err.getRuleStack())\n+            .suggestion(err.getSuggestion())\n+            .errorCode(err.getErrorCode())\n+            .position(convertPositionRange(err.getStartToken(), err.getStopToken(), mapping))\n+            .build();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMDYyOA=="}, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 124}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDQ3Nzg0OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxMTo0OFrOGloyqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoxMTo0OFrOGloyqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExODgyNw==", "bodyText": "Something seems to have interrupted you here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442118827", "createdAt": "2020-06-18T10:11:48Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {\n+\n+  /**\n+   * Retrieve and return the copybook by its name. C", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NDUyODQ1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxMDoyNjo0NVrOGlpSKQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNzo0NDoyNVrOGl5zHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNjg4OQ==", "bodyText": "You have deleted @Nonnull for ctx, but don't check the null before first use.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442126889", "createdAt": "2020-06-18T10:26:45Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -152,39 +319,48 @@ private void checkCopybookNameLength(String copybookName, Position position) {\n   }\n \n   @Override\n-  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+  public void exitReplaceArea(ReplaceAreaContext ctx) {\n     /*\n      * replacement phrase\n      */\n-    preprocessorCleanerService.pop();\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5NzQ3MA==", "bodyText": "Oops, putting it back", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442397470", "createdAt": "2020-06-18T17:44:25Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -152,39 +319,48 @@ private void checkCopybookNameLength(String copybookName, Position position) {\n   }\n \n   @Override\n-  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+  public void exitReplaceArea(ReplaceAreaContext ctx) {\n     /*\n      * replacement phrase\n      */\n-    preprocessorCleanerService.pop();\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNjg4OQ=="}, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 357}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTc4NTM3OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNTo1MjoyMFrOGl1q0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQwOTowOTozMlrOGoJqOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyOTgxMA==", "bodyText": "A bunch of methods visitSomething starts with throwWarning. It scares me.\nCould it be like throwWarningForMisspelledKeyword?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442329810", "createdAt": "2020-06-18T15:52:20Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +47,275 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM5OTkwNg==", "bodyText": "It was just a PoC for misspelled keywords check. It should be not only rewritten but refactored and finalized", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442399906", "createdAt": "2020-06-18T17:48:45Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +47,275 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyOTgxMA=="}, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDc1NDQ5MQ==", "bodyText": "Regarding activity planned for the upcoming PI, Github Issues to come.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r444754491", "createdAt": "2020-06-24T09:09:32Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +47,275 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyOTgxMA=="}, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1NTkyMjIyOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjoyNjo1N1rOGl3CSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yMlQxMTozMzo1NlrOGm8zaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MjIwMg==", "bodyText": "It could be done like this:\n.collect(groupingBy(error -> error.getPosition().getDocumentURI(), mapping(toDiagnostic(), toList())));", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442352202", "createdAt": "2020-06-18T16:26:57Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "diffHunk": "@@ -68,23 +76,69 @@ public AnalysisResult analyze(\n     return toAnalysisResult(engine.run(uri, text, textDocumentSyncType.toString()), uri);\n   }\n \n+  /**\n+   * Don't analyze the document if it is empty or contains only sequence area\n+   *\n+   * @param text - document to analyze\n+   * @return true if the document is empty from the engine point of view\n+   */\n   private static boolean isEmpty(String text) {\n     return text.length() <= FIRST_LINE_SEQ_AND_EXTRA_OP;\n   }\n \n-  private static List<Diagnostic> convertErrors(List<SyntaxError> errors, String uri) {\n+  private AnalysisResult toAnalysisResult(ResultWithErrors<SemanticContext> result, String uri) {\n+    SemanticContext context = result.getResult();\n+    return new AnalysisResult(\n+        collectDiagnosticsForAffectedDocuments(\n+            convertErrors(result.getErrors()), context.getCopybookDefinitions(), uri),\n+        convertPositions(context.getVariableDefinitions()),\n+        convertPositions(context.getVariableUsages()),\n+        convertPositions(context.getParagraphDefinitions()),\n+        convertPositions(context.getParagraphUsages()),\n+        convertPositions(context.getCopybookDefinitions()),\n+        convertPositions(context.getCopybookUsages()));\n+  }\n+\n+  /**\n+   * Collect diagnostics for each document, used in the analysis - the main COBOL file and all the\n+   * copybooks. If there were no errors for some URI, then provide an empty list to clean-up the\n+   * errors after the previous analysis.\n+   *\n+   * @param diagnostics - list of found syntax and semantic errors\n+   * @param copybookDefinitions - list of copybook definitions used in this analysis\n+   * @param uri - current document URI\n+   * @return map with file URI as a key, and lists of diagnostics as values\n+   */\n+  private Map<String, List<Diagnostic>> collectDiagnosticsForAffectedDocuments(\n+      Map<String, List<Diagnostic>> diagnostics,\n+      Map<String, Collection<Position>> copybookDefinitions,\n+      String uri) {\n+    Map<String, List<Diagnostic>> result = new HashMap<>(diagnostics);\n+    copybookDefinitions.values().stream()\n+        .flatMap(Collection::stream)\n+        .map(Position::getDocumentURI)\n+        .forEach(it -> result.putIfAbsent(it, emptyList()));\n+    result.putIfAbsent(uri, emptyList());\n+    return result;\n+  }\n+\n+  private static Map<String, List<Diagnostic>> convertErrors(List<SyntaxError> errors) {\n     return errors.stream()\n-        .filter(errorOnlyFromCurrentDocument(uri))\n-        .map(toDiagnostic())\n-        .collect(toList());\n+        .map(SyntaxError::getPosition)\n+        .map(Position::getDocumentURI)\n+        .distinct()\n+        .collect(toMap(uri -> uri, toDiagnostics(errors)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzQ5NTI3Mw==", "bodyText": "wow", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r443495273", "createdAt": "2020-06-22T11:33:56Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "diffHunk": "@@ -68,23 +76,69 @@ public AnalysisResult analyze(\n     return toAnalysisResult(engine.run(uri, text, textDocumentSyncType.toString()), uri);\n   }\n \n+  /**\n+   * Don't analyze the document if it is empty or contains only sequence area\n+   *\n+   * @param text - document to analyze\n+   * @return true if the document is empty from the engine point of view\n+   */\n   private static boolean isEmpty(String text) {\n     return text.length() <= FIRST_LINE_SEQ_AND_EXTRA_OP;\n   }\n \n-  private static List<Diagnostic> convertErrors(List<SyntaxError> errors, String uri) {\n+  private AnalysisResult toAnalysisResult(ResultWithErrors<SemanticContext> result, String uri) {\n+    SemanticContext context = result.getResult();\n+    return new AnalysisResult(\n+        collectDiagnosticsForAffectedDocuments(\n+            convertErrors(result.getErrors()), context.getCopybookDefinitions(), uri),\n+        convertPositions(context.getVariableDefinitions()),\n+        convertPositions(context.getVariableUsages()),\n+        convertPositions(context.getParagraphDefinitions()),\n+        convertPositions(context.getParagraphUsages()),\n+        convertPositions(context.getCopybookDefinitions()),\n+        convertPositions(context.getCopybookUsages()));\n+  }\n+\n+  /**\n+   * Collect diagnostics for each document, used in the analysis - the main COBOL file and all the\n+   * copybooks. If there were no errors for some URI, then provide an empty list to clean-up the\n+   * errors after the previous analysis.\n+   *\n+   * @param diagnostics - list of found syntax and semantic errors\n+   * @param copybookDefinitions - list of copybook definitions used in this analysis\n+   * @param uri - current document URI\n+   * @return map with file URI as a key, and lists of diagnostics as values\n+   */\n+  private Map<String, List<Diagnostic>> collectDiagnosticsForAffectedDocuments(\n+      Map<String, List<Diagnostic>> diagnostics,\n+      Map<String, Collection<Position>> copybookDefinitions,\n+      String uri) {\n+    Map<String, List<Diagnostic>> result = new HashMap<>(diagnostics);\n+    copybookDefinitions.values().stream()\n+        .flatMap(Collection::stream)\n+        .map(Position::getDocumentURI)\n+        .forEach(it -> result.putIfAbsent(it, emptyList()));\n+    result.putIfAbsent(uri, emptyList());\n+    return result;\n+  }\n+\n+  private static Map<String, List<Diagnostic>> convertErrors(List<SyntaxError> errors) {\n     return errors.stream()\n-        .filter(errorOnlyFromCurrentDocument(uri))\n-        .map(toDiagnostic())\n-        .collect(toList());\n+        .map(SyntaxError::getPosition)\n+        .map(Position::getDocumentURI)\n+        .distinct()\n+        .collect(toMap(uri -> uri, toDiagnostics(errors)));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MjIwMg=="}, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc4OTI0NjIzOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwODo1OTo1NVrOGqy3mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjoyODoxM1rOGx7xjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUyNjgxMA==", "bodyText": "Is it still valid? We must expect .c4z/.copybooks.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447526810", "createdAt": "2020-06-30T08:59:55Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -31,45 +30,36 @@\n import com.google.inject.Injector;\n import lombok.experimental.UtilityClass;\n import org.awaitility.Awaitility;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.DidOpenTextDocumentParams;\n-import org.eclipse.lsp4j.TextDocumentItem;\n-import org.eclipse.lsp4j.services.LanguageClient;\n+import org.eclipse.lsp4j.*;\n import org.eclipse.lsp4j.services.TextDocumentService;\n \n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n \n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n /** This utility class provides methods to run use cases with Cobol code examples. */\n @UtilityClass\n public class UseCaseUtils {\n   public static final String DOCUMENT_URI = \"file:///c%3A/workspace/document.cbl\";\n   public static final String DOCUMENT_2_URI = \"file:///c%3A/workspace/document2.cbl\";\n+  private static final String CPY_URI_PREFIX = \"file:///c%3A/workspace/.copybooks/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUzNDUwNA==", "bodyText": "That's correct, but we don't apply any actual file system calls, and this value is just a mock.\nI will fix it", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447534504", "createdAt": "2020-06-30T09:12:20Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -31,45 +30,36 @@\n import com.google.inject.Injector;\n import lombok.experimental.UtilityClass;\n import org.awaitility.Awaitility;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.DidOpenTextDocumentParams;\n-import org.eclipse.lsp4j.TextDocumentItem;\n-import org.eclipse.lsp4j.services.LanguageClient;\n+import org.eclipse.lsp4j.*;\n import org.eclipse.lsp4j.services.TextDocumentService;\n \n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n \n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n /** This utility class provides methods to run use cases with Cobol code examples. */\n @UtilityClass\n public class UseCaseUtils {\n   public static final String DOCUMENT_URI = \"file:///c%3A/workspace/document.cbl\";\n   public static final String DOCUMENT_2_URI = \"file:///c%3A/workspace/document2.cbl\";\n+  private static final String CPY_URI_PREFIX = \"file:///c%3A/workspace/.copybooks/\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUyNjgxMA=="}, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMjc0OQ==", "bodyText": "fixed in #427", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455012749", "createdAt": "2020-07-15T12:28:13Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -31,45 +30,36 @@\n import com.google.inject.Injector;\n import lombok.experimental.UtilityClass;\n import org.awaitility.Awaitility;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.DidOpenTextDocumentParams;\n-import org.eclipse.lsp4j.TextDocumentItem;\n-import org.eclipse.lsp4j.services.LanguageClient;\n+import org.eclipse.lsp4j.*;\n import org.eclipse.lsp4j.services.TextDocumentService;\n \n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n \n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n /** This utility class provides methods to run use cases with Cobol code examples. */\n @UtilityClass\n public class UseCaseUtils {\n   public static final String DOCUMENT_URI = \"file:///c%3A/workspace/document.cbl\";\n   public static final String DOCUMENT_2_URI = \"file:///c%3A/workspace/document2.cbl\";\n+  private static final String CPY_URI_PREFIX = \"file:///c%3A/workspace/.copybooks/\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUyNjgxMA=="}, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDg2ODMzOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0MDo1N1rOGrCh5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNToyNzowNFrOGyDj6w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzM5OA==", "bodyText": "Just initialize copybookName during declaration, then this line can be removed.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447783398", "createdAt": "2020-06-30T15:40:57Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 339}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0MDMzMQ==", "bodyText": "The grammar here guarantees that we won't reach the else clause, I may simplify this clause", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455140331", "createdAt": "2020-07-15T15:27:04Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzM5OA=="}, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 339}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDkwNjA3OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0OToxNVrOGrC5Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxNToyNzoyOVrOGyDk_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4OTM3MQ==", "bodyText": "!( isEmpty(copybookName) || isEmpty(uri) ) is simpler and no double-negate", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447789371", "createdAt": "2020-06-30T15:49:15Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 350}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTE0MDYwNQ==", "bodyText": "Ok, makes sense", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455140605", "createdAt": "2020-07-15T15:27:29Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4OTM3MQ=="}, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 350}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDkxNzM2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MTozNFrOGrDAJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MTozNFrOGrDAJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MTE0Mg==", "bodyText": "Why hard coded? better use existing meaningful constant.\nseverity(DiagnosticSeverity.Error.getValue())", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447791142", "createdAt": "2020-06-30T15:51:34Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDkxODMwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MTo0NFrOGrDAsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MTo0NFrOGrDAsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MTI4MQ==", "bodyText": "same", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447791281", "createdAt": "2020-06-30T15:51:44Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)\n+            .suggestion(String.format(RECURSION_DETECTED, usage.getName()))\n+            .position(usage.getPosition())\n+            .build());\n+  }\n+\n+  private void reportMissingCopybooks(String copybookName, Position position) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .position(position)\n+            .suggestion(format(ERROR_SUGGESTION, copybookName))\n+            .severity(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 380}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDkyMzkyOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MjozOVrOGrDEPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MjozOVrOGrDEPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MjE5MQ==", "bodyText": ".severity(DiagnosticSeverity.Information.getValue())", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447792191", "createdAt": "2020-06-30T15:52:39Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)\n+            .suggestion(String.format(RECURSION_DETECTED, usage.getName()))\n+            .position(usage.getPosition())\n+            .build());\n+  }\n+\n+  private void reportMissingCopybooks(String copybookName, Position position) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .position(position)\n+            .suggestion(format(ERROR_SUGGESTION, copybookName))\n+            .severity(1)\n+            .errorCode(MISSING_COPYBOOK)\n+            .build());\n+  }\n+\n+  private void checkCopybookNameLength(String copybookName, Position position) {\n+    if (copybookName != null && copybookName.length() > 8) {\n+      errors.add(\n+          SyntaxError.syntaxError()\n+              .severity(3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 389}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDkzODY1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1NTo0MlrOGrDNOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1NTo0MlrOGrDNOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDQ5MA==", "bodyText": "Better practice is use a general return at the end of method, especially if catch block logs the exception.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447794490", "createdAt": "2020-06-30T15:55:42Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving;\n+  private String copybookName;\n+\n+  SynchronousCopybookResolution(DataBusBroker broker) {\n+    this.broker = broker;\n+    broker.subscribe(FETCHED_COPYBOOK_EVENT, this);\n+  }\n+\n+  /**\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param syncType - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content; or null in case\n+   *     of severe issue.\n+   * @throws IllegalStateException if the instance reused.\n+   */\n+  @Nullable\n+  @Override\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName, @Nonnull String documentUri, @Nonnull String syncType) {\n+    checkState();\n+\n+    if (isCopybookInCache(copybookName)) {\n+      broker.unSubscribe(this);\n+      return getContentFromCache(copybookName);\n+    }\n+\n+    this.copybookName = copybookName;\n+    waitForResolving = new CompletableFuture<>();\n+    broker.postData(\n+        RequiredCopybookEvent.builder()\n+            .name(copybookName)\n+            .documentUri(documentUri)\n+            .textDocumentSyncType(syncType)\n+            .build());\n+    try {\n+      return waitForResolving.get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      LOG.error(\"Error resolving copybook: \", e);\n+      currentThread().interrupt();\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDk1NTE5OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1OTozOFrOGrDX4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1OTozOFrOGrDX4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NzIxNg==", "bodyText": "Please, move this uri, and content retrieval logic after checking !copybookName.equals(name),  so it will not create redundant objects here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447797216", "createdAt": "2020-06-30T15:59:38Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving;\n+  private String copybookName;\n+\n+  SynchronousCopybookResolution(DataBusBroker broker) {\n+    this.broker = broker;\n+    broker.subscribe(FETCHED_COPYBOOK_EVENT, this);\n+  }\n+\n+  /**\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param syncType - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content; or null in case\n+   *     of severe issue.\n+   * @throws IllegalStateException if the instance reused.\n+   */\n+  @Nullable\n+  @Override\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName, @Nonnull String documentUri, @Nonnull String syncType) {\n+    checkState();\n+\n+    if (isCopybookInCache(copybookName)) {\n+      broker.unSubscribe(this);\n+      return getContentFromCache(copybookName);\n+    }\n+\n+    this.copybookName = copybookName;\n+    waitForResolving = new CompletableFuture<>();\n+    broker.postData(\n+        RequiredCopybookEvent.builder()\n+            .name(copybookName)\n+            .documentUri(documentUri)\n+            .textDocumentSyncType(syncType)\n+            .build());\n+    try {\n+      return waitForResolving.get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      LOG.error(\"Error resolving copybook: \", e);\n+      currentThread().interrupt();\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void observerCallback(@Nonnull FetchedCopybookEvent event) {\n+    if (copybookName == null) {\n+      LOG.warn(\"A disposed instance of copybook resolver used: \" + toString());\n+      return;\n+    }\n+    String name = event.getName();\n+    String uri = event.getUri();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 104}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MDk4NTA1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PreprocessorCleanerServiceImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjowNjo0N1rOGrDqow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQwODo1NDoxNlrOGyhfKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjAxOQ==", "bodyText": "Inconsistent injection, one is via constructor, other inline [I saw usage: new PreprocessorCleanerServiceImpl(new TokenUtilsImpl());].  Should be both either via constructor, or both via inline.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447802019", "createdAt": "2020-06-30T16:06:47Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PreprocessorCleanerServiceImpl.java", "diffHunk": "@@ -27,36 +27,67 @@\n import java.util.Scanner;\n \n import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.util.Optional.ofNullable;\n \n public class PreprocessorCleanerServiceImpl implements PreprocessorCleanerService {\n-  private Deque<CobolDocumentContext> contexts = new ArrayDeque<>();\n+  private Deque<StringBuilder> contexts = new ArrayDeque<>();\n+  private TokenUtils tokenUtils;\n \n-  public PreprocessorCleanerServiceImpl() {\n-    contexts.push(new CobolDocumentContext());\n+  @Inject\n+  public PreprocessorCleanerServiceImpl(TokenUtils tokenUtils) {\n+    this.tokenUtils = tokenUtils;\n+    contexts.push(new StringBuilder());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTYzMDYzNA==", "bodyText": "The injection in the given example is in the unit test, and the best practice is to avoid using dependency injection in tests", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455630634", "createdAt": "2020-07-16T08:54:16Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PreprocessorCleanerServiceImpl.java", "diffHunk": "@@ -27,36 +27,67 @@\n import java.util.Scanner;\n \n import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.util.Optional.ofNullable;\n \n public class PreprocessorCleanerServiceImpl implements PreprocessorCleanerService {\n-  private Deque<CobolDocumentContext> contexts = new ArrayDeque<>();\n+  private Deque<StringBuilder> contexts = new ArrayDeque<>();\n+  private TokenUtils tokenUtils;\n \n-  public PreprocessorCleanerServiceImpl() {\n-    contexts.push(new CobolDocumentContext());\n+  @Inject\n+  public PreprocessorCleanerServiceImpl(TokenUtils tokenUtils) {\n+    this.tokenUtils = tokenUtils;\n+    contexts.push(new StringBuilder());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjAxOQ=="}, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTAxOTgzOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoxNDozNVrOGrD_2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjoyODo0MFrOGx7yjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNzQ0OQ==", "bodyText": "Please change hardcoded value,  DiagnosticSeverity.Error.getValue() == it.getSeverity().getValue()", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447807449", "createdAt": "2020-06-30T16:14:35Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -168,19 +158,25 @@ public static AnalysisResult analyze(String text) {\n   public static List<Diagnostic> analyzeForErrors(String text) {\n     return analyzeForErrors(text, emptyList());\n   }\n+\n   /**\n    * Analyze the given text using a real language engine leaving only the diagnostics with the\n    * severe (level 1) errors providing copybooks required for the analysis\n    *\n    * @param text - text to analyze\n    * @param copybooks - list of copybooks required for the analysis\n-   * @return list of diagnostics with only severe errors\n+   * @return map of diagnostics with only severe errors\n    */\n   public static List<Diagnostic> analyzeForErrors(String text, List<CobolText> copybooks) {\n-    return analyze(text, copybooks).getDiagnostics().stream()\n-        .filter(it -> it.getSeverity().getValue() == 1)\n-        .collect(toList());\n+    return ofNullable(analyze(text, copybooks).getDiagnostics().get(DOCUMENT_URI))\n+        .map(\n+            diagnostics ->\n+                diagnostics.stream()\n+                    .filter(it -> it.getSeverity().getValue() == 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMzAwNg==", "bodyText": "fixed in #427", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455013006", "createdAt": "2020-07-15T12:28:40Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -168,19 +158,25 @@ public static AnalysisResult analyze(String text) {\n   public static List<Diagnostic> analyzeForErrors(String text) {\n     return analyzeForErrors(text, emptyList());\n   }\n+\n   /**\n    * Analyze the given text using a real language engine leaving only the diagnostics with the\n    * severe (level 1) errors providing copybooks required for the analysis\n    *\n    * @param text - text to analyze\n    * @param copybooks - list of copybooks required for the analysis\n-   * @return list of diagnostics with only severe errors\n+   * @return map of diagnostics with only severe errors\n    */\n   public static List<Diagnostic> analyzeForErrors(String text, List<CobolText> copybooks) {\n-    return analyze(text, copybooks).getDiagnostics().stream()\n-        .filter(it -> it.getSeverity().getValue() == 1)\n-        .collect(toList());\n+    return ofNullable(analyze(text, copybooks).getDiagnostics().get(DOCUMENT_URI))\n+        .map(\n+            diagnostics ->\n+                diagnostics.stream()\n+                    .filter(it -> it.getSeverity().getValue() == 1)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNzQ0OQ=="}, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTAyOTY5OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoxNzowMlrOGrEGQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjoyODo0N1rOGx7y1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwOTA4OA==", "bodyText": "But return type is List", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447809088", "createdAt": "2020-06-30T16:17:02Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -168,19 +158,25 @@ public static AnalysisResult analyze(String text) {\n   public static List<Diagnostic> analyzeForErrors(String text) {\n     return analyzeForErrors(text, emptyList());\n   }\n+\n   /**\n    * Analyze the given text using a real language engine leaving only the diagnostics with the\n    * severe (level 1) errors providing copybooks required for the analysis\n    *\n    * @param text - text to analyze\n    * @param copybooks - list of copybooks required for the analysis\n-   * @return list of diagnostics with only severe errors\n+   * @return map of diagnostics with only severe errors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAxMzA3Nw==", "bodyText": "fixed in #427", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455013077", "createdAt": "2020-07-15T12:28:47Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -168,19 +158,25 @@ public static AnalysisResult analyze(String text) {\n   public static List<Diagnostic> analyzeForErrors(String text) {\n     return analyzeForErrors(text, emptyList());\n   }\n+\n   /**\n    * Analyze the given text using a real language engine leaving only the diagnostics with the\n    * severe (level 1) errors providing copybooks required for the analysis\n    *\n    * @param text - text to analyze\n    * @param copybooks - list of copybooks required for the analysis\n-   * @return list of diagnostics with only severe errors\n+   * @return map of diagnostics with only severe errors", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwOTA4OA=="}, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTA4NDIwOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjoyNzowMFrOGrEk-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNVQxMjo1MTowNFrOGx8mag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNjk1NA==", "bodyText": "Is context non-null all the time ?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447816954", "createdAt": "2020-06-30T16:27:00Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "diffHunk": "@@ -68,23 +75,60 @@ public AnalysisResult analyze(\n     return toAnalysisResult(engine.run(uri, text, textDocumentSyncType.toString()), uri);\n   }\n \n+  /**\n+   * Don't analyze the document if it is empty or contains only sequence area\n+   *\n+   * @param text - document to analyze\n+   * @return true if the document is empty from the engine point of view\n+   */\n   private static boolean isEmpty(String text) {\n     return text.length() <= FIRST_LINE_SEQ_AND_EXTRA_OP;\n   }\n \n-  private static List<Diagnostic> convertErrors(List<SyntaxError> errors, String uri) {\n-    return errors.stream()\n-        .filter(errorOnlyFromCurrentDocument(uri))\n-        .map(toDiagnostic())\n-        .collect(toList());\n+  private AnalysisResult toAnalysisResult(ResultWithErrors<SemanticContext> result, String uri) {\n+    SemanticContext context = result.getResult();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTAyNjI4Mg==", "bodyText": "Yes, it is either fulfilled or empty. Added annotations to assure that.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r455026282", "createdAt": "2020-07-15T12:51:04Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "diffHunk": "@@ -68,23 +75,60 @@ public AnalysisResult analyze(\n     return toAnalysisResult(engine.run(uri, text, textDocumentSyncType.toString()), uri);\n   }\n \n+  /**\n+   * Don't analyze the document if it is empty or contains only sequence area\n+   *\n+   * @param text - document to analyze\n+   * @return true if the document is empty from the engine point of view\n+   */\n   private static boolean isEmpty(String text) {\n     return text.length() <= FIRST_LINE_SEQ_AND_EXTRA_OP;\n   }\n \n-  private static List<Diagnostic> convertErrors(List<SyntaxError> errors, String uri) {\n-    return errors.stream()\n-        .filter(errorOnlyFromCurrentDocument(uri))\n-        .map(toDiagnostic())\n-        .collect(toList());\n+  private AnalysisResult toAnalysisResult(ResultWithErrors<SemanticContext> result, String uri) {\n+    SemanticContext context = result.getResult();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNjk1NA=="}, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5MTEzMDUzOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorImpl.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjozNjowNVrOGrFABg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjozNjowNVrOGrFABg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyMzg3OA==", "bodyText": "Here no need unnecessary line-comments, see TokenUtilsImpl#retrieveTokens similar method quite readable", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447823878", "createdAt": "2020-06-30T16:36:05Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorImpl.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.CopybookUsage;\n+import com.ca.lsp.core.cobol.model.ExtendedDocument;\n+import com.ca.lsp.core.cobol.model.ResultWithErrors;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorLexer;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.StartRuleContext;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListenerFactory;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.google.inject.Inject;\n+import org.antlr.v4.runtime.CharStreams;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTreeWalker;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This class runs pre-processing for COBOL using CobolPreprocessor.g4 grammar file. As a result, it\n+ * returns an extended document with all the available copybooks included, with their definitions\n+ * and usages specified, as well as related errors.\n+ */\n+public class GrammarPreprocessorImpl implements GrammarPreprocessor {\n+  private GrammarPreprocessorListenerFactory listenerFactory;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  public GrammarPreprocessorImpl(\n+      GrammarPreprocessorListenerFactory listenerFactory, TokenUtils tokenUtils) {\n+    this.listenerFactory = listenerFactory;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public ResultWithErrors<ExtendedDocument> buildExtendedDocument(\n+      @Nonnull String uri,\n+      @Nonnull String code,\n+      @Nonnull Deque<CopybookUsage> copybookStack,\n+      @Nonnull String textDocumentSyncType) {\n+    // run the lexer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzE4MjkxOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/antlr4/com/ca/lsp/core/cobol/parser/CobolParser.g4", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxMDo1OFrOGzSZHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxODoxMFrOGzSodQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMTkwMw==", "bodyText": "remove TODO or make it beautiful \ud83d\udc85", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456431903", "createdAt": "2020-07-17T13:10:58Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/antlr4/com/ca/lsp/core/cobol/parser/CobolParser.g4", "diffHunk": "@@ -959,6 +959,15 @@ dataDescriptionEntryFormat3\n dataDescriptionEntryExecSql\n    : EXECSQLLINE+ DOT_FS?\n    ;\n+\n+//TODO: make it beautiful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzNTgyOQ==", "bodyText": "I changed the logic a little bit, now I check the terminals if they have the copybook enter/exit tags. Probably, we may delete those rules", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456435829", "createdAt": "2020-07-17T13:18:10Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/antlr4/com/ca/lsp/core/cobol/parser/CobolParser.g4", "diffHunk": "@@ -959,6 +959,15 @@ dataDescriptionEntryFormat3\n dataDescriptionEntryExecSql\n    : EXECSQLLINE+ DOT_FS?\n    ;\n+\n+//TODO: make it beautiful", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMTkwMw=="}, "originalCommit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzE4NTk2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/antlr4/com/ca/lsp/core/cobol/parser/CobolParser.g4", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxMTo0MlrOGzSa5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxNDozMVrOGzSg9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjM1Nw==", "bodyText": "I guess this is not solved, I can take care of it", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456432357", "createdAt": "2020-07-17T13:11:42Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/antlr4/com/ca/lsp/core/cobol/parser/CobolParser.g4", "diffHunk": "@@ -1154,7 +1163,17 @@ statement\n     exitStatement | generateStatement | gobackStatement | goToStatement | ifStatement | initializeStatement | initiateStatement | inspectStatement | mergeStatement | moveStatement | \n     multiplyStatement | openStatement | performStatement | purgeStatement | readStatement | receiveStatement | releaseStatement | returnStatement | rewriteStatement | searchStatement | \n     sendStatement | serviceReloadStatement | serviceLabelStatement | setStatement | sortStatement | startStatement | stopStatement | stringStatement | subtractStatement |\n-    terminateStatement | titleStatement | unstringStatement | writeStatement | xmlStatement\n+    terminateStatement | titleStatement | unstringStatement | writeStatement | xmlStatement | enterCpy | exitCpy\n+   ;\n+\n+\n+//TODO: modify the copybook name rule to accept everything including keywords", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMzkwOA==", "bodyText": "It is done here, but we should adjust the copybook name rule in CobolPreprocessor.g4. Now it accepts some keywords, but not all of them", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456433908", "createdAt": "2020-07-17T13:14:31Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/antlr4/com/ca/lsp/core/cobol/parser/CobolParser.g4", "diffHunk": "@@ -1154,7 +1163,17 @@ statement\n     exitStatement | generateStatement | gobackStatement | goToStatement | ifStatement | initializeStatement | initiateStatement | inspectStatement | mergeStatement | moveStatement | \n     multiplyStatement | openStatement | performStatement | purgeStatement | readStatement | receiveStatement | releaseStatement | returnStatement | rewriteStatement | searchStatement | \n     sendStatement | serviceReloadStatement | serviceLabelStatement | setStatement | sortStatement | startStatement | stopStatement | stringStatement | subtractStatement |\n-    terminateStatement | titleStatement | unstringStatement | writeStatement | xmlStatement\n+    terminateStatement | titleStatement | unstringStatement | writeStatement | xmlStatement | enterCpy | exitCpy\n+   ;\n+\n+\n+//TODO: modify the copybook name rule to accept everything including keywords", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjM1Nw=="}, "originalCommit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "originalPosition": 34}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0NzE5NTk2OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/broadcom/lsp/cdi/EngineModule.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxNDoxN1rOGzSgjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxNDoxN1rOGzSgjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMzgwNg==", "bodyText": "names of this classes makes me think you are speaking about antlr auto generated classes", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456433806", "createdAt": "2020-07-17T13:14:17Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/broadcom/lsp/cdi/EngineModule.java", "diffHunk": "@@ -32,9 +38,12 @@\n   protected void configure() {\n     bind(CobolLanguageEngine.class);\n     bind(CobolPreprocessor.class).to(CobolPreprocessorImpl.class);\n-    bind(CopybookAnalysis.class).to(CopybookParallelAnalysis.class);\n-    install(new FactoryModuleBuilder().build(AnalyseCopybookTaskFactory.class));\n     bind(CobolPreprocessor.class).to(CobolPreprocessorImpl.class);\n-    bind(CobolSemanticParser.class).to(CobolSemanticParserImpl.class);\n+    bind(GrammarPreprocessor.class).to(GrammarPreprocessorImpl.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzM3MzI3OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/model/DocumentHierarchyLevel.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTo1NDoyNFrOG-0Zlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDo1MToyMVrOG-7p7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyMzQxNQ==", "bodyText": "You could use Map::getOrDefault here and in the initialForward methods.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468523415", "createdAt": "2020-08-11T11:54:24Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/model/DocumentHierarchyLevel.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.model;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Optional.ofNullable;\n+\n+public class DocumentHierarchyLevel {\n+  private int index;\n+  private List<Position> positions;\n+  private Map<Integer, Integer> shifts;\n+\n+  public DocumentHierarchyLevel(DocumentMapping documentMapping) {\n+    index = 0;\n+    positions = documentMapping.getPositions();\n+    shifts = documentMapping.getShifts();\n+    initialForward();\n+  }\n+\n+  public Position getCurrent() {\n+    return index < positions.size() ? positions.get(index) : null;\n+  }\n+\n+  public void forward() {\n+    index += ofNullable(shifts.get(index)).orElse(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODY0MjI4NQ==", "bodyText": "That's true, I will do it", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468642285", "createdAt": "2020-08-11T14:51:21Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/model/DocumentHierarchyLevel.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.model;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Optional.ofNullable;\n+\n+public class DocumentHierarchyLevel {\n+  private int index;\n+  private List<Position> positions;\n+  private Map<Integer, Integer> shifts;\n+\n+  public DocumentHierarchyLevel(DocumentMapping documentMapping) {\n+    index = 0;\n+    positions = documentMapping.getPositions();\n+    shifts = documentMapping.getShifts();\n+    initialForward();\n+  }\n+\n+  public Position getCurrent() {\n+    return index < positions.size() ? positions.get(index) : null;\n+  }\n+\n+  public void forward() {\n+    index += ofNullable(shifts.get(index)).orElse(1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyMzQxNQ=="}, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQzMzM3OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PositionMappingUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoxMToxM1rOG-09AA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDozMzo1M1rOG-62qQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMjQ4MA==", "bodyText": "We need to think about watchdog here to handle look ahead infinity loop. It could be a feature for future implementation.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468532480", "createdAt": "2020-08-11T12:11:13Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PositionMappingUtils.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.util.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.DocumentHierarchyLevel;\n+import com.ca.lsp.core.cobol.model.DocumentMapping;\n+import lombok.experimental.UtilityClass;\n+import org.antlr.v4.runtime.Token;\n+\n+import javax.annotation.Nonnull;\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import static com.ca.lsp.core.cobol.parser.CobolLexer.COPYENTRY;\n+import static com.ca.lsp.core.cobol.parser.CobolLexer.COPYEXIT;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class maps positions of extended document to the original ones.\n+ *\n+ * <p>Preprocessor may internally change the content of the processing document, so the resulting\n+ * positions of syntax and semantic analysis won't match the user expectations. In order to avoid\n+ * it, the tokens provided by {@link com.ca.lsp.core.cobol.parser.CobolLexer} should be compared\n+ * with ones provided by {@link com.ca.lsp.core.cobol.parser.CobolPreprocessorLexer}. The comparison\n+ * applied by string equity.\n+ */\n+@UtilityClass\n+public class PositionMappingUtils {\n+\n+  private static final int URI_PREFIX_LENGTH = CPY_ENTER_TAG.length() + CPY_URI_OPEN.length();\n+  private static final int URI_SUFFIX_LENGTH = CPY_URI_CLOSE.length();\n+\n+  /**\n+   * Map the tokens of the extended document to original ones using document mapping, collected by\n+   * {@link com.ca.lsp.core.cobol.parser.CobolPreprocessorListener}.\n+   *\n+   * @param tokens - tokens of extended documents, provided by {@link\n+   *     com.ca.lsp.core.cobol.parser.CobolLexer}\n+   * @param documentPositions - initial document and copybooks positions\n+   * @param documentUri - URI of the current document\n+   * @return map of tokens and original positions.\n+   */\n+  public Map<Token, Position> createPositionMapping(\n+      List<Token> tokens, Map<String, DocumentMapping> documentPositions, String documentUri) {\n+    Map<Token, Position> result = new HashMap<>();\n+    Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+    enterDocument(documentUri, documentPositions, documentHierarchyStack);\n+    tokens.forEach(mapToken(documentPositions, result, documentHierarchyStack));\n+    return result;\n+  }\n+\n+  private Consumer<Token> mapToken(\n+      Map<String, DocumentMapping> documentPositions,\n+      Map<Token, Position> result,\n+      Deque<DocumentHierarchyLevel> documentHierarchyStack) {\n+    return token -> {\n+      if (token.getType() == COPYENTRY) {\n+        enterDocument(\n+            extractCopybookName(token.getText()), documentPositions, documentHierarchyStack);\n+      } else if (token.getType() == COPYEXIT) {\n+        exitDocument(documentHierarchyStack);\n+      } else {\n+        mapTokenToPosition(token, result, documentHierarchyStack);\n+      }\n+    };\n+  }\n+\n+  private void mapTokenToPosition(\n+      Token token,\n+      Map<Token, Position> mappingAccumulator,\n+      Deque<DocumentHierarchyLevel> documentHierarchyStack) {\n+    Position position = currentDocument(documentHierarchyStack).getCurrent();\n+    if (position == null) return;\n+    if (tokenMatches(token.getText(), position.getToken())) {\n+      mappingAccumulator.put(token, position);\n+      currentDocument(documentHierarchyStack).forward();\n+    } else {\n+      applyLookAhead(token, mappingAccumulator, documentHierarchyStack);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYyOTE2MQ==", "bodyText": "I don't think an infinity loop may appear here: if the token not mapped, it is skipped", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468629161", "createdAt": "2020-08-11T14:33:53Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PositionMappingUtils.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.util.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.DocumentHierarchyLevel;\n+import com.ca.lsp.core.cobol.model.DocumentMapping;\n+import lombok.experimental.UtilityClass;\n+import org.antlr.v4.runtime.Token;\n+\n+import javax.annotation.Nonnull;\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import static com.ca.lsp.core.cobol.parser.CobolLexer.COPYENTRY;\n+import static com.ca.lsp.core.cobol.parser.CobolLexer.COPYEXIT;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class maps positions of extended document to the original ones.\n+ *\n+ * <p>Preprocessor may internally change the content of the processing document, so the resulting\n+ * positions of syntax and semantic analysis won't match the user expectations. In order to avoid\n+ * it, the tokens provided by {@link com.ca.lsp.core.cobol.parser.CobolLexer} should be compared\n+ * with ones provided by {@link com.ca.lsp.core.cobol.parser.CobolPreprocessorLexer}. The comparison\n+ * applied by string equity.\n+ */\n+@UtilityClass\n+public class PositionMappingUtils {\n+\n+  private static final int URI_PREFIX_LENGTH = CPY_ENTER_TAG.length() + CPY_URI_OPEN.length();\n+  private static final int URI_SUFFIX_LENGTH = CPY_URI_CLOSE.length();\n+\n+  /**\n+   * Map the tokens of the extended document to original ones using document mapping, collected by\n+   * {@link com.ca.lsp.core.cobol.parser.CobolPreprocessorListener}.\n+   *\n+   * @param tokens - tokens of extended documents, provided by {@link\n+   *     com.ca.lsp.core.cobol.parser.CobolLexer}\n+   * @param documentPositions - initial document and copybooks positions\n+   * @param documentUri - URI of the current document\n+   * @return map of tokens and original positions.\n+   */\n+  public Map<Token, Position> createPositionMapping(\n+      List<Token> tokens, Map<String, DocumentMapping> documentPositions, String documentUri) {\n+    Map<Token, Position> result = new HashMap<>();\n+    Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+    enterDocument(documentUri, documentPositions, documentHierarchyStack);\n+    tokens.forEach(mapToken(documentPositions, result, documentHierarchyStack));\n+    return result;\n+  }\n+\n+  private Consumer<Token> mapToken(\n+      Map<String, DocumentMapping> documentPositions,\n+      Map<Token, Position> result,\n+      Deque<DocumentHierarchyLevel> documentHierarchyStack) {\n+    return token -> {\n+      if (token.getType() == COPYENTRY) {\n+        enterDocument(\n+            extractCopybookName(token.getText()), documentPositions, documentHierarchyStack);\n+      } else if (token.getType() == COPYEXIT) {\n+        exitDocument(documentHierarchyStack);\n+      } else {\n+        mapTokenToPosition(token, result, documentHierarchyStack);\n+      }\n+    };\n+  }\n+\n+  private void mapTokenToPosition(\n+      Token token,\n+      Map<Token, Position> mappingAccumulator,\n+      Deque<DocumentHierarchyLevel> documentHierarchyStack) {\n+    Position position = currentDocument(documentHierarchyStack).getCurrent();\n+    if (position == null) return;\n+    if (tokenMatches(token.getText(), position.getToken())) {\n+      mappingAccumulator.put(token, position);\n+      currentDocument(documentHierarchyStack).forward();\n+    } else {\n+      applyLookAhead(token, mappingAccumulator, documentHierarchyStack);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMjQ4MA=="}, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjkyNzQ2ODUxOnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/ReplacingServiceImpl.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoyMToxMlrOG-1SFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxNDoxNzozNFrOG-6HMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzg3Nw==", "bodyText": "Are you sure about that? Never seen formatting string with groups like (? ... )\nOr maybe you use the result inside the Antlr engine?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468537877", "createdAt": "2020-08-11T12:21:12Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/ReplacingServiceImpl.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.util.impl;\n+\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceClauseContext;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplacePseudoTextContext;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceSameElementContext;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+\n+import static com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceliteralContext;\n+import static java.lang.String.format;\n+import static java.util.Arrays.stream;\n+import static java.util.Optional.ofNullable;\n+import static java.util.regex.Matcher.quoteReplacement;\n+import static java.util.stream.Collectors.joining;\n+import static org.apache.commons.lang3.StringUtils.split;\n+\n+/**\n+ * This service applies replacing for given text by replace clauses and tokens. It may work with\n+ * REPLACING and REPLACE statements.\n+ */\n+@Singleton\n+public class ReplacingServiceImpl implements ReplacingService {\n+  /**\n+   * Look-before and look-ahead pattern to check that the token wrapped with separators, i.e.\n+   * whitespaces, dots ot line breaks. Not includes separators to the found substring.\n+   */\n+  private static final String SEPARATE_TOKEN_PATTERN = \"(?<=[\\\\.\\\\s\\\\r\\\\n])%s(?=[\\\\.\\\\s\\\\r\\\\n])\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODYxNzAwOA==", "bodyText": "It is to require, but not include some value into the matching pattern", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468617008", "createdAt": "2020-08-11T14:17:34Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/ReplacingServiceImpl.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.util.impl;\n+\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceClauseContext;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplacePseudoTextContext;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceSameElementContext;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+\n+import static com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceliteralContext;\n+import static java.lang.String.format;\n+import static java.util.Arrays.stream;\n+import static java.util.Optional.ofNullable;\n+import static java.util.regex.Matcher.quoteReplacement;\n+import static java.util.stream.Collectors.joining;\n+import static org.apache.commons.lang3.StringUtils.split;\n+\n+/**\n+ * This service applies replacing for given text by replace clauses and tokens. It may work with\n+ * REPLACING and REPLACE statements.\n+ */\n+@Singleton\n+public class ReplacingServiceImpl implements ReplacingService {\n+  /**\n+   * Look-before and look-ahead pattern to check that the token wrapped with separators, i.e.\n+   * whitespaces, dots ot line breaks. Not includes separators to the found substring.\n+   */\n+  private static final String SEPARATE_TOKEN_PATTERN = \"(?<=[\\\\.\\\\s\\\\r\\\\n])%s(?=[\\\\.\\\\s\\\\r\\\\n])\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzg3Nw=="}, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0NzE1MzE1OnYy", "diffSide": "RIGHT", "path": "com.ca.lsp.cobol/pom.xml", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNDoxMDo0NlrOHBqarQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMVQxNDowMzo0NlrOHEugxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwNTU4MQ==", "bodyText": "I hope that only one should be left.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r471505581", "createdAt": "2020-08-17T14:10:46Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/pom.xml", "diffHunk": "@@ -41,7 +42,9 @@\n         <commons.io.version>2.5</commons.io.version>\n         <commons.text.version>1.6</commons.text.version>\n         <lombok.version>1.18.10</lombok.version>\n-        <junit.version>4.12</junit.version>\n+        <junit-jupiter.version>5.6.0</junit-jupiter.version>\n+        <junit.platform.version>1.6.0</junit.platform.version>\n+        <junit.platform.version>1.5.2</junit.platform.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwOTgzMQ==", "bodyText": "@asatklichov what do you think?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r471509831", "createdAt": "2020-08-17T14:17:03Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/pom.xml", "diffHunk": "@@ -41,7 +42,9 @@\n         <commons.io.version>2.5</commons.io.version>\n         <commons.text.version>1.6</commons.text.version>\n         <lombok.version>1.18.10</lombok.version>\n-        <junit.version>4.12</junit.version>\n+        <junit-jupiter.version>5.6.0</junit-jupiter.version>\n+        <junit.platform.version>1.6.0</junit.platform.version>\n+        <junit.platform.version>1.5.2</junit.platform.version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwNTU4MQ=="}, "originalCommit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDcxODQwNQ==", "bodyText": "@temanbrcom Sorry now saw this, I will remove older version.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r474718405", "createdAt": "2020-08-21T14:03:46Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/pom.xml", "diffHunk": "@@ -41,7 +42,9 @@\n         <commons.io.version>2.5</commons.io.version>\n         <commons.text.version>1.6</commons.text.version>\n         <lombok.version>1.18.10</lombok.version>\n-        <junit.version>4.12</junit.version>\n+        <junit-jupiter.version>5.6.0</junit-jupiter.version>\n+        <junit.platform.version>1.6.0</junit.platform.version>\n+        <junit.platform.version>1.5.2</junit.platform.version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwNTU4MQ=="}, "originalCommit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4027, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}