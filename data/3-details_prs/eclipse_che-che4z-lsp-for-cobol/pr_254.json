{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0MTc0NTAz", "number": 254, "title": "#251 - Fix nested copybook issue", "bodyText": "Fix #251 allowing to download nested copybooks that are defined inside copybooks imported in a main cobol file.", "createdAt": "2020-03-26T13:35:29Z", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254", "merged": true, "mergeCommit": {"oid": "6a79dd81ec6d225f8934bfa6d7d03019b495e283"}, "closed": true, "closedAt": "2020-04-01T16:47:47Z", "author": {"login": "zacanbrcom"}, "timelineItems": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcOMokuAH2gAyMzk0MTc0NTAzOmM0Yjc1ZWFmMjlhNjk2M2E2YmYzYTY4YTJkZDQ1MDc0MGNlMWRiZWQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTaL8KgFqTM4NTc0NjA3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "c4b75eaf29a6963a6bf3a68a2dd450740ce1dbed", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c4b75eaf29a6963a6bf3a68a2dd450740ce1dbed", "committedDate": "2020-03-16T11:44:12Z", "message": "Move responsability on DependencyService and adjust unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "708562617e6ed5e71f4053455f01bb7f2d99b9de", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/708562617e6ed5e71f4053455f01bb7f2d99b9de", "committedDate": "2020-03-20T09:00:52Z", "message": "Refactor FSConfig file"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1955e9620852abcce2b851a85aeba80517c038bf", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1955e9620852abcce2b851a85aeba80517c038bf", "committedDate": "2020-03-20T10:45:07Z", "message": "update unit test and concrete implementation in CopybookDependencyServiceImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "335d28357e703ab0ebd3b66d817089c9c24a184d", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/335d28357e703ab0ebd3b66d817089c9c24a184d", "committedDate": "2020-03-24T08:29:03Z", "message": "Fix lombok issue - need deep investigation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2e0234e0afa9169c93f134b0383b64348fb100ca", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2e0234e0afa9169c93f134b0383b64348fb100ca", "committedDate": "2020-03-26T07:55:38Z", "message": "Add e2e test involving preprocessor and copybook service"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2b9c7edf64bd6732bf0e5246c9ad9150e46ae3fd", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2b9c7edf64bd6732bf0e5246c9ad9150e46ae3fd", "committedDate": "2020-03-26T13:38:30Z", "message": "Remove commented code after unit test refactoring"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2846fdcc3f6b513d05bef7ba45aab93e404dc9c6", "committedDate": "2020-03-26T15:14:51Z", "message": "Update Changelog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgyMTIxOTI1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#pullrequestreview-382121925", "createdAt": "2020-03-26T15:25:07Z", "commit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNToyNTowN1rOF8MWcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxNTo0MjoyOFrOF8NNaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MTIzMg==", "bodyText": "are you setting the workspaceFolders in dependencyService somewhere else?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r398661232", "createdAt": "2020-03-26T15:25:07Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -135,120 +115,47 @@ private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n   }\n \n   private List<Path> generatePathListFromSettings(String profile, List<String> datasetList) {\n-    // can happen here that copybooks or internal structure is null\n     return datasetList.stream()\n         .map(\n             it ->\n                 Paths.get(\n-                    getCopybookFolder(getWorkspaceFoldersAsPathList().get(0))\n+                    getCopybookBaseFolder(getWorkspaceFoldersAsPathList().get(0))\n                         + filesystemSeparator()\n                         + profile\n                         + filesystemSeparator()\n                         + it))\n-        .filter(Objects::nonNull)\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * @param fileName copybook name\n-   * @param targetFolderPath physical path of workspace where to search for the copybook\n-   * @return Path of the found copybook in the target folder.\n-   */\n-  private Path applySearch(String fileName, Path targetFolderPath) {\n-    try (Stream<Path> pathStream =\n-        Files.find(\n-            targetFolderPath,\n-            100,\n-            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n-            FileVisitOption.FOLLOW_LINKS)) {\n-      return pathStream.findAny().orElse(null);\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-      return null;\n-    }\n-  }\n-\n   private List<Path> getWorkspaceFoldersAsPathList() {\n     return Optional.ofNullable(getWorkspaceFolders())\n         .map(Collection::stream)\n         .orElseGet(Stream::empty)\n         .filter(Objects::nonNull)\n-        .map(this::resolveUriPath)\n+        .map(this::resolveURI)\n         .collect(Collectors.toList());\n   }\n \n   private List<WorkspaceFolder> getWorkspaceFolders() {\n     return workspaceFolders;\n   }\n \n-  /**\n-   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n-   * the FileSystemService, example: [input:\n-   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n-   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n-   *\n-   * @param it workspace folder\n-   * @return the Path of the workspace folder\n-   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n-   */\n-  private Path resolveUriPath(WorkspaceFolder it) {\n-    try {\n-      return Paths.get(new URI(it.getUri()).normalize());\n-    } catch (URISyntaxException e) {\n-      log.error(e.getMessage());\n-    }\n-    return null;\n+  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n+    return getPathFromURI(workspaceFolder.getUri());\n   }\n \n-  private Path getCopybookFolder(Path workspaceFolderPath) {\n+  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n     return Paths.get(workspaceFolderPath + filesystemSeparator() + COPYBOOK_FOLDER_NAME);\n   }\n \n   /** create the task and pass it to the executor service */\n   @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n     String requiredCopybookName = event.getName();\n-    String content = null;\n-    Path path;\n-\n-    // if the document is in DID_OPEN mode is possible write on dependency file..\n-    if (isFileInDidOpen(event)) {\n-      dependencyService.setWorkspaceFolderPaths(getWorkspaceFoldersAsPathList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 131}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2NDM3Mw==", "bodyText": "I guess here is the answer to the question if you are setting the workspaceFolders, correct?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r398664373", "createdAt": "2020-03-26T15:29:01Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -135,120 +115,47 @@ private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n   }\n \n   private List<Path> generatePathListFromSettings(String profile, List<String> datasetList) {\n-    // can happen here that copybooks or internal structure is null\n     return datasetList.stream()\n         .map(\n             it ->\n                 Paths.get(\n-                    getCopybookFolder(getWorkspaceFoldersAsPathList().get(0))\n+                    getCopybookBaseFolder(getWorkspaceFoldersAsPathList().get(0))\n                         + filesystemSeparator()\n                         + profile\n                         + filesystemSeparator()\n                         + it))\n-        .filter(Objects::nonNull)\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * @param fileName copybook name\n-   * @param targetFolderPath physical path of workspace where to search for the copybook\n-   * @return Path of the found copybook in the target folder.\n-   */\n-  private Path applySearch(String fileName, Path targetFolderPath) {\n-    try (Stream<Path> pathStream =\n-        Files.find(\n-            targetFolderPath,\n-            100,\n-            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n-            FileVisitOption.FOLLOW_LINKS)) {\n-      return pathStream.findAny().orElse(null);\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-      return null;\n-    }\n-  }\n-\n   private List<Path> getWorkspaceFoldersAsPathList() {\n     return Optional.ofNullable(getWorkspaceFolders())\n         .map(Collection::stream)\n         .orElseGet(Stream::empty)\n         .filter(Objects::nonNull)\n-        .map(this::resolveUriPath)\n+        .map(this::resolveURI)\n         .collect(Collectors.toList());\n   }\n \n   private List<WorkspaceFolder> getWorkspaceFolders() {\n     return workspaceFolders;\n   }\n \n-  /**\n-   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n-   * the FileSystemService, example: [input:\n-   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n-   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n-   *\n-   * @param it workspace folder\n-   * @return the Path of the workspace folder\n-   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n-   */\n-  private Path resolveUriPath(WorkspaceFolder it) {\n-    try {\n-      return Paths.get(new URI(it.getUri()).normalize());\n-    } catch (URISyntaxException e) {\n-      log.error(e.getMessage());\n-    }\n-    return null;\n+  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n+    return getPathFromURI(workspaceFolder.getUri());\n   }\n \n-  private Path getCopybookFolder(Path workspaceFolderPath) {\n+  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n     return Paths.get(workspaceFolderPath + filesystemSeparator() + COPYBOOK_FOLDER_NAME);\n   }\n \n   /** create the task and pass it to the executor service */\n   @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n     String requiredCopybookName = event.getName();\n-    String content = null;\n-    Path path;\n-\n-    // if the document is in DID_OPEN mode is possible write on dependency file..\n-    if (isFileInDidOpen(event)) {\n-      dependencyService.setWorkspaceFolderPaths(getWorkspaceFoldersAsPathList());\n-      dependencyService.addCopybookInDepFile(requiredCopybookName, event.getDocumentUri());\n-    }\n-\n-    if (missingInformationToSearchCopybooks()) {\n-      selectAppropriateMessageForCommunication();\n \n-      dataBus.postData(\n-          FetchedCopybookEvent.builder()\n-              .name(requiredCopybookName)\n-              .uri(null)\n-              .content(null)\n-              .build());\n-      return;\n-    }\n-\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-\n-    // search the copybook against the target folders provided from the settings\n-    path =\n-        findCopybook(\n-            requiredCopybookName,\n-            (String) configurationSettingsStorable.getProfiles(),\n-            configurationSettingsStorable.getPaths());\n-\n-    if (isFileExists(path)) {\n-      content = retrieveContentByPath(path);\n-    }\n-\n-    dataBus.postData(\n-        FetchedCopybookEvent.builder()\n-            .name(requiredCopybookName)\n-            .uri(Optional.ofNullable(path).map(Path::toUri).map(URI::toString).orElse(null))\n-            .content(content)\n-            .build());\n+    dependencyService.addCopybookInDepFile(\n+        event, requiredCopybookName, getWorkspaceFoldersAsPathList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY3NTMwNw==", "bodyText": "if two dependency files are created then do we need to update both .dep files?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r398675307", "createdAt": "2020-03-26T15:42:28Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/CopybookServiceE2ETest.java", "diffHunk": "@@ -158,4 +162,60 @@ private void waitAndAssert(Boolean expected) {\n       fail(e.getMessage());\n     }\n   }\n+\n+  /**\n+   * This test verify that when a nested copybook is processed a new dependency file is created. So", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 133}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzOTYzNTM1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#pullrequestreview-383963535", "createdAt": "2020-03-30T15:19:32Z", "commit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNToxOTozM1rOF9u9Hw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNTo0MTowNlrOF9v_Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI3Njc2Nw==", "bodyText": "Paths#get() documentation recommends to use workspaceFolderPath.resolve(COPYBOOK_FOLDER_NAME) here", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400276767", "createdAt": "2020-03-30T15:19:33Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -135,120 +115,47 @@ private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n   }\n \n   private List<Path> generatePathListFromSettings(String profile, List<String> datasetList) {\n-    // can happen here that copybooks or internal structure is null\n     return datasetList.stream()\n         .map(\n             it ->\n                 Paths.get(\n-                    getCopybookFolder(getWorkspaceFoldersAsPathList().get(0))\n+                    getCopybookBaseFolder(getWorkspaceFoldersAsPathList().get(0))\n                         + filesystemSeparator()\n                         + profile\n                         + filesystemSeparator()\n                         + it))\n-        .filter(Objects::nonNull)\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * @param fileName copybook name\n-   * @param targetFolderPath physical path of workspace where to search for the copybook\n-   * @return Path of the found copybook in the target folder.\n-   */\n-  private Path applySearch(String fileName, Path targetFolderPath) {\n-    try (Stream<Path> pathStream =\n-        Files.find(\n-            targetFolderPath,\n-            100,\n-            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n-            FileVisitOption.FOLLOW_LINKS)) {\n-      return pathStream.findAny().orElse(null);\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-      return null;\n-    }\n-  }\n-\n   private List<Path> getWorkspaceFoldersAsPathList() {\n     return Optional.ofNullable(getWorkspaceFolders())\n         .map(Collection::stream)\n         .orElseGet(Stream::empty)\n         .filter(Objects::nonNull)\n-        .map(this::resolveUriPath)\n+        .map(this::resolveURI)\n         .collect(Collectors.toList());\n   }\n \n   private List<WorkspaceFolder> getWorkspaceFolders() {\n     return workspaceFolders;\n   }\n \n-  /**\n-   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n-   * the FileSystemService, example: [input:\n-   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n-   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n-   *\n-   * @param it workspace folder\n-   * @return the Path of the workspace folder\n-   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n-   */\n-  private Path resolveUriPath(WorkspaceFolder it) {\n-    try {\n-      return Paths.get(new URI(it.getUri()).normalize());\n-    } catch (URISyntaxException e) {\n-      log.error(e.getMessage());\n-    }\n-    return null;\n+  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n+    return getPathFromURI(workspaceFolder.getUri());\n   }\n \n-  private Path getCopybookFolder(Path workspaceFolderPath) {\n+  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n     return Paths.get(workspaceFolderPath + filesystemSeparator() + COPYBOOK_FOLDER_NAME);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5MDc3Ng==", "bodyText": "The file separators are not required for the Paths#get() method", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400290776", "createdAt": "2020-03-30T15:37:27Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemUtils.java", "diffHunk": "@@ -108,4 +114,143 @@ public static String decodeURI(String uri) {\n       return uri;\n     }\n   }\n+\n+  /**\n+   * This method return a {@link Path} representation of a bunch of {@link String} given as input or\n+   * null if is not possible get the path. After each pah a FS separator is added automatically\n+   *\n+   * @param basePath the string that represent the base path\n+   * @param more additional String used to compose the path\n+   * @return the {@link Path} that contains all the given segment, null if the path doesn't exists.\n+   */\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI5MzYzOQ==", "bodyText": "You may use Files#exists to match the Law of Demetra", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400293639", "createdAt": "2020-03-30T15:41:06Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemUtils.java", "diffHunk": "@@ -108,4 +114,143 @@ public static String decodeURI(String uri) {\n       return uri;\n     }\n   }\n+\n+  /**\n+   * This method return a {@link Path} representation of a bunch of {@link String} given as input or\n+   * null if is not possible get the path. After each pah a FS separator is added automatically\n+   *\n+   * @param basePath the string that represent the base path\n+   * @param more additional String used to compose the path\n+   * @return the {@link Path} that contains all the given segment, null if the path doesn't exists.\n+   */\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(\n+        basePath,\n+        filesystemSeparator(),\n+        Arrays.stream(more)\n+            .map(path -> path + filesystemSeparator())\n+            .collect(Collectors.joining()));\n+  }\n+\n+  /**\n+   * This method create a folder from a given path\n+   *\n+   * @param path in input that will be used to create the folder\n+   */\n+  public void createFolder(Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Create a file on filesystem from a given {@link Path}\n+   *\n+   * @param path target path that will be used to create the file\n+   */\n+  public void createFile(Path path) {\n+    if (!path.toFile().exists()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 77}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9cb39ef8ac7bd1371edaa69cb4ca142edc7700a9", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9cb39ef8ac7bd1371edaa69cb4ca142edc7700a9", "committedDate": "2020-03-31T07:35:44Z", "message": "Merge remote-tracking branch 'remotes/origin/development' into 251_AddNestedCpyInDep\n\n# Conflicts:\n#\tCHANGELOG.md\n#\tclients/cobol-lsp-vscode-extension/CHANGELOG.md\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyServiceImpl.java\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemUtils.java\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/FileSystemConfiguration.java\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/DependencyServiceTest.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NTQwMjgw", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#pullrequestreview-384540280", "createdAt": "2020-03-31T09:07:59Z", "commit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwOTowNzo1OVrOF-MP4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwOTowNzo1OVrOF-MP4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc1NjcwNg==", "bodyText": "why are there two methods which are doing most likely the same thing? isDocumentInDidOpen and isFileInDidOpen", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400756706", "createdAt": "2020-03-31T09:07:59Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyServiceImpl.java", "diffHunk": "@@ -40,6 +36,46 @@\n   private static final String DEP_EXTENSION = \".dep\";\n   @Getter private List<Path> workspaceFolderPaths;\n \n+  /**\n+   * This method is invoked to handle the insertion of a copybook name into the dependency file\n+   *\n+   * @param event contains information the copybook (document URI and event sync type)\n+   * @param requiredCopybookName name that represent the new copybook that is supposed to be written\n+   * @param targetPaths the reference path where create or search a dependency file.\n+   */\n+  @Override\n+  public void addCopybookInDepFile(\n+      RequiredCopybookEvent event, String requiredCopybookName, List<Path> targetPaths) {\n+    setWorkspaceFolderPaths(targetPaths);\n+    if (isFileInDidOpen(event) || isNestedCopybookBeProcessed(event)) {\n+      writeCopybookInDepFile(requiredCopybookName, event.getDocumentUri());\n+    }\n+  }\n+\n+  private boolean isNestedCopybookBeProcessed(RequiredCopybookEvent event) {\n+    return isDocumentInDidOpen(event)\n+        && getExtensionFromURI(event.getDocumentUri()).equalsIgnoreCase(\"cpy\");\n+  }\n+\n+  private boolean isDocumentInDidOpen(RequiredCopybookEvent event) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 47}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg0NTg4Nzc1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#pullrequestreview-384588775", "createdAt": "2020-03-31T10:11:17Z", "commit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMDoxMToxOFrOF-Opfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQxMDoxODo1M1rOF-O7Eg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5NjAzMQ==", "bodyText": "As I can see, here you change the internal state with the same information every time. Maybe, you may set the workspaceFolderPaths on initialization or pass it to the following methods, not touching the state of the object?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400796031", "createdAt": "2020-03-31T10:11:18Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyServiceImpl.java", "diffHunk": "@@ -40,6 +36,46 @@\n   private static final String DEP_EXTENSION = \".dep\";\n   @Getter private List<Path> workspaceFolderPaths;\n \n+  /**\n+   * This method is invoked to handle the insertion of a copybook name into the dependency file\n+   *\n+   * @param event contains information the copybook (document URI and event sync type)\n+   * @param requiredCopybookName name that represent the new copybook that is supposed to be written\n+   * @param targetPaths the reference path where create or search a dependency file.\n+   */\n+  @Override\n+  public void addCopybookInDepFile(\n+      RequiredCopybookEvent event, String requiredCopybookName, List<Path> targetPaths) {\n+    setWorkspaceFolderPaths(targetPaths);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDc5ODU3MA==", "bodyText": "Do we assume the workspace folders as static? If yes, we may save the result of getWorkspaceFoldersAsPathList() instead of storing the workspaceFolders. It will allow us not to repeat this conversion every time.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400798570", "createdAt": "2020-03-31T10:15:35Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -135,120 +115,47 @@ private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n   }\n \n   private List<Path> generatePathListFromSettings(String profile, List<String> datasetList) {\n-    // can happen here that copybooks or internal structure is null\n     return datasetList.stream()\n         .map(\n             it ->\n                 Paths.get(\n-                    getCopybookFolder(getWorkspaceFoldersAsPathList().get(0))\n+                    getCopybookBaseFolder(getWorkspaceFoldersAsPathList().get(0))\n                         + filesystemSeparator()\n                         + profile\n                         + filesystemSeparator()\n                         + it))\n-        .filter(Objects::nonNull)\n         .collect(Collectors.toList());\n   }\n \n-  /**\n-   * @param fileName copybook name\n-   * @param targetFolderPath physical path of workspace where to search for the copybook\n-   * @return Path of the found copybook in the target folder.\n-   */\n-  private Path applySearch(String fileName, Path targetFolderPath) {\n-    try (Stream<Path> pathStream =\n-        Files.find(\n-            targetFolderPath,\n-            100,\n-            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n-            FileVisitOption.FOLLOW_LINKS)) {\n-      return pathStream.findAny().orElse(null);\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-      return null;\n-    }\n-  }\n-\n   private List<Path> getWorkspaceFoldersAsPathList() {\n     return Optional.ofNullable(getWorkspaceFolders())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDgwMDUzMA==", "bodyText": "Due to we call this setter only on the initialization, we may replace it with an assisted injection to disallow the changing of the object's internal state.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r400800530", "createdAt": "2020-03-31T10:18:53Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -80,21 +75,6 @@ public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n     this.workspaceFolders = workspaceFolders;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2846fdcc3f6b513d05bef7ba45aab93e404dc9c6"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f624c3754e2964eeb0a05fadc8bbb21d6c59cdb", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8f624c3754e2964eeb0a05fadc8bbb21d6c59cdb", "committedDate": "2020-04-01T08:02:54Z", "message": "Address request of change"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a3bbeb6ee3d1f277b59e009d3e090edbef6c930", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a3bbeb6ee3d1f277b59e009d3e090edbef6c930", "committedDate": "2020-04-01T11:36:27Z", "message": "Refactor CopybookDependencyServiceImpl.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f7c9367178af65605d1c59635a5d777c1b43a5e", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3f7c9367178af65605d1c59635a5d777c1b43a5e", "committedDate": "2020-04-01T11:47:18Z", "message": "Polish CopybookDependencyServiceImpl & FileSystemUtils.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7052edcd559b47a5c154597b449d469d5ae2cbf", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d7052edcd559b47a5c154597b449d469d5ae2cbf", "committedDate": "2020-04-01T12:50:53Z", "message": "Fix extra chars in javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/795d4728b44d2a7f039d0e6e67e36eab727d1af8", "committedDate": "2020-04-01T12:53:07Z", "message": "Cleanup FileSystemUtils.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1NjQzNjgx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#pullrequestreview-385643681", "createdAt": "2020-04-01T14:31:34Z", "commit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDozMTozNFrOF_DeLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQxNDo1NToxMlrOF_Ekcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2MTQ4Nw==", "bodyText": "Seems like you don't need to store the list of WorkspaceFolder at all - you convert them on the initialization and then don't use anymore", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401661487", "createdAt": "2020-04-01T14:31:34Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -52,6 +46,8 @@\n   private static final String COPYBOOK_FOLDER_NAME = \".copybooks\";\n   private final DataBusBroker dataBus;\n   private List<WorkspaceFolder> workspaceFolders;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2NDI3Mw==", "bodyText": "Seems like this is the responsibility of MyLanguageServer on the initialization or of Guice using assisted injection.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401664273", "createdAt": "2020-04-01T14:35:10Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -71,28 +67,23 @@ public CopybookServiceImpl(\n   }\n \n   /**\n-   * Store the informations about the workspace folder defined by the client IDE\n+   * Store the information about the workspace folders defined by the client IDE\n    *\n    * @param workspaceFolders list of workspace folders sent by the client to the server\n    */\n   @Override\n   public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n     this.workspaceFolders = workspaceFolders;\n+    createPathListFromWorkspaceFolders();\n+    setPathListInDependencyFile();\n   }\n \n-  /**\n-   * @param uriForFileName of copybook found under workspace folder\n-   * @return content of the file as String content\n-   */\n-  @Nullable\n-  String retrieveContentByPath(Path uriForFileName) {\n-    String content = null;\n-    try (Stream<String> stream = Files.lines(uriForFileName)) {\n-      content = stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n-    } catch (IOException e) {\n-      log.error(e.getMessage());\n-    }\n-    return content;\n+  private void createPathListFromWorkspaceFolders() {\n+    workspaceFolderPaths = getWorkspaceFoldersAsPathList();\n+  }\n+\n+  private void setPathListInDependencyFile() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2OTA1MQ==", "bodyText": "The resolveUriPath() is not used", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401669051", "createdAt": "2020-04-01T14:41:44Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemUtils.java", "diffHunk": "@@ -112,43 +114,153 @@ public static String decodeURI(String uri) {\n   }\n \n   /**\n-   * @param workspaceFolders folders which are provided at the init moment\n-   * @return a list of path of those folders\n+   * This method return a {@link Path} representation of a bunch of {@link String} given as input or\n+   * null if is not possible get the path. After each pah a FS separator is added automatically\n+   *\n+   * @param basePath the string that represent the base path\n+   * @param more additional String used to compose the path\n+   * @return the {@link Path} that contains all the given segment, null if the path doesn't exists.\n    */\n-  public List<Path> getWorkspaceFoldersAsPathList(List<WorkspaceFolder> workspaceFolders) {\n-    return Optional.ofNullable(workspaceFolders)\n-        .map(Collection::stream)\n-        .orElseGet(Stream::empty)\n-        .filter(Objects::nonNull)\n-        .map(FileSystemUtils::resolveUriPath)\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  /**\n+   * This method return the list of paths represented by a fixed part (outer + inner) and a variable\n+   * part iterated to obtains path in this form: {[base,middle,v1],[base,middle,v2], ...}\n+   *\n+   * @param outer first level of folder\n+   * @param inner second level of folder (represent the name of an inner folder)\n+   * @param variablePart list of names of folders that are contained inside the inner\n+   * @return a lis of paths represented in the way: {[outer,inner,v1],[outer,inner,v2], ...}\n+   */\n+  public List<Path> getPathList(@Nonnull String outer, String inner, List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, inner, it))\n+        .filter(Files::exists)\n         .collect(Collectors.toList());\n   }\n \n   /**\n-   * This method can be used to extract the name of a given COBOL file from the URI\n+   * This method create a folder from a given path\n+   *\n+   * @param path in input that will be used to create the folder\n+   */\n+  public void createFolder(Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+    }\n+  }\n+\n+  /**\n+   * Create a file on filesystem from a given {@link Path}\n    *\n-   * @param documentUri\n-   * @return the cobol program name from the given URI\n+   * @param path target path that will be used to create the file\n    */\n-  public String getFileNameFromURI(String documentUri) {\n-    String result = null;\n+  public void createFile(Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(e.getMessage());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * This method extract the name of a file from a valid {@link URI} and return the name back to the\n+   * client as String or null in case of error.\n+   *\n+   * @param uri the reference of the file from where extract the name\n+   * @return the String representation of the file name or null if any {@link URISyntaxException} is\n+   *     caught.\n+   */\n+  public String getNameFromURI(String uri) {\n     try {\n-      result = FilenameUtils.getBaseName(Paths.get(new URI(documentUri)).getFileName().toString());\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n     } catch (URISyntaxException e) {\n       log.error(e.getMessage());\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * This method extract the file extension from the {@link URI} given as input\n+   *\n+   * @param uri reference to the file from where extract the file extension\n+   * @return the String representation of the file extension or null if the URI is not valid\n+   */\n+  public String getExtensionFromURI(String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  /**\n+   * This method retrieve the content of a dependency file and return it back to the callee.\n+   *\n+   * @param filePath target path of the file\n+   * @return the content of the dependency file or null if doesn't exists\n+   */\n+  public List<String> getContentFromFile(Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+      return Collections.emptyList();\n+    }\n+  }\n+\n+  /**\n+   * @param path URI from where extract the content\n+   * @return content of the file as String representation\n+   */\n+  @Nullable\n+  public String getContentByPath(Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * @param fileName file to search\n+   * @param targetFolderPath physical path where to search for the file\n+   * @return Path of the found copybook in the target folder.\n+   */\n+  public Path applySearch(String fileName, Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(e.getMessage());\n+      return null;\n     }\n-    return result;\n   }\n \n   /**\n-   * This method provides the path to a specific file based on the COBOL file\n+   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n+   * the FileSystemService, example: [input:\n+   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n+   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n    *\n-   * @param dependencyFolderPath the folder where we are creating the dependency file\n-   * @param cobolFileName\n-   * @return the path of the dependency file\n+   * @param uri {@link URI} representation of a file\n+   * @return the {@link Path} representation of the given URI in input\n+   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n    */\n-  public Path retrieveDependencyFile(Path dependencyFolderPath, String cobolFileName) {\n-    return Paths.get(dependencyFolderPath + filesystemSeparator() + cobolFileName + DEP_EXTENSION);\n+  public Path getPathFromURI(String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(e.getMessage());\n+      return null;\n+    }\n   }\n \n   /**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3MTM3OA==", "bodyText": "This is an exposure of implementation details to the public interface. Not critical, just bad practice.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401671378", "createdAt": "2020-04-01T14:44:46Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyService.java", "diffHunk": "@@ -24,11 +26,14 @@\n  * management\n  */\n public interface CopybookDependencyService {\n+\n+  void addCopybookInDepFile(RequiredCopybookEvent event, String requiredCopybookName);\n+\n+  boolean isFileInDidOpen(RequiredCopybookEvent event);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3MjMxMQ==", "bodyText": "A typo in the method name", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401672311", "createdAt": "2020-04-01T14:45:54Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/dependency/CopybookDependencyServiceImpl.java", "diffHunk": "@@ -64,24 +58,62 @@ public CopybookDependencyServiceImpl(\n   }\n \n   /**\n-   * This method write the copybook name sent by the {@link CopybookServiceImpl} into the dependency\n-   * file.\n+   * This method is invoked to handle the insertion of a copybook name into the dependency file\n    *\n-   * @param requiredCopybookName copybook name that should be written in the dependency file\n-   * @param documentUri extract the name of the cobol file from the URI\n+   * @param event contains information the copybook (document URI and event sync type)\n+   * @param requiredCopybookName name that represent the new copybook that is supposed to be written\n    */\n-  @Beta\n   @Override\n-  public void addCopybookInDepFile(String requiredCopybookName, String documentUri) {\n-    String cobolFileName = getFileNameFromURI(documentUri);\n-    Path dependencyFolderPath = createDependencyFileFolder();\n-    Path dependencyFile = retrieveDependencyFile(dependencyFolderPath, cobolFileName);\n+  public void addCopybookInDepFile(RequiredCopybookEvent event, String requiredCopybookName) {\n+    if (isFileInDidOpen(event) || isProcessingACopybbok(event)) {\n+      writeCopybookInDepFile(requiredCopybookName, event.getDocumentUri());\n+    }\n+  }\n+\n+  private boolean isProcessingACopybbok(RequiredCopybookEvent event) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3NzQ2Nw==", "bodyText": "I think we will receive a method name code smell here and for two more methods in this class", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401677467", "createdAt": "2020-04-01T14:52:41Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/CopybookServiceE2ETest.java", "diffHunk": "@@ -79,62 +84,60 @@ public void initActivities() {\n    * file.\n    */\n   @Test\n-  public void generateDependencyFileOnCallbackPositiveTest() {\n-\n-    // generate a required copybook event\n+  public void publishRequestOfCopybook_createDependencyFile() {\n     broker.postData(\n         RequiredCopybookEvent.builder()\n             .name(CPY_NAME_WITHOUT_EXT)\n-            .documentUri(DOCUMENT_URI)\n+            .documentUri(COBOL_FILE_DOCUMENT_URI)\n             .textDocumentSyncType(\"DID_OPEN\")\n             .build());\n+\n     // after one second is expected to found the dep file on filesystem\n-    waitAndAssert(Boolean.TRUE);\n+    waitAndAssert_DepFileIsCreated(Boolean.TRUE);\n   }\n \n   /**\n    * This test verify that when the preprocessor publish a require copybook event without specifying\n    * the TextDocumentSync type, the FileSystem service will not write/update any dependency file.\n    */\n   @Test\n-  public void NotGenerateDependencyFileOnCallbackNegativeTest() {\n-    // generate a required copybook event\n+  public void noTextDocSyncTypeDefined_NoDependencyFileIsCreated() {\n     broker.postData(\n         RequiredCopybookEvent.builder()\n             .name(CPY_NAME_WITHOUT_EXT)\n-            .documentUri(DOCUMENT_URI)\n+            .documentUri(COBOL_FILE_DOCUMENT_URI)\n             .build());\n+\n     // after one second is expected to found the dep file on filesystem\n-    waitAndAssert(Boolean.FALSE);\n+    waitAndAssert_DepFileIsCreated(Boolean.FALSE);\n   }\n \n   /**\n    * This test verify that when the preprocessor publish a require copybook event when the document\n    * is in DID_CHANGE mode and the FileSystem service will not write/update any dependency file.\n    */\n   @Test\n-  public void NotGenerateDependencyFileOnDidChangeTest() {\n-    // generate a required copybook event\n+  public void DocumentInDidChangeMode_NoDepFileIsCreated() {\n     broker.postData(\n         RequiredCopybookEvent.builder()\n             .name(CPY_NAME_WITHOUT_EXT)\n-            .documentUri(DOCUMENT_URI)\n+            .documentUri(COBOL_FILE_DOCUMENT_URI)\n             .textDocumentSyncType(\"DID_CHANGE\")\n             .build());\n     // after one second is expected to found the dep file on filesystem\n-    waitAndAssert(Boolean.FALSE);\n+    waitAndAssert_DepFileIsCreated(Boolean.FALSE);\n   }\n \n   /**\n    * This test verify that when a non required event is published on the databus, the dependency\n    * file is not created. This test assume that .cobdep folder exists but no depfile is created.\n    */\n   @Test\n-  public void noDependencyFileWithOtherEvent() {\n+  public void unknownEventPublished_NoDepFileIsCreated() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY3OTQ3NQ==", "bodyText": "I would prefer to avoid using Guice in tests and call the observer callback directly, but it is not critical at the moment and we may do it later", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#discussion_r401679475", "createdAt": "2020-04-01T14:55:12Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/DependencyServiceTest.java", "diffHunk": "@@ -45,53 +47,77 @@\n /** This class represent all the unit test for the copybook dependency managament service */\n @Slf4j\n public class DependencyServiceTest extends FileSystemConfiguration {\n+  public static final String NESTED_CPY_NAME = \"CPYNEST2\";\n   private final DataBusBroker broker =\n       Guice.createInjector(new DatabusModule()).getInstance(DataBusBroker.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1NzQ2MDcy", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/254#pullrequestreview-385746072", "createdAt": "2020-04-01T16:21:13Z", "commit": {"oid": "795d4728b44d2a7f039d0e6e67e36eab727d1af8"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1250, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}