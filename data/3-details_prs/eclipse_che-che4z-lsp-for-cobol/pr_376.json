{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI2NDgxMjc3", "number": 376, "title": "Support Copybooks in the Local Workspace", "bodyText": "When a user is working in a workspace, it should be possible to define the physical location of copybooks that are defined within the workspace. The valid resources (both local copybooks or valid dataset definitions) defined in the settings.json should be consumed by the LSP server to resolve copybooks during the analysis of a COBOL file.\nThe LSP-Client should be able to resolve the list of URIs starting from a configuration defined by the user in the settings.json.\nUse configuration requests to resolve copybook names with their URIs and load their content on the server using file system calls. Apply middleware to differentiate copybooks' calls and usual configuration requests.", "createdAt": "2020-06-02T10:01:35Z", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376", "merged": true, "mergeCommit": {"oid": "17a9306fe7b02dc328b5aab704257889b6d97c43"}, "closed": true, "closedAt": "2020-06-04T11:37:42Z", "author": {"login": "temanbrcom"}, "timelineItems": {"totalCount": 148, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcnnVXnAFqTQyMzQ0MTMwMA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcn8HwJAFqTQyNDMzNzg3Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDQxMzAw", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423441300", "createdAt": "2020-06-03T10:58:46Z", "commit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo1ODo0NlrOGeWvSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo1ODo0NlrOGeWvSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4MzAxNw==", "bodyText": "In case when we have many extensions we will do many calls to FS to check the file existing state. Things will go harder in a case when we also want to support case insensitive scenario.\nI think what is possible to take a list of files from the folder once and then work with that list.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434483017", "createdAt": "2020-06-03T10:58:46Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDQyNzI4", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423442728", "createdAt": "2020-06-03T11:00:58Z", "commit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTowMDo1OFrOGeWzng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTowMDo1OFrOGeWzng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4NDEyNg==", "bodyText": "If it is not ...", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434484126", "createdAt": "2020-06-03T11:00:58Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {\n+                    return uri;\n+                }\n+            }\n+        }\n+    }\n+\n+    constructor(private profileService: ProfileService, private copybooksDownloader: CopybooksDownloader) {\n+    }\n+\n+    /**\n+     * This function will try to resolve a given copybook name applying a two-step search strategy:\n+     * - search it on folders provided by the user in the setting.json\n+     * - search in the folder where the extension download copybooks from MF (.copybooks)\n+     * If is not found in the previous steps than the user is notified and needs to download it from MF", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 82}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDU2NTUz", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423456553", "createdAt": "2020-06-03T11:23:14Z", "commit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMToyMzoxNFrOGeXdXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMToyMzoxNFrOGeXdXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ5NDgxNA==", "bodyText": "I suggest start using, in next time,  \"org.hamcrest.core\" assertThat  instead of Assert methods. We can look at it once we discuss in deep about TDD/BDD.\ne.g.\nassertThat(1, is(params.getRegistrations().size()));\nassertThat(registration.getId(), notNullValue());", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434494814", "createdAt": "2020-06-03T11:23:14Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WatcherServiceImplTest.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.ca.lsp.cobol.service.providers.ClientProvider;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+import org.junit.Test;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+import static org.junit.Assert.*;\n+import static org.mockito.ArgumentCaptor.forClass;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+\n+/**\n+ * This class is a unit test for the {@link WatcherServiceImpl} and asserts that it creates correct\n+ * JSON object structures on each watching request.\n+ */\n+public class WatcherServiceImplTest {\n+\n+  @Test\n+  public void watchConfigurationChange() {\n+    LanguageClient client = mock(LanguageClient.class);\n+    ClientProvider provider = new ClientProvider();\n+    provider.set(client);\n+    ArgumentCaptor<RegistrationParams> captor = forClass(RegistrationParams.class);\n+    WatcherService watcherService = new WatcherServiceImpl(provider);\n+\n+    watcherService.watchConfigurationChange();\n+\n+    verify(client).registerCapability(captor.capture());\n+\n+    RegistrationParams params = captor.getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDY2NTI3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423466527", "createdAt": "2020-06-03T11:38:43Z", "commit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTozODo0M1rOGeX6mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTozODo0M1rOGeX6mA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwMjI5Ng==", "bodyText": "I would prefer to avoid using -er endings in class names", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434502296", "createdAt": "2020-06-03T11:38:43Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "diffHunk": "@@ -14,15 +14,21 @@\n \n import * as fs from \"fs\";\n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n-import { loadDepFile, DependenciesDesc } from \"./DependencyService\";\n-import { C4Z_FOLDER, DEPENDENCIES_FOLDER, PROCESS_DOWNLOAD_ERROR_MSG, DSN_NOT_FOUND_ERROR_MSG, INVALID_CREDENTIALS_ERROR_MSG, DSN_PLACEHOLDER, PROFILE_NAME_PLACEHOLDER, CONN_REFUSED_ERROR_MSG, NO_PASSWORD_ERROR_MSG } from \"../constants\";\n-import { CopybookFix } from \"./CopybookFix\";\n-import { CopybooksPathGenerator, createDatasetPath, createCopybookPath, checkWorkspace } from \"./CopybooksPathGenerator\";\n-import { CopybookProfile, DownloadQueue } from \"./DownloadQueue\";\n-import { ProfileService } from \"./ProfileService\";\n-import { ZoweApi } from \"./ZoweApi\";\n-import { Type, ZoweError } from \"./ZoweError\";\n+import {\n+    CONN_REFUSED_ERROR_MSG,\n+    DSN_NOT_FOUND_ERROR_MSG,\n+    DSN_PLACEHOLDER,\n+    INVALID_CREDENTIALS_ERROR_MSG,\n+    NO_PASSWORD_ERROR_MSG,\n+    PROCESS_DOWNLOAD_ERROR_MSG,\n+    PROFILE_NAME_PLACEHOLDER,\n+} from \"../constants\";\n+import {CopybookFix} from \"./CopybookFix\";\n+import {checkWorkspace, CopybooksPathGenerator, createCopybookPath, createDatasetPath} from \"./CopybooksPathGenerator\";\n+import {CopybookProfile, DownloadQueue} from \"./DownloadQueue\";\n+import {ProfileService} from \"./ProfileService\";\n+import {ZoweApi} from \"./ZoweApi\";\n+import {Type, ZoweError} from \"./ZoweError\";\n \n export class CopybooksDownloader implements vscode.Disposable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDc0NjQ2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423474646", "createdAt": "2020-06-03T11:51:10Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMTo1MToxMVrOGeYTTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjoxNTowNFrOGeZExA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUwODYyMg==", "bodyText": "Also, this check is case-sensitive", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434508622", "createdAt": "2020-06-03T11:51:11Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ4MzAxNw=="}, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxMzgxMw==", "bodyText": "\"copybooks\" may be defined as an element of SettingsParametersEnum", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434513813", "createdAt": "2020-06-03T12:00:48Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,122 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final SettingsService settingsService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+          DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.settingsService = settingsService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n-  /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n-   *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n   @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n+  public void invalidateURICache() {\n+    copybookPath.clear();\n   }\n \n   /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n+   *\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      settingsService\n+          .getConfiguration(\"copybook\", cobolFileName, requiredCopybookName)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNTkwNA==", "bodyText": "Missing Override annotation", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434515904", "createdAt": "2020-06-03T12:04:59Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjQwOA==", "bodyText": "Not descriptive var name", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434516408", "createdAt": "2020-06-03T12:05:55Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {\n+    register(\n+        paths.stream()\n+            .map(\n+                it -> {\n+                  folderWatchers.add(it);\n+                  return new Registration(\n+                      it,\n+                      WATCH_FILES,\n+                      new DidChangeWatchedFilesRegistrationOptions(\n+                          singletonList(\n+                              new FileSystemWatcher(\"**/\" + it + \"/**/*\", WATCH_ALL_KIND))));\n+                })\n+            .collect(toList()));\n+  }\n+\n+  @Override\n+  public void removeWatchers(@Nonnull List<String> paths) {\n+    List<String> collect = paths.stream().filter(folderWatchers::remove).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxNjk2MQ==", "bodyText": "\"**/\" + it + \"/**/*\" is on a lower abstracion layer and should be exctracted", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434516961", "createdAt": "2020-06-03T12:07:00Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/WatcherServiceImpl.java", "diffHunk": "@@ -0,0 +1,112 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.Singleton;\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.services.LanguageClient;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static java.util.Collections.singletonList;\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This class creates watchers with type to watch all types of events. The key to remove a watcher\n+ * is its path without any changes.\n+ */\n+@Singleton\n+public class WatcherServiceImpl implements WatcherService {\n+\n+  /** Glob patterns to watch the copybooks folder and copybook files */\n+  private static final String COPYBOOKS_FOLDER_GLOB = \"**/.copybooks/**/*\";\n+\n+  /**\n+   * The kind of events of interest, for watchers calculated as WatchKind.Create | WatchKind.Change\n+   * | WatchKind.Delete which is 7\n+   */\n+  private static final int WATCH_ALL_KIND = 7;\n+\n+  private static final String WATCH_FILES = \"workspace/didChangeWatchedFiles\";\n+  private static final String WATCH_CONFIGURATION = \"workspace/didChangeConfiguration\";\n+\n+  private final List<String> folderWatchers = new ArrayList<>();\n+\n+  private final Provider<LanguageClient> clientProvider;\n+\n+  @Inject\n+  WatcherServiceImpl(Provider<LanguageClient> clientProvider) {\n+    this.clientProvider = clientProvider;\n+  }\n+\n+  @Nonnull\n+  public List<String> getWatchingFolders() {\n+    return unmodifiableList(folderWatchers);\n+  }\n+\n+  public void watchConfigurationChange() {\n+    register(singletonList(new Registration(\"configurationChange\", WATCH_CONFIGURATION, null)));\n+  }\n+\n+  public void watchPredefinedFolder() {\n+    register(\n+        singletonList(\n+            new Registration(\n+                \"copybooksWatcher\",\n+                WATCH_FILES,\n+                new DidChangeWatchedFilesRegistrationOptions(\n+                    singletonList(new FileSystemWatcher(COPYBOOKS_FOLDER_GLOB, WATCH_ALL_KIND))))));\n+  }\n+\n+  public void addWatchers(@Nonnull List<String> paths) {\n+    register(\n+        paths.stream()\n+            .map(\n+                it -> {\n+                  folderWatchers.add(it);\n+                  return new Registration(\n+                      it,\n+                      WATCH_FILES,\n+                      new DidChangeWatchedFilesRegistrationOptions(\n+                          singletonList(\n+                              new FileSystemWatcher(\"**/\" + it + \"/**/*\", WATCH_ALL_KIND))));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUxODU4NA==", "bodyText": "Outdated javadoc. Probably, the whole method may be removed", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434518584", "createdAt": "2020-06-03T12:09:56Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/FileSystemService.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.utils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.nio.file.Path;\n+import java.nio.file.StandardOpenOption;\n+import java.util.List;\n+\n+/** This interface represents API for low-level file systems access */\n+public interface FileSystemService {\n+  /**\n+   * Normalize the URI defined in the workspace to get a NIO Path object that will be used within\n+   * the FileSystemService, example: [input:\n+   * file:///C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy] --> [output:\n+   * C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy]\n+   *\n+   * @param uri URI string representation of a file\n+   * @return the {@link Path} representation of the given URI in input\n+   * @throws IllegalArgumentException if the URI of WorkspaceFolder is not valid\n+   */\n+  @Nullable\n+  Path getPathFromURI(@Nonnull String uri);\n+\n+  /**\n+   * This method extracts the name of a file from a valid {@link URI} and return the name back to\n+   * the client as String or null in case of error.\n+   *\n+   * @param uri the reference of the file from where extract the name\n+   * @return the String representation of the file name or null if any {@link URISyntaxException} is\n+   *     caught.\n+   */\n+  @Nullable\n+  String getNameFromURI(@Nonnull String uri);\n+\n+  /**\n+   * Retrieve the content of the file as a string.\n+   *\n+   * @param file URI from where extract the content\n+   * @return content of the file as String representation\n+   */\n+  @Nullable\n+  String getContentByPath(@Nonnull Path file);\n+\n+  /**\n+   * Check if the file with the given path exists\n+   *\n+   * @param file NIO path of the file to check\n+   * @return true if the path represent a valid file, false otherwise\n+   */\n+  boolean fileExists(@Nullable Path file);\n+\n+  /**\n+   * Replace special chars (as parenthesis, spaces and so on) that are encoded by the LSP protocol\n+   * on the client side. Needs to be encoded in order to display to the user the uri correctly.\n+   *\n+   * @param uri provided by the {@link org.eclipse.lsp4j.services.TextDocumentService}\n+   * @return a new String decoded with UTF8\n+   */\n+  @Nonnull\n+  String decodeURI(@Nonnull String uri);\n+\n+  /**\n+   * Retrieve the content of a dependency file and return it back to the callee.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMDk3MQ==", "bodyText": "Incorrect method javadoc pattern - should start with a verb in the active voice", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434520971", "createdAt": "2020-06-03T12:14:27Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 224}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyMTI4NA==", "bodyText": "What pattern? The dot?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434521284", "createdAt": "2020-06-03T12:15:04Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA=="}, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTAyMjkx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423502291", "createdAt": "2020-06-03T12:30:03Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozMDowM1rOGeZldw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozMDowM1rOGeZldw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyOTY1NQ==", "bodyText": "The method called asynchronously. Inside we add and remove watchers. It could cause us an issue if this method will be called in two threads. Is it make sense to use a synchronized method here?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434529655", "createdAt": "2020-06-03T12:30:03Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CobolWorkspaceServiceImpl.java", "diffHunk": "@@ -67,66 +76,72 @@ public CobolWorkspaceServiceImpl(DataBusBroker dataBus, Provider<LanguageClient>\n   @Nonnull\n   @Override\n   public CompletableFuture<Object> executeCommand(@Nonnull ExecuteCommandParams params) {\n+    runAsync(executeCopybookFix(params)).whenComplete(reportExceptionIfFound(params));\n+\n     return completedFuture(null);\n   }\n \n+  private Runnable executeCopybookFix(@Nonnull ExecuteCommandParams params) {\n+    return () -> {\n+      if (MISSING_COPYBOOK.name().equals(params.getCommand())) {\n+        rerunAnalysis();\n+      }\n+    };\n+  }\n+\n   /**\n-   * This is a notification triggered automatically when the user modify configuration settings in\n-   * the client\n+   * Process changed configuration on the client state. This notification triggered automatically\n+   * when the user modify configuration settings in the client. Invalidate all the caches to avoid\n+   * dirty state.\n    *\n    * @param params - LSPSpecification -> The actual changed settings; Actually -> null all the time.\n    */\n   @Override\n   public void didChangeConfiguration(DidChangeConfigurationParams params) {\n-    try {\n-\n-      // invalidate cache to avoid false positive\n-      dataBus.invalidateCache();\n-      fetchSettings(LSP_PREFIX.label + \".\" + CPY_MANAGER.label, null)\n-          .thenAccept(e -> dataBus.postData(FetchedSettingsEvent.builder().content(e).build()));\n-    } catch (RuntimeException e) {\n-      log.error(e.getMessage());\n-    }\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> acceptSettingsChange(toStrings(it)));\n   }\n \n-  /**\n-   * After client notifies the server that there is a setting change we need to request the client\n-   * those changing by sending a workspace/configuration JSON request\n-   *\n-   * @param section - The configuration section asked for.\n-   * @param scope - The scope to get the configuration section for.\n-   * @return - CompletedFuture which contains an object with the settings asked for.\n-   */\n-  private CompletableFuture<List<Object>> fetchSettings(String section, String scope) {\n-    ConfigurationParams params =\n-        new ConfigurationParams(provideConfigurationItemList(section, scope));\n-    return clientProvider.get().configuration(params);\n+  private void acceptSettingsChange(List<String> localFolders) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 119}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTA3ODI3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423507827", "createdAt": "2020-06-03T12:37:13Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozNzoxM1rOGeZ1EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMjozNzoxM1rOGeZ1EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUzMzY0OQ==", "bodyText": "The same as CobolWorkspaceServiceImpl#toString. I think that it could be a method of SettingsService.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434533649", "createdAt": "2020-06-03T12:37:13Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "diffHunk": "@@ -162,10 +106,23 @@ void retrieveAndStoreConfiguration() {\n         new WorkspaceServerCapabilities(workspaceFoldersOptions);\n     capabilities.setWorkspace(workspaceServiceCapabilities);\n \n-    copybookService.setWorkspaceFolders(params.getWorkspaceFolders());\n     return supplyAsync(() -> new InitializeResult(capabilities));\n   }\n \n+  private void addLocalFilesWatcher() {\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> watchingService.addWatchers(toStrings(it)));\n+  }\n+\n+  private List<String> toStrings(List<Object> it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTMyMjAx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423532201", "createdAt": "2020-06-03T13:07:12Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowNzoxMlrOGea8dw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowNzoxMlrOGea8dw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MTkyNw==", "bodyText": "This line doesn't cover all cases. It converts Unix separators to Windows, but leave Windows separators unchanged for Unix.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434551927", "createdAt": "2020-06-03T13:07:12Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTMzNzI1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423533725", "createdAt": "2020-06-03T13:09:02Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowOTowMlrOGebA0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzowOTowMlrOGebA0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1MzA0MQ==", "bodyText": "Not sure that it will be safe to delete \" symbol.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434553041", "createdAt": "2020-06-03T13:09:02Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTM2NTY0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423536564", "createdAt": "2020-06-03T13:12:14Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxMjoxNFrOGebIxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxMjoxNFrOGebIxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NTA3Ng==", "bodyText": "It creates the file only if needed. Could it be renamed like ensureFile?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434555076", "createdAt": "2020-06-03T13:12:14Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTM4MzE2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423538316", "createdAt": "2020-06-03T13:14:12Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNDoxMlrOGebN9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNDoxMlrOGebN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NjQwNQ==", "bodyText": "We could use System.lineSeparator() here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434556405", "createdAt": "2020-06-03T13:14:12Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTM4NTE0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423538514", "createdAt": "2020-06-03T13:14:25Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNDoyNVrOGebOiw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNDoyNVrOGebOiw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NjU1NQ==", "bodyText": "I think there is no need to wrap this into else block due to the first if contains an early-return.\nAlso, is it guaranteed that something will be returned in any case?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434556555", "createdAt": "2020-06-03T13:14:25Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();\n+        const localFolderList: string[] = copybookResolver.resolve(targetFolders);\n+\n+        for (const folder of localFolderList) {\n+            let uri: URL = this.getURIFrom(folder, copybookName);\n+\n+            if (fs.existsSync(uri)) {\n+                return uri.href;\n+            } else {\n+                uri = this.getURIFrom(folder, copybookName, CopybookUtil.getValidCopybookExtensionList());\n+                if (fs.existsSync(uri)) {\n+                    return uri.href;\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * This method is responsible to return an URI without extension if the extension is not provided or an URI\n+     * that contains an allowed extension.\n+     * @param folder is the first part of the URI referred to the folder defined in the setting.json\n+     * @param copybookName is the name of copybook identified by the LSP server that needs to be found locally\n+     * or downloaded\n+     * @param extensions an optional parameter to produce an URI of an allowed extension list, verifyng that\n+     * this URI really exists on FS.\n+     */\n+    private static getURIFrom(folder: string, copybookName: string, extensions?: string[]): URL {\n+        if (!extensions) {\n+            return new URL(path.join(folder, copybookName));\n+        } else {\n+            for (const extension of extensions) {\n+                const uri = new URL(path.join(folder, copybookName + \".\" + extension));\n+                if (fs.existsSync(uri)) {\n+                    return uri;\n+                }\n+            }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTQzNDkw", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423543490", "createdAt": "2020-06-03T13:20:03Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMDowM1rOGebcgQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMDowM1rOGebcgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MDEyOQ==", "bodyText": "It makes sense to use Set here instead of List.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434560129", "createdAt": "2020-06-03T13:20:03Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 213}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTQ1ODE1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423545815", "createdAt": "2020-06-03T13:22:41Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMjo0MVrOGebjRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyMjo0MVrOGebjRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MTg2Mw==", "bodyText": "This check is useless. The file couldn't be a file and a directory at the same time.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434561863", "createdAt": "2020-06-03T13:22:41Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 233}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTM5OTEy", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423539912", "createdAt": "2020-06-03T13:15:59Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoxNTo1OVrOGebSjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzoyNjo1M1rOGebugw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1NzU4MQ==", "bodyText": "Non-alphabetical order", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434557581", "createdAt": "2020-06-03T13:15:59Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "diffHunk": "@@ -15,26 +15,26 @@\n import * as fs from \"fs\";\n import * as net from \"net\";\n import * as vscode from \"vscode\";\n-import { LANGUAGE_ID } from \"../constants\";\n-import {CancellationToken, ConfigurationParams, ConfigurationRequest, LanguageClient, LanguageClientOptions, StreamInfo} from \"vscode-languageclient\";\n+import { LanguageClient, LanguageClientOptions, StreamInfo, ConfigurationRequest, ConfigurationParams} from \"vscode-languageclient\";\n import { ConfigurationWorkspaceMiddleware } from \"vscode-languageclient/lib/configuration\";\n-import { CopybooksPathGenerator } from \"./CopybooksPathGenerator\";\n+import { LANGUAGE_ID } from \"../constants\";\n import { JavaCheck } from \"./JavaCheck\";\n+import { Middleware } from \"./Middleware\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1ODQzMA==", "bodyText": "The line indent not adjusted", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434558430", "createdAt": "2020-06-03T13:17:22Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "diffHunk": "@@ -49,22 +49,21 @@ export class LanguageClientService {\n     private createClientOptions(): LanguageClientOptions {\n         const signatureFunc: ConfigurationRequest.MiddlewareSignature = async (\n             params: ConfigurationParams,\n-            token: CancellationToken,\n+            token: vscode.CancellationToken,\n             next: ConfigurationRequest.HandlerSignature) => {\n-\n-            // TODO if request params are right\n-            return (await this.copybooksPathGenerator.listUris()).map(uri => uri.toString());\n-            // TODO else return next(params, token);\n+                return await this.middleware.handleConfigurationRequest(params, token, next);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU1ODU3NA==", "bodyText": "Extra line", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434558574", "createdAt": "2020-06-03T13:17:35Z", "author": {"login": "temanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts", "diffHunk": "@@ -49,22 +49,21 @@ export class LanguageClientService {\n     private createClientOptions(): LanguageClientOptions {\n         const signatureFunc: ConfigurationRequest.MiddlewareSignature = async (\n             params: ConfigurationParams,\n-            token: CancellationToken,\n+            token: vscode.CancellationToken,\n             next: ConfigurationRequest.HandlerSignature) => {\n-\n-            // TODO if request params are right\n-            return (await this.copybooksPathGenerator.listUris()).map(uri => uri.toString());\n-            // TODO else return next(params, token);\n+                return await this.middleware.handleConfigurationRequest(params, token, next);\n         };\n         const configurationMiddleware: ConfigurationWorkspaceMiddleware = {\n             configuration: signatureFunc,\n         };\n \n         return {\n             documentSelector: [LANGUAGE_ID],\n-            middleware: { workspace: configurationMiddleware }\n+            middleware: { workspace: configurationMiddleware },\n         };\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2MTA5NA==", "bodyText": "I think it is better to mark WatcherServiceImpl#addWatchers and WatcherServiceImpl#removeWatchers as synchronized to reduce the sync area", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434561094", "createdAt": "2020-06-03T13:21:31Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CobolWorkspaceServiceImpl.java", "diffHunk": "@@ -67,66 +76,72 @@ public CobolWorkspaceServiceImpl(DataBusBroker dataBus, Provider<LanguageClient>\n   @Nonnull\n   @Override\n   public CompletableFuture<Object> executeCommand(@Nonnull ExecuteCommandParams params) {\n+    runAsync(executeCopybookFix(params)).whenComplete(reportExceptionIfFound(params));\n+\n     return completedFuture(null);\n   }\n \n+  private Runnable executeCopybookFix(@Nonnull ExecuteCommandParams params) {\n+    return () -> {\n+      if (MISSING_COPYBOOK.name().equals(params.getCommand())) {\n+        rerunAnalysis();\n+      }\n+    };\n+  }\n+\n   /**\n-   * This is a notification triggered automatically when the user modify configuration settings in\n-   * the client\n+   * Process changed configuration on the client state. This notification triggered automatically\n+   * when the user modify configuration settings in the client. Invalidate all the caches to avoid\n+   * dirty state.\n    *\n    * @param params - LSPSpecification -> The actual changed settings; Actually -> null all the time.\n    */\n   @Override\n   public void didChangeConfiguration(DidChangeConfigurationParams params) {\n-    try {\n-\n-      // invalidate cache to avoid false positive\n-      dataBus.invalidateCache();\n-      fetchSettings(LSP_PREFIX.label + \".\" + CPY_MANAGER.label, null)\n-          .thenAccept(e -> dataBus.postData(FetchedSettingsEvent.builder().content(e).build()));\n-    } catch (RuntimeException e) {\n-      log.error(e.getMessage());\n-    }\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> acceptSettingsChange(toStrings(it)));\n   }\n \n-  /**\n-   * After client notifies the server that there is a setting change we need to request the client\n-   * those changing by sending a workspace/configuration JSON request\n-   *\n-   * @param section - The configuration section asked for.\n-   * @param scope - The scope to get the configuration section for.\n-   * @return - CompletedFuture which contains an object with the settings asked for.\n-   */\n-  private CompletableFuture<List<Object>> fetchSettings(String section, String scope) {\n-    ConfigurationParams params =\n-        new ConfigurationParams(provideConfigurationItemList(section, scope));\n-    return clientProvider.get().configuration(params);\n+  private void acceptSettingsChange(List<String> localFolders) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDUyOTY1NQ=="}, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 119}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NDczOQ==", "bodyText": "Probably, some forgotten code", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434564739", "createdAt": "2020-06-03T13:26:53Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WorkspaceServiceTest.java", "diffHunk": "@@ -47,48 +51,171 @@\n  * implementation.\n  */\n @Slf4j\n+@SuppressWarnings(\"unchecked\")\n public class WorkspaceServiceTest {\n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n-   * not recognized.\n+   * Test of the workspace/executeCommand entry point. Assert that on a MISSING_COPYBOOK the {@link\n+   * RequiredCopybookEvent} fired.\n    */\n   @Test\n-  public void testExecuteNonExistingCommand() {\n+  public void testExecuteCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    String copybookName = \"COPYBOOK\";\n+\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n+        service.executeCommand(\n+            new ExecuteCommandParams(\n+                MISSING_COPYBOOK.name(),\n+                asList(new JsonPrimitive(copybookName), new JsonPrimitive(DOCUMENT_URI))));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, timeout(1000).times(0)).postData(any());\n+    verify(broker, timeout(10000)).invalidateCache();\n+    verify(broker, timeout(10000)).postData(any(RunAnalysisEvent.class));\n   }\n \n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the argument\n-   * list is incomplete.\n+   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n+   * not recognized.\n    */\n   @Test\n-  public void testExecuteCommandIncorrectArguments() {\n+  public void testExecuteNonExistingCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(\n-            new ExecuteCommandParams(\n-                MISSING_COPYBOOK.name(), singletonList(new JsonPrimitive(DOCUMENT_URI))));\n+        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, never()).postData(any());\n+    verify(broker, timeout(1000).times(0)).postData(any());\n+  }\n+\n+  /** Test a new watcher created when a new path add in setting.json */\n+  @Test\n+  public void testChangeConfigurationNewPath() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(watcherCaptor.capture());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path list not changed */\n+  @Test\n+  public void testChangeConfigurationNoChangesInPaths() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n   }\n+\n+  /** Test an existing watcher removed when its path doesn't exist in setting.json */\n+  @Test\n+  public void testChangeConfigurationPathRemoved() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(watcherCaptor.capture());\n+    verify(copybookService).invalidateURICache();\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path is empty */\n+  @Test\n+  public void testChangeConfigurationNoPathToRegister() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+  }\n+\n+  /**\n+   * This test verifies that the Workspace Service reacts on the file created watcher's\n+   * notifications\n+   */\n+  @Test\n+  public void testDidChangeWatchedFilesExistingFileCreated() {\n+    log.error(\"asdd\", new Error());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNTUzMjYx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423553261", "createdAt": "2020-06-03T13:30:46Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzozMDo0NlrOGeb4-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMzozMDo0NlrOGeb4-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDU2NzQxOQ==", "bodyText": "hasFileValidExtension function use equalsIgnoreCase, we can drop .toLowerCase() here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434567419", "createdAt": "2020-06-03T13:30:46Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")\n+        && FilenameUtils.getBaseName(currentFile.getName()).equalsIgnoreCase(requiredName)\n+        && hasFileValidExtension(currentFile.getAbsoluteFile().toString().toLowerCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 236}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjEwNzg2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423610786", "createdAt": "2020-06-03T14:27:57Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyNzo1N1rOGeegxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyNzo1N1rOGeegxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMDM3NQ==", "bodyText": "I would suggest to make it plural", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434610375", "createdAt": "2020-06-03T14:27:57Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,122 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final SettingsService settingsService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+          DataBusBroker dataBus, SettingsService settingsService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.settingsService = settingsService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n-  /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n-   *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n   @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n+  public void invalidateURICache() {\n+    copybookPath.clear();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 107}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjEyNDQ0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423612444", "createdAt": "2020-06-03T14:29:31Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyOTozMVrOGeelaA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDoyOTozMVrOGeelaA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMTU2MA==", "bodyText": "Do we really need this message?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434611560", "createdAt": "2020-06-03T14:29:31Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/WorkspaceServiceTest.java", "diffHunk": "@@ -47,48 +51,171 @@\n  * implementation.\n  */\n @Slf4j\n+@SuppressWarnings(\"unchecked\")\n public class WorkspaceServiceTest {\n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n-   * not recognized.\n+   * Test of the workspace/executeCommand entry point. Assert that on a MISSING_COPYBOOK the {@link\n+   * RequiredCopybookEvent} fired.\n    */\n   @Test\n-  public void testExecuteNonExistingCommand() {\n+  public void testExecuteCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    String copybookName = \"COPYBOOK\";\n+\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n+        service.executeCommand(\n+            new ExecuteCommandParams(\n+                MISSING_COPYBOOK.name(),\n+                asList(new JsonPrimitive(copybookName), new JsonPrimitive(DOCUMENT_URI))));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, timeout(1000).times(0)).postData(any());\n+    verify(broker, timeout(10000)).invalidateCache();\n+    verify(broker, timeout(10000)).postData(any(RunAnalysisEvent.class));\n   }\n \n   /**\n-   * Test of the workspace/executeCommand entry point. Assert no changes applied if the argument\n-   * list is incomplete.\n+   * Test of the workspace/executeCommand entry point. Assert no changes applied if the command name\n+   * not recognized.\n    */\n   @Test\n-  public void testExecuteCommandIncorrectArguments() {\n+  public void testExecuteNonExistingCommand() {\n     DataBusBroker broker = mock(DataBusBroker.class);\n-    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null);\n+    WorkspaceService service = new CobolWorkspaceServiceImpl(broker, null, null, null);\n \n     CompletableFuture<Object> result =\n-        service.executeCommand(\n-            new ExecuteCommandParams(\n-                MISSING_COPYBOOK.name(), singletonList(new JsonPrimitive(DOCUMENT_URI))));\n+        service.executeCommand(new ExecuteCommandParams(\"Missing command name\", emptyList()));\n \n     try {\n       assertNull(result.get());\n     } catch (InterruptedException | ExecutionException e) {\n       fail(e.getMessage());\n     }\n-    verify(broker, never()).postData(any());\n+    verify(broker, timeout(1000).times(0)).postData(any());\n+  }\n+\n+  /** Test a new watcher created when a new path add in setting.json */\n+  @Test\n+  public void testChangeConfigurationNewPath() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(watcherCaptor.capture());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path list not changed */\n+  @Test\n+  public void testChangeConfigurationNoChangesInPaths() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label))\n+        .thenReturn(completedFuture(singletonList(arr)));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n   }\n+\n+  /** Test an existing watcher removed when its path doesn't exist in setting.json */\n+  @Test\n+  public void testChangeConfigurationPathRemoved() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    ArgumentCaptor<List<String>> watcherCaptor = forClass(List.class);\n+    JsonArray arr = new JsonArray();\n+    String path = \"foo/bar\";\n+    arr.add(new JsonPrimitive(path));\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(singletonList(path));\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(watcherCaptor.capture());\n+    verify(copybookService).invalidateURICache();\n+    assertEquals(path, watcherCaptor.getValue().get(0));\n+\n+    verify(broker).postData(any(RunAnalysisEvent.class));\n+  }\n+\n+  /** Test no watchers added or removed when the path is empty */\n+  @Test\n+  public void testChangeConfigurationNoPathToRegister() {\n+    DefaultDataBusBroker broker = mock(DefaultDataBusBroker.class);\n+    SettingsService settingsService = mock(SettingsService.class);\n+    WatcherService watchingService = mock(WatcherService.class);\n+    CopybookService copybookService = mock(CopybookService.class);\n+\n+    WorkspaceService workspaceService =\n+        new CobolWorkspaceServiceImpl(broker, settingsService, watchingService, copybookService);\n+\n+    when(settingsService.getConfiguration(LOCAL_PATHS.label)).thenReturn(completedFuture(emptyList()));\n+    when(watchingService.getWatchingFolders()).thenReturn(emptyList());\n+\n+    workspaceService.didChangeConfiguration(new DidChangeConfigurationParams(null));\n+\n+    verify(watchingService).addWatchers(emptyList());\n+    verify(watchingService).removeWatchers(emptyList());\n+    verify(copybookService).invalidateURICache();\n+  }\n+\n+  /**\n+   * This test verifies that the Workspace Service reacts on the file created watcher's\n+   * notifications\n+   */\n+  @Test\n+  public void testDidChangeWatchedFilesExistingFileCreated() {\n+    log.error(\"asdd\", new Error());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 211}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjE0NTQy", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423614542", "createdAt": "2020-06-03T14:31:32Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozMTozMlrOGeerqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozMTozMlrOGeerqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzE2MA==", "bodyText": "But this method is not returning a String but a List of strings.. I am not sure that is correct this name..", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434613160", "createdAt": "2020-06-03T14:31:32Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyLanguageServerImpl.java", "diffHunk": "@@ -162,10 +106,23 @@ void retrieveAndStoreConfiguration() {\n         new WorkspaceServerCapabilities(workspaceFoldersOptions);\n     capabilities.setWorkspace(workspaceServiceCapabilities);\n \n-    copybookService.setWorkspaceFolders(params.getWorkspaceFolders());\n     return supplyAsync(() -> new InitializeResult(capabilities));\n   }\n \n+  private void addLocalFilesWatcher() {\n+    settingsService\n+        .getConfiguration(LOCAL_PATHS.label)\n+        .thenAccept(it -> watchingService.addWatchers(toStrings(it)));\n+  }\n+\n+  private List<String> toStrings(List<Object> it) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 147}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjE0ODQ1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423614845", "createdAt": "2020-06-03T14:31:51Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozMTo1MlrOGeesfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozMTo1MlrOGeesfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxMzM3NQ==", "bodyText": "Newline here! Is it a time to enable static code checks as part of CI?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434613375", "createdAt": "2020-06-03T14:31:52Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/actions/FindCopybookCommandTest.java", "diffHunk": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.service.delegates.actions;\n+\n+import org.eclipse.lsp4j.*;\n+import org.eclipse.lsp4j.jsonrpc.messages.Either;\n+import org.junit.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static java.util.Collections.singletonList;\n+import static org.eclipse.lsp4j.CodeActionKind.QuickFix;\n+import static org.eclipse.lsp4j.DiagnosticSeverity.Error;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+\n+/**\n+ * Test {@link FindCopybookCommand} code action provider that resolves diagnostics for missing\n+ * copybooks.\n+ */\n+public class FindCopybookCommandTest {\n+\n+    private static final String TITLE = \"Fetch copybook\";\n+    private static final String COPYBOOK_NAME = \"CPYNAME\";\n+\n+    private static final Range RANGE = new Range(new Position(0, 0), new Position(0, 1));\n+    private static final Diagnostic SYNTAX_ERROR =\n+            new Diagnostic(RANGE, \"Syntax error\", Error, null, null);\n+    private static final Diagnostic COPYBOOK_ERROR =\n+            new Diagnostic(\n+                    RANGE, COPYBOOK_NAME + \": Copybook not found\", Error, null, MISSING_COPYBOOK.name());\n+\n+    /** Test a code action to resolve the required copybook created for the missing copybook error. */\n+    @Test\n+    public void testCollectCommandsOrActionsPositive() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    /** Test nothing created for a syntax error. */\n+    @Test\n+    public void testCollectCommandsOrActionsNegative() {\n+\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = singletonList(SYNTAX_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(0, actions.size());\n+    }\n+\n+    /** Test only correct errors processed. */\n+    @Test\n+    public void testCollectCommandsOrActionsMixed() {\n+        CodeActionProvider provider = new FindCopybookCommand();\n+\n+        List<Diagnostic> diagnostics = Arrays.asList(SYNTAX_ERROR, COPYBOOK_ERROR);\n+        CodeActionParams params =\n+                new CodeActionParams(\n+                        new TextDocumentIdentifier(DOCUMENT_URI), RANGE, new CodeActionContext(diagnostics));\n+\n+        List<Either<Command, CodeAction>> actions = provider.collectCommandsOrActions(params);\n+\n+        assertEquals(1, actions.size());\n+\n+        CodeAction action = actions.get(0).getRight();\n+        assertCorrectCodeAction(action);\n+    }\n+\n+    private void assertCorrectCodeAction(CodeAction action) {\n+        assertEquals(TITLE, action.getTitle());\n+        assertEquals(QuickFix, action.getKind());\n+        assertEquals(COPYBOOK_ERROR, action.getDiagnostics().get(0));\n+        assertNull(action.getEdit());\n+\n+        Command command = action.getCommand();\n+        assertEquals(TITLE, command.getTitle());\n+        assertEquals(MISSING_COPYBOOK.name(), command.getCommand());\n+\n+        List<Object> arguments = command.getArguments();\n+        assertEquals(2, arguments.size());\n+        assertEquals(COPYBOOK_NAME, arguments.get(0));\n+        assertEquals(DOCUMENT_URI, arguments.get(1));\n+    }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNjE5NDgz", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423619483", "createdAt": "2020-06-03T14:36:30Z", "commit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozNjozMFrOGee6hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNDozNjozMFrOGee6hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYxNjk2NQ==", "bodyText": "what about to introduce a small Facade that accept the mode (DID_OPEN or DID_CHANGE) and invoke the correct implementation? The thing that analyzeDocumentFirstTime could be executed when we need to use DID_OPEN mode could not be clear for the developer", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434616965", "createdAt": "2020-06-03T14:36:30Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/MyTextDocumentService.java", "diffHunk": "@@ -195,7 +198,7 @@ public void didSave(DidSaveTextDocumentParams params) {\n \n   @Override\n   public void observerCallback(@Nonnull RunAnalysisEvent event) {\n-    docs.forEach((key, value) -> analyzeChanges(key, value.getText()));\n+    docs.forEach((key, value) -> analyzeDocumentFirstTime(key, value.getText()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0bbde763af1a96a543afaae0e8ce9bfcc851b85"}, "originalPosition": 17}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNzcwNTQz", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423770543", "createdAt": "2020-06-03T17:20:39Z", "commit": {"oid": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoyMDo0MFrOGel4hQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxNzoyMTowNlrOGel5jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTE0MQ==", "bodyText": "Better naming would be ClientSettingsService or LanguageClientSettingsService", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434731141", "createdAt": "2020-06-03T17:20:40Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsService.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ *\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDczMTQwNw==", "bodyText": "respective to above interface", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434731407", "createdAt": "2020-06-03T17:21:06Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/SettingsServiceImpl.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "46ae6e8269d21e41d0df0b301cb73e9ba18c3605"}, "originalPosition": 2}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b1522423610609b80eaeccb91c13259602e91d5", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3b1522423610609b80eaeccb91c13259602e91d5", "committedDate": "2020-06-04T10:11:01Z", "message": "refactor: Remove POC vsc commands GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4445649ea0b39c6a4ab5ebf1df27ca3506eac3a6", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4445649ea0b39c6a4ab5ebf1df27ca3506eac3a6", "committedDate": "2020-06-04T10:11:18Z", "message": "refactor: Invoke handleQueue() from start() GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ddb641328b520948fbb5e810f02dc87ee7e11e0", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4ddb641328b520948fbb5e810f02dc87ee7e11e0", "committedDate": "2020-06-04T10:11:33Z", "message": "refactor: Remove unused function GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "caec99f76090d57624096d0e637c0910123796b3", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/caec99f76090d57624096d0e637c0910123796b3", "committedDate": "2020-06-04T10:11:44Z", "message": "refactor: Use fs API for Node 10x and apply linting GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c2e9dbf71fbf67cfbd490f7ff8aabf4ab5b3b84", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7c2e9dbf71fbf67cfbd490f7ff8aabf4ab5b3b84", "committedDate": "2020-06-04T10:11:58Z", "message": "refactor: Apply linting GH-23 GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "932ffb8f3115933233b5981ee4e240a15970e5eb", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/932ffb8f3115933233b5981ee4e240a15970e5eb", "committedDate": "2020-06-04T10:12:13Z", "message": "refactor: Don't resolve copybooks in unregistered local folders GH-355\nInvalidate cached URIs when watcher list chagned."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6bd5a017a9a2c25b1abba883122e1918f0bbb7b2", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6bd5a017a9a2c25b1abba883122e1918f0bbb7b2", "committedDate": "2020-06-04T10:12:24Z", "message": "refactor: Rename ClientService to SettingsService\n\nAdd the header to Middleware.ts\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dfe575ae00412b4a9ad50add97fe1094e4c6381d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/dfe575ae00412b4a9ad50add97fe1094e4c6381d", "committedDate": "2020-06-04T10:12:25Z", "message": "refactor: Remove dead code #23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b6be411b01298b38c02c4b844192fa673a7a2539", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b6be411b01298b38c02c4b844192fa673a7a2539", "committedDate": "2020-06-04T10:12:25Z", "message": "refactor: Remove obsolete code #23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "989a279ed02e9753e46c1bfeeed6aa9ec9690e4d", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/989a279ed02e9753e46c1bfeeed6aa9ec9690e4d", "committedDate": "2020-06-04T10:12:25Z", "message": "refactor: Apply linting GH-23 GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43413f657530a08ffdb87189e0055002a6efcddc", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/43413f657530a08ffdb87189e0055002a6efcddc", "committedDate": "2020-06-04T10:12:25Z", "message": "refactor: Make watchers registration thread-safe GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aa6321f9b2178c603ea783d990ebbb4d3e98273", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6aa6321f9b2178c603ea783d990ebbb4d3e98273", "committedDate": "2020-06-04T10:12:43Z", "message": "Merge remote-tracking branch 'origin/fetch-priority-final' into fetch-priority-final\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/services/Middleware.ts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e489c0665e725771722ea9a387cd5049b0f7db0", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8e489c0665e725771722ea9a387cd5049b0f7db0", "committedDate": "2020-06-04T10:12:44Z", "message": "refactor: Address request of change GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40b79841619dcea771476cc9722d4715e2e53801", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/40b79841619dcea771476cc9722d4715e2e53801", "committedDate": "2020-06-04T10:12:53Z", "message": "Merge remote-tracking branch 'origin/fetch-priority-final' into fetch-priority-final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21387d29a6d2cb67334aa6b1c0416c28b0b8de26", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/21387d29a6d2cb67334aa6b1c0416c28b0b8de26", "committedDate": "2020-06-04T10:12:54Z", "message": "refactor: Address request of change GH-23 GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ea7c0706577299a017ba6ea66993bc1dcc99c2d5", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ea7c0706577299a017ba6ea66993bc1dcc99c2d5", "committedDate": "2020-06-04T10:13:06Z", "message": "refactor: Extract monade method to reduce code duplication GH-23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47b6a434b339b0de832aec354816f7caec9c5e50", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/47b6a434b339b0de832aec354816f7caec9c5e50", "committedDate": "2020-06-04T10:14:23Z", "message": "Merge branch 'fetch-priority-final' of https://github.com/eclipse/che-che4z-lsp-for-cobol into fetch-priority-final"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "875815ae7a7fbb2974146bf8f0097e8f98b34530", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/875815ae7a7fbb2974146bf8f0097e8f98b34530", "committedDate": "2020-06-04T10:14:24Z", "message": "refactor: Address request of change GH-23 GH-376"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "278f2981bbe67a9014aab6874e1bfeaddd0b3ce8", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/278f2981bbe67a9014aab6874e1bfeaddd0b3ce8", "committedDate": "2020-06-04T10:14:37Z", "message": "refactor: Move all the posiible settings parameters to one enum #327"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b18e141049bbf3df56f257ae0d46bc92ad8a58c6", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b18e141049bbf3df56f257ae0d46bc92ad8a58c6", "committedDate": "2020-06-04T10:14:37Z", "message": "refactor: Make response parsing null safe #327"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5e5cf34d287effef08ccf00c8f953999c398d289", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5e5cf34d287effef08ccf00c8f953999c398d289", "committedDate": "2020-06-04T10:14:37Z", "message": "refactor: Adjust class indentation #23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "80220be25da328e2d2e4f168f7bb17310832fa11", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/80220be25da328e2d2e4f168f7bb17310832fa11", "committedDate": "2020-06-04T10:14:37Z", "message": "test: Remove folder structure to avoid dirty state #23"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3251228ce4a493061b35e22b37120bc61e2d153d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3251228ce4a493061b35e22b37120bc61e2d153d", "committedDate": "2020-06-04T09:56:58Z", "message": "test: Remove folder structure to avoid dirty state #23"}, "afterCommit": {"oid": "80220be25da328e2d2e4f168f7bb17310832fa11", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/80220be25da328e2d2e4f168f7bb17310832fa11", "committedDate": "2020-06-04T10:14:37Z", "message": "test: Remove folder structure to avoid dirty state #23"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzA0Mzg5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-424304389", "createdAt": "2020-06-04T10:21:26Z", "commit": {"oid": "80220be25da328e2d2e4f168f7bb17310832fa11"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzA0NTQ5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-424304549", "createdAt": "2020-06-04T10:21:36Z", "commit": {"oid": "80220be25da328e2d2e4f168f7bb17310832fa11"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MzM3ODcy", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-424337872", "createdAt": "2020-06-04T11:11:55Z", "commit": {"oid": "80220be25da328e2d2e4f168f7bb17310832fa11"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "681cb50681ff03b860271ba4a5b1ff0027256163", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/681cb50681ff03b860271ba4a5b1ff0027256163", "committedDate": "2020-04-16T11:09:56Z", "message": "Add test to parse json like settings"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "debf4657c25a45ebd21c5e21ecd12e857555b21c", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/debf4657c25a45ebd21c5e21ecd12e857555b21c", "committedDate": "2020-06-02T10:00:30Z", "message": "refactor: Add check for non-existing copybook file #355"}, "afterCommit": {"oid": "4a9db1f5f3f93a7384a997389668551cdf4d9c23", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4a9db1f5f3f93a7384a997389668551cdf4d9c23", "committedDate": "2020-06-02T10:50:56Z", "message": "refactor: Add check for non-existing copybook file #355"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a9db1f5f3f93a7384a997389668551cdf4d9c23", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4a9db1f5f3f93a7384a997389668551cdf4d9c23", "committedDate": "2020-06-02T10:50:56Z", "message": "refactor: Add check for non-existing copybook file #355"}, "afterCommit": {"oid": "8d13d50e421b0f0bdcbfa37fcf58eb75c3bad258", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8d13d50e421b0f0bdcbfa37fcf58eb75c3bad258", "committedDate": "2020-06-02T11:32:20Z", "message": "refactor: Add check for non-existing copybook file #355"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8d13d50e421b0f0bdcbfa37fcf58eb75c3bad258", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8d13d50e421b0f0bdcbfa37fcf58eb75c3bad258", "committedDate": "2020-06-02T11:32:20Z", "message": "refactor: Add check for non-existing copybook file #355"}, "afterCommit": {"oid": "3fa27292b279346025b333a08f8e3103742c735a", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3fa27292b279346025b333a08f8e3103742c735a", "committedDate": "2020-06-02T11:50:06Z", "message": "refactor: Add check for non-existing copybook file #355"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3fa27292b279346025b333a08f8e3103742c735a", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3fa27292b279346025b333a08f8e3103742c735a", "committedDate": "2020-06-02T11:50:06Z", "message": "refactor: Add check for non-existing copybook file #355"}, "afterCommit": {"oid": "fe352b6ceda6a5fb98aef425dab1f65809a95905", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fe352b6ceda6a5fb98aef425dab1f65809a95905", "committedDate": "2020-06-02T11:56:45Z", "message": "refactor: Add check for non-existing copybook file #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e65fcb569c535189d26074d8c73180264f4e4939", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e65fcb569c535189d26074d8c73180264f4e4939", "committedDate": "2020-06-02T12:19:36Z", "message": "refactor: Introduce on-demand client configuration calls GH-327\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3029af7b967ba7eaa794bad5208fa48b61aa3940", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3029af7b967ba7eaa794bad5208fa48b61aa3940", "committedDate": "2020-06-02T12:21:47Z", "message": "Merge pull request #360 from grianbrcom/hackathon\n\nSettings request PoC."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fe352b6ceda6a5fb98aef425dab1f65809a95905", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fe352b6ceda6a5fb98aef425dab1f65809a95905", "committedDate": "2020-06-02T11:56:45Z", "message": "refactor: Add check for non-existing copybook file #355"}, "afterCommit": {"oid": "e00072c4ce656db9ef5b88c11bce5f8f7b3880a0", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e00072c4ce656db9ef5b88c11bce5f8f7b3880a0", "committedDate": "2020-06-02T12:22:32Z", "message": "refactor: Add check for non-existing copybook file #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "098f4bc4fab1476f6f9faad5f07182bba639784f", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/098f4bc4fab1476f6f9faad5f07182bba639784f", "committedDate": "2020-06-02T12:29:03Z", "message": "feat: Fetch copybooks without .dep files GH-327\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49ea34b7de8d6c58e09c243a0c7ccad93aa414ab", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/49ea34b7de8d6c58e09c243a0c7ccad93aa414ab", "committedDate": "2020-06-02T12:29:43Z", "message": "refactor: Clean-up ClientService GH-327\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9550d1186d2649763d31ed809b113c01665f2571", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9550d1186d2649763d31ed809b113c01665f2571", "committedDate": "2020-06-02T12:31:26Z", "message": "Merge pull request #361 from grianbrcom/hackathon\n\nHackathon"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "70aad367972fa8a12c2fcfdb198917d9c9419f1c", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/70aad367972fa8a12c2fcfdb198917d9c9419f1c", "committedDate": "2020-06-02T12:31:27Z", "message": "Merge pull request #362 from grianbrcom/hackathon\n\nFix analyse and rewrite ClientService"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cc95d6978e0fbfff3764c9e5cbedacc9059b09db", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cc95d6978e0fbfff3764c9e5cbedacc9059b09db", "committedDate": "2020-06-02T12:31:27Z", "message": "refactor: Move copybook fetch Quick Fix to the server GH-327"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa665044793615413805367db574a1bdd818a490", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fa665044793615413805367db574a1bdd818a490", "committedDate": "2020-06-02T12:31:59Z", "message": "refactor: Interrupt a thread that had an exception #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3909b849ec0d5fe8494614a305351fe5a58e8a0d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3909b849ec0d5fe8494614a305351fe5a58e8a0d", "committedDate": "2020-06-02T12:31:59Z", "message": "refactor: Remove deprecated settings provider #355"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e00072c4ce656db9ef5b88c11bce5f8f7b3880a0", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e00072c4ce656db9ef5b88c11bce5f8f7b3880a0", "committedDate": "2020-06-02T12:22:32Z", "message": "refactor: Add check for non-existing copybook file #355"}, "afterCommit": {"oid": "84df73adba5b9d9fa790141725c55af05dcc09c4", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/84df73adba5b9d9fa790141725c55af05dcc09c4", "committedDate": "2020-06-02T12:34:53Z", "message": "refactor: Add check for non-existing copybook file #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0358b9541c2a9e0b9410c43a3a6b13ab324cb5e2", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0358b9541c2a9e0b9410c43a3a6b13ab324cb5e2", "committedDate": "2020-06-02T12:37:47Z", "message": "feat: Introduce dynamic registration for watchers GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6510533cf02ca74cf83911f0b8bcd5e1d2db763", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f6510533cf02ca74cf83911f0b8bcd5e1d2db763", "committedDate": "2020-06-02T12:37:56Z", "message": "tests: Adjust Workspace Service unit test #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0e3eeb57da431594cb28ba79216b52b66e5c553d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0e3eeb57da431594cb28ba79216b52b66e5c553d", "committedDate": "2020-06-02T12:37:56Z", "message": "refactor: Make configuration calls async #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "715179e5fed2342fb5a97d317bddaac15205030d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/715179e5fed2342fb5a97d317bddaac15205030d", "committedDate": "2020-06-02T12:37:56Z", "message": "refactor:Make Watching Service a singleton #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7117683e8ff09c067d850cda9be2f7957630bca1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7117683e8ff09c067d850cda9be2f7957630bca1", "committedDate": "2020-06-02T12:37:56Z", "message": "fix: Fix glob pattern for dynamic registration #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "010b756f3b5c70e3c218a40661943a200cd642c3", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/010b756f3b5c70e3c218a40661943a200cd642c3", "committedDate": "2020-06-02T12:37:56Z", "message": "test: Adjust Language Server test to the new requirements #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3b42dbc079c4df8a2a20b2cc492ea403944b5e9e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3b42dbc079c4df8a2a20b2cc492ea403944b5e9e", "committedDate": "2020-06-02T12:37:56Z", "message": "tests: Adjust tests to new requirements #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b82e96461195421724f6494ef76a7edefcaed26", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9b82e96461195421724f6494ef76a7edefcaed26", "committedDate": "2020-06-02T12:37:56Z", "message": "test: Remove deprecated tests #355"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "84df73adba5b9d9fa790141725c55af05dcc09c4", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/84df73adba5b9d9fa790141725c55af05dcc09c4", "committedDate": "2020-06-02T12:34:53Z", "message": "refactor: Add check for non-existing copybook file #355"}, "afterCommit": {"oid": "177be4fd2bb27d904f093bf06346947531684156", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/177be4fd2bb27d904f093bf06346947531684156", "committedDate": "2020-06-02T12:38:41Z", "message": "refactor: Add check for non-existing copybook file #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3ea69edf69923f6afec650bde6c1b51ff010aff9", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3ea69edf69923f6afec650bde6c1b51ff010aff9", "committedDate": "2020-06-02T12:44:31Z", "message": "test: Add test related to path validation GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b594f074ca1dda3751fd92574d523dc365d6c39", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6b594f074ca1dda3751fd92574d523dc365d6c39", "committedDate": "2020-06-02T12:44:46Z", "message": "refactor: Exclude invalid URIs on paths parsing GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "859c3f53593741475f546ecfe2892bc7d92b39e7", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/859c3f53593741475f546ecfe2892bc7d92b39e7", "committedDate": "2020-06-02T12:46:08Z", "message": "refactor: Introduce URI validation in the Local Copybook Resolver GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3781fc6f259ef463e1fa9cf61e37e728913902fe", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3781fc6f259ef463e1fa9cf61e37e728913902fe", "committedDate": "2020-06-02T12:46:30Z", "message": "refactor: Apply more descriptive name for class and test GH-23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "96d3c99093bd1f2bf82801dd9f95b2569d25c090", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/96d3c99093bd1f2bf82801dd9f95b2569d25c090", "committedDate": "2020-06-02T12:47:23Z", "message": "test: Add unit test to avoid duplicates in URI list GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6a053212accd15c3c28f3a190c9ba977e326021b", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6a053212accd15c3c28f3a190c9ba977e326021b", "committedDate": "2020-06-02T12:47:37Z", "message": "test: Polish test suite and minor changes GH-23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5c614a695862f5114237f14742da888e630b79e8", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5c614a695862f5114237f14742da888e630b79e8", "committedDate": "2020-06-02T12:47:54Z", "message": "refactor: Minor changes on API naming and documentation GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f76c5226a4119a65edfcca0fd1de7ec4fba9874b", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f76c5226a4119a65edfcca0fd1de7ec4fba9874b", "committedDate": "2020-06-02T12:48:23Z", "message": "refactor: Minor changes on API GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8ccdb983b43055dad6ae9cbc97b684614f7a2fc", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a8ccdb983b43055dad6ae9cbc97b684614f7a2fc", "committedDate": "2020-06-02T12:48:47Z", "message": "Merge remote-tracking branch 'remotes/origin/development' into POC_LocalURISetting\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "572c86ee036b8d9b8334b4699f8698c5729d02a3", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/572c86ee036b8d9b8334b4699f8698c5729d02a3", "committedDate": "2020-06-02T12:48:48Z", "message": "Address merge conflicts with development"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "286daefb632119f89e47e59fc8065decf2edc99e", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/286daefb632119f89e47e59fc8065decf2edc99e", "committedDate": "2020-06-02T12:48:55Z", "message": "refactor: Address conflict with existent path key in json definition GH-327"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89555943a5d26b08e6d2544799521ac62a9dff05", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/89555943a5d26b08e6d2544799521ac62a9dff05", "committedDate": "2020-06-02T12:49:57Z", "message": "refactor: Add URI normalize to avoid unexpected result - as double slashes GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09b8016fefdfa414faebf6b6d0c5f78eafd3b5db", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/09b8016fefdfa414faebf6b6d0c5f78eafd3b5db", "committedDate": "2020-06-02T12:50:08Z", "message": "Update API to return URI in the result array"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d3a06880c5080ba42ef232bf189846d99f625f6", "author": {"user": {"login": "sergiuilie", "name": "Sergiu Ilie"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7d3a06880c5080ba42ef232bf189846d99f625f6", "committedDate": "2020-06-02T12:50:08Z", "message": "feat: Retrieve local copybooks if exists GH-327"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a82ee02d2b5d866550d12dfed4ad793789c7864", "author": {"user": {"login": "sergiuilie", "name": "Sergiu Ilie"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a82ee02d2b5d866550d12dfed4ad793789c7864", "committedDate": "2020-06-02T12:50:16Z", "message": "Merge remote-tracking branch 'origin/development' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/package.json\n#\tclients/cobol-lsp-vscode-extension/src/__tests__/LocalCopybookResolverTest.ts\n#\tclients/cobol-lsp-vscode-extension/src/constants.ts\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksPathGenerator.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/settings/LocalCopybookResolver.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/settings/util/SettingsUtils.ts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ebe933fc02d9fcca212b78ec586082e413e0727", "author": {"user": {"login": "sergiuilie", "name": "Sergiu Ilie"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4ebe933fc02d9fcca212b78ec586082e413e0727", "committedDate": "2020-06-02T12:50:17Z", "message": "refactor: Adjust variable declaration GH-23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d44c31426a24e47bd0237886267e07713026982c", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d44c31426a24e47bd0237886267e07713026982c", "committedDate": "2020-06-02T12:50:21Z", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0bbf921e0c0d4a4904a1281a1ce05c5d114d5aa8", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0bbf921e0c0d4a4904a1281a1ce05c5d114d5aa8", "committedDate": "2020-06-02T12:50:22Z", "message": "Test sending local URI from client to server GH-327"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "678b9181159a278a62bb9a947c316473faa9ea34", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/678b9181159a278a62bb9a947c316473faa9ea34", "committedDate": "2020-06-02T12:50:24Z", "message": "Address request change to readability improvements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "838ab89c97baf44cf28d08d314df5fd0198752b8", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/838ab89c97baf44cf28d08d314df5fd0198752b8", "committedDate": "2020-06-02T12:50:29Z", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4b945eefa9d6bda6a295a08aa6c65f267893f1b", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c4b945eefa9d6bda6a295a08aa6c65f267893f1b", "committedDate": "2020-06-02T12:50:36Z", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f540302efb8d9542f830e101908a5a3cb7e3822e", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f540302efb8d9542f830e101908a5a3cb7e3822e", "committedDate": "2020-06-02T12:50:36Z", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2482c926dd9b4ff9cee64bdc1c82fb41b4ae486b", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2482c926dd9b4ff9cee64bdc1c82fb41b4ae486b", "committedDate": "2020-06-02T12:50:40Z", "message": "Merge remote-tracking branch 'origin/fetch-priority' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/extension.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "781137d136e6746e52ff8bdae83b62ff3a98b426", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/781137d136e6746e52ff8bdae83b62ff3a98b426", "committedDate": "2020-06-02T12:50:41Z", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "018694134e19d64565ff552b15acd67085ef9dd2", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/018694134e19d64565ff552b15acd67085ef9dd2", "committedDate": "2020-06-02T12:50:41Z", "message": "test: Clean unit test for Copybook Resolver GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64ac0fa46330b13c67b8d78081fa11c73eaec2cc", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/64ac0fa46330b13c67b8d78081fa11c73eaec2cc", "committedDate": "2020-06-02T12:50:41Z", "message": "refactor: Clean up client part GH-23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9292bd6d9ffcb4f2f574b346ef0b74fd4b2392cb", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9292bd6d9ffcb4f2f574b346ef0b74fd4b2392cb", "committedDate": "2020-06-02T12:50:41Z", "message": "refactor: Refactor Middleware client part (GH-364)\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92de7e33f68ef000bea797ac4f65dd38034c3fd1", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/92de7e33f68ef000bea797ac4f65dd38034c3fd1", "committedDate": "2020-06-02T12:50:41Z", "message": "refactor: Clean up client part of copybook resolution GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "130bbe553896ebba481de0cdd8b7933b752d9636", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/130bbe553896ebba481de0cdd8b7933b752d9636", "committedDate": "2020-06-02T12:50:41Z", "message": "refactor: Fix middleware issue (GH-365)\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1afe03985110b5b71004a57953221c8c61a3c510", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1afe03985110b5b71004a57953221c8c61a3c510", "committedDate": "2020-06-02T12:50:41Z", "message": "fix: Fix issue with indirect overwrite settings conf for dsn paths"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "49d5730708035682fb3ef2fe5431c2122f6794fe", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/49d5730708035682fb3ef2fe5431c2122f6794fe", "committedDate": "2020-06-02T12:50:41Z", "message": "refactor: Remove obsolete prioritization on the client side"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee86a20208d0e4786be3929e7af072b27182bfb0", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ee86a20208d0e4786be3929e7af072b27182bfb0", "committedDate": "2020-06-02T12:50:45Z", "message": "Merge remote-tracking branch 'remotes/origin/copybooks-middleware' into fetch-priority\n\n# Conflicts:\n#\tclients/cobol-lsp-vscode-extension/src/services/LanguageClientService.ts\n#\tcom.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ac90c31f45c33e783e74cac7ff1be424a14f2eb", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9ac90c31f45c33e783e74cac7ff1be424a14f2eb", "committedDate": "2020-06-02T12:50:45Z", "message": "refactor: Fix cobol name extraction (GH-366)\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58048f62c926c9728de07fe5a748fff8289f0c14", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/58048f62c926c9728de07fe5a748fff8289f0c14", "committedDate": "2020-06-02T12:50:45Z", "message": "refactor: Introduce method to handle responsability for just add missing copybook in the internal queue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9552e3b51e607efbf9f00c70fd47257a7744e4f1", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9552e3b51e607efbf9f00c70fd47257a7744e4f1", "committedDate": "2020-06-02T12:50:45Z", "message": "test: Add client tests for middleware (GH-367)\n\nFiltering fetch copybook events only for didOpen.\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6657ccd6f53c7b285412b464a44ee47063580f56", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6657ccd6f53c7b285412b464a44ee47063580f56", "committedDate": "2020-06-02T12:50:45Z", "message": "refactor: Remove unused methods GH-23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39169e2c57e2e748990b95f1697a3b678c917691", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/39169e2c57e2e748990b95f1697a3b678c917691", "committedDate": "2020-06-02T12:50:45Z", "message": "fix: Fix issue related to copybook with extension that were not recognized as valid URI GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "842cfcc9451baba457b39d40f8b855850b833eb5", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/842cfcc9451baba457b39d40f8b855850b833eb5", "committedDate": "2020-06-02T12:50:46Z", "message": "Merge branch 'copybooks-middleware' into fetch-priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "783716b52d9c427884a2eefe8230d8fb6e9568a8", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/783716b52d9c427884a2eefe8230d8fb6e9568a8", "committedDate": "2020-06-02T12:50:46Z", "message": "test: Provide a unit test for Watching Service #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58e8305c23dac7a22bcd1d2809e54674de4624af", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/58e8305c23dac7a22bcd1d2809e54674de4624af", "committedDate": "2020-06-02T12:50:49Z", "message": "test: Improve CopybookURI.ts code coverage and address lint of javadoc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "163bee3dd43efbaae91ceea88203e3bceb315ff9", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/163bee3dd43efbaae91ceea88203e3bceb315ff9", "committedDate": "2020-06-02T12:50:50Z", "message": "Merge remote-tracking branch 'origin/fetch-priority' into fetch-priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e67f5b626e109aad45788805b0f3f9846abed86", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6e67f5b626e109aad45788805b0f3f9846abed86", "committedDate": "2020-06-02T12:50:55Z", "message": "Merge remote-tracking branch 'origin/fetch-priority' into fetch-priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a16eeb1993a523d759738f7e8586ce8dd3e81399", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a16eeb1993a523d759738f7e8586ce8dd3e81399", "committedDate": "2020-06-02T12:50:56Z", "message": "Merge branch 'development' into fetch-priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3713b3a2701016ab72670135065974fdaace8a87", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3713b3a2701016ab72670135065974fdaace8a87", "committedDate": "2020-06-02T12:50:56Z", "message": "refactor: Remove deprected tests #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0898b9a6ec8609ee4c4615bd8656f071a4f6ca80", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0898b9a6ec8609ee4c4615bd8656f071a4f6ca80", "committedDate": "2020-06-02T12:50:56Z", "message": "refactor: Delete unused classes GH-23\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb8074847eec320e0e899f0d3c19b82135756ab8", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fb8074847eec320e0e899f0d3c19b82135756ab8", "committedDate": "2020-06-02T12:50:56Z", "message": "test: Improved SettingsUtils unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3791c50c3df3689ea360b6a7d044c95545f3779b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3791c50c3df3689ea360b6a7d044c95545f3779b", "committedDate": "2020-06-02T12:50:56Z", "message": "Merge pull request #370 from grianbrcom/fp_fix\n\ndelete unused class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b305bc91f9952767ec52908cdd435a17970ccbf2", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b305bc91f9952767ec52908cdd435a17970ccbf2", "committedDate": "2020-06-02T12:50:57Z", "message": "Merge pull request GH-370 from grianbrcom/fp_fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4c1242bddfcbd5bcda943a7a414e1eab5550c963", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4c1242bddfcbd5bcda943a7a414e1eab5550c963", "committedDate": "2020-06-02T12:50:57Z", "message": "Merge pull request GH-370 from grianbrcom/fp_fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63fc95ed19e23a40224a2508ee82cd67ad3c75b5", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/63fc95ed19e23a40224a2508ee82cd67ad3c75b5", "committedDate": "2020-06-02T12:50:57Z", "message": "refactor: Add File Service to simplify testing GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51b944819b4e267da8e8179319146297a7aba087", "author": {"user": {"login": "asatklichov", "name": "Azat Satklichov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/51b944819b4e267da8e8179319146297a7aba087", "committedDate": "2020-06-02T12:50:58Z", "message": "Merge from fet priority\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9474e2a6433e0c1a1034ad0e0eeecded8be56438", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9474e2a6433e0c1a1034ad0e0eeecded8be56438", "committedDate": "2020-06-02T12:50:58Z", "message": "Merge pull request #371 from asatklichov/fetch-priority-gitignore\n\nFetch priority gitignore"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7ed36583ad8ab467bcb07f80987f8677a54cfa5", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e7ed36583ad8ab467bcb07f80987f8677a54cfa5", "committedDate": "2020-06-02T12:50:59Z", "message": "refactor: Make URI resolution work with .c4z folder #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e28e508453cc1d020ace7556922139b90884514f", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e28e508453cc1d020ace7556922139b90884514f", "committedDate": "2020-06-02T12:50:59Z", "message": "refactor: Remove deprecated URI resolution #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "61fd795630f9c9b5e828d5d92fa5a52f23739ec2", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/61fd795630f9c9b5e828d5d92fa5a52f23739ec2", "committedDate": "2020-06-02T12:50:59Z", "message": "test: Skip not finalized tests #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a0d2e4a36f36100cea7a930d2cd78405f9b722f3", "author": {"user": {"login": "zacanbrcom", "name": "Andrea Zaccaro"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a0d2e4a36f36100cea7a930d2cd78405f9b722f3", "committedDate": "2020-06-02T12:50:59Z", "message": "test: Define PathsService.ts unit test GH-355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b760bd532d827afab0c6b458cb6d993d32f78a54", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b760bd532d827afab0c6b458cb6d993d32f78a54", "committedDate": "2020-06-02T12:50:59Z", "message": "refactor: Add check for non-existing copybook file #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c907a621a9a2edffdd7de7fc610fe9948d341c85", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c907a621a9a2edffdd7de7fc610fe9948d341c85", "committedDate": "2020-06-02T13:08:21Z", "message": "refactor: Remove unused files GH-23"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "177be4fd2bb27d904f093bf06346947531684156", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/177be4fd2bb27d904f093bf06346947531684156", "committedDate": "2020-06-02T12:38:41Z", "message": "refactor: Add check for non-existing copybook file #355"}, "afterCommit": {"oid": "c907a621a9a2edffdd7de7fc610fe9948d341c85", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c907a621a9a2edffdd7de7fc610fe9948d341c85", "committedDate": "2020-06-02T13:08:21Z", "message": "refactor: Remove unused files GH-23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adb2a7aa7d35b0f756a244639793eb529b3384a2", "author": {"user": {"login": "asatklichov", "name": "Azat Satklichov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/adb2a7aa7d35b0f756a244639793eb529b3384a2", "committedDate": "2020-06-02T14:30:42Z", "message": "refactor: Add missing copyright header GH-23\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ddd3cc9f358c1114c445cee9dd4d1e8b2b33168a", "author": {"user": {"login": "asatklichov", "name": "Azat Satklichov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ddd3cc9f358c1114c445cee9dd4d1e8b2b33168a", "committedDate": "2020-06-02T14:34:48Z", "message": "test: Update test to work with temp folder GH-23\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "343697768b8d1df42b3eb106519c085ca45a6c0c", "author": {"user": {"login": "asatklichov", "name": "Azat Satklichov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/343697768b8d1df42b3eb106519c085ca45a6c0c", "committedDate": "2020-06-02T14:41:31Z", "message": "ci: Add Jest treshold for client tests\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640", "author": {"user": {"login": "asatklichov", "name": "Azat Satklichov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f8ea14e2fec6f2793b0b997ea00c8958d031b640", "committedDate": "2020-06-02T14:44:45Z", "message": "refactor: Remove duplicated method calls GH-23\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjk3Mzk1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423297395", "createdAt": "2020-06-03T07:43:57Z", "commit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0Mzo1OFrOGeP7EQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0Mzo1OFrOGeP7EQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3MTM0NQ==", "bodyText": "Those thing should be removed because are part of the first POC, I'll assign to myself this double check to verify that we didn't lose the latest version of package.json", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434371345", "createdAt": "2020-06-03T07:43:58Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/package.json", "diffHunk": "@@ -56,6 +56,14 @@\n             {\n                 \"command\": \"broadcom-cobol-lsp.cpy-manager.resolve-local-copybooks\",\n                 \"title\": \"Resolve Local Copybooks\"\n+            },\n+            {\n+                \"command\": \"broadcom-cobol-lsp.cpy-manager.resolve-git-copybooks\",\n+                \"title\": \"Resolve Local 2\"\n+            },\n+            {\n+                \"command\": \"broadcom-cobol-lsp.cpy-manager.resolve-git-copybooks-2\",\n+                \"title\": \"Get local copybooks\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 11}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjk5NjE1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423299615", "createdAt": "2020-06-03T07:47:06Z", "commit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0NzowNlrOGeQBzA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNzo0NzowNlrOGeQBzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM3MzA2OA==", "bodyText": "@zacanbrcom remove this comment and verify that handleQueue() is correctly engaged from the start() method", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434373068", "createdAt": "2020-06-03T07:47:06Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybooksDownloader.ts", "diffHunk": "@@ -103,10 +113,12 @@ export class CopybooksDownloader implements vscode.Disposable {\n         this.queue.stop();\n     }\n \n+    //TODO: NO INVOKED IN THE CODE BUT USED BY UNIT TEST\n+    //TODO: VERIFY ZOWE ERRORS ARE STILL SUPPORTED", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 125}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMzA5NzY2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423309766", "createdAt": "2020-06-03T08:01:08Z", "commit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwODowMTowOFrOGeQgqA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwODowMTowOFrOGeQgqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDM4MDk2OA==", "bodyText": "@grianbrcom it's time to get rid of this TODO", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434380968", "createdAt": "2020-06-03T08:01:08Z", "author": {"login": "zacanbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/ClientService.java", "diffHunk": "@@ -0,0 +1,9 @@\n+package com.ca.lsp.cobol.service;\n+\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+\n+public interface ClientService {\n+  // TODO:provide more descriptive name for this class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8ea14e2fec6f2793b0b997ea00c8958d031b640"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMzg5NzY1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423389765", "createdAt": "2020-06-03T09:44:01Z", "commit": {"oid": "6948538f01f06238c1de7b912f057d84122c6574"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTo0NDowMVrOGeUSuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwOTo0NDowMVrOGeUSuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ0MjkzNw==", "bodyText": "is result null-safe ?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434442937", "createdAt": "2020-06-03T09:44:01Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/CopybookServiceImpl.java", "diffHunk": "@@ -16,164 +16,117 @@\n package com.ca.lsp.cobol.service;\n \n import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n-import com.broadcom.lsp.domain.cobol.event.model.DataEventType;\n import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n-import com.ca.lsp.cobol.model.ConfigurationSettingsStorable;\n-import com.ca.lsp.cobol.service.delegates.dependency.CopybookDependencyService;\n+import com.ca.lsp.cobol.service.utils.FileSystemService;\n+import com.google.gson.JsonPrimitive;\n import com.google.inject.Inject;\n-import com.google.inject.Provider;\n import com.google.inject.Singleton;\n import lombok.extern.slf4j.Slf4j;\n-import org.eclipse.lsp4j.WorkspaceFolder;\n \n import java.net.URI;\n import java.nio.file.Path;\n-import java.util.Collection;\n import java.util.List;\n-import java.util.Objects;\n-import java.util.Optional;\n-import java.util.stream.Collectors;\n-import java.util.stream.Stream;\n+import java.util.Map;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.function.Consumer;\n \n-import static com.ca.lsp.cobol.service.utils.FileSystemUtils.*;\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.REQUIRED_COPYBOOK_EVENT;\n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n+import static java.util.Optional.ofNullable;\n \n-@Singleton\n+/** This service processes copybook requests and returns content by its name */\n @Slf4j\n+@Singleton\n+@SuppressWarnings(\"unchecked\")\n public class CopybookServiceImpl implements CopybookService {\n   private final DataBusBroker dataBus;\n-  private List<Path> workspaceFolderPaths;\n+  private final ClientService clientService;\n+  private final FileSystemService files;\n \n-  private CopybookDependencyService dependencyService;\n-  private final Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider;\n+  private final Map<String, Path> copybookPath = new ConcurrentHashMap<>(8, 0.9f, 1);\n \n   @Inject\n   public CopybookServiceImpl(\n-      DataBusBroker dataBus,\n-      Provider<ConfigurationSettingsStorable> configurationSettingsStorableProvider,\n-      CopybookDependencyService dependencyService) {\n+      DataBusBroker dataBus, ClientService clientService, FileSystemService files) {\n     this.dataBus = dataBus;\n-    this.configurationSettingsStorableProvider = configurationSettingsStorableProvider;\n-    this.dependencyService = dependencyService;\n-    dataBus.subscribe(DataEventType.REQUIRED_COPYBOOK_EVENT, this);\n-  }\n-\n-  /**\n-   * Store the information about the workspace folders defined by the client IDE\n-   *\n-   * @param workspaceFolders list of workspace folders sent by the client to the server\n-   */\n-  @Override\n-  public void setWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    createPathListFromWorkspaceFolders(workspaceFolders);\n-    setPathListInDependencyFile();\n-  }\n-\n-  private void createPathListFromWorkspaceFolders(List<WorkspaceFolder> workspaceFolders) {\n-    workspaceFolderPaths =\n-        Optional.ofNullable(workspaceFolders)\n-            .map(Collection::stream)\n-            .orElseGet(Stream::empty)\n-            .filter(Objects::nonNull)\n-            .map(this::resolveURI)\n-            .collect(Collectors.toList());\n-  }\n+    this.clientService = clientService;\n+    this.files = files;\n \n-  private void setPathListInDependencyFile() {\n-    dependencyService.setWorkspaceFolderPaths(workspaceFolderPaths);\n+    dataBus.subscribe(REQUIRED_COPYBOOK_EVENT, this);\n   }\n \n   /**\n-   * From a given copybook name (without file extension) this method will return the URI of the file\n-   * - if exists applying a deep search in the copybook folder. No filtered folders where to specify\n-   * the search are defined.\n+   * Retrieve copybook content by its name, and the document name {@see RequiredCopybookEvent}. It\n+   * will apply a file system calls only if the {@link TextDocumentSyncType is DID_OPEN} in order to\n+   * avoid obtaining the copybooks with incomplete names.\n    *\n-   * @param fileName (i.e. COPYTEST)\n-   * @return NIO Path of file (i.e. C:/Users/test/AppData/Local/Temp/WORKSPACE/COPYTEST.cpy) or null\n-   *     if not found. This case should be covered by an appropriate diagnostic message using the\n-   *     Communication service delegate object.\n-   */\n-  @Override\n-  public Path findCopybook(String fileName) {\n-    return workspaceFolderPaths.stream()\n-        .map(it -> applySearch(fileName, getCopybookBaseFolder(it)))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  /**\n-   * This method is used to search for a copybook against a given configuration of datasets that\n-   * represent the sub-path of the copyooks folder\n+   * <p>The retrieved URIs stored in the cache. If the URI points to non-existing file, then the\n+   * cache invalidated and new request applied.\n    *\n-   * @param filename copybook name\n-   * @return The path of the existent copybook or null if not found\n+   * <p>Replies with copybook content and its URI if exists, or with an empty response if the\n+   * copybook not found. The response sends in any case.\n+   *\n+   * @param event - copybook request params\n    */\n   @Override\n-  public Path findCopybook(String filename, List<String> datasetList) {\n-    return retrievePathOrNull(\n-        filename,\n-        getPathList(getCopybookBaseFolder(workspaceFolderPaths.get(0)).toString(), datasetList));\n-  }\n-\n-  private Path retrievePathOrNull(String filename, List<Path> datasetPathList) {\n-    return datasetPathList.stream()\n-        .map(it -> applySearch(filename, it))\n-        .filter(Objects::nonNull)\n-        .findAny()\n-        .orElse(null);\n-  }\n-\n-  private Path resolveURI(WorkspaceFolder workspaceFolder) {\n-    return getPathFromURI(workspaceFolder.getUri());\n-  }\n-\n-  private Path getCopybookBaseFolder(Path workspaceFolderPath) {\n-    return getCopybookFolderPath(workspaceFolderPath.toString());\n-  }\n-\n-  /** create the task and pass it to the executor service */\n-  @Override\n   public void observerCallback(RequiredCopybookEvent event) {\n-\n     String requiredCopybookName = event.getName();\n-    dependencyService.addCopybookInDepFile(event, requiredCopybookName);\n-    resolveCopybookContent(requiredCopybookName);\n-  }\n \n-  /**\n-   * This method is delegated to check that the user have right settings to retrieve the content of\n-   * a copybook from a given name\n-   *\n-   * @param requiredCopybookName name of the copybook for what is necessary retrieve the content if\n-   *     exists.\n-   */\n-  private void resolveCopybookContent(String requiredCopybookName) {\n-    ConfigurationSettingsStorable configurationSettingsStorable =\n-        configurationSettingsStorableProvider.get();\n-    if (configurationSettingsStorable == null) {\n-      publishOnDatabus(requiredCopybookName);\n-      return;\n+    if (copybookPath.containsKey(requiredCopybookName)) {\n+      Path file = copybookPath.get(requiredCopybookName);\n+      if (files.fileExists(file)) {\n+        sendResponse(requiredCopybookName, files.getContentByPath(file), file);\n+        return;\n+      } else {\n+        copybookPath.remove(requiredCopybookName);\n+      }\n     }\n-\n-    Path path = findCopybook(requiredCopybookName, configurationSettingsStorable.getPaths());\n-    if (isFileExists(path)) {\n-      publishOnDatabus(requiredCopybookName, getContentByPath(path), path);\n+    if (DID_OPEN.name().equals(event.getTextDocumentSyncType())) {\n+      String cobolFileName = files.getNameFromURI(event.getDocumentUri());\n+      clientService\n+          .callClient(\"copybook\", cobolFileName, requiredCopybookName)\n+          .thenAccept(sendResponse(requiredCopybookName));\n     } else {\n-      publishOnDatabus(requiredCopybookName);\n+      sendResponse(requiredCopybookName, null, null);\n     }\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName, String content, Path path) {\n+  private Consumer<List<Object>> sendResponse(String requiredCopybookName) {\n+    return result -> dataBus.postData(fetchCopybook(requiredCopybookName, retrieveURI(result)));\n+  }\n+\n+  private void sendResponse(String requiredCopybookName, String content, Path path) {\n     dataBus.postData(\n         FetchedCopybookEvent.builder()\n             .name(requiredCopybookName)\n-            .uri(Optional.ofNullable(path).map(Path::toUri).map(URI::toString).orElse(null))\n+            .uri(toURI(path))\n             .content(content)\n             .build());\n   }\n \n-  private void publishOnDatabus(String requiredCopybookName) {\n-    dataBus.postData(FetchedCopybookEvent.builder().name(requiredCopybookName).build());\n+  private FetchedCopybookEvent fetchCopybook(String requiredCopybookName, String uri) {\n+    if (uri.isEmpty()) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    Path file = files.getPathFromURI(uri);\n+    if (file == null) {\n+      return FetchedCopybookEvent.builder().name(requiredCopybookName).build();\n+    }\n+    copybookPath.put(requiredCopybookName, file);\n+\n+    return FetchedCopybookEvent.builder()\n+        .name(requiredCopybookName)\n+        .uri(toURI(file))\n+        .content(files.getContentByPath(file))\n+        .build();\n+  }\n+\n+  private String toURI(Path file) {\n+    return ofNullable(file).map(Path::toUri).map(URI::toString).orElse(null);\n+  }\n+\n+  private String retrieveURI(List<Object> result) {\n+    return result.isEmpty() ? \"\" : ((JsonPrimitive) result.get(0)).getAsString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6948538f01f06238c1de7b912f057d84122c6574"}, "originalPosition": 232}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDAyMDMw", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423402030", "createdAt": "2020-06-03T10:00:24Z", "commit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMDoyNFrOGeU34w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDowMDoyNFrOGeU34w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ1MjQ1MQ==", "bodyText": "header is missing - guys double check if you have configured the IDE to generate header every time you create a new file :)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434452451", "createdAt": "2020-06-03T10:00:24Z", "author": {"login": "zacanbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/Middleware.ts", "diffHunk": "@@ -0,0 +1,32 @@\n+import {CancellationToken} from \"vscode\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDExOTc3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423411977", "createdAt": "2020-06-03T10:14:28Z", "commit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoxNDoyOFrOGeVWJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoxNDoyOFrOGeVWJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2MDE5OA==", "bodyText": "would be better if we have same formatting", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434460198", "createdAt": "2020-06-03T10:14:28Z", "author": {"login": "asatklichov"}, "path": "clients/cobol-lsp-vscode-extension/src/extension.ts", "diffHunk": "@@ -13,25 +13,24 @@\n  */\n \n import * as vscode from \"vscode\";\n-import * as path from \"path\";\n+\n import { changeDefaultZoweProfile } from \"./commands/ChangeDefaultZoweProfile\";\n import { editDatasetPaths } from \"./commands/EditDatasetPaths\";\n import { fetchCopybookCommand } from \"./commands/FetchCopybookCommand\";\n-import { C4Z_FOLDER, DEPENDENCIES_FOLDER, GITIGNORE_FILE, REASON_MSG } from \"./constants\";\n+import { C4Z_FOLDER, GITIGNORE_FILE} from \"./constants\";\n import { LANGUAGE_ID, SETTINGS_SECTION } from \"./constants\";\n import { CopybookFix } from \"./services/CopybookFix\";\n import { CopybooksCodeActionProvider } from \"./services/CopybooksCodeActionProvider\";\n import { CopybooksDownloader } from \"./services/CopybooksDownloader\";\n import { CopybooksPathGenerator } from \"./services/CopybooksPathGenerator\";\n import { initializeSettings, createFileWithGivenPath } from \"./services/Settings\";\n \n-import {resolveLocalCopybooksCommand} from \"./commands/ResolveLocalCopybooksCommand\";\n-import { LanguageClientService } from \"./services/LanguageClientService\";\n-import { PathsService } from \"./services/PathsService\";\n-import { ProfileService } from \"./services/ProfileService\";\n-import {CopybookResolver} from \"./services/settings/CopybookResolver\";\n-import {LocalCopybookResolver} from \"./services/settings/LocalCopybookResolver\";\n-import { ZoweApi } from \"./services/ZoweApi\";\n+import {CopybookURI} from \"./services/CopybookURI\";\n+import {LanguageClientService} from \"./services/LanguageClientService\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 26}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDE4MjYw", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423418260", "createdAt": "2020-06-03T10:23:35Z", "commit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoyMzozNVrOGeVpSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDoyMzozNVrOGeVpSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ2NTA5OA==", "bodyText": "Is DATASETS used?  If yes, we can still alphabetize.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434465098", "createdAt": "2020-06-03T10:23:35Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/SettingsParametersEnum.java", "diffHunk": "@@ -20,7 +20,9 @@\n  */\n public enum SettingsParametersEnum {\n   CPY_MANAGER(\"cpy-manager\"),\n-  LSP_PREFIX(\"broadcom-cobol-lsp\");\n+  LSP_PREFIX(\"broadcom-cobol-lsp\"),\n+  LOCAL_PATHS(\"cpy-manager.paths.local\"),\n+  DATASETS(\"cpy-manager.paths.dsn\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDMwMTY3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423430167", "createdAt": "2020-06-03T10:41:43Z", "commit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0MTo0M1rOGeWN9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0MTo0M1rOGeWN9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NDQ4NQ==", "bodyText": "return null? Optional will help also get-rid off null-checks.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434474485", "createdAt": "2020-06-03T10:41:43Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 193}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDMwMjk3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423430297", "createdAt": "2020-06-03T10:41:54Z", "commit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0MTo1NFrOGeWOVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0MTo1NFrOGeWOVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NDU4MQ==", "bodyText": "same", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434474581", "createdAt": "2020-06-03T10:41:54Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 204}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDMwODcx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423430871", "createdAt": "2020-06-03T10:42:48Z", "commit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0Mjo0OVrOGeWQCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0Mjo0OVrOGeWQCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTAxNg==", "bodyText": "You check if filePath exists but delete wsPath.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434475016", "createdAt": "2020-06-03T10:42:49Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/__tests__/SettingsTest.ts", "diffHunk": "@@ -18,31 +11,40 @@ import {SettingsUtils} from \"../services/settings/util/SettingsUtils\";\n  * Contributors:\n  *   Broadcom, Inc. - initial API and implementation\n  */\n+import * as fs from \"fs-extra\";\n+import * as path from \"path\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, GITIGNORE_FILE} from \"../constants\";\n+import {createFileWithGivenPath, initializeSettings} from \"../services/Settings\";\n+import {SettingsUtils} from \"../services/settings/util/SettingsUtils\";\n \n-const fsPath = \"/ws-vscode\";\n-const c4zFolder = \".c4z\";\n-const fileName = \".gitignore\";\n+const fsPath = \"tmp-ws\";\n+const scheme = \"file\";\n+let wsPath: string;\n+let c4zPath: string;\n let filePath: string;\n \n beforeAll(() => {\n-    vscode.workspace.workspaceFolders = [{ uri: { fsPath } } as any];\n-    filePath = path.join(vscode.workspace.workspaceFolders[0].uri.fsPath, c4zFolder, fileName);\n+    vscode.workspace.workspaceFolders = [{uri: {fsPath}} as any];\n+    wsPath = path.join(vscode.workspace.workspaceFolders[0].uri.fsPath);\n+    c4zPath = path.join(wsPath, C4Z_FOLDER);\n+    filePath = path.join(c4zPath, GITIGNORE_FILE);\n });\n \n afterAll(() => {\n-        if (fs.existsSync(filePath)) {\n-            fs.unlinkSync(filePath);\n-        }\n+    if (fs.existsSync(filePath)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDMyMDQy", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423432042", "createdAt": "2020-06-03T10:44:34Z", "commit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0NDozNFrOGeWTcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo0NDozNFrOGeWTcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3NTg5MA==", "bodyText": "pattern should be in argument", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434475890", "createdAt": "2020-06-03T10:44:34Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/utils/WorkspaceFileService.java", "diffHunk": "@@ -0,0 +1,254 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.cobol.service.utils;\n+\n+import com.google.inject.Singleton;\n+import lombok.extern.slf4j.Slf4j;\n+import org.apache.commons.io.FilenameUtils;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.net.URI;\n+import java.net.URISyntaxException;\n+import java.net.URLDecoder;\n+import java.nio.file.*;\n+import java.util.List;\n+import java.util.stream.Stream;\n+\n+import static java.lang.String.format;\n+import static java.nio.file.Files.readAllLines;\n+import static java.nio.file.StandardOpenOption.WRITE;\n+import static java.util.Arrays.asList;\n+import static java.util.Collections.emptyList;\n+import static java.util.stream.Collectors.toList;\n+\n+/**\n+ * This service implements API for low-level file systems access. It mainly oriented to work with\n+ * copybooks, especially with .copybooks folder.\n+ */\n+@Singleton\n+@Slf4j\n+public class WorkspaceFileService implements FileSystemService {\n+  private static final List<String> ALLOWED_EXTENSIONS = asList(\"cpy\", \"cbl\", \"cobol\", \"cob\");\n+  private static final String COPYBOOKS_FOLDER = \".copybooks\";\n+  private static final String C4Z_FOLDER = \".c4z\";\n+\n+  @Override\n+  public boolean fileExists(@Nullable Path file) {\n+    return file != null && file.toFile().exists();\n+  }\n+\n+  @Override\n+  public void writeInFile(\n+      @Nonnull Path targetPath,\n+      @Nonnull String content,\n+      @Nullable StandardOpenOption standardOpenOption) {\n+    try {\n+      Files.write(targetPath, (content + \"\\n\").getBytes(), WRITE, standardOpenOption);\n+    } catch (IOException e) {\n+      log.error(\"Error writing to file: \" + targetPath, e);\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String decodeURI(@Nonnull String uri) {\n+    try {\n+      return URLDecoder.decode(uri, \"UTF-8\");\n+    } catch (UnsupportedEncodingException e) {\n+      log.error(\"Cannot decode URI: \" + uri, e);\n+      return uri;\n+    }\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> interpretPaths(@Nonnull List<Object> settings) {\n+    return settings.stream()\n+        .map(Object::toString)\n+        .map(\n+            path ->\n+                path.substring(path.indexOf(COPYBOOKS_FOLDER) + COPYBOOKS_FOLDER.length())\n+                    .replace(\"/\", filesystemSeparator())\n+                    .replace(\"\\\"\", \"\"))\n+        .collect(toList());\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getPath(@Nonnull String basePath, @Nonnull String... more) {\n+    return Paths.get(basePath, more);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public Path getCopybookFolderPath(@Nonnull String workspacePath) {\n+    return getPath(workspacePath, C4Z_FOLDER, COPYBOOKS_FOLDER);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<Path> getPathList(@Nonnull String outer, @Nonnull List<String> variablePart) {\n+    return variablePart.stream()\n+        .map(it -> Paths.get(outer, it))\n+        .filter(Files::exists)\n+        .collect(toList());\n+  }\n+\n+  @Override\n+  public Path createFolders(Path path) {\n+    try {\n+      return Files.createDirectories(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folders for \" + path, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void createFolder(@Nonnull Path path) {\n+    try {\n+      Files.createDirectory(path);\n+    } catch (IOException e) {\n+      log.error(\"Error creating folder: \" + path, e);\n+    }\n+  }\n+\n+  @Override\n+  public void createFile(@Nonnull Path path) {\n+    if (!path.toFile().exists()) {\n+      try {\n+        Files.createFile(path);\n+      } catch (IOException e) {\n+        log.error(\"Error creating file: \" + path, e);\n+      }\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getNameFromURI(@Nonnull String uri) {\n+    try {\n+      return FilenameUtils.getBaseName(Paths.get(new URI(uri)).getFileName().toString());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot get file name from: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getExtensionFromURI(@Nonnull String uri) {\n+    return FilenameUtils.getExtension(uri);\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public List<String> getContentFromFile(@Nonnull Path filePath) {\n+    try {\n+      return readAllLines(filePath);\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + filePath.toString(), e);\n+      return emptyList();\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public String getContentByPath(@Nonnull Path path) {\n+    try (Stream<String> stream = Files.lines(path)) {\n+      return stream.reduce((s1, s2) -> s1 + \"\\r\\n\" + s2).orElse(\"\");\n+    } catch (IOException e) {\n+      log.error(\"Cannot get content of: \" + path.toString(), e);\n+      return null;\n+    }\n+  }\n+\n+  @Nullable\n+  @Override\n+  public Path applySearch(@Nonnull String fileName, @Nonnull Path targetFolderPath) {\n+    try (Stream<Path> pathStream =\n+        Files.find(\n+            targetFolderPath,\n+            100,\n+            (path, basicFileAttributes) -> isValidFileFound(path.toFile(), fileName),\n+            FileVisitOption.FOLLOW_LINKS)) {\n+      return pathStream.findAny().orElse(null);\n+    } catch (IOException e) {\n+      log.error(format(\"Error searching for %s in %s\", fileName, targetFolderPath.toString()), e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  public Path getPathFromURI(@Nonnull String uri) {\n+    try {\n+      return Paths.get(new URI(uri).normalize());\n+    } catch (URISyntaxException e) {\n+      log.error(\"Cannot find file by given URI: \" + uri, e);\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void removeIfPresent(@Nonnull String element, @Nonnull Path targetPath) {\n+    try {\n+      List<String> result = getContentFromFile(targetPath);\n+\n+      List<String> updatedLines = result.stream().filter(s -> !s.equals(element)).collect(toList());\n+\n+      // don't write if the lines were not modify\n+      if (!updatedLines.equals(result)) {\n+        Files.write(targetPath, updatedLines, StandardOpenOption.TRUNCATE_EXISTING);\n+      }\n+    } catch (IOException e) {\n+      log.error(format(\"Cannot remove %s in %s\", element, targetPath.toString()), e);\n+    }\n+  }\n+  /**\n+   * From a given file this routine analyze if the file is not a directory and have a valid\n+   * ALLOWED_EXTENSIONS\n+   *\n+   * @param currentFile file analyzed during the scan of a folder\n+   * @param requiredName the name of the file to match\n+   * @return true if all the condition are met, false otherwise\n+   */\n+  private boolean isValidFileFound(File currentFile, String requiredName) {\n+    return currentFile.isFile()\n+        && !currentFile.isDirectory()\n+        && currentFile.getName().contains(\".\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9b17d9cd9b1f6ac2a59bf152c8dafdde21f5fb86"}, "originalPosition": 234}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzNDM1OTQ5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#pullrequestreview-423435949", "createdAt": "2020-06-03T10:50:40Z", "commit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo1MDo0MFrOGeWfEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QxMDo1MDo0MFrOGeWfEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDQ3ODg2NQ==", "bodyText": "The LocalCopybookResolver doesn't have any internal state. Is it necessary to create an instance?\nCould resolve be a static utility method?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/376#discussion_r434478865", "createdAt": "2020-06-03T10:50:40Z", "author": {"login": "grianbrcom"}, "path": "clients/cobol-lsp-vscode-extension/src/services/CopybookURI.ts", "diffHunk": "@@ -0,0 +1,119 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+import * as fs from \"fs\";\n+import * as path from \"path\";\n+import {URL} from \"url\";\n+import * as vscode from \"vscode\";\n+import {C4Z_FOLDER, COPYBOOKS_FOLDER, PATHS_LOCAL_KEY, PATHS_ZOWE, SETTINGS_SECTION} from \"../constants\";\n+import {CopybooksDownloader} from \"./CopybooksDownloader\";\n+import {ProfileService} from \"./ProfileService\";\n+import {CopybookResolver} from \"./settings/CopybookResolver\";\n+import {LocalCopybookResolver} from \"./settings/LocalCopybookResolver\";\n+import {CopybookUtil} from \"./settings/util/CopybookUtil\";\n+\n+/**\n+ * This class is responsible to identify from which source resolve copybooks required by the server.\n+ */\n+export class CopybookURI {\n+    /**\n+     * This method scan the list of folders as given input and find the required copybook name within the folder.\n+     * If found returns its URI representation\n+     * @param copybookName name of the copybook asked by the server\n+     * @param targetFolders list of folders from where to search the copybook\n+     */\n+    public static searchInWorkspace(copybookName: string, targetFolders: string[]): string {\n+        const copybookResolver: CopybookResolver = new LocalCopybookResolver();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8aee8a181ba31c5473ae69915b4117bb0d965c98"}, "originalPosition": 36}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1113, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}