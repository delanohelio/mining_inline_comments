{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1OTYyMjgz", "number": 338, "title": "Introduce Extended Document Building and Replacing Statements Support", "bodyText": "This pull request contains a lot of changes for the language engine.\n\nRemoved a separate cleaning stage;\nProcessing logic remade to work with an extended document;\nIntroduced REPLACING statements support;\nThe positions from the extended document mapped to the original ones;\nGrammar refactored;\nFixed some semantic analysis bugs;\nIncreased functional coverage for use case tests;\nIntroduce Go to Definitions for Copybooks;\nSend found errors to the related files;\nIntroduce the Use Case Engine to simplify testing;\nAllow keyword as a copybook name;\nUnderline the entire incorrect variable structure;\nJUnit 5 migration\nCloses #432, #426. #387, #352, #351, #350, #348, #342, #335, #321, #304, #220", "createdAt": "2020-05-11T08:57:34Z", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338", "merged": true, "mergeCommit": {"oid": "a2322e5f00ef62bbfac8a446966954be2843dc02"}, "closed": true, "closedAt": "2020-08-17T15:41:00Z", "author": {"login": "temanbrcom"}, "timelineItems": {"totalCount": 171, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc12zceAH2gAyNDE1OTYyMjgzOmI5OTMwZTY3Zjc4MmY1OGYxNDAzZGE0N2QyMjA1ZTRkYTNhNWVmZTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc_zQLAAFqTQ2ODUxMjExMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "b9930e67f782f58f1403da47d2205e4da3a5efe9", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b9930e67f782f58f1403da47d2205e4da3a5efe9", "committedDate": "2020-07-17T16:55:08Z", "message": "refactor: Prevent NPE if END-PERFORM missing on inline statements"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7debe578042136ce437281d67d5d385eafc1ec5a", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7debe578042136ce437281d67d5d385eafc1ec5a", "committedDate": "2020-07-20T11:15:12Z", "message": "perf: Replace token string check with type check to speed it up"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "00ddd676811d6cd3b31a02c271403e2f83108879", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/00ddd676811d6cd3b31a02c271403e2f83108879", "committedDate": "2020-07-22T17:07:14Z", "message": "refactor: Simplify copybook exit tag to decrease ambiguity"}, "afterCommit": {"oid": "daf96754548ca086e1368f669cfeaee78d45d837", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/daf96754548ca086e1368f669cfeaee78d45d837", "committedDate": "2020-07-23T08:46:15Z", "message": "refactor: Remove copy tags ambiguities to speed up processing"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ec6133029c262cd02eda11556bdae8f285b64c95", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ec6133029c262cd02eda11556bdae8f285b64c95", "committedDate": "2020-07-24T20:27:02Z", "message": "refactor: Make visitor work with pre-calculated mapping"}, "afterCommit": {"oid": "a3e1c7b57ba0ff5cebc4d8d9b74f268b3545a78b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a3e1c7b57ba0ff5cebc4d8d9b74f268b3545a78b", "committedDate": "2020-07-24T20:27:49Z", "message": "refactor: Make visitor work with pre-calculated mapping"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a3e1c7b57ba0ff5cebc4d8d9b74f268b3545a78b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a3e1c7b57ba0ff5cebc4d8d9b74f268b3545a78b", "committedDate": "2020-07-24T20:27:49Z", "message": "refactor: Make visitor work with pre-calculated mapping"}, "afterCommit": {"oid": "8a4261d9d227faec7b4ad358610f1789f0f098cc", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8a4261d9d227faec7b4ad358610f1789f0f098cc", "committedDate": "2020-07-27T09:29:58Z", "message": "refactor: Make visitor work with pre-calculated mapping\nExtract initial positions and shifts of copy statement replacings in preprocessor and map  the tokens of main parser to them after syntax analysis."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8a4261d9d227faec7b4ad358610f1789f0f098cc", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8a4261d9d227faec7b4ad358610f1789f0f098cc", "committedDate": "2020-07-27T09:29:58Z", "message": "refactor: Make visitor work with pre-calculated mapping\nExtract initial positions and shifts of copy statement replacings in preprocessor and map  the tokens of main parser to them after syntax analysis."}, "afterCommit": {"oid": "03abd454e50232eda93d134dd4edb10ce93527b4", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/03abd454e50232eda93d134dd4edb10ce93527b4", "committedDate": "2020-07-27T13:34:57Z", "message": "refactor: Make visitor work with pre-calculated mapping\nExtract initial positions and shifts of copy statement replacings in preprocessor and map  the tokens of main parser to them after syntax analysis."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a63b7b88c1a0236cf126df0bb77a5306c084ab99", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a63b7b88c1a0236cf126df0bb77a5306c084ab99", "committedDate": "2020-07-31T08:28:45Z", "message": "refactor: Remove unused rules from preprocessor grammar"}, "afterCommit": {"oid": "ca1da876efc93291738f78037175d9db2d29f9c0", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ca1da876efc93291738f78037175d9db2d29f9c0", "committedDate": "2020-07-31T08:29:45Z", "message": "refactor: Remove unused rules from preprocessor grammar"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37e17fa62eba8793cdbdb64634b83d0cd540ce1e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/37e17fa62eba8793cdbdb64634b83d0cd540ce1e", "committedDate": "2020-07-31T08:40:27Z", "message": "test: Make test work with Junit 5"}, "afterCommit": {"oid": "7329a64c3017fd19cbaa868905033d3e11ffc685", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7329a64c3017fd19cbaa868905033d3e11ffc685", "committedDate": "2020-07-31T09:29:11Z", "message": "test: Make test work with Junit 5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fa00c50335f72456bc201b56341ccf9ddea09e6", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8fa00c50335f72456bc201b56341ccf9ddea09e6", "committedDate": "2020-07-31T09:32:14Z", "message": "feat: Syntax coloring support\n\nCloses #421\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29929be47f3b57b8998a9d7a4876097a50fcdfac", "author": {"user": {"login": "grianbrcom", "name": "Anton Grigorev"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/29929be47f3b57b8998a9d7a4876097a50fcdfac", "committedDate": "2020-07-31T09:32:14Z", "message": "feat: Show rulers in editor\n\nIn editor rulers shown on positions 7, 11, 72 and 80\n\nSigned-off-by: Anton Grigorev <anton.grigorev@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "faa95950b4fccb6dba8893c62dfea329cd3f801f", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/faa95950b4fccb6dba8893c62dfea329cd3f801f", "committedDate": "2020-07-31T09:32:14Z", "message": "test: Make Use Case Engine work with unexpected symbols"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "23e6e4345ca3bd4245e93c9b9922ca3e56fc760f", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/23e6e4345ca3bd4245e93c9b9922ca3e56fc760f", "committedDate": "2020-07-31T09:32:14Z", "message": "refactor: Make Cobol Parser process all the syntax errors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7abf90e5f70e00a855e92bc8475fe8907f31ffff", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7abf90e5f70e00a855e92bc8475fe8907f31ffff", "committedDate": "2020-07-31T09:32:15Z", "message": "perf: Fix collecting unnecessary positions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "149b5d96d45183d0265fba00d284ef84a2d10e4c", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/149b5d96d45183d0265fba00d284ef84a2d10e4c", "committedDate": "2020-07-31T09:32:27Z", "message": "perf: Drop unnecesary text writing operations"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a1e42f6851b615205b409f19461b91b3c1abbd33", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a1e42f6851b615205b409f19461b91b3c1abbd33", "committedDate": "2020-07-31T09:32:35Z", "message": "perf: Remove copy tags ambiguities to speed up processing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aec7c09025a67bb6082748ec34cde50f84734d3e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/aec7c09025a67bb6082748ec34cde50f84734d3e", "committedDate": "2020-07-31T09:32:43Z", "message": "test: Make log level for tests configurable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c30ddcb02610d9b525eff0cc313d80c1553b4606", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c30ddcb02610d9b525eff0cc313d80c1553b4606", "committedDate": "2020-07-31T09:32:43Z", "message": "refactor: Fix closing copybook content after comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4ad572acc2e03b29c20b0707fa3367ffc317cc4d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4ad572acc2e03b29c20b0707fa3367ffc317cc4d", "committedDate": "2020-07-31T09:32:43Z", "message": "test: Make tests provide file name to simplify debug"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fdd5ea3ca3fd291edb5df1a89a489dbca22abc9", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8fdd5ea3ca3fd291edb5df1a89a489dbca22abc9", "committedDate": "2020-07-31T09:32:43Z", "message": "refactor: Make visitor work with pre-calculated mapping\nExtract initial positions and shifts of copy statement replacings in preprocessor and map  the tokens of main parser to them after syntax analysis."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e388bcf0654da03d25f2e4e0b6936b3d6077d8a", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9e388bcf0654da03d25f2e4e0b6936b3d6077d8a", "committedDate": "2020-07-31T09:32:43Z", "message": "refactor: Extract PIC preprocessor grammar to support PIC clauses\nSeparate lexer gramamar required to split PIC clauses by tokens correctly to simplify the mapping of positions."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "adc160a09c7665b4d30c4d68e83336751504a07b", "author": {"user": {"login": "asatklichov", "name": "Azat Satklichov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/adc160a09c7665b4d30c4d68e83336751504a07b", "committedDate": "2020-07-31T09:32:59Z", "message": "build: Migration to jUnit5 #432\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0218c4173102138bb0951de9864f5e8aea0e9f6", "author": {"user": {"login": "asatklichov", "name": "Azat Satklichov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d0218c4173102138bb0951de9864f5e8aea0e9f6", "committedDate": "2020-07-31T09:34:54Z", "message": "test: Skip postive tests if filesToTestPath is not provided\n\nSigned-off-by: Azat Satklichov <azat.satklichov@broadcom.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "92c0c93e9c7dd455a163a9a81904d068a3ab962b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/92c0c93e9c7dd455a163a9a81904d068a3ab962b", "committedDate": "2020-07-31T09:34:54Z", "message": "perf: Move EXEC statements processing to parser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3d44049fc9b534046c0d3b1efe42db4ef02b26c", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d3d44049fc9b534046c0d3b1efe42db4ef02b26c", "committedDate": "2020-07-31T09:35:02Z", "message": "perf: Adjust copybook position shifts on mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "01460430d83e72c76e1fc2954f403049910b2b9b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/01460430d83e72c76e1fc2954f403049910b2b9b", "committedDate": "2020-07-31T09:35:11Z", "message": "refactor: Move EJECT statement to the parser to simplify mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a9b005484a7d39cec3cb64a08ab6420b3fc6e40", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5a9b005484a7d39cec3cb64a08ab6420b3fc6e40", "committedDate": "2020-07-31T09:35:11Z", "message": "perf: Remove unused rules from preprocessor grammar"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c6f73bf87e7646dbeb4c8af506ccfb9ea05951da", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c6f73bf87e7646dbeb4c8af506ccfb9ea05951da", "committedDate": "2020-07-31T09:35:19Z", "message": "style: Remove resolved TODOs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ccfef0d77d343552c70c83134baafb4daf8d568b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ccfef0d77d343552c70c83134baafb4daf8d568b", "committedDate": "2020-07-31T09:35:39Z", "message": "test: Remove obsolete test suites"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6d3a10dcd533da92414803ce716f74a0ae8cab2d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6d3a10dcd533da92414803ce716f74a0ae8cab2d", "committedDate": "2020-07-31T09:35:39Z", "message": "test: Make test work with Junit 5"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "7329a64c3017fd19cbaa868905033d3e11ffc685", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7329a64c3017fd19cbaa868905033d3e11ffc685", "committedDate": "2020-07-31T09:29:11Z", "message": "test: Make test work with Junit 5"}, "afterCommit": {"oid": "6d3a10dcd533da92414803ce716f74a0ae8cab2d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6d3a10dcd533da92414803ce716f74a0ae8cab2d", "committedDate": "2020-07-31T09:35:39Z", "message": "test: Make test work with Junit 5"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3960ce70a55667d80ca87e2f99b3a4a4a5316ac9", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3960ce70a55667d80ca87e2f99b3a4a4a5316ac9", "committedDate": "2020-07-31T09:53:08Z", "message": "refactor: Remove obsolete preprocessor cleaning delegate"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c97770d1275f7fdefd2eda796290244137cb8764", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c97770d1275f7fdefd2eda796290244137cb8764", "committedDate": "2020-07-31T12:28:45Z", "message": "perf: Add position shifts for compiler directives"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9188f6be77ce007d9084cdbf4313fe0cfd09916", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a9188f6be77ce007d9084cdbf4313fe0cfd09916", "committedDate": "2020-07-31T12:35:50Z", "message": "test: Fix mock to avoid NPE on build"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad0c2df53496fb7385ed4a520b92d1c6fbd756f7", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ad0c2df53496fb7385ed4a520b92d1c6fbd756f7", "committedDate": "2020-07-31T15:25:53Z", "message": "refactor: Clean-up mapping classes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0371c116ce647f7a138016f1c07ceff3afdb38e7", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0371c116ce647f7a138016f1c07ceff3afdb38e7", "committedDate": "2020-08-03T13:54:15Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb85d853f311cfe4ede365f963583ccb056faa3e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cb85d853f311cfe4ede365f963583ccb056faa3e", "committedDate": "2020-08-03T16:41:44Z", "message": "test: Remove public declarations from tests as a part of JUnit 5 migration"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c78341b6ffe83f5c7aeafaa7f87b3db8d2e22f37", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c78341b6ffe83f5c7aeafaa7f87b3db8d2e22f37", "committedDate": "2020-08-03T15:40:51Z", "message": "test: Remove public declarations from tests as a part of JUnit 5 migration"}, "afterCommit": {"oid": "cb85d853f311cfe4ede365f963583ccb056faa3e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cb85d853f311cfe4ede365f963583ccb056faa3e", "committedDate": "2020-08-03T16:41:44Z", "message": "test: Remove public declarations from tests as a part of JUnit 5 migration"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5ca72c05a2dee2d02042318a2b788d03a64ad513", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5ca72c05a2dee2d02042318a2b788d03a64ad513", "committedDate": "2020-08-04T08:25:43Z", "message": "ci: Set Java language level to 11 for SonarCloud"}, "afterCommit": {"oid": "998ca192c6d6156ed0316a2fae5d5d8cbb8dda42", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/998ca192c6d6156ed0316a2fae5d5d8cbb8dda42", "committedDate": "2020-08-04T08:53:06Z", "message": "ci: Set Java language level to 11 for SonarCloud"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "998ca192c6d6156ed0316a2fae5d5d8cbb8dda42", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/998ca192c6d6156ed0316a2fae5d5d8cbb8dda42", "committedDate": "2020-08-04T08:53:06Z", "message": "ci: Set Java language level to 11 for SonarCloud"}, "afterCommit": {"oid": "cb85d853f311cfe4ede365f963583ccb056faa3e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cb85d853f311cfe4ede365f963583ccb056faa3e", "committedDate": "2020-08-03T16:41:44Z", "message": "test: Remove public declarations from tests as a part of JUnit 5 migration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "29f19e526ad739c2cc0c582b80a183061af73bb6", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/29f19e526ad739c2cc0c582b80a183061af73bb6", "committedDate": "2020-08-04T12:34:52Z", "message": "test: Cover PositionMappingUtils with unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9234ba2b44816ef361ae5ab5c2278426a0bb97d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c9234ba2b44816ef361ae5ab5c2278426a0bb97d", "committedDate": "2020-08-04T12:35:45Z", "message": "refactor: Skip null positions on the visitor to avoid exceptions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2158bbed28673ea1a5f293bdb0886bea150f15ea", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2158bbed28673ea1a5f293bdb0886bea150f15ea", "committedDate": "2020-08-04T12:51:54Z", "message": "refactor: Change CobolVisitor API to simplify testng"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "168303b96bf7b309e7da850ec26d7b13a9f28d84", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/168303b96bf7b309e7da850ec26d7b13a9f28d84", "committedDate": "2020-08-04T13:38:35Z", "message": "test: Cover CobolLanguageEngine with unit test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ffa280f6b3c4b24b807bba1a8c26cac3df35f7da", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ffa280f6b3c4b24b807bba1a8c26cac3df35f7da", "committedDate": "2020-08-04T15:23:58Z", "message": "refactor: Log syntax errors immediately to simlify debugging #342"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "043f05acecd305b0fe26f4ef8e05988ef6573335", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/043f05acecd305b0fe26f4ef8e05988ef6573335", "committedDate": "2020-08-04T15:47:43Z", "message": "refactor: Group alternatives with anchors in regex"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2de5916655829f6a72c22cce52fc62c2fc7c63c7", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2de5916655829f6a72c22cce52fc62c2fc7c63c7", "committedDate": "2020-08-04T16:08:12Z", "message": "refactor: Decrease log level of copybook resolution error to avoid unnecessary logging on production"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57094634b328bf55744dd8a87460857e7d5284ed", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/57094634b328bf55744dd8a87460857e7d5284ed", "committedDate": "2020-08-05T15:09:32Z", "message": "test: Introduce test coverage for GrammarPreprocessorListenerImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c5260076fb66b30bdef759d0e83f848ed3c8402c", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c5260076fb66b30bdef759d0e83f848ed3c8402c", "committedDate": "2020-08-06T12:23:41Z", "message": "fix: Allow keyword as a copybook name #304"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "90301f0152f6051444308702b8737cd8863d50d0", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/90301f0152f6051444308702b8737cd8863d50d0", "committedDate": "2020-08-07T14:52:30Z", "message": "refactor: Make REPLACING accept everything in pseudo-text pattern"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0e00b5d1ed0a53b793259577397c3e144336a2b7", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/0e00b5d1ed0a53b793259577397c3e144336a2b7", "committedDate": "2020-08-07T14:40:37Z", "message": "refactor: Make REPLACING accept everything in pseudo-text pattern"}, "afterCommit": {"oid": "90301f0152f6051444308702b8737cd8863d50d0", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/90301f0152f6051444308702b8737cd8863d50d0", "committedDate": "2020-08-07T14:52:30Z", "message": "refactor: Make REPLACING accept everything in pseudo-text pattern"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1e953fa974a582ccd26a082a0fe59cb47863a7d8", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1e953fa974a582ccd26a082a0fe59cb47863a7d8", "committedDate": "2020-08-07T14:57:21Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22c29fff10b95e6ba577040abe6053d04fbed142", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/22c29fff10b95e6ba577040abe6053d04fbed142", "committedDate": "2020-08-10T14:47:06Z", "message": "refactor: Extract error message as a constant"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36bda6abc1e1b8eb0330d975ba044096249d528a", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/36bda6abc1e1b8eb0330d975ba044096249d528a", "committedDate": "2020-08-10T15:04:22Z", "message": "feat: Underline the entire incorrect variable structure #321"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1d06306127a169064db80eb372f20262087d61c0", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1d06306127a169064db80eb372f20262087d61c0", "committedDate": "2020-08-10T16:24:34Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7f0559923fe2977b23a4b27459b916fff8375225", "committedDate": "2020-08-11T09:50:06Z", "message": "style: Use general return for copybook resolution as a best practice"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY0OTkyMzYx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-464992361", "createdAt": "2020-08-11T11:54:24Z", "commit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMTo1NDoyNFrOG-0Zlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjoyMToxMlrOG-1SFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUyMzQxNQ==", "bodyText": "You could use Map::getOrDefault here and in the initialForward methods.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468523415", "createdAt": "2020-08-11T11:54:24Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/model/DocumentHierarchyLevel.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.model;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static java.util.Optional.ofNullable;\n+\n+public class DocumentHierarchyLevel {\n+  private int index;\n+  private List<Position> positions;\n+  private Map<Integer, Integer> shifts;\n+\n+  public DocumentHierarchyLevel(DocumentMapping documentMapping) {\n+    index = 0;\n+    positions = documentMapping.getPositions();\n+    shifts = documentMapping.getShifts();\n+    initialForward();\n+  }\n+\n+  public Position getCurrent() {\n+    return index < positions.size() ? positions.get(index) : null;\n+  }\n+\n+  public void forward() {\n+    index += ofNullable(shifts.get(index)).orElse(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzMjQ4MA==", "bodyText": "We need to think about watchdog here to handle look ahead infinity loop. It could be a feature for future implementation.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468532480", "createdAt": "2020-08-11T12:11:13Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PositionMappingUtils.java", "diffHunk": "@@ -0,0 +1,186 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.util.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.DocumentHierarchyLevel;\n+import com.ca.lsp.core.cobol.model.DocumentMapping;\n+import lombok.experimental.UtilityClass;\n+import org.antlr.v4.runtime.Token;\n+\n+import javax.annotation.Nonnull;\n+import java.util.*;\n+import java.util.function.Consumer;\n+\n+import static com.ca.lsp.core.cobol.parser.CobolLexer.COPYENTRY;\n+import static com.ca.lsp.core.cobol.parser.CobolLexer.COPYEXIT;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class maps positions of extended document to the original ones.\n+ *\n+ * <p>Preprocessor may internally change the content of the processing document, so the resulting\n+ * positions of syntax and semantic analysis won't match the user expectations. In order to avoid\n+ * it, the tokens provided by {@link com.ca.lsp.core.cobol.parser.CobolLexer} should be compared\n+ * with ones provided by {@link com.ca.lsp.core.cobol.parser.CobolPreprocessorLexer}. The comparison\n+ * applied by string equity.\n+ */\n+@UtilityClass\n+public class PositionMappingUtils {\n+\n+  private static final int URI_PREFIX_LENGTH = CPY_ENTER_TAG.length() + CPY_URI_OPEN.length();\n+  private static final int URI_SUFFIX_LENGTH = CPY_URI_CLOSE.length();\n+\n+  /**\n+   * Map the tokens of the extended document to original ones using document mapping, collected by\n+   * {@link com.ca.lsp.core.cobol.parser.CobolPreprocessorListener}.\n+   *\n+   * @param tokens - tokens of extended documents, provided by {@link\n+   *     com.ca.lsp.core.cobol.parser.CobolLexer}\n+   * @param documentPositions - initial document and copybooks positions\n+   * @param documentUri - URI of the current document\n+   * @return map of tokens and original positions.\n+   */\n+  public Map<Token, Position> createPositionMapping(\n+      List<Token> tokens, Map<String, DocumentMapping> documentPositions, String documentUri) {\n+    Map<Token, Position> result = new HashMap<>();\n+    Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+    enterDocument(documentUri, documentPositions, documentHierarchyStack);\n+    tokens.forEach(mapToken(documentPositions, result, documentHierarchyStack));\n+    return result;\n+  }\n+\n+  private Consumer<Token> mapToken(\n+      Map<String, DocumentMapping> documentPositions,\n+      Map<Token, Position> result,\n+      Deque<DocumentHierarchyLevel> documentHierarchyStack) {\n+    return token -> {\n+      if (token.getType() == COPYENTRY) {\n+        enterDocument(\n+            extractCopybookName(token.getText()), documentPositions, documentHierarchyStack);\n+      } else if (token.getType() == COPYEXIT) {\n+        exitDocument(documentHierarchyStack);\n+      } else {\n+        mapTokenToPosition(token, result, documentHierarchyStack);\n+      }\n+    };\n+  }\n+\n+  private void mapTokenToPosition(\n+      Token token,\n+      Map<Token, Position> mappingAccumulator,\n+      Deque<DocumentHierarchyLevel> documentHierarchyStack) {\n+    Position position = currentDocument(documentHierarchyStack).getCurrent();\n+    if (position == null) return;\n+    if (tokenMatches(token.getText(), position.getToken())) {\n+      mappingAccumulator.put(token, position);\n+      currentDocument(documentHierarchyStack).forward();\n+    } else {\n+      applyLookAhead(token, mappingAccumulator, documentHierarchyStack);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODUzNzg3Nw==", "bodyText": "Are you sure about that? Never seen formatting string with groups like (? ... )\nOr maybe you use the result inside the Antlr engine?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r468537877", "createdAt": "2020-08-11T12:21:12Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/ReplacingServiceImpl.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.util.impl;\n+\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceClauseContext;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplacePseudoTextContext;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceSameElementContext;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTree;\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import javax.annotation.Nonnull;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.regex.Pattern;\n+\n+import static com.ca.lsp.core.cobol.parser.CobolPreprocessor.ReplaceliteralContext;\n+import static java.lang.String.format;\n+import static java.util.Arrays.stream;\n+import static java.util.Optional.ofNullable;\n+import static java.util.regex.Matcher.quoteReplacement;\n+import static java.util.stream.Collectors.joining;\n+import static org.apache.commons.lang3.StringUtils.split;\n+\n+/**\n+ * This service applies replacing for given text by replace clauses and tokens. It may work with\n+ * REPLACING and REPLACE statements.\n+ */\n+@Singleton\n+public class ReplacingServiceImpl implements ReplacingService {\n+  /**\n+   * Look-before and look-ahead pattern to check that the token wrapped with separators, i.e.\n+   * whitespaces, dots ot line breaks. Not includes separators to the found substring.\n+   */\n+  private static final String SEPARATE_TOKEN_PATTERN = \"(?<=[\\\\.\\\\s\\\\r\\\\n])%s(?=[\\\\.\\\\s\\\\r\\\\n])\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7f0559923fe2977b23a4b27459b916fff8375225"}, "originalPosition": 52}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6363a22a01d3b00cc6cc989371483052f34ebd21", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6363a22a01d3b00cc6cc989371483052f34ebd21", "committedDate": "2020-08-11T15:05:11Z", "message": "refactor: Decrease visibility of DocumentHierarchyLevel and provide Javadocs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "363fd7be9400050f828fec198858cb27d484486e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/363fd7be9400050f828fec198858cb27d484486e", "committedDate": "2020-08-12T14:03:08Z", "message": "refactor: Remove unused grammar listener nodes from preporcessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7e33ca760bc50e135aece08c84184d6a9da1833d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7e33ca760bc50e135aece08c84184d6a9da1833d", "committedDate": "2020-08-12T14:31:45Z", "message": "test: Add unit test coverage for all the copybook processing cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33fb92ad466276f768385f5d48ae7e93394d71b1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/33fb92ad466276f768385f5d48ae7e93394d71b1", "committedDate": "2020-08-13T16:58:28Z", "message": "refactor: Remove redundand REPLACE OFF processing"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzU5Mjk2", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-467359296", "createdAt": "2020-08-14T07:22:48Z", "commit": {"oid": "33fb92ad466276f768385f5d48ae7e93394d71b1"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae810f0a0768d1d02c2e1da1221944350e66c34f", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ae810f0a0768d1d02c2e1da1221944350e66c34f", "committedDate": "2020-08-14T09:01:02Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98c6b8b2c56d04ed2153da2bf756fa530ed55701", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/98c6b8b2c56d04ed2153da2bf756fa530ed55701", "committedDate": "2020-08-14T11:12:12Z", "message": "docs: Update readme and changelog for REPLACING etc."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7218af23ce90fe431f4117be815051c480a78540", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7218af23ce90fe431f4117be815051c480a78540", "committedDate": "2020-08-14T16:42:48Z", "message": "refactor: Prevent index exception on replacing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba0b3191760f86c4e57b45587c00c8b74fbb2aef", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ba0b3191760f86c4e57b45587c00c8b74fbb2aef", "committedDate": "2020-08-14T16:43:19Z", "message": "test: Add test coverage for ReplacingServiceImpl"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7d8eecf03fed651573eabfac80f249865c7fe741", "committedDate": "2020-08-17T11:39:57Z", "message": "refactor: Make preprocessor grammar less eager to validate pseudo-text replacing correctly"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NDUxNDIy", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-468451422", "createdAt": "2020-08-17T13:15:02Z", "commit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NDU3MTIw", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-468457120", "createdAt": "2020-08-17T13:22:15Z", "commit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NDk3OTI3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-468497927", "createdAt": "2020-08-17T14:10:46Z", "commit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNDoxMDo0NlrOHBqarQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xN1QxNDoxMDo0NlrOHBqarQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTUwNTU4MQ==", "bodyText": "I hope that only one should be left.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r471505581", "createdAt": "2020-08-17T14:10:46Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/pom.xml", "diffHunk": "@@ -41,7 +42,9 @@\n         <commons.io.version>2.5</commons.io.version>\n         <commons.text.version>1.6</commons.text.version>\n         <lombok.version>1.18.10</lombok.version>\n-        <junit.version>4.12</junit.version>\n+        <junit-jupiter.version>5.6.0</junit-jupiter.version>\n+        <junit.platform.version>1.6.0</junit.platform.version>\n+        <junit.platform.version>1.5.2</junit.platform.version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NDk5NTM3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-468499537", "createdAt": "2020-08-17T14:12:38Z", "commit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY4NTEyMTEy", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-468512112", "createdAt": "2020-08-17T14:26:08Z", "commit": {"oid": "7d8eecf03fed651573eabfac80f249865c7fe741"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a89002df6587955c953ec002998f2bf98b5a57b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5a89002df6587955c953ec002998f2bf98b5a57b", "committedDate": "2020-05-06T10:42:09Z", "message": "feat: Introduce replacing support GH-335\nAdd capability to replace copybook content by the pattern provided in a REPLACING statement.\nIntroduce synchronous building for the extend document.\nRemove deprecated async copybook processing."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a54d1879e1a2fa811c7471084ac2f55547f2f5a8", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a54d1879e1a2fa811c7471084ac2f55547f2f5a8", "committedDate": "2020-05-06T11:52:19Z", "message": "perf: Move document cleaning to cobol preprocessor GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d3dfa8868d86e89779e5536d9590eecb6903036a", "author": {"user": {"login": "sergiuilie", "name": "Sergiu Ilie"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d3dfa8868d86e89779e5536d9590eecb6903036a", "committedDate": "2020-05-06T11:52:32Z", "message": "perf: Move exec statements to Preprocessor GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da1102682c28e6410e15fa783f527798862d4ca4", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/da1102682c28e6410e15fa783f527798862d4ca4", "committedDate": "2020-05-06T11:52:50Z", "message": "perf: Remove separate cleaner on preprocessor stage GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2f1566e08782b59cf2f795d99db726018ff9a304", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2f1566e08782b59cf2f795d99db726018ff9a304", "committedDate": "2020-05-06T11:52:50Z", "message": "perf: Remove deprecated parallel copybooks processing infrastructure GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cfe38659609d772d0f687d12e6549916185d899a", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/cfe38659609d772d0f687d12e6549916185d899a", "committedDate": "2020-05-06T11:55:01Z", "message": "refactor: Fix variable structure building GH-220\nMake it work with the extended document."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08c9ac856e5ea4ede08110c6ea512b32ee6fae30", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/08c9ac856e5ea4ede08110c6ea512b32ee6fae30", "committedDate": "2020-05-06T11:56:18Z", "message": "test: Improve functional coverage of use cases GH-23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f1596361c32d6a69ce28cee760ca55635469116", "author": {"user": {"login": "sergiuilie", "name": "Sergiu Ilie"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1f1596361c32d6a69ce28cee760ca55635469116", "committedDate": "2020-05-06T12:01:30Z", "message": "perf: Remove unnecessary preprocessor grammar rules GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6250c8a4bf8a5a3801676648368c3fc92721b783", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/6250c8a4bf8a5a3801676648368c3fc92721b783", "committedDate": "2020-05-06T12:02:19Z", "message": "perf: Remove redudant cleaner grammar GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2cd70fbc3c0500c641e5ef7152c54d231180a669", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2cd70fbc3c0500c641e5ef7152c54d231180a669", "committedDate": "2020-05-06T12:02:19Z", "message": "refactor: Allow variable structure rebuild on each change GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5918ba72edd6ac9e54301690c41f7fb6bcf0c243", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/5918ba72edd6ac9e54301690c41f7fb6bcf0c243", "committedDate": "2020-05-06T12:04:40Z", "message": "refactor: Collect initial postions on preprocessor GH-220\nInitial positons needed to build mapping between extended and original document."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a3cde8df7ffbf7028bc03050ba922e8d957e1b7", "author": {"user": {"login": "sergiuilie", "name": "Sergiu Ilie"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8a3cde8df7ffbf7028bc03050ba922e8d957e1b7", "committedDate": "2020-05-06T12:07:52Z", "message": "refactor: Add copybooks entry/exit marker GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9132ee74a296a58c3cc5f1fdd95ac009ba5e974e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/9132ee74a296a58c3cc5f1fdd95ac009ba5e974e", "committedDate": "2020-05-06T12:10:06Z", "message": "refactor: Introduce stack-based position calculation GH-220\nUse the Preprocessor to collect the initial document positions before expansions and copybook deltas (the difference between copybook definition and copybook size).\nUse a stack inside the Visitor to track the currently processing document hierarchy level. Calculate current token index shift based on accumulated deltas of the current stack head.\nLocate positions by token names."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a73c38ef05a67ee856f2604784196b16b4b9bd3", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a73c38ef05a67ee856f2604784196b16b4b9bd3", "committedDate": "2020-05-06T12:10:22Z", "message": "fix: Make variable usage processing left-to-right GH-220\nRight-to-to-left processing order for usages of structured variables may cause errors in position retrieving.\nThe reason is that in this case variable to the right shifts the current processing index too far and the position of the variable to the left is lost."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12439a83abc1ed52515830168b2a621c9db25136", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/12439a83abc1ed52515830168b2a621c9db25136", "committedDate": "2020-05-06T12:10:22Z", "message": "test: Adjust tests to the extended document building GH-220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa0db94c2366d55086a675cb603cbac4a523aa1b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fa0db94c2366d55086a675cb603cbac4a523aa1b", "committedDate": "2020-05-06T12:10:22Z", "message": "feat: Introduce full document syntax analysis GH-220\nBuild an the extended document by replacing copy statements with copybook content.\nRetrieve postions from the initial documents to map token positions from the extended document to the original ones.\nCollect the tokens of syntax errors found by the Parser grammar, semantic errors found by the CobolVisitor and the semantic elements positions and usages, and map them to the previosly collected initial positions.\nRemove duplicated children visiting in the Visitor."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b601672b357ca3290c0c7ffe69a5231c836366f1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b601672b357ca3290c0c7ffe69a5231c836366f1", "committedDate": "2020-05-06T16:31:13Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5MzA0MTUx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-409304151", "createdAt": "2020-05-11T15:52:48Z", "commit": {"oid": "4482b739663663c61d6f040812ed278d8b08ba4f"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Mjo0OFrOGTie6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMVQxNTo1Njo0NlrOGTiptg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0MTA5OA==", "bodyText": "To be refactored in #342", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423141098", "createdAt": "2020-05-11T15:52:48Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4482b739663663c61d6f040812ed278d8b08ba4f"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0MzU5NQ==", "bodyText": "The logic of calling this method is going to be changed in #340", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423143595", "createdAt": "2020-05-11T15:56:22Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4482b739663663c61d6f040812ed278d8b08ba4f"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzE0Mzg2Mg==", "bodyText": "To be used in #339", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r423143862", "createdAt": "2020-05-11T15:56:46Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitStatement(StatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfThen(IfThenContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfElse(IfElseContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitPerformInlineStatement(PerformInlineStatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitSentence(SentenceContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIdentifier(IdentifierContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitEvaluateWhenOther(EvaluateWhenOtherContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n-  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n-    if (ctx.dataName() != null) {\n-      String variable = ctx.dataName().getText().toUpperCase();\n-      checkForVariable(\n-          variable,\n-          ctx.getStart().getLine(),\n-          ctx.dataName().getStart().getCharPositionInLine(),\n-          ctx);\n-    }\n+  public Class visitParagraphName(ParagraphNameContext ctx) {\n+    paragraphs.define(ctx.getText().toUpperCase(), ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  public Class visitDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (checkForVariable(\n-        ctx.getText(), ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine(), null)) {\n-      checkParentContainsChildren(ctx.getText(), child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitDataDescriptionEntryFormat1(DataDescriptionEntryFormat1Context ctx) {\n+\n+    String levelNumber = ctx.otherLevel().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInData(\n-      String child, int childStartLine, int childPositionInLine, InDataContext ctx) {\n-    checkForDataName2(ctx.dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat2(DataDescriptionEntryFormat2Context ctx) {\n+\n+    String levelNumber = ctx.LEVEL_NUMBER_66().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInTable(\n-      String child, int childStartLine, int childPositionInLine, InTableContext ctx) {\n-    checkForDataName2(ctx.tableCall().dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat3(DataDescriptionEntryFormat3Context ctx) {\n+    String levelNumber = ctx.LEVEL_NUMBER_88().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n+  private void defineVariable(String level, String name, Token token) {\n+    variables.define(new Variable(level, name), token);\n+  }\n+\n   @Override\n   public Class visitParagraphNameUsage(ParagraphNameUsageContext ctx) {\n-    addUsage(semanticContext.getParagraphs(), ctx);\n+    String name = ctx.getText().toUpperCase();\n+    addUsage(paragraphs, name, ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  private void checkForDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (ctx != null) {\n-      visitDataName2(ctx, child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n+    ofNullable(ctx.dataName())\n+        .map(it -> it.getText().toUpperCase())\n+        .ifPresent(variable -> checkForVariable(variable, ctx));\n+    return visitChildren(ctx);\n   }\n \n-  private void throwWarning(String wrongToken, int startLine, int charPositionInLine) {\n-    MisspelledKeywordDistance.calculateDistance(wrongToken.toUpperCase())\n-        .ifPresent(\n-            correctWord ->\n-                getSemanticError(wrongToken, startLine, charPositionInLine, correctWord));\n-  }\n+  @Override\n+  public Class visitTerminal(TerminalNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n \n-  private void throwSuggestion(String wrongToken, int startLine, int charPositionInLine) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"Invalid definition for: \" + wrongToken)\n-            .severity(INFO_LEVEL)\n-            .build());\n+    return super.visitTerminal(node);\n   }\n \n-  private void getSemanticError(\n-      String wrongToken, int startLine, int charPositionInLine, String correctWord) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"A misspelled word, maybe you want to put \" + correctWord)\n-            .severity(WARNING_LEVEL)\n-            .build());\n+  @Override\n+  public Class visitErrorNode(ErrorNode node) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4482b739663663c61d6f040812ed278d8b08ba4f"}, "originalPosition": 324}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "committedDate": "2020-05-12T09:50:24Z", "message": "refactor: Add caching for copybooks on preprocessor #220"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4482b739663663c61d6f040812ed278d8b08ba4f", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4482b739663663c61d6f040812ed278d8b08ba4f", "committedDate": "2020-05-07T16:50:59Z", "message": "refactor: Add caching for copybooks on preprocessor #220"}, "afterCommit": {"oid": "8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8ff55efcc7856b814f7172cb17a3080fbbe8baf1", "committedDate": "2020-05-12T09:50:24Z", "message": "refactor: Add caching for copybooks on preprocessor #220"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNjkzNDk5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-410693499", "createdAt": "2020-05-13T08:19:13Z", "commit": {"oid": "8ff55efcc7856b814f7172cb17a3080fbbe8baf1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODoxOToxM1rOGUmmtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xM1QwODoxOToxM1rOGUmmtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDI1NzIwNQ==", "bodyText": "This may throw similar semantic errors for different reasons. To be fixed in #321", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r424257205", "createdAt": "2020-05-13T08:19:13Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +48,293 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionEntryCpy(DataDescriptionEntryCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitEnterCpy(EnterCpyContext ctx) {\n+    String cpyName = retrieveCpyName(ctx.IDENTIFIER(), ctx);\n+    documentHierarchyStack.push(nextDocLevel(cpyName));\n+    return visitChildren(ctx);\n+  }\n+\n+  private String retrieveCpyName(TerminalNode identifier, ParserRuleContext ctx) {\n+    return ofNullable(identifier)\n+        .map(ParseTree::getText)\n+        .orElse(ctx.getChildCount() > 1 ? ctx.getChild(1).getText() : \"\");\n+  }\n+\n+  private DocumentHierarchyLevel nextDocLevel(String cpyName) {\n+    return new DocumentHierarchyLevel(\n+        cpyName, ofNullable(documentPositions.get(cpyName)).orElse(emptyList()));\n+  }\n+\n+  @Override\n+  public Class visitDataDescriptionExitCpy(DataDescriptionExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  @Override\n+  public Class visitExitCpy(ExitCpyContext ctx) {\n+    moveToPreviousLevel();\n+    return visitChildren(ctx);\n+  }\n+\n+  private void moveToPreviousLevel() {\n+    documentHierarchyStack.pop();\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitStatement(StatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfThen(IfThenContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIfElse(IfElseContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitPerformInlineStatement(PerformInlineStatementContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitSentence(SentenceContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitIdentifier(IdentifierContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n   public Class visitEvaluateWhenOther(EvaluateWhenOtherContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n   @Override\n-  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n-    if (ctx.dataName() != null) {\n-      String variable = ctx.dataName().getText().toUpperCase();\n-      checkForVariable(\n-          variable,\n-          ctx.getStart().getLine(),\n-          ctx.dataName().getStart().getCharPositionInLine(),\n-          ctx);\n-    }\n+  public Class visitParagraphName(ParagraphNameContext ctx) {\n+    paragraphs.define(ctx.getText().toUpperCase(), ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  public Class visitDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (checkForVariable(\n-        ctx.getText(), ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine(), null)) {\n-      checkParentContainsChildren(ctx.getText(), child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitDataDescriptionEntryFormat1(DataDescriptionEntryFormat1Context ctx) {\n+\n+    String levelNumber = ctx.otherLevel().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInData(\n-      String child, int childStartLine, int childPositionInLine, InDataContext ctx) {\n-    checkForDataName2(ctx.dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat2(DataDescriptionEntryFormat2Context ctx) {\n+\n+    String levelNumber = ctx.LEVEL_NUMBER_66().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n-  public Class visitInTable(\n-      String child, int childStartLine, int childPositionInLine, InTableContext ctx) {\n-    checkForDataName2(ctx.tableCall().dataName2(), child, childStartLine, childPositionInLine);\n+  @Override\n+  public Class visitDataDescriptionEntryFormat3(DataDescriptionEntryFormat3Context ctx) {\n+    String levelNumber = ctx.LEVEL_NUMBER_88().getText();\n+    ofNullable(ctx.dataName1())\n+        .ifPresent(\n+            variable -> defineVariable(levelNumber, variable.getText(), variable.getStart()));\n     return visitChildren(ctx);\n   }\n \n+  private void defineVariable(String level, String name, Token token) {\n+    variables.define(new Variable(level, name), token);\n+  }\n+\n   @Override\n   public Class visitParagraphNameUsage(ParagraphNameUsageContext ctx) {\n-    addUsage(semanticContext.getParagraphs(), ctx);\n+    String name = ctx.getText().toUpperCase();\n+    addUsage(paragraphs, name, ctx.getStart());\n     return visitChildren(ctx);\n   }\n \n-  private void checkForDataName2(\n-      DataName2Context ctx, String child, int childStartLine, int childPositionInLine) {\n-    if (ctx != null) {\n-      visitDataName2(ctx, child, childStartLine, childPositionInLine);\n-    }\n+  @Override\n+  public Class visitQualifiedDataNameFormat1(QualifiedDataNameFormat1Context ctx) {\n+    ofNullable(ctx.dataName())\n+        .map(it -> it.getText().toUpperCase())\n+        .ifPresent(variable -> checkForVariable(variable, ctx));\n+    return visitChildren(ctx);\n   }\n \n-  private void throwWarning(String wrongToken, int startLine, int charPositionInLine) {\n-    MisspelledKeywordDistance.calculateDistance(wrongToken.toUpperCase())\n-        .ifPresent(\n-            correctWord ->\n-                getSemanticError(wrongToken, startLine, charPositionInLine, correctWord));\n-  }\n+  @Override\n+  public Class visitTerminal(TerminalNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n \n-  private void throwSuggestion(String wrongToken, int startLine, int charPositionInLine) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"Invalid definition for: \" + wrongToken)\n-            .severity(INFO_LEVEL)\n-            .build());\n+    return super.visitTerminal(node);\n   }\n \n-  private void getSemanticError(\n-      String wrongToken, int startLine, int charPositionInLine, String correctWord) {\n-    errors.add(\n-        SyntaxError.syntaxError()\n-            .position(\n-                new Position(\n-                    documentUri,\n-                    charPositionInLine,\n-                    getWrongTokenStopPosition(wrongToken, charPositionInLine),\n-                    startLine,\n-                    charPositionInLine))\n-            .suggestion(\"A misspelled word, maybe you want to put \" + correctWord)\n-            .severity(WARNING_LEVEL)\n-            .build());\n+  @Override\n+  public Class visitErrorNode(ErrorNode node) {\n+    Token token = node.getSymbol();\n+    Position position = calculatePosition(token);\n+    mapping.put(token, position);\n+\n+    return super.visitTerminal(node);\n   }\n \n-  private boolean checkForVariable(\n-      String variable, int startLine, int charPositionInLine, ParserRuleContext ctx) {\n-    if (!semanticContext.getVariables().contains(variable)) {\n-      throwSuggestion(variable, startLine, charPositionInLine);\n-      return false;\n-    } else if (ctx instanceof QualifiedDataNameFormat1Context\n-        && ((QualifiedDataNameFormat1Context) ctx).qualifiedInData() != null) {\n-      iterateOverQualifiedDataNames(\n-          (QualifiedDataNameFormat1Context) ctx, variable, startLine, charPositionInLine);\n-      addUsage(semanticContext.getVariables(), variable, ctx);\n+  private void checkForVariable(String variable, QualifiedDataNameFormat1Context ctx) {\n+    checkVariableDefinition(variable, ctx.getStart());\n+    addUsage(variables, variable, ctx.getStart());\n+\n+    if (ctx.qualifiedInData() != null) {\n+      iterateOverQualifiedDataNames(ctx, variable);\n     }\n-    return true;\n   }\n \n-  private void iterateOverQualifiedDataNames(\n-      QualifiedDataNameFormat1Context ctx, String variable, int startLine, int charPositionInLine) {\n+  private void iterateOverQualifiedDataNames(QualifiedDataNameFormat1Context ctx, String variable) {\n+    String child = variable;\n+    Token childToken = ctx.getStart();\n     for (QualifiedInDataContext node : ctx.qualifiedInData()) {\n-      if (node.inData() != null) {\n-        visitInData(variable, startLine, charPositionInLine, node.inData());\n-        DataName2Context context = node.inData().dataName2();\n-        variable = context.getText();\n-        addUsage(semanticContext.getVariables(), context);\n-      } else {\n-        visitInTable(variable, startLine, charPositionInLine, node.inTable());\n-        DataName2Context context = node.inTable().tableCall().dataName2();\n-        variable = context.getText();\n-        addUsage(semanticContext.getVariables(), context);\n-      }\n+\n+      DataName2Context context = getDataName2Context(node);\n+      String parent = context.getText().toUpperCase();\n+      Token parentToken = context.getStart();\n+\n+      checkVariableDefinition(parent, parentToken);\n+      checkVariableStructure(parent, child, childToken);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8ff55efcc7856b814f7172cb17a3080fbbe8baf1"}, "originalPosition": 375}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86a8ba02a349f03403100796dac7b401d9b705e7", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/86a8ba02a349f03403100796dac7b401d9b705e7", "committedDate": "2020-05-13T11:38:27Z", "message": "refactor: Make CPY tags work with URIs #220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60c0734c5e4335c72b7767c574e59082f4f77bd9", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/60c0734c5e4335c72b7767c574e59082f4f77bd9", "committedDate": "2020-05-13T13:00:06Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f6266e5221c343270be3fddaa79748c525536272", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f6266e5221c343270be3fddaa79748c525536272", "committedDate": "2020-06-05T09:38:36Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "537aee56929b078633a15ad75aaa3c9fec855e65", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/537aee56929b078633a15ad75aaa3c9fec855e65", "committedDate": "2020-06-08T13:06:59Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4fc5ab4c5119fb1dfb29af11df39b19a4f5f6504", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/4fc5ab4c5119fb1dfb29af11df39b19a4f5f6504", "committedDate": "2020-06-10T14:56:04Z", "message": "feat: Introduce Go To Definition for copybooks #387"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72f3cfecdaaeca9b896b411f7f0b163097a0f793", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/72f3cfecdaaeca9b896b411f7f0b163097a0f793", "committedDate": "2020-06-11T09:21:43Z", "message": "feat: Show syntax and semantic errors in copybooks GH-351\nSend errors found in the extended document to the related files in correct postitions."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI5ODI5MjM0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-429829234", "createdAt": "2020-06-12T15:19:49Z", "commit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNToxOTo0OVrOGjH9XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xMlQxNToxOTo0OVrOGjH9XQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQ4Mzc0MQ==", "bodyText": "Don't ask, I know it is disgusting. To be rewritten later.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r439483741", "createdAt": "2020-06-12T15:19:49Z", "author": {"login": "temanbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/strategy/CobolErrorStrategy.java", "diffHunk": "@@ -84,12 +77,32 @@ public void reportError(Parser recognizer, RecognitionException e) {\n     }\n   }\n \n+  @Override\n+  public void sync(Parser recognizer) {\n+    Token currentToken = recognizer.getCurrentToken();\n+    String terminal = currentToken.getText();\n+    // If the processing stopped at the copybook enter tag and cannot be recovered in place, it\n+    // means that there are, in fact, two affected tokens\n+    if (terminal.startsWith(\"*>CPYENTER\")) {\n+      int nextTokenType = recognizer.getInputStream().LA(3);\n+      IntervalSet expecting = getExpectedTokens(recognizer);\n+      if (expecting.contains(nextTokenType)) {\n+        // Move processing forward two times\n+        recognizer.consume();\n+        recognizer.consume();\n+      }\n+    }\n+    super.sync(recognizer);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNDM4NjM5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-430438639", "createdAt": "2020-06-15T08:44:20Z", "commit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODo0NDoyMFrOGjoubA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODo0NDoyMFrOGjoubA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAyMDU4OA==", "bodyText": "Adjective is used for Interface naming  -  ResolvableCopybook", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440020588", "createdAt": "2020-06-15T08:44:20Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNDYwNzA4", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-430460708", "createdAt": "2020-06-15T09:13:06Z", "commit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOToxMzowNlrOGjpxdQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwOToxMzowNlrOGjpxdQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAzNzc0OQ==", "bodyText": "replaceable with reduce(0, Integer::sum)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440037749", "createdAt": "2020-06-15T09:13:06Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -14,130 +14,297 @@\n package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n \n import com.broadcom.lsp.domain.common.model.Position;\n-import com.ca.lsp.core.cobol.model.CopybookUsage;\n-import com.ca.lsp.core.cobol.model.SyntaxError;\n-import com.ca.lsp.core.cobol.model.Variable;\n+import com.ca.lsp.core.cobol.model.*;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n import com.ca.lsp.core.cobol.preprocessor.sub.document.CobolSemanticParserListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorStringUtils;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorCleanerServiceImpl;\n-import com.ca.lsp.core.cobol.semantics.SemanticContext;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n import lombok.Getter;\n import lombok.extern.slf4j.Slf4j;\n import org.antlr.v4.runtime.BufferedTokenStream;\n import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n import org.antlr.v4.runtime.tree.TerminalNode;\n \n import javax.annotation.Nonnull;\n import javax.annotation.Nullable;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.function.Consumer;\n+import java.util.*;\n \n-import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.COMMENT_TAG;\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.convertTokensToPositions;\n+import static com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils.retrieveTokens;\n+import static java.lang.String.format;\n import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n \n /**\n- * ANTLR visitor, which preprocesses a given COBOL program by executing COPY and REPLACE statements.\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n  */\n @Slf4j\n public class CobolSemanticParserListenerImpl extends CobolPreprocessorBaseListener\n     implements CobolSemanticParserListener {\n   private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n   private static final String COPYBOOK_OVER_8_CHARACTERS =\n       \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n \n   @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n \n-  private final PreprocessorCleanerServiceImpl preprocessorCleanerService;\n-  private final String documentUri;\n-  private final BufferedTokenStream tokens;\n-  private final SemanticContext semanticContext;\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n \n+  private PreprocessorCleanerServiceImpl cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+\n+  @Inject\n   CobolSemanticParserListenerImpl(\n-      String documentUri, BufferedTokenStream tokens, SemanticContext semanticContext) {\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerServiceImpl cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions) {\n     this.documentUri = documentUri;\n     this.tokens = tokens;\n-    this.semanticContext = semanticContext;\n-\n-    preprocessorCleanerService = new PreprocessorCleanerServiceImpl();\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n   }\n \n   @Nonnull\n   @Override\n-  public CobolDocumentContext context() {\n-    return preprocessorCleanerService.context();\n+  public String getResult() {\n+    return cleaner.peek().read();\n   }\n \n   @Override\n-  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // push a new context for the COMPILER OPTIONS terminals\n-    preprocessorCleanerService.push();\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n   }\n \n   @Override\n-  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void enterParagraphName(@Nonnull ParagraphNameContext ctx) {\n-    semanticContext.getParagraphs().define(ctx.getText().toUpperCase(), retrievePosition(ctx));\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n   }\n \n   @Override\n-  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n-    preprocessorCleanerService.push();\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n-    // throw away COMPILER OPTIONS terminals\n-    preprocessorCleanerService.pop();\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat1(@Nonnull DataDescriptionEntryFormat1Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat2(@Nonnull DataDescriptionEntryFormat2Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n   }\n \n   @Override\n-  public void exitDataDescriptionEntryFormat3(@Nonnull DataDescriptionEntryFormat3Context ctx) {\n-    createVariableAndDefine(ctx);\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n   }\n \n   @Override\n   public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+\n+    // throw away COPY terminals\n+    cleaner.pop();\n+\n+    // a new context for the copy book content\n+    cleaner.peek().write(CPY_ENTER_TAG);\n     /*\n-     * define the copy book\n+     * copy the copy book\n      */\n-    CopySourceContext copySource = ctx.copySource();\n-    String copybookName = retrieveCopybookName(copySource);\n-    Position position = retrievePosition(copySource);\n-    defineCopybook(copybookName, position);\n+    String copybookName = retrieveCopybookName(ctx.copySource());\n+    Position position = retrievePosition(ctx.copySource());\n+\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String copybookContent = model.getContent();\n+\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, model.getUri());\n+\n+    List<ReplacingPhraseContext> replacingPhraseContexts = ctx.replacingPhrase();\n+    if (!replacingPhraseContexts.isEmpty()) {\n+      applyReplacing(copybookName, model.getUri(), copybookContent, replacingPhraseContexts);\n+    } else {\n+      writeCopybookContent(\"<URI>\" + model.getUri() + \"</URI>\", copybookContent);\n+    }\n+\n+    String content = cleaner.peek().read();\n+    cleaner.pop();\n+\n+    cleaner.peek().write(content);\n+  }\n+\n+  private void applyReplacing(\n+      String copybookName,\n+      String uri,\n+      String copybookContent,\n+      List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    String copybookWithReplacingName =\n+        getUniqueNameForReplacing(copybookName, replacingPhraseContexts);\n+\n+    cleaner.peek().write(\"<URI>\" + copybookWithReplacingName + \"</URI>. \");\n+    CobolDocumentContext documentContext = cleaner.push();\n+    replacingPhraseContexts.forEach(\n+        it -> documentContext.storeReplaceablesAndReplacements(it.replaceClause()));\n+\n+    documentContext.write(copybookContent);\n+    documentContext.replaceReplaceablesByReplacements(tokens);\n+\n+    documentMappings.put(\n+        copybookWithReplacingName,\n+        convertTokensToPositions(uri, retrieveTokens(documentContext.read())));\n+    documentContext.write(CPY_EXIT_TAG);\n+  }\n+\n+  private String getUniqueNameForReplacing(\n+      String copybookName, List<ReplacingPhraseContext> replacingPhraseContexts) {\n+    return copybookName\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce((r1, r2) -> r1 + r2)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 269}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNTAyMjA1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-430502205", "createdAt": "2020-06-15T10:08:13Z", "commit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDowODoxM1rOGjrugQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDowODoxM1rOGjrugQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA2OTc2MQ==", "bodyText": "both by default null", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440069761", "createdAt": "2020-06-15T10:08:13Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 50}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNTA4OTg5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-430508989", "createdAt": "2020-06-15T10:17:51Z", "commit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDoxNzo1MlrOGjsCiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDoxNzo1MlrOGjsCiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3NDg4OQ==", "bodyText": "This if block can be removed, if rootVariable != null used, we have false return at the end.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440074889", "createdAt": "2020-06-15T10:17:52Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/CobolVariableContext.java", "diffHunk": "@@ -94,6 +92,10 @@ public Variable get(String name) {\n   public boolean parentContainsSpecificChild(String rootVariableName, String targetVariableName) {\n     Variable rootVariable = get(rootVariableName);\n \n+    if (rootVariable == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 89}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNTEzNTQy", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-430513542", "createdAt": "2020-06-15T10:24:38Z", "commit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDoyNDozOFrOGjsQEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMDoyNDozOFrOGjsQEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3ODM1Mw==", "bodyText": "Should be documented, not merging into one, but onto two different collections", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440078353", "createdAt": "2020-06-15T10:24:38Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/NamedSubContext.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.semantics;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import lombok.Getter;\n+\n+import java.util.Collection;\n+\n+public class NamedSubContext<T> implements SubContext<String, T> {\n+\n+  @Getter private final Multimap<String, T> definitions = HashMultimap.create();\n+\n+  @Getter private final Multimap<String, T> usages = HashMultimap.create();\n+\n+  @Override\n+  public void define(String name, T token) {\n+    definitions.put(name, token);\n+  }\n+\n+  @Override\n+  public void addUsage(String name, T token) {\n+    usages.put(name, token);\n+  }\n+\n+  @Override\n+  public Collection<String> getAll() {\n+    return definitions.keySet();\n+  }\n+\n+  @Override\n+  public boolean contains(String name) {\n+    return definitions.containsKey(name);\n+  }\n+\n+  @Override\n+  public void merge(SubContext<String, T> subContext) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 51}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNTQ3NTIx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-430547521", "createdAt": "2020-06-15T11:17:15Z", "commit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMToxNzoxNlrOGjt1QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMToxNzoxNlrOGjt1QA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDEwNDI1Ng==", "bodyText": "same, by default null", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440104256", "createdAt": "2020-06-15T11:17:16Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestCopybookCaching.java", "diffHunk": "@@ -24,64 +25,54 @@\n import com.ca.lsp.cobol.positive.CobolText;\n import com.ca.lsp.cobol.service.mocks.MockCopybookService;\n import com.ca.lsp.cobol.service.mocks.MockCopybookServiceImpl;\n-import com.ca.lsp.core.cobol.model.CopybookUsage;\n-import com.ca.lsp.core.cobol.model.PreprocessedInput;\n-import com.ca.lsp.core.cobol.model.ResultWithErrors;\n-import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n-import com.ca.lsp.core.cobol.preprocessor.sub.copybook.AnalyseCopybookTask;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.impl.CopybookResolutionProvider;\n import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.MultiMapSerializableHelper;\n-import com.ca.lsp.core.cobol.semantics.SemanticContext;\n import com.google.common.collect.HashMultimap;\n import com.google.common.collect.Multimap;\n import com.google.inject.Guice;\n+import com.google.inject.Injector;\n import lombok.extern.slf4j.Slf4j;\n import org.junit.After;\n import org.junit.Before;\n import org.junit.Test;\n \n-import static java.util.Collections.emptyList;\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.DOCUMENT_URI;\n import static java.util.Collections.singletonList;\n import static junit.framework.TestCase.assertTrue;\n-import static org.mockito.ArgumentMatchers.any;\n-import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.when;\n \n /**\n- * This test checks the logic of caching logic performed by copybook analyzer. The cache invalidated\n- * before each test run. The runAnalysis() method starts the analyzing task synchronously, and after\n- * finish the content of the copybook should appear in cache managing by databus. After accessing\n- * the cache element its hit counter should increase to maintain the element persistence. Also, all\n- * the objects in cache expected to be serializable.\n+ * This test checks the caching logic performed by copybook resolution. The cache invalidated before\n+ * each test run. The runAnalysis() method starts the resolving task synchronously, and after finish\n+ * the content of the copybook should appear in cache managing by data bus. After accessing the\n+ * cache element its hit counter should increase to maintain the element persistence. Also, all the\n+ * objects in cache expected to be serializable.\n  */\n @Slf4j\n-public class AnalyzeCopybookCaching {\n+public class TestCopybookCaching {\n   private final String COPYBOOK_NAME = \"copy\";\n   private final String COPYBOOK_CONTENT = \"000230 77  REPORT-STATUS           PIC 99 VALUE ZERO.\";\n \n-  private final Position POSITION_FIRST_OCCURRENCE = new Position(null, 0, 0, 0, 0);\n-  private final Position POSITION_SECOND_OCCURRENCE = new Position(null, 10, 10, 10, 10);\n+  private final Position POSITION_FIRST_OCCURRENCE = new Position(null, 0, 0, 0, 0, null);\n+  private final Position POSITION_SECOND_OCCURRENCE = new Position(null, 10, 10, 10, 10, null);\n   private final Multimap<String, Position> paragraphDefinitions = HashMultimap.create();\n \n-  private final DataBusBroker databus =\n-      Guice.createInjector(new DatabusModule()).getInstance(DataBusBroker.class);\n-\n-  private CobolPreprocessor preprocessor = mock(CobolPreprocessor.class);\n+  private DataBusBroker databus = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 65}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwNTY4MTM4", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-430568138", "createdAt": "2020-06-15T11:49:52Z", "commit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMTo0OTo1MlrOGjuxYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQxMTo0OTo1MlrOGjuxYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDExOTY0OA==", "bodyText": "In many tests, there are similar/same testing steps with different value.\nIt would be perfect to extract it to a single method.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r440119648", "createdAt": "2020-06-15T11:49:52Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/usecases/TestVariableUsedSeveralTimesInOneStatement.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.cobol.usecases;\n+\n+import com.ca.lsp.cobol.service.delegates.validations.AnalysisResult;\n+import org.eclipse.lsp4j.Diagnostic;\n+import org.eclipse.lsp4j.Location;\n+import org.junit.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import static com.ca.lsp.cobol.service.delegates.validations.UseCaseUtils.*;\n+import static org.junit.Assert.assertEquals;\n+\n+/**\n+ * This test checks that document with multi-definitions parsed correctly and all the usages of\n+ * variables placed in one line found.\n+ */\n+public class TestVariableUsedSeveralTimesInOneStatement {\n+  private static final String TEXT =\n+      \"       Identification Division. \\n\"\n+          + \"       Program-id.    ProgramId.\\n\"\n+          + \"       Data Division.\\n\"\n+          + \"       Working-Storage Section.\\n\"\n+          + \"       01   PARENT1. \\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       01   PARENT2.\\n\"\n+          + \"        02   CHILD      PIC 9(4) Binary. \\n\"\n+          + \"       Procedure Division.\\n\"\n+          + \"       000-Main-Logic.\\n\"\n+          + \"           MOVE CHILD IN PARENT1 TO CHILD IN PARENT2.\\n\"\n+          + \"       End program ProgramId.\";\n+\n+  private static final String CHILD = \"CHILD\";\n+  private static final String PARENT1 = \"PARENT1\";\n+  private static final String PARENT2 = \"PARENT2\";\n+  private static final String MAIN_LOGIC = \"000-MAIN-LOGIC\";\n+\n+  @Test\n+  public void test() {\n+    AnalysisResult result = analyze(TEXT);\n+    assertDiagnostics(result.getDiagnostics());\n+\n+    assertCopybookUsages(result.getCopybookUsages());\n+    assertCopybookDefinitions(result.getCopybookDefinitions());\n+\n+    assertVariableUsages(result.getVariableUsages());\n+    assertVariableDefinitions(result.getVariableDefinitions());\n+\n+    assertParagraphDefinitions(result.getParagraphDefinitions());\n+    assertParagraphUsages(result.getParagraphUsages());\n+  }\n+\n+  private void assertDiagnostics(Map<String, List<Diagnostic>> diagnostics) {\n+    long numberOfDiagnostics = diagnostics.values().stream().mapToLong(List::size).sum();\n+    assertEquals(\"Diagnostics: \" + diagnostics.toString(), 0, numberOfDiagnostics);\n+  }\n+\n+  private void assertParagraphUsages(Map<String, List<Location>> usages) {\n+    assertEquals(\"Paragraph usages: \" + usages.toString(), 0, usages.size());\n+  }\n+\n+  private void assertParagraphDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Paragraph definitions: \" + definitions.toString(), 1, definitions.size());\n+    assertNumberOfLocations(definitions, MAIN_LOGIC, 1);\n+    assertLocation(definitions, MAIN_LOGIC, DOCUMENT_URI, 9, 7);\n+  }\n+\n+  private void assertCopybookDefinitions(Map<String, List<Location>> copybookDefinitions) {\n+    assertEquals(\n+        \"Copybook definitions: \" + copybookDefinitions.toString(), 0, copybookDefinitions.size());\n+  }\n+\n+  private void assertCopybookUsages(Map<String, List<Location>> copybookUsages) {\n+    assertEquals(\"Copybook usages: \" + copybookUsages.toString(), 0, copybookUsages.size());\n+  }\n+\n+  private void assertVariableDefinitions(Map<String, List<Location>> definitions) {\n+    assertEquals(\"Variable definitions: \" + definitions.toString(), 3, definitions.size());\n+\n+    assertNumberOfLocations(definitions, PARENT1, 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 95}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ee1f38ae68b2ab6d83ad412f00883abf7237ddb8", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ee1f38ae68b2ab6d83ad412f00883abf7237ddb8", "committedDate": "2020-06-15T12:49:46Z", "message": "feat: Support copybook usages everywhere GH-352"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a66a3bcd78d802ade4ebcd1505910ec4cf2c999", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a66a3bcd78d802ade4ebcd1505910ec4cf2c999", "committedDate": "2020-06-15T12:49:55Z", "message": "refactor: Introduce replacing statements with several patterns #350"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22", "committedDate": "2020-06-12T13:04:39Z", "message": "feat: Support copybook usages everythere #352"}, "afterCommit": {"oid": "2a66a3bcd78d802ade4ebcd1505910ec4cf2c999", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/2a66a3bcd78d802ade4ebcd1505910ec4cf2c999", "committedDate": "2020-06-15T12:49:55Z", "message": "refactor: Introduce replacing statements with several patterns #350"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "400d15f67cb7dc0f041740abd26ffb7055e2b47a", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/400d15f67cb7dc0f041740abd26ffb7055e2b47a", "committedDate": "2020-06-15T15:05:49Z", "message": "doc: Update javadocs for semantic context models"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c932ab348ce5aa01e9980a274848be7f2ec14730", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c932ab348ce5aa01e9980a274848be7f2ec14730", "committedDate": "2020-06-15T15:12:24Z", "message": "refactor: Use a predefined operator to simplify lambda #23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d74e2576393b6b24ef7de4a9ea49c8ab9c24e350", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d74e2576393b6b24ef7de4a9ea49c8ab9c24e350", "committedDate": "2020-06-16T08:11:54Z", "message": "refactor: Remove unnecessary default field declaration #23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "beed215ee23dce6de0a96f2964210665cf55ee5c", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/beed215ee23dce6de0a96f2964210665cf55ee5c", "committedDate": "2020-06-16T08:12:32Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec", "committedDate": "2020-06-16T11:03:43Z", "message": "refactor: Add null check for element with duplicated definitions #220"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69bc6f8d480460a49f701f52f878719f17bec9e3", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/69bc6f8d480460a49f701f52f878719f17bec9e3", "committedDate": "2020-06-18T17:05:48Z", "message": "refactor: Make replacing applicable immediately"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMzMTIxMzU1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-433121355", "createdAt": "2020-06-18T09:50:24Z", "commit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQwOTo1MDoyNFrOGloDCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOFQxNjoyNjo1N1rOGl3CSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEwNjYzNA==", "bodyText": "Multimap goes on input and outputs Map. We could lose data here. Is it possible to have many tokens for one key in source?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442106634", "createdAt": "2020-06-18T09:50:24Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExMDYyOA==", "bodyText": "You could use copy builder here like:\n    return err -> err.toBuilder()\n            .position(convertPositionRange(err.getStartToken(), err.getStopToken(), mapping))\n            .build();\n\nThe annotation for SyntaxError constructor must be changed to:\n  @Builder(builderMethodName = \"syntaxError\", toBuilder = true)", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442110628", "createdAt": "2020-06-18T09:57:09Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/engine/CobolLanguageEngine.java", "diffHunk": "@@ -59,32 +67,87 @@ public CobolLanguageEngine(CobolPreprocessor preprocessor) {\n   public ResultWithErrors<SemanticContext> run(\n       String documentUri, String text, String textDocumentSyncType) {\n \n-    ResultWithErrors<PreprocessedInput> preProcessedInput =\n+    ResultWithErrors<ExtendedDocument> extendedDocument =\n         preprocessor.process(documentUri, text, textDocumentSyncType);\n \n     CobolLexer lexer =\n-        new CobolLexer(CharStreams.fromString(preProcessedInput.getResult().getInput()));\n+        new CobolLexer(CharStreams.fromString(extendedDocument.getResult().getText()));\n \n-    List<SyntaxError> errors = new ArrayList<>(preProcessedInput.getErrors());\n+    List<SyntaxError> accumulatedErrors = new ArrayList<>(extendedDocument.getErrors());\n \n+    ParserListener listener = new ParserListener();\n     lexer.removeErrorListeners();\n-    lexer.addErrorListener(new VerboseListener(errors, documentUri));\n+    lexer.addErrorListener(listener);\n \n     CommonTokenStream tokens = new CommonTokenStream(lexer);\n-    CobolParser parser = new CobolParser(tokens);\n \n+    CobolParser parser = new CobolParser(tokens);\n     parser.removeErrorListeners();\n-    parser.addErrorListener(new VerboseListener(errors, documentUri));\n+    parser.addErrorListener(listener);\n     parser.setErrorHandler(new CobolErrorStrategy());\n \n     CobolParser.StartRuleContext tree = parser.startRule();\n-    CobolVisitor visitor =\n-        new CobolVisitor(documentUri, preProcessedInput.getResult().getSemanticContext());\n+    CobolVisitor visitor = new CobolVisitor(documentUri, extendedDocument.getResult());\n     visitor.visit(tree);\n \n-    errors.addAll(visitor.getErrors());\n+    Map<Token, Position> mapping = visitor.getMapping();\n+    accumulatedErrors.addAll(finalizeErrors(listener.getErrors(), mapping));\n+    accumulatedErrors.addAll(finalizeErrors(visitor.getErrors(), mapping));\n+    accumulatedErrors.forEach(err -> LOG.debug(err.toString()));\n+\n+    return new ResultWithErrors<>(buildSemanticContext(visitor, mapping), accumulatedErrors);\n+  }\n+\n+  private SemanticContext buildSemanticContext(CobolVisitor visitor, Map<Token, Position> mapping) {\n+    return new SemanticContext(\n+        mapPositions(visitor.getVariables().getDefinitions(), mapping),\n+        mapPositions(visitor.getVariables().getUsages(), mapping),\n+        mapPositions(visitor.getParagraphs().getDefinitions(), mapping),\n+        mapPositions(visitor.getParagraphs().getUsages(), mapping),\n+        visitor.getCopybooks().getDefinitions().asMap(),\n+        visitor.getCopybooks().getUsages().asMap());\n+  }\n+\n+  private Map<String, Collection<Position>> mapPositions(\n+      Multimap<String, Token> source, Map<Token, Position> mapping) {\n+    return source.asMap().entrySet().stream()\n+        .collect(toMap(Map.Entry::getKey, mapPositions(mapping)));\n+  }\n+\n+  private Function<Map.Entry<String, Collection<Token>>, Collection<Position>> mapPositions(\n+      Map<Token, Position> mapping) {\n+    return it -> it.getValue().stream().map(mapping::get).collect(toSet());\n+  }\n+\n+  private List<SyntaxError> finalizeErrors(List<SyntaxError> errors, Map<Token, Position> mapping) {\n+    return errors.stream()\n+        .map(convertError(mapping))\n+        .filter(it -> it.getPosition() != null)\n+        .collect(toList());\n+  }\n+\n+  private Function<SyntaxError, SyntaxError> convertError(Map<Token, Position> mapping) {\n+    return err ->\n+        SyntaxError.syntaxError()\n+            .severity(err.getSeverity())\n+            .ruleStack(err.getRuleStack())\n+            .suggestion(err.getSuggestion())\n+            .errorCode(err.getErrorCode())\n+            .position(convertPositionRange(err.getStartToken(), err.getStopToken(), mapping))\n+            .build();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjExODgyNw==", "bodyText": "Something seems to have interrupted you here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442118827", "createdAt": "2020-06-18T10:11:48Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/CopybookResolution.java", "diffHunk": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document;\n+\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+\n+/** This interface represents the API for retrieving copybooks */\n+public interface CopybookResolution {\n+\n+  /**\n+   * Retrieve and return the copybook by its name. C", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjEyNjg4OQ==", "bodyText": "You have deleted @Nonnull for ctx, but don't check the null before first use.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442126889", "createdAt": "2020-06-18T10:26:45Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/CobolSemanticParserListenerImpl.java", "diffHunk": "@@ -152,39 +319,48 @@ private void checkCopybookNameLength(String copybookName, Position position) {\n   }\n \n   @Override\n-  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+  public void exitReplaceArea(ReplaceAreaContext ctx) {\n     /*\n      * replacement phrase\n      */\n-    preprocessorCleanerService.pop();\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 357}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjMyOTgxMA==", "bodyText": "A bunch of methods visitSomething starts with throwWarning. It scares me.\nCould it be like throwWarningForMisspelledKeyword?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442329810", "createdAt": "2020-06-18T15:52:20Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/visitor/CobolVisitor.java", "diffHunk": "@@ -38,212 +47,275 @@\n   private static final int INFO_LEVEL = 3;\n \n   @Getter private List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private Map<Token, Position> mapping = new HashMap<>();\n+  @Getter private SubContext<String, Token> paragraphs = new NamedSubContext<>();\n+  @Getter private CobolVariableContext<Token> variables = new CobolVariableContext<>();\n \n-  private String documentUri;\n-  private SemanticContext semanticContext;\n+  @Getter private NamedSubContext<Position> copybooks;\n \n-  public CobolVisitor(String documentUri, SemanticContext semanticContext) {\n-    this.documentUri = documentUri;\n-    this.semanticContext = semanticContext;\n+  private Deque<DocumentHierarchyLevel> documentHierarchyStack = new ArrayDeque<>();\n+  private Map<String, List<Position>> documentPositions;\n+\n+  public CobolVisitor(String documentUri, ExtendedDocument extendedDocument) {\n+    copybooks = extendedDocument.getCopybooks();\n+    documentPositions = extendedDocument.getDocumentPositions();\n+    documentHierarchyStack.push(\n+        new DocumentHierarchyLevel(\n+            documentUri, new ArrayList<>(documentPositions.get(documentUri))));\n+  }\n+\n+  @Nullable\n+  private Position calculatePosition(Token token) {\n+    DocumentHierarchyLevel currentDocument = documentHierarchyStack.peek();\n+    if (currentDocument == null) {\n+      return null;\n+    }\n+    String tokenText = token.getText();\n+    List<Position> positions = currentDocument.getPositions();\n+    Position position = findPosition(tokenText, positions);\n+    if (position != null) {\n+      currentDocument.setPositions(\n+          positions.subList(positions.indexOf(position) + 1, positions.size()));\n+    } else {\n+      position = applyReversePositionLookUp(tokenText, currentDocument.getName(), positions.size());\n+    }\n+    return position;\n+  }\n+\n+  private Position applyReversePositionLookUp(\n+      String tokenText, String docName, int numberOfCurrentPositions) {\n+\n+    List<Position> initialPositions = documentPositions.get(docName);\n+    if (initialPositions == null) {\n+      return null;\n+    }\n+\n+    List<Position> subList =\n+        initialPositions.subList(0, initialPositions.size() - numberOfCurrentPositions);\n+    Collections.reverse(subList);\n+\n+    return findPosition(tokenText, subList);\n+  }\n+\n+  private Position findPosition(String tokenText, List<Position> subList) {\n+    return subList.stream().filter(it -> it.getToken().equals(tokenText)).findFirst().orElse(null);\n   }\n \n   @Override\n   public Class visitProcedureSection(ProcedureSectionContext ctx) {\n-    String wrongToken = ctx.getStart().getText();\n-    throwWarning(wrongToken, ctx.getStart().getLine(), ctx.getStart().getCharPositionInLine());\n+    throwWarning(ctx.getStart());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjM1MjIwMg==", "bodyText": "It could be done like this:\n.collect(groupingBy(error -> error.getPosition().getDocumentURI(), mapping(toDiagnostic(), toList())));", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r442352202", "createdAt": "2020-06-18T16:26:57Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "diffHunk": "@@ -68,23 +76,69 @@ public AnalysisResult analyze(\n     return toAnalysisResult(engine.run(uri, text, textDocumentSyncType.toString()), uri);\n   }\n \n+  /**\n+   * Don't analyze the document if it is empty or contains only sequence area\n+   *\n+   * @param text - document to analyze\n+   * @return true if the document is empty from the engine point of view\n+   */\n   private static boolean isEmpty(String text) {\n     return text.length() <= FIRST_LINE_SEQ_AND_EXTRA_OP;\n   }\n \n-  private static List<Diagnostic> convertErrors(List<SyntaxError> errors, String uri) {\n+  private AnalysisResult toAnalysisResult(ResultWithErrors<SemanticContext> result, String uri) {\n+    SemanticContext context = result.getResult();\n+    return new AnalysisResult(\n+        collectDiagnosticsForAffectedDocuments(\n+            convertErrors(result.getErrors()), context.getCopybookDefinitions(), uri),\n+        convertPositions(context.getVariableDefinitions()),\n+        convertPositions(context.getVariableUsages()),\n+        convertPositions(context.getParagraphDefinitions()),\n+        convertPositions(context.getParagraphUsages()),\n+        convertPositions(context.getCopybookDefinitions()),\n+        convertPositions(context.getCopybookUsages()));\n+  }\n+\n+  /**\n+   * Collect diagnostics for each document, used in the analysis - the main COBOL file and all the\n+   * copybooks. If there were no errors for some URI, then provide an empty list to clean-up the\n+   * errors after the previous analysis.\n+   *\n+   * @param diagnostics - list of found syntax and semantic errors\n+   * @param copybookDefinitions - list of copybook definitions used in this analysis\n+   * @param uri - current document URI\n+   * @return map with file URI as a key, and lists of diagnostics as values\n+   */\n+  private Map<String, List<Diagnostic>> collectDiagnosticsForAffectedDocuments(\n+      Map<String, List<Diagnostic>> diagnostics,\n+      Map<String, Collection<Position>> copybookDefinitions,\n+      String uri) {\n+    Map<String, List<Diagnostic>> result = new HashMap<>(diagnostics);\n+    copybookDefinitions.values().stream()\n+        .flatMap(Collection::stream)\n+        .map(Position::getDocumentURI)\n+        .forEach(it -> result.putIfAbsent(it, emptyList()));\n+    result.putIfAbsent(uri, emptyList());\n+    return result;\n+  }\n+\n+  private static Map<String, List<Diagnostic>> convertErrors(List<SyntaxError> errors) {\n     return errors.stream()\n-        .filter(errorOnlyFromCurrentDocument(uri))\n-        .map(toDiagnostic())\n-        .collect(toList());\n+        .map(SyntaxError::getPosition)\n+        .map(Position::getDocumentURI)\n+        .distinct()\n+        .collect(toMap(uri -> uri, toDiagnostics(errors)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "81d185fb48776f0bdfadb2ed9ac2ac4f27dc6fec"}, "originalPosition": 111}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "31462a39a249ec0a869ac6fac9c6b6e4991e83ca", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/31462a39a249ec0a869ac6fac9c6b6e4991e83ca", "committedDate": "2020-06-18T17:50:03Z", "message": "doc: Fix Javadoc for CopybookResolution"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c9bb71ef06e9d929e9870e58dbcc1068cc5a7c06", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c9bb71ef06e9d929e9870e58dbcc1068cc5a7c06", "committedDate": "2020-06-19T13:44:09Z", "message": "refactor: Extract REPLACING as a separate service #335"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c822649ceb76b7382780113d8a2066578accf173", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c822649ceb76b7382780113d8a2066578accf173", "committedDate": "2020-06-19T14:45:13Z", "message": "refactor: Collapse function duplication in Prerpocessor listener #335"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "98da0d1e89526a642ad4361202485c41efa58afd", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/98da0d1e89526a642ad4361202485c41efa58afd", "committedDate": "2020-06-19T15:09:09Z", "message": "refactor: Remove redundant conditional clause in replacing application #335"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "104190aacc2d57af0e35dd7942f2251b34f660be", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/104190aacc2d57af0e35dd7942f2251b34f660be", "committedDate": "2020-06-19T16:02:55Z", "message": "refactor: Apply replacing for copybook before processing #335"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eca869dd1d2ccb7d901767ce94b7bac54c15f7be", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/eca869dd1d2ccb7d901767ce94b7bac54c15f7be", "committedDate": "2020-06-19T16:39:34Z", "message": "refactor: Simplify preprocessor cleaning API #335"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c2012ac504b4db4df8b1bc96cd0396a3c8fb81d9", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/c2012ac504b4db4df8b1bc96cd0396a3c8fb81d9", "committedDate": "2020-06-19T16:45:23Z", "message": "refactor: Remove redundant null check"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "85acdca0274f3c5b508ff8dcd1f040706b0e81b1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/85acdca0274f3c5b508ff8dcd1f040706b0e81b1", "committedDate": "2020-06-22T11:14:10Z", "message": "refactor: Make visitor accept missing copybook names #355"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "33af0bb2c603fc59873f6c30dc717c85cb22bda9", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/33af0bb2c603fc59873f6c30dc717c85cb22bda9", "committedDate": "2020-06-22T11:19:38Z", "message": "refactor: Simplify adjusting syntax errors using toBuilder() #23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a8db4b56ccb64b3e85c9a4b92a09c55084e2326f", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a8db4b56ccb64b3e85c9a4b92a09c55084e2326f", "committedDate": "2020-06-22T11:36:08Z", "message": "refactor: Simplify syntax error conversion #23"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56a454e9c0d7ddd308056497a0cf21297759b760", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/56a454e9c0d7ddd308056497a0cf21297759b760", "committedDate": "2020-06-22T13:13:46Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ff1218129ce6538128f8732ddbff068f91a86e3e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ff1218129ce6538128f8732ddbff068f91a86e3e", "committedDate": "2020-06-24T14:45:11Z", "message": "fix: Make COPY accept only one REPLACING with multiple patterns #335"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ad03ee843214c8d80ec28a37bf976637c145a47b", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ad03ee843214c8d80ec28a37bf976637c145a47b", "committedDate": "2020-06-25T13:13:24Z", "message": "refactor: Clean-up replacing infrastructure"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83aa91138d24f2b7474338e5878db9704ad7b9d1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/83aa91138d24f2b7474338e5878db9704ad7b9d1", "committedDate": "2020-06-25T16:11:05Z", "message": "refactor: Make literal replacing applicable only for full tokens #335"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7f03d0bca35cadd9dbcdb4fc5a58313ccf6a96a7", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/7f03d0bca35cadd9dbcdb4fc5a58313ccf6a96a7", "committedDate": "2020-06-26T08:08:36Z", "message": "refactor: Exstract replacing logic to increase testability #335"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22eef64502a017908d5a96cfab71e40f5d077a06", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/22eef64502a017908d5a96cfab71e40f5d077a06", "committedDate": "2020-06-26T10:30:20Z", "message": "refactor: Extract token utils to provide DI #24"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69283e391feb9c63678ad0cfab9ad6de9f9944dd", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/69283e391feb9c63678ad0cfab9ad6de9f9944dd", "committedDate": "2020-06-26T12:52:55Z", "message": "refactor: Remove redundant method to simplify token utils API"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47be51219c7ea7d822342b11e8bcad0be9268afd", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/47be51219c7ea7d822342b11e8bcad0be9268afd", "committedDate": "2020-06-26T13:08:44Z", "message": "refactor: Move value class to the appropriate place"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b408f09304f082171b2e609884c22ec5b3eab66e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b408f09304f082171b2e609884c22ec5b3eab66e", "committedDate": "2020-06-26T14:52:13Z", "message": "refactor: Bind preprocessor cleaner to increase testability #24"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bdfdf706a8e1b2510a43240535ae328d2fd463d1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/bdfdf706a8e1b2510a43240535ae328d2fd463d1", "committedDate": "2020-06-26T15:45:48Z", "message": "refactor: Move classes to the appropriate packages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "470825ce3075e1b58964484415043d80ae9df449", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/470825ce3075e1b58964484415043d80ae9df449", "committedDate": "2020-06-26T16:36:35Z", "message": "refactor: Change out-of-date name of preprocessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/3a8948e156deaa357f8179d50484136219c597ac", "committedDate": "2020-06-29T08:36:36Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5ODEzNjk1", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-439813695", "createdAt": "2020-06-30T08:59:55Z", "commit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwODo1OTo1NVrOGqy3mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQwODo1OTo1NVrOGqy3mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUyNjgxMA==", "bodyText": "Is it still valid? We must expect .c4z/.copybooks.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447526810", "createdAt": "2020-06-30T08:59:55Z", "author": {"login": "grianbrcom"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -31,45 +30,36 @@\n import com.google.inject.Injector;\n import lombok.experimental.UtilityClass;\n import org.awaitility.Awaitility;\n-import org.eclipse.lsp4j.Diagnostic;\n-import org.eclipse.lsp4j.DidOpenTextDocumentParams;\n-import org.eclipse.lsp4j.TextDocumentItem;\n-import org.eclipse.lsp4j.services.LanguageClient;\n+import org.eclipse.lsp4j.*;\n import org.eclipse.lsp4j.services.TextDocumentService;\n \n import java.util.List;\n+import java.util.Map;\n import java.util.concurrent.Callable;\n import java.util.concurrent.TimeUnit;\n \n+import static com.ca.lsp.cobol.service.TextDocumentSyncType.DID_OPEN;\n import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n import static java.util.stream.Collectors.toList;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n \n /** This utility class provides methods to run use cases with Cobol code examples. */\n @UtilityClass\n public class UseCaseUtils {\n   public static final String DOCUMENT_URI = \"file:///c%3A/workspace/document.cbl\";\n   public static final String DOCUMENT_2_URI = \"file:///c%3A/workspace/document2.cbl\";\n+  private static final String CPY_URI_PREFIX = \"file:///c%3A/workspace/.copybooks/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTQ1ODc3", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-440145877", "createdAt": "2020-06-30T15:40:56Z", "commit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0MDo1N1rOGrCh5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0MDo1N1rOGrCh5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4MzM5OA==", "bodyText": "Just initialize copybookName during declaration, then this line can be removed.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447783398", "createdAt": "2020-06-30T15:40:57Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 339}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTUzNDI4", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-440153428", "createdAt": "2020-06-30T15:49:14Z", "commit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0OToxNVrOGrC5Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo0OToxNVrOGrC5Ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc4OTM3MQ==", "bodyText": "!( isEmpty(copybookName) || isEmpty(uri) ) is simpler and no double-negate", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447789371", "createdAt": "2020-06-30T15:49:15Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 350}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTU2NTA0", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-440156504", "createdAt": "2020-06-30T15:51:33Z", "commit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MTozNFrOGrDAJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MTozNFrOGrDAJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MTE0Mg==", "bodyText": "Why hard coded? better use existing meaningful constant.\nseverity(DiagnosticSeverity.Error.getValue())", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447791142", "createdAt": "2020-06-30T15:51:34Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 369}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTU2NjQ4", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-440156648", "createdAt": "2020-06-30T15:51:44Z", "commit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MTo0NFrOGrDAsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MTo0NFrOGrDAsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MTI4MQ==", "bodyText": "same", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447791281", "createdAt": "2020-06-30T15:51:44Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)\n+            .suggestion(String.format(RECURSION_DETECTED, usage.getName()))\n+            .position(usage.getPosition())\n+            .build());\n+  }\n+\n+  private void reportMissingCopybooks(String copybookName, Position position) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .position(position)\n+            .suggestion(format(ERROR_SUGGESTION, copybookName))\n+            .severity(1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 380}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwMTU3NDI5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-440157429", "createdAt": "2020-06-30T15:52:38Z", "commit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNTo1MjozOVrOGrDEPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0zMFQxNjo0NjozNFrOGrFbRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5MjE5MQ==", "bodyText": ".severity(DiagnosticSeverity.Information.getValue())", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447792191", "createdAt": "2020-06-30T15:52:39Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorListenerImpl.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.*;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorBaseListener;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.*;\n+import com.ca.lsp.core.cobol.preprocessor.CobolPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.PreprocessorCleanerService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.impl.PreprocessorStringUtils;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.ReplacingService;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.ca.lsp.core.cobol.semantics.NamedSubContext;\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+import com.google.inject.assistedinject.Assisted;\n+import lombok.Getter;\n+import lombok.extern.slf4j.Slf4j;\n+import org.antlr.v4.runtime.BufferedTokenStream;\n+import org.antlr.v4.runtime.ParserRuleContext;\n+import org.antlr.v4.runtime.RuleContext;\n+import org.antlr.v4.runtime.tree.TerminalNode;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.*;\n+\n+import static com.ca.lsp.core.cobol.model.ErrorCode.MISSING_COPYBOOK;\n+import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.lang.String.format;\n+import static java.util.Collections.emptyList;\n+import static java.util.Optional.ofNullable;\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+/**\n+ * ANTLR listener, which builds an extended document from the given COBOL program by executing COPY\n+ * and REPLACE statements and removing non-processable sections starting with EXEC statements.\n+ */\n+@Slf4j\n+public class GrammarPreprocessorListenerImpl extends CobolPreprocessorBaseListener\n+    implements GrammarPreprocessorListener {\n+  private static final String RECURSION_DETECTED = \"Recursive copybook declaration for: %s\";\n+  private static final String COPYBOOK_OVER_8_CHARACTERS =\n+      \"Copybook declaration has more than 8 characters for: %s\";\n+  private static final String ERROR_SUGGESTION = \"%s: Copybook not found\";\n+\n+  @Getter private final List<SyntaxError> errors = new ArrayList<>();\n+  @Getter private final NamedSubContext<Position> copybooks = new NamedSubContext<>();\n+  @Getter private final Map<String, List<Position>> documentMappings = new HashMap<>();\n+\n+  private PreprocessorCleanerService cleaner;\n+  private String documentUri;\n+  private BufferedTokenStream tokens;\n+  private String textDocumentSyncType;\n+  private CobolPreprocessor preprocessor;\n+  private Provider<CopybookResolution> resolutions;\n+  private Deque<CopybookUsage> copybookStack;\n+  private ReplacingService replacingService;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  GrammarPreprocessorListenerImpl(\n+      @Assisted(\"uri\") String documentUri,\n+      @Assisted BufferedTokenStream tokens,\n+      @Assisted Deque<CopybookUsage> copybookStack,\n+      @Assisted(\"textDocumentSyncType\") String textDocumentSyncType,\n+      PreprocessorCleanerService cleaner,\n+      CobolPreprocessor preprocessor,\n+      Provider<CopybookResolution> resolutions,\n+      ReplacingService replacingService,\n+      TokenUtils tokenUtils) {\n+    this.documentUri = documentUri;\n+    this.tokens = tokens;\n+    this.copybookStack = copybookStack;\n+    this.textDocumentSyncType = textDocumentSyncType;\n+    this.cleaner = cleaner;\n+    this.preprocessor = preprocessor;\n+    this.resolutions = resolutions;\n+    this.replacingService = replacingService;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public String getResult() {\n+    return cleaner.read();\n+  }\n+\n+  @Override\n+  public void enterExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecCicsStatement(@Nonnull ExecCicsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_CICS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlStatement(@Nonnull ExecSqlStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQL_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitExecSqlImsStatement(@Nonnull ExecSqlImsStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, EXEC_SQLIMS_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitEjectStatement(@Nonnull EjectStatementContext ctx) {\n+    cleaner.excludeStatementFromText(ctx, COMMENT_TAG, tokens);\n+  }\n+\n+  @Override\n+  public void enterCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // push a new context for the COMPILER OPTIONS terminals\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void enterCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    cleaner.push();\n+  }\n+\n+  @Override\n+  public void exitCompilerOptions(@Nonnull CompilerOptionsContext ctx) {\n+    // throw away COMPILER OPTIONS terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitCopyStatement(@Nonnull CopyStatementContext ctx) {\n+    CopySourceContext copySource = ctx.copySource();\n+    List<ReplaceClauseContext> replacing = getReplacing(ctx);\n+\n+    String copybookName = retrieveCopybookName(copySource);\n+    Position position = retrievePosition(copySource);\n+    CopybookModel model = getCopyBookContent(copybookName, position);\n+    String uri = model.getUri();\n+    String rawContent = model.getContent();\n+    String copybookId = getCopybookId(uri, replacing);\n+    String replacedContent = applyReplacing(rawContent, replacing);\n+\n+    ExtendedDocument copybookDocument =\n+        processCopybook(copybookName, uri, replacedContent, position);\n+    String copybookContent = copybookDocument.getText();\n+\n+    checkCopybookNameLength(copybookName, position);\n+    addCopybookUsage(copybookName, position);\n+    addCopybookDefinition(copybookName, uri);\n+\n+    collectNestedSemanticData(uri, copybookId, replacedContent, copybookDocument);\n+    writeCopybook(copybookId, copybookContent);\n+  }\n+\n+  @Override\n+  public void exitReplaceArea(@Nonnull ReplaceAreaContext ctx) {\n+    List<ReplaceClauseContext> replaceClauses = ctx.replaceByStatement().replaceClause();\n+\n+    String content = applyReplacing(cleaner.read(), replaceClauses);\n+\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  @Override\n+  public void exitReplaceByStatement(@Nonnull ReplaceByStatementContext ctx) {\n+    // throw away terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitReplaceOffStatement(@Nonnull ReplaceOffStatementContext ctx) {\n+    // throw away REPLACE OFF terminals\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void exitTitleStatement(@Nonnull TitleStatementContext ctx) {\n+    // throw away title statement\n+    cleaner.pop();\n+  }\n+\n+  @Override\n+  public void visitTerminal(@Nonnull TerminalNode node) {\n+    cleaner.writeToken(node, tokens);\n+  }\n+\n+  private List<ReplaceClauseContext> getReplacing(@Nonnull CopyStatementContext ctx) {\n+    return ofNullable(ctx.replacingPhrase())\n+        .map(ReplacingPhraseContext::replaceClause)\n+        .orElse(emptyList());\n+  }\n+\n+  private void collectNestedSemanticData(\n+      String uri, String copybookId, String replacedContent, ExtendedDocument copybookDocument) {\n+    copybooks.merge(copybookDocument.getCopybooks());\n+    documentMappings.putAll(copybookDocument.getDocumentPositions());\n+    documentMappings.computeIfAbsent(\n+        copybookId, it -> tokenUtils.retrievePositionsFromText(uri, replacedContent));\n+  }\n+\n+  private void writeCopybook(String copybookId, String copybookContent) {\n+    // throw away COPY terminals\n+    cleaner.pop();\n+    // write copybook beginning trigger\n+    cleaner.write(CPY_ENTER_TAG);\n+    cleaner.write(\"<URI>\");\n+    cleaner.write(copybookId);\n+    cleaner.write(\"</URI>. \");\n+    // a new context for the copy book content\n+    cleaner.push();\n+    cleaner.write(copybookContent);\n+    // write copybook closing trigger\n+    cleaner.write(CPY_EXIT_TAG);\n+\n+    String content = cleaner.read();\n+    cleaner.pop();\n+    cleaner.write(content);\n+  }\n+\n+  private String applyReplacing(\n+      String rawContent, List<ReplaceClauseContext> replaceClauseContexts) {\n+    return replacingService.applyReplacing(rawContent, replaceClauseContexts, tokens);\n+  }\n+\n+  private String getCopybookId(\n+      String copybookURI, List<ReplaceClauseContext> replacingPhraseContexts) {\n+    return copybookURI\n+        + replacingPhraseContexts.stream()\n+            .map(RuleContext::getText)\n+            .reduce(String::concat)\n+            .orElse(\"\")\n+            .replaceAll(\"[^a-zA-Z0-9]+\", \"\")\n+            .trim();\n+  }\n+\n+  private CopybookModel getCopyBookContent(String copybookName, Position position) {\n+\n+    if (copybookName == null) return emptyModel(null);\n+\n+    if (hasRecursion(copybookName)) {\n+      copybookStack.forEach(this::reportRecursiveCopybook);\n+      return emptyModel(copybookName);\n+    }\n+\n+    CopybookModel copybook =\n+        resolutions.get().resolve(copybookName, documentUri, textDocumentSyncType);\n+\n+    if (copybook == null || copybook.getContent() == null) {\n+      reportMissingCopybooks(copybookName, position);\n+      return emptyModel(copybookName);\n+    }\n+\n+    return copybook;\n+  }\n+\n+  private boolean hasRecursion(String copybookName) {\n+    return copybookStack.stream().map(CopybookUsage::getName).anyMatch(copybookName::equals);\n+  }\n+\n+  private ExtendedDocument processCopybook(\n+      String copybookName, String uri, String content, Position position) {\n+    copybookStack.push(new CopybookUsage(copybookName, position));\n+    ResultWithErrors<ExtendedDocument> result =\n+        preprocessor.process(uri, content, copybookStack, textDocumentSyncType);\n+    copybookStack.pop();\n+\n+    errors.addAll(result.getErrors());\n+\n+    return result.getResult();\n+  }\n+\n+  private CopybookModel emptyModel(String copybookName) {\n+    return new CopybookModel(copybookName, \"\", \"\");\n+  }\n+\n+  @Nullable\n+  private String retrieveCopybookName(@Nonnull CopySourceContext copySource) {\n+    String copybookName;\n+    if (copySource.cobolWord() != null) {\n+      copybookName = copySource.cobolWord().getText().toUpperCase();\n+    } else if (copySource.literal() != null) {\n+      copybookName =\n+          PreprocessorStringUtils.trimQuotes(copySource.literal().getText())\n+              .replace(\"\\\\\", \"/\")\n+              .toUpperCase();\n+    } else {\n+      LOG.warn(\"Unknown copy book reference type {}\", copySource);\n+      copybookName = null;\n+    }\n+\n+    return copybookName;\n+  }\n+\n+  private void addCopybookUsage(@Nullable String copybookName, @Nonnull Position position) {\n+    ofNullable(copybookName).ifPresent(it -> copybooks.addUsage(it, position));\n+  }\n+\n+  private void addCopybookDefinition(String copybookName, String uri) {\n+    if (!isEmpty(copybookName) && !isEmpty(uri)) {\n+      copybooks.define(copybookName, new Position(uri, 0, -1, 1, 0, null));\n+    }\n+  }\n+\n+  @Nonnull\n+  private Position retrievePosition(@Nonnull ParserRuleContext token) {\n+    return new Position(\n+        documentUri,\n+        token.getStart().getStartIndex(),\n+        token.getStop().getStopIndex(),\n+        token.getStart().getLine(),\n+        token.getStart().getCharPositionInLine(),\n+        token.getStart().getText());\n+  }\n+\n+  private void reportRecursiveCopybook(CopybookUsage usage) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .severity(1)\n+            .suggestion(String.format(RECURSION_DETECTED, usage.getName()))\n+            .position(usage.getPosition())\n+            .build());\n+  }\n+\n+  private void reportMissingCopybooks(String copybookName, Position position) {\n+    errors.add(\n+        SyntaxError.syntaxError()\n+            .position(position)\n+            .suggestion(format(ERROR_SUGGESTION, copybookName))\n+            .severity(1)\n+            .errorCode(MISSING_COPYBOOK)\n+            .build());\n+  }\n+\n+  private void checkCopybookNameLength(String copybookName, Position position) {\n+    if (copybookName != null && copybookName.length() > 8) {\n+      errors.add(\n+          SyntaxError.syntaxError()\n+              .severity(3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 389}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NDQ5MA==", "bodyText": "Better practice is use a general return at the end of method, especially if catch block logs the exception.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447794490", "createdAt": "2020-06-30T15:55:42Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving;\n+  private String copybookName;\n+\n+  SynchronousCopybookResolution(DataBusBroker broker) {\n+    this.broker = broker;\n+    broker.subscribe(FETCHED_COPYBOOK_EVENT, this);\n+  }\n+\n+  /**\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param syncType - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content; or null in case\n+   *     of severe issue.\n+   * @throws IllegalStateException if the instance reused.\n+   */\n+  @Nullable\n+  @Override\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName, @Nonnull String documentUri, @Nonnull String syncType) {\n+    checkState();\n+\n+    if (isCopybookInCache(copybookName)) {\n+      broker.unSubscribe(this);\n+      return getContentFromCache(copybookName);\n+    }\n+\n+    this.copybookName = copybookName;\n+    waitForResolving = new CompletableFuture<>();\n+    broker.postData(\n+        RequiredCopybookEvent.builder()\n+            .name(copybookName)\n+            .documentUri(documentUri)\n+            .textDocumentSyncType(syncType)\n+            .build());\n+    try {\n+      return waitForResolving.get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      LOG.error(\"Error resolving copybook: \", e);\n+      currentThread().interrupt();\n+      return null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzc5NzIxNg==", "bodyText": "Please, move this uri, and content retrieval logic after checking !copybookName.equals(name),  so it will not create redundant objects here.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447797216", "createdAt": "2020-06-30T15:59:38Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/SynchronousCopybookResolution.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.cobol.databus.api.CopybookRepository;\n+import com.broadcom.lsp.domain.cobol.databus.api.DataBusBroker;\n+import com.broadcom.lsp.domain.cobol.databus.model.CopybookStorable;\n+import com.broadcom.lsp.domain.cobol.event.api.EventObserver;\n+import com.broadcom.lsp.domain.cobol.event.model.FetchedCopybookEvent;\n+import com.broadcom.lsp.domain.cobol.event.model.RequiredCopybookEvent;\n+import com.ca.lsp.core.cobol.model.CopybookModel;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.CopybookResolution;\n+import lombok.extern.slf4j.Slf4j;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+\n+import static com.broadcom.lsp.domain.cobol.event.model.DataEventType.FETCHED_COPYBOOK_EVENT;\n+import static java.lang.Thread.currentThread;\n+import static java.util.Optional.ofNullable;\n+\n+/**\n+ * This class uses the data bus to retrieve the content of the given copybook. If the copybook has\n+ * already been retrieved, then it is taking out of the cache. The instances are disposable and\n+ * cannot be reused. To create an instance, use the {@link CopybookResolutionProvider}. It uses a\n+ * {@link CompletableFuture} to synchronize the interaction with the data bus.\n+ */\n+@Slf4j\n+public class SynchronousCopybookResolution\n+    implements CopybookResolution, EventObserver<FetchedCopybookEvent> {\n+  private static final String EXCEPTION_MESSAGE = \"Copybook resolution instance cannot be reused\";\n+\n+  private DataBusBroker broker;\n+\n+  private CompletableFuture<CopybookModel> waitForResolving;\n+  private String copybookName;\n+\n+  SynchronousCopybookResolution(DataBusBroker broker) {\n+    this.broker = broker;\n+    broker.subscribe(FETCHED_COPYBOOK_EVENT, this);\n+  }\n+\n+  /**\n+   * Retrieve and return the copybook by its name. Copybook may cached to limit interactions with\n+   * the file system.\n+   *\n+   * @param copybookName - the name of the copybook to be retrieved\n+   * @param documentUri - the currently processing document that contains the copy statement\n+   * @param syncType - text document synchronization type\n+   * @return a CopybookModel that contains copybook name, its URI and the content; or null in case\n+   *     of severe issue.\n+   * @throws IllegalStateException if the instance reused.\n+   */\n+  @Nullable\n+  @Override\n+  public CopybookModel resolve(\n+      @Nonnull String copybookName, @Nonnull String documentUri, @Nonnull String syncType) {\n+    checkState();\n+\n+    if (isCopybookInCache(copybookName)) {\n+      broker.unSubscribe(this);\n+      return getContentFromCache(copybookName);\n+    }\n+\n+    this.copybookName = copybookName;\n+    waitForResolving = new CompletableFuture<>();\n+    broker.postData(\n+        RequiredCopybookEvent.builder()\n+            .name(copybookName)\n+            .documentUri(documentUri)\n+            .textDocumentSyncType(syncType)\n+            .build());\n+    try {\n+      return waitForResolving.get();\n+    } catch (InterruptedException | ExecutionException e) {\n+      LOG.error(\"Error resolving copybook: \", e);\n+      currentThread().interrupt();\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  public void observerCallback(@Nonnull FetchedCopybookEvent event) {\n+    if (copybookName == null) {\n+      LOG.warn(\"A disposed instance of copybook resolver used: \" + toString());\n+      return;\n+    }\n+    String name = event.getName();\n+    String uri = event.getUri();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwMjAxOQ==", "bodyText": "Inconsistent injection, one is via constructor, other inline [I saw usage: new PreprocessorCleanerServiceImpl(new TokenUtilsImpl());].  Should be both either via constructor, or both via inline.", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447802019", "createdAt": "2020-06-30T16:06:47Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/util/impl/PreprocessorCleanerServiceImpl.java", "diffHunk": "@@ -27,36 +27,67 @@\n import java.util.Scanner;\n \n import static com.ca.lsp.core.cobol.preprocessor.ProcessingConstants.*;\n+import static java.util.Optional.ofNullable;\n \n public class PreprocessorCleanerServiceImpl implements PreprocessorCleanerService {\n-  private Deque<CobolDocumentContext> contexts = new ArrayDeque<>();\n+  private Deque<StringBuilder> contexts = new ArrayDeque<>();\n+  private TokenUtils tokenUtils;\n \n-  public PreprocessorCleanerServiceImpl() {\n-    contexts.push(new CobolDocumentContext());\n+  @Inject\n+  public PreprocessorCleanerServiceImpl(TokenUtils tokenUtils) {\n+    this.tokenUtils = tokenUtils;\n+    contexts.push(new StringBuilder());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwNzQ0OQ==", "bodyText": "Please change hardcoded value,  DiagnosticSeverity.Error.getValue() == it.getSeverity().getValue()", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447807449", "createdAt": "2020-06-30T16:14:35Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -168,19 +158,25 @@ public static AnalysisResult analyze(String text) {\n   public static List<Diagnostic> analyzeForErrors(String text) {\n     return analyzeForErrors(text, emptyList());\n   }\n+\n   /**\n    * Analyze the given text using a real language engine leaving only the diagnostics with the\n    * severe (level 1) errors providing copybooks required for the analysis\n    *\n    * @param text - text to analyze\n    * @param copybooks - list of copybooks required for the analysis\n-   * @return list of diagnostics with only severe errors\n+   * @return map of diagnostics with only severe errors\n    */\n   public static List<Diagnostic> analyzeForErrors(String text, List<CobolText> copybooks) {\n-    return analyze(text, copybooks).getDiagnostics().stream()\n-        .filter(it -> it.getSeverity().getValue() == 1)\n-        .collect(toList());\n+    return ofNullable(analyze(text, copybooks).getDiagnostics().get(DOCUMENT_URI))\n+        .map(\n+            diagnostics ->\n+                diagnostics.stream()\n+                    .filter(it -> it.getSeverity().getValue() == 1)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgwOTA4OA==", "bodyText": "But return type is List", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447809088", "createdAt": "2020-06-30T16:17:02Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/test/java/com/ca/lsp/cobol/service/delegates/validations/UseCaseUtils.java", "diffHunk": "@@ -168,19 +158,25 @@ public static AnalysisResult analyze(String text) {\n   public static List<Diagnostic> analyzeForErrors(String text) {\n     return analyzeForErrors(text, emptyList());\n   }\n+\n   /**\n    * Analyze the given text using a real language engine leaving only the diagnostics with the\n    * severe (level 1) errors providing copybooks required for the analysis\n    *\n    * @param text - text to analyze\n    * @param copybooks - list of copybooks required for the analysis\n-   * @return list of diagnostics with only severe errors\n+   * @return map of diagnostics with only severe errors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgxNjk1NA==", "bodyText": "Is context non-null all the time ?", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447816954", "createdAt": "2020-06-30T16:27:00Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-service-cobol/src/main/java/com/ca/lsp/cobol/service/delegates/validations/CobolLanguageEngineFacade.java", "diffHunk": "@@ -68,23 +75,60 @@ public AnalysisResult analyze(\n     return toAnalysisResult(engine.run(uri, text, textDocumentSyncType.toString()), uri);\n   }\n \n+  /**\n+   * Don't analyze the document if it is empty or contains only sequence area\n+   *\n+   * @param text - document to analyze\n+   * @return true if the document is empty from the engine point of view\n+   */\n   private static boolean isEmpty(String text) {\n     return text.length() <= FIRST_LINE_SEQ_AND_EXTRA_OP;\n   }\n \n-  private static List<Diagnostic> convertErrors(List<SyntaxError> errors, String uri) {\n-    return errors.stream()\n-        .filter(errorOnlyFromCurrentDocument(uri))\n-        .map(toDiagnostic())\n-        .collect(toList());\n+  private AnalysisResult toAnalysisResult(ResultWithErrors<SemanticContext> result, String uri) {\n+    SemanticContext context = result.getResult();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgyMzg3OA==", "bodyText": "Here no need unnecessary line-comments, see TokenUtilsImpl#retrieveTokens similar method quite readable", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447823878", "createdAt": "2020-06-30T16:36:05Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/preprocessor/sub/document/impl/GrammarPreprocessorImpl.java", "diffHunk": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *   Broadcom, Inc. - initial API and implementation\n+ */\n+package com.ca.lsp.core.cobol.preprocessor.sub.document.impl;\n+\n+import com.broadcom.lsp.domain.common.model.Position;\n+import com.ca.lsp.core.cobol.model.CopybookUsage;\n+import com.ca.lsp.core.cobol.model.ExtendedDocument;\n+import com.ca.lsp.core.cobol.model.ResultWithErrors;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorLexer;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser;\n+import com.ca.lsp.core.cobol.parser.CobolPreprocessorParser.StartRuleContext;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessor;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListener;\n+import com.ca.lsp.core.cobol.preprocessor.sub.document.GrammarPreprocessorListenerFactory;\n+import com.ca.lsp.core.cobol.preprocessor.sub.util.TokenUtils;\n+import com.google.inject.Inject;\n+import org.antlr.v4.runtime.CharStreams;\n+import org.antlr.v4.runtime.CommonTokenStream;\n+import org.antlr.v4.runtime.tree.ParseTreeWalker;\n+\n+import javax.annotation.Nonnull;\n+import java.util.Deque;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * This class runs pre-processing for COBOL using CobolPreprocessor.g4 grammar file. As a result, it\n+ * returns an extended document with all the available copybooks included, with their definitions\n+ * and usages specified, as well as related errors.\n+ */\n+public class GrammarPreprocessorImpl implements GrammarPreprocessor {\n+  private GrammarPreprocessorListenerFactory listenerFactory;\n+  private TokenUtils tokenUtils;\n+\n+  @Inject\n+  public GrammarPreprocessorImpl(\n+      GrammarPreprocessorListenerFactory listenerFactory, TokenUtils tokenUtils) {\n+    this.listenerFactory = listenerFactory;\n+    this.tokenUtils = tokenUtils;\n+  }\n+\n+  @Nonnull\n+  @Override\n+  public ResultWithErrors<ExtendedDocument> buildExtendedDocument(\n+      @Nonnull String uri,\n+      @Nonnull String code,\n+      @Nonnull Deque<CopybookUsage> copybookStack,\n+      @Nonnull String textDocumentSyncType) {\n+    // run the lexer", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3a8948e156deaa357f8179d50484136219c597ac"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzgzMDg1NA==", "bodyText": "Or just rename the method", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r447830854", "createdAt": "2020-06-30T16:46:34Z", "author": {"login": "asatklichov"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/ca/lsp/core/cobol/semantics/NamedSubContext.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright (c) 2020 Broadcom.\n+ * The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n+ *\n+ * This program and the accompanying materials are made\n+ * available under the terms of the Eclipse Public License 2.0\n+ * which is available at https://www.eclipse.org/legal/epl-2.0/\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *\n+ * Contributors:\n+ *    Broadcom, Inc. - initial API and implementation\n+ *\n+ */\n+\n+package com.ca.lsp.core.cobol.semantics;\n+\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.Multimap;\n+import lombok.Getter;\n+\n+import java.util.Collection;\n+\n+public class NamedSubContext<T> implements SubContext<String, T> {\n+\n+  @Getter private final Multimap<String, T> definitions = HashMultimap.create();\n+\n+  @Getter private final Multimap<String, T> usages = HashMultimap.create();\n+\n+  @Override\n+  public void define(String name, T token) {\n+    definitions.put(name, token);\n+  }\n+\n+  @Override\n+  public void addUsage(String name, T token) {\n+    usages.put(name, token);\n+  }\n+\n+  @Override\n+  public Collection<String> getAll() {\n+    return definitions.keySet();\n+  }\n+\n+  @Override\n+  public boolean contains(String name) {\n+    return definitions.containsKey(name);\n+  }\n+\n+  @Override\n+  public void merge(SubContext<String, T> subContext) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDA3ODM1Mw=="}, "originalCommit": {"oid": "fc5f403cbd49894e3e9dbd9ed1baf28feebc0b22"}, "originalPosition": 51}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e961f05766de669cd76fad406c09aeb72ecbbf84", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e961f05766de669cd76fad406c09aeb72ecbbf84", "committedDate": "2020-07-02T11:25:48Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8df544c5ab23513b19a3d90d38b91f8a36367219", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/8df544c5ab23513b19a3d90d38b91f8a36367219", "committedDate": "2020-07-14T15:07:38Z", "message": "test: Introduce use case preprocessor to simplify testing GH-426"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17b322362183e60affd3b72546e4f2e0f7082151", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/17b322362183e60affd3b72546e4f2e0f7082151", "committedDate": "2020-07-14T15:14:21Z", "message": "refactor: Extract source info text as an enum"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db34dd94b6285d5b75b3b0f01ca9173a7e634d1d", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/db34dd94b6285d5b75b3b0f01ca9173a7e634d1d", "committedDate": "2020-07-14T15:47:36Z", "message": "test: Refactor tests with the Use Case Engine #426"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d0d5bb636036338355807fa0076170caf2ff48ee", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/d0d5bb636036338355807fa0076170caf2ff48ee", "committedDate": "2020-07-14T15:51:34Z", "message": "refactor: Fix too long line error position counting"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "227d35b53ded871be1bbeb192a22f4c1e702a3a2", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/227d35b53ded871be1bbeb192a22f4c1e702a3a2", "committedDate": "2020-07-14T16:01:37Z", "message": "test: Add copyright headers to Use Case Engine files #426"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a7cc8abb2184192d6f4948d71b3cac758060ab3a", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a7cc8abb2184192d6f4948d71b3cac758060ab3a", "committedDate": "2020-07-15T08:00:34Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1cbc55aaf6839713e5ffb7e4efcf0c88616ef5ec", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/1cbc55aaf6839713e5ffb7e4efcf0c88616ef5ec", "committedDate": "2020-07-15T08:31:25Z", "message": "Merge branch 'mapping' into usecase-preprocessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "81eba78935cc9b99e572f8a61d1966638acc9de3", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/81eba78935cc9b99e572f8a61d1966638acc9de3", "committedDate": "2020-07-15T08:40:17Z", "message": "test: Remove duplicated test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "83aac6e3a9dd8458e07aa5780a9b5eb3fa5ae3f1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/83aac6e3a9dd8458e07aa5780a9b5eb3fa5ae3f1", "committedDate": "2020-07-15T11:28:36Z", "message": "refactor: Define error severity levels as an enum"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8680b0ad7ef69b31999966dcdc28b6d70a8bbcb", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/b8680b0ad7ef69b31999966dcdc28b6d70a8bbcb", "committedDate": "2020-07-15T11:34:55Z", "message": "Merge branch 'mapping' into usecase-preprocessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fb1604fb1938ac36002afc1945b2c459850f5758", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fb1604fb1938ac36002afc1945b2c459850f5758", "committedDate": "2020-07-15T12:25:39Z", "message": "test: Remove outdated methods from UseCaseUtils #426"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93d9e49803b64d05a90201c7e73f01c574aa2b98", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/93d9e49803b64d05a90201c7e73f01c574aa2b98", "committedDate": "2020-07-15T12:46:46Z", "message": "refactor: Assure null-safety for the language engine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f29dbdb936e8897157028e156296352f596846ce", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f29dbdb936e8897157028e156296352f596846ce", "committedDate": "2020-07-15T14:59:05Z", "message": "test: Fix replacing copybook names on UseCaseEngine"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60824ec989a0f3ff7a36d4475692039171cafe1e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/60824ec989a0f3ff7a36d4475692039171cafe1e", "committedDate": "2020-07-16T08:41:30Z", "message": "refactor: Remove redundant operations on copybook name retrieving"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac83016dd7dd26fe1d1b7e30981e762c32cb3c94", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/ac83016dd7dd26fe1d1b7e30981e762c32cb3c94", "committedDate": "2020-07-16T08:43:00Z", "message": "refactor: Move check to prevent redundant objects creation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fe657254335a8121c2b64d8c85e4a6cadeeb84f3", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/fe657254335a8121c2b64d8c85e4a6cadeeb84f3", "committedDate": "2020-07-16T11:46:22Z", "message": "test: Add unit test for grammar preprocessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f69232b09a90465ee58f06758ab52b4272b2a77f", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/f69232b09a90465ee58f06758ab52b4272b2a77f", "committedDate": "2020-07-16T14:16:39Z", "message": "refactor: Remove redundant checks on syntax error registration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12ad47aaf984d714f2547786a2707cc9aceffba1", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/12ad47aaf984d714f2547786a2707cc9aceffba1", "committedDate": "2020-07-16T14:46:20Z", "message": "fix: Remove techincal tokens from keyword completion suggestions #348"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "eaf685edcd9bc6922c0e2fa2284a5ab6dae68ed0", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/eaf685edcd9bc6922c0e2fa2284a5ab6dae68ed0", "committedDate": "2020-07-16T16:00:39Z", "message": "refactor: Fix source info identifier"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "16924d49150529a7ab5b0e0e0a8c73a8a7ac99fe", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/16924d49150529a7ab5b0e0e0a8c73a8a7ac99fe", "committedDate": "2020-07-17T08:26:10Z", "message": "test: Fix annotations in javadoc for tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a2b889bd18c6b6811d0c4dd85caba9b03bd802fe", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/a2b889bd18c6b6811d0c4dd85caba9b03bd802fe", "committedDate": "2020-07-17T10:12:58Z", "message": "refactor: Refactor use cases with Java 11 collections"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e01d8851a515c458653c6e8dedd65cb9bfc9172e", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/e01d8851a515c458653c6e8dedd65cb9bfc9172e", "committedDate": "2020-07-17T10:17:21Z", "message": "Merge pull request #427 from eclipse/usecase-preprocessor\n\nIntroduce Use Case Preprocessor"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913", "author": {"user": {"login": "temanbrcom", "name": "Andrei Temnikov"}}, "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/commit/67352b8e361d9543c702e9a615bdf9449e852913", "committedDate": "2020-07-17T10:45:06Z", "message": "Merge branch 'development' into mapping"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNjQzNzAx", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-450643701", "createdAt": "2020-07-17T13:10:58Z", "commit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxMDo1OFrOGzSZHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxMDo1OFrOGzSZHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMTkwMw==", "bodyText": "remove TODO or make it beautiful \ud83d\udc85", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456431903", "createdAt": "2020-07-17T13:10:58Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/antlr4/com/ca/lsp/core/cobol/parser/CobolParser.g4", "diffHunk": "@@ -959,6 +959,15 @@ dataDescriptionEntryFormat3\n dataDescriptionEntryExecSql\n    : EXECSQLLINE+ DOT_FS?\n    ;\n+\n+//TODO: make it beautiful", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNjQ0MjY5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-450644269", "createdAt": "2020-07-17T13:11:42Z", "commit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxMTo0MlrOGzSa5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxMTo0MlrOGzSa5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMjM1Nw==", "bodyText": "I guess this is not solved, I can take care of it", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456432357", "createdAt": "2020-07-17T13:11:42Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/antlr4/com/ca/lsp/core/cobol/parser/CobolParser.g4", "diffHunk": "@@ -1154,7 +1163,17 @@ statement\n     exitStatement | generateStatement | gobackStatement | goToStatement | ifStatement | initializeStatement | initiateStatement | inspectStatement | mergeStatement | moveStatement | \n     multiplyStatement | openStatement | performStatement | purgeStatement | readStatement | receiveStatement | releaseStatement | returnStatement | rewriteStatement | searchStatement | \n     sendStatement | serviceReloadStatement | serviceLabelStatement | setStatement | sortStatement | startStatement | stopStatement | stringStatement | subtractStatement |\n-    terminateStatement | titleStatement | unstringStatement | writeStatement | xmlStatement\n+    terminateStatement | titleStatement | unstringStatement | writeStatement | xmlStatement | enterCpy | exitCpy\n+   ;\n+\n+\n+//TODO: modify the copybook name rule to accept everything including keywords", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDUwNjQ2MTY5", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#pullrequestreview-450646169", "createdAt": "2020-07-17T13:14:17Z", "commit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxNDoxN1rOGzSgjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xN1QxMzoxNDoxN1rOGzSgjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQzMzgwNg==", "bodyText": "names of this classes makes me think you are speaking about antlr auto generated classes", "url": "https://github.com/eclipse/che-che4z-lsp-for-cobol/pull/338#discussion_r456433806", "createdAt": "2020-07-17T13:14:17Z", "author": {"login": "sergiuilie"}, "path": "com.ca.lsp.cobol/lsp-core-cobol-parser/src/main/java/com/broadcom/lsp/cdi/EngineModule.java", "diffHunk": "@@ -32,9 +38,12 @@\n   protected void configure() {\n     bind(CobolLanguageEngine.class);\n     bind(CobolPreprocessor.class).to(CobolPreprocessorImpl.class);\n-    bind(CopybookAnalysis.class).to(CopybookParallelAnalysis.class);\n-    install(new FactoryModuleBuilder().build(AnalyseCopybookTaskFactory.class));\n     bind(CobolPreprocessor.class).to(CobolPreprocessorImpl.class);\n-    bind(CobolSemanticParser.class).to(CobolSemanticParserImpl.class);\n+    bind(GrammarPreprocessor.class).to(GrammarPreprocessorImpl.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "67352b8e361d9543c702e9a615bdf9449e852913"}, "originalPosition": 31}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1084, "cost": 1, "resetAt": "2021-11-01T13:51:04Z"}}}