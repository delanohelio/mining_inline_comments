{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NTc1ODM0", "number": 2714, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDowNzozNVrOEYpY5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxMTowMzoxN1rOEbNSUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjc5Mzk5OnYy", "diffSide": "RIGHT", "path": "pmd-java/etc/grammar/Java.jjt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDowNzozNVrOHBGISw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxMzowMDo0OVrOHBSS9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTA1MQ==", "bodyText": "I'm not sure this works. non - sealed is a valid subtraction expression, even without the spaces, and should remain so. By the maximal munch rule, this token would match  the expression non-sealed, and also cut the identifier if the second variable name is longer: tokenizing non-sealedNumber as [non-sealed, Number] instead of [non, -, sealedNumber]\nAnyway, one solution would be to match this as three tokens in a production. Eg something like\nvoid Modifiers(): {} {\n( \"public\"\n| ...\n|  LOOKAHEAD({isNonSealedMod()}) <IDENTIFIER> \"-\" <IDENTIFIER>\n)*\n}\n\n// in the java\n\n    boolean isToken(int index, int kind) {\n        return getToken(index).kind == kind;\n    }\n    \n    boolean isKeyword(int index, String image) {\n        Token tok = getToken(index);\n        return tok.kind == IDENTIFIER && tok.getImage().equals(image);\n    }\n    \n    // matches \"non-$name\"\n    boolean isNonSealedMod() {\n        return isKeyword(1, \"non\")\n            && isToken(2, MINUS)\n            && isKeyword(3, \"sealed\");\n    }\n\nI'm not sure how to constrain this so that there is no space between the tokens. Maybe just comparing columns", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470911051", "createdAt": "2020-08-15T00:07:35Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -980,6 +1024,14 @@ TOKEN :\n | < GT: \">\" >\n }\n \n+// Note: New token need to be added at the very end in order to\n+// keep (binary) compatibility with the generated token ids\n+// see JavaParserConstants\n+TOKEN :\n+{\n+  < NON_SEALED: \"non-sealed\" >", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTExMDE1Nw==", "bodyText": "Thanks for the review!\nHm.... yes, that's probably a problem: non-sealed is only a valid keyword with java15+, but should be parsed as you said as a subtraction expression before java15.... I'll try your suggestion.", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r471110157", "createdAt": "2020-08-16T12:58:39Z", "author": {"login": "adangel"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -980,6 +1024,14 @@ TOKEN :\n | < GT: \">\" >\n }\n \n+// Note: New token need to be added at the very end in order to\n+// keep (binary) compatibility with the generated token ids\n+// see JavaParserConstants\n+TOKEN :\n+{\n+  < NON_SEALED: \"non-sealed\" >", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTA1MQ=="}, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTExMDM4OA==", "bodyText": "It seems, this is exactly the way that javac is using: https://github.com/openjdk/jdk/blob/77522d127099ce787490a4a513e80c67e77be4b2/src/jdk.compiler/share/classes/com/sun/tools/javac/parser/JavacParser.java#L4228-L4240", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r471110388", "createdAt": "2020-08-16T13:00:49Z", "author": {"login": "adangel"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -980,6 +1024,14 @@ TOKEN :\n | < GT: \">\" >\n }\n \n+// Note: New token need to be added at the very end in order to\n+// keep (binary) compatibility with the generated token ids\n+// see JavaParserConstants\n+TOKEN :\n+{\n+  < NON_SEALED: \"non-sealed\" >", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTA1MQ=="}, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgxNjY5OnYy", "diffSide": "RIGHT", "path": "pmd-java/etc/grammar/Java.jjt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDoyODo0NFrOHBGUhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDoyODo0NFrOHBGUhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNDE4Mg==", "bodyText": "I don't like this very much. There may be an arbitrary amount of annotations before the record. See my comment in BlockStatement", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470914182", "createdAt": "2020-08-15T00:28:44Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -432,45 +449,66 @@ public class JavaParser {\n    */\n   private boolean inSwitchLabel = false;\n \n-  private boolean isJava13PreviewOr14() {\n-      return jdkVersion >= 14 || jdkVersion >= 13 && preview;\n-  }\n-\n   private void checkForSwitchRules() {\n-    if (!isJava13PreviewOr14()) {\n-      throwParseException(\"Switch rules in switch statements are only supported with Java 13 Preview, or Java >= 14\");\n+    if (jdkVersion < 14) {\n+      throwParseException(\"Switch rules in switch statements are only supported with Java >= 14\");\n     }\n   }\n   private void checkForSwitchExpression() {\n-    if (!isJava13PreviewOr14()) {\n-      throwParseException(\"Switch expressions are only supported with Java 13 Preview, or Java >= 14\");\n+    if (jdkVersion < 14) {\n+      throwParseException(\"Switch expressions are only supported with Java >= 14\");\n     }\n   }\n \n   private void checkForYieldStatement() {\n-    if (!isJava13PreviewOr14()) {\n-      throwParseException(\"Yield statements are only supported with Java 13 Preview or Java >= 14\");\n+    if (jdkVersion < 14) {\n+      throwParseException(\"Yield statements are only supported with Java >= 14\");\n     }\n   }\n \n   private void checkForTextBlockLiteral() {\n-    if (jdkVersion != 13 && jdkVersion != 14 || !preview) {\n-      throwParseException(\"Text block literals are only supported with Java 13 Preview or Java 14 Preview\");\n+    if (jdkVersion < 15 && !preview) {\n+      throwParseException(\"Text block literals are only supported with Java 14 Preview and Java >= 15\");\n     }\n   }\n \n   private void checkForNewStringSpaceEscape(String s) {\n-    if ((jdkVersion != 14 || !preview) && s.contains(\"\\\\s\") && !s.contains(\"\\\\\\\\s\")) {\n-      throwParseException(\"The escape sequence \\\"\\\\s\\\" is only supported with Java 14 Preview\");\n+    if ((jdkVersion < 15 && !preview) && s.contains(\"\\\\s\") && !s.contains(\"\\\\\\\\s\")) {\n+      throwParseException(\"The escape sequence \\\"\\\\s\\\" is only supported with Java 14 Preview and Java >= 15\");\n     }\n   }\n \n   private void checkForRecordType() {\n-    if (jdkVersion != 14 || !preview) {\n-      throwParseException(\"Records are only supported with Java 14 Preview\");\n+    if (!isRecordTypeSupported()) {\n+      throwParseException(\"Records are only supported with Java 14 Preview and Java 15 Preview\");\n+    }\n+  }\n+\n+  private boolean isRecordTypeSupported() {\n+    return (jdkVersion == 14 || jdkVersion == 15) && preview;\n+  }\n+\n+  private boolean isRecordDeclarationAhead() {\n+    int amount = 1;\n+    while (amount < 10) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgxOTMxOnYy", "diffSide": "RIGHT", "path": "pmd-java/etc/grammar/Java.jjt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDozMToxM1rOHBGV6g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDozMToxM1rOHBGV6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNDUzOA==", "bodyText": "Maybe rename this to LocalTypeDecl.\nThe javac parser names this production classOrRecordOrInterfaceOrEnumDeclaration... your pick", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470914538", "createdAt": "2020-08-15T00:31:13Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1879,22 +1949,25 @@ void BlockStatement():\n   LOOKAHEAD( { isNextTokenAnAssert() } ) AssertStatement()\n | LOOKAHEAD( { isYieldStart() } ) YieldStatement()\n |\n-  LOOKAHEAD(( \"final\" | Annotation() )* Type() <IDENTIFIER>)\n+  LOOKAHEAD(2147483647, ( \"final\" | Annotation() )* Type() <IDENTIFIER>, {isRecordTypeSupported() && !isRecordDeclarationAhead() || !isRecordTypeSupported()})\n   LocalVariableDeclaration() \";\"\n |\n+  LOOKAHEAD(1, {isRecordTypeSupported() && !isRecordDeclarationAhead() || !isRecordTypeSupported()})\n   Statement()\n |\n   // we don't need to lookahead further here\n   // the ambiguity between start of local class and local variable decl\n-  // is already handled in the lookahead guarding LocalVariableDeclaration above.\n-  LocalClassDecl()\n+  // and start of local record and local variable decl or statement\n+  // is already handled in the lookahead guarding LocalVariableDeclaration\n+  // and Statement above.\n+  LocalClassOrRecordDecl()\n }\n \n-void LocalClassDecl() #void:\n+void LocalClassOrRecordDecl() #void:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 231}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0MjgzMjk5OnYy", "diffSide": "RIGHT", "path": "pmd-java/etc/grammar/Java.jjt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo0NTo1NVrOHBGdQQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDo0NTo1NVrOHBGdQQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNjQxNw==", "bodyText": "The lookaheads would be easier if this was lifted to BlockStatement to dominate both LocalVariableDeclaration and this production. But you'll maybe have to define an auxilliary LocalVariableDeclaration that has no modifiers. So it would allow local variables to have disallowed modifiers, but it's already the case for all other declarations, and it's not like we care anywhere", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470916417", "createdAt": "2020-08-15T00:45:55Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1903,7 +1976,11 @@ void LocalClassDecl() #void:\n     // In particular, it unfortunately allows local class declarations to start\n     // with a \"default\" modifier, which introduces an ambiguity with default\n     // switch labels. This is guarded by a custom lookahead around SwitchLabel\n-    mods=Modifiers() ClassOrInterfaceDeclaration(mods)\n+    mods=Modifiers()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 246}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjg3NDExOnYy", "diffSide": "RIGHT", "path": "pmd-java/etc/grammar/Java.jjt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTozMzozMVrOHBGyDg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNlQxOTo0NzozNVrOHBUwsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMTc0Mg==", "bodyText": "These lookaheads seem a bit too complicated, and isRecordStart is limited to 10 tokens. We could simplify it that way (looking into the javac parser):\n\nIf the statement starts with @ of final, then what follows is necessarily a local declaration (variable or type). We can parse modifiers for both, and then parse the rest of the declaration.\n\nAfter modifiers, the check isRecordStart() is O(1), as it just tests for \"record\" <IDENTIFIER>. It doesn't require a lookahead limit\n\n\nIf the statement starts with an identifier, we must differentiate between several special identifiers (all of which are somewhat conditioned by jdk version + following tokens)\n\nnon-sealed. This is a semantic error, but for resilience, we can still parse Modifiers() LocalTypeDecl()\nrecord -> RecordDeclaration()\nenum -> EnumDeclaration()\nassert -> AssertStatement()\nyield -> YieldStatement()\nanything else:\n\nLookeahead for ClassOrInterfaceType() <IDENTIFIER> -> local variable declaration\n\nOtherwise, either labeled statement or statement expression (both are in Statement)\n\n\n\n\n\n\nIf the statement starts with any modifier token other than final, eg public, then what follows is Modifiers() LocalTypeDecl()\nIf the statement starts with a primitive type token, we must lookahead for Type() <IDENTIFIER> and parse a local variable declaration\nIf the statement starts with anything else, Statement will catch it", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470921742", "createdAt": "2020-08-15T01:33:31Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1879,22 +1949,25 @@ void BlockStatement():\n   LOOKAHEAD( { isNextTokenAnAssert() } ) AssertStatement()\n | LOOKAHEAD( { isYieldStart() } ) YieldStatement()\n |\n-  LOOKAHEAD(( \"final\" | Annotation() )* Type() <IDENTIFIER>)\n+  LOOKAHEAD(2147483647, ( \"final\" | Annotation() )* Type() <IDENTIFIER>, {isRecordTypeSupported() && !isRecordDeclarationAhead() || !isRecordTypeSupported()})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE1MDc3MQ==", "bodyText": "I've tried it - not exactly the way you described, please have a look.", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r471150771", "createdAt": "2020-08-16T19:47:35Z", "author": {"login": "adangel"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1879,22 +1949,25 @@ void BlockStatement():\n   LOOKAHEAD( { isNextTokenAnAssert() } ) AssertStatement()\n | LOOKAHEAD( { isYieldStart() } ) YieldStatement()\n |\n-  LOOKAHEAD(( \"final\" | Annotation() )* Type() <IDENTIFIER>)\n+  LOOKAHEAD(2147483647, ( \"final\" | Annotation() )* Type() <IDENTIFIER>, {isRecordTypeSupported() && !isRecordDeclarationAhead() || !isRecordTypeSupported()})", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMTc0Mg=="}, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk0Mjg3NzM2OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/ast/Java15PreviewTest.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTozNzozOVrOHBGzvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xOFQwOTozMzo1NlrOHCLeZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMjE3Mw==", "bodyText": "Do we need to continue writing grammar tests this way? This is really inferior to the kotlin tests, and hard to update to java-grammar...", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470922173", "createdAt": "2020-08-15T01:37:39Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/ast/Java15PreviewTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import java.util.List;\n+\n+import org.junit.Assert;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import net.sourceforge.pmd.lang.ast.ParseException;\n+import net.sourceforge.pmd.lang.java.JavaParsingHelper;\n+import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeBodyDeclaration.DeclarationKind;\n+\n+public class Java15PreviewTest {\n+    private final JavaParsingHelper java15p =\n+            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion(\"15-preview\")\n+                                             .withResourceContext(Java15PreviewTest.class, \"jdkversiontests/java15p/\");\n+\n+    private final JavaParsingHelper java15 = java15p.withDefaultVersion(\"15\");\n+\n+    @Test\n+    public void patternMatchingInstanceof() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"PatternMatchingInstanceof.java\");\n+        List<ASTInstanceOfExpression> instanceOfExpressions = compilationUnit.findDescendantsOfType(ASTInstanceOfExpression.class);\n+        Assert.assertEquals(4, instanceOfExpressions.size());\n+        for (ASTInstanceOfExpression expr : instanceOfExpressions) {\n+            Assert.assertTrue(expr.getChild(1) instanceof ASTTypeTestPattern);\n+            ASTVariableDeclaratorId variable = expr.getChild(1).getFirstChildOfType(ASTVariableDeclaratorId.class);\n+            Assert.assertEquals(String.class, variable.getType());\n+            Assert.assertEquals(\"s\", variable.getVariableName());\n+            Assert.assertTrue(variable.isPatternBinding());\n+            Assert.assertTrue(variable.isFinal());\n+            // Note: these variables are not part of the symbol table\n+            // See ScopeAndDeclarationFinder#visit(ASTVariableDeclaratorId, Object)\n+            Assert.assertNull(variable.getNameDeclaration());\n+        }\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void patternMatchingInstanceofBeforeJava15PreviewShouldFail() {\n+        java15.parseResource(\"PatternMatchingInstanceof.java\");\n+    }\n+\n+    @Test\n+    public void recordPoint() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"Point.java\");\n+        ASTRecordDeclaration recordDecl = compilationUnit.getFirstDescendantOfType(ASTRecordDeclaration.class);\n+        Assert.assertEquals(\"Point\", recordDecl.getImage());\n+        Assert.assertFalse(recordDecl.isNested());\n+        Assert.assertFalse(recordDecl.isLocal());\n+        Assert.assertTrue(\"Records are implicitly always final\", recordDecl.isFinal());\n+        List<ASTRecordComponent> components = recordDecl.getFirstChildOfType(ASTRecordComponentList.class)\n+                                                        .findChildrenOfType(ASTRecordComponent.class);\n+        Assert.assertEquals(2, components.size());\n+        Assert.assertEquals(\"x\", components.get(0).getVarId().getImage());\n+        Assert.assertEquals(\"y\", components.get(1).getVarId().getImage());\n+        Assert.assertNull(components.get(0).getVarId().getNameDeclaration().getAccessNodeParent());\n+        Assert.assertEquals(Integer.TYPE, components.get(0).getVarId().getNameDeclaration().getType());\n+        Assert.assertEquals(\"int\", components.get(0).getVarId().getNameDeclaration().getTypeImage());\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordPointBeforeJava15PreviewShouldFail() {\n+        java15.parseResource(\"Point.java\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordCtorWithThrowsShouldFail() {\n+        java15p.parse(\"  record R {\"\n+                          + \"   R throws IOException {}\"\n+                          + \"  }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordMustNotExtend() {\n+        java15p.parse(\"record RecordEx(int x) extends Number { }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    @Ignore(\"Should we check this?\")\n+    public void recordCannotBeAbstract() {\n+        java15p.parse(\"abstract record RecordEx(int x) { }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    @Ignore(\"Should we check this?\")\n+    public void recordCannotHaveInstanceFields() {\n+        java15p.parse(\"record RecordFields(int x) { private int y = 1; }\");\n+    }\n+\n+    @Test\n+    public void innerRecords() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"Records.java\");\n+        List<ASTRecordDeclaration> recordDecls = compilationUnit.findDescendantsOfType(ASTRecordDeclaration.class, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE1MDkyOQ==", "bodyText": "I'll try tomorrow to write Kotlin - that basically entails that we ditch eclipse as a supported IDE for developing PMD (see https://github.com/pmd/pmd/wiki/Setup-IDE)... since Kotlin+Eclipse doesn't work.", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r471150929", "createdAt": "2020-08-16T19:49:23Z", "author": {"login": "adangel"}, "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/ast/Java15PreviewTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import java.util.List;\n+\n+import org.junit.Assert;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import net.sourceforge.pmd.lang.ast.ParseException;\n+import net.sourceforge.pmd.lang.java.JavaParsingHelper;\n+import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeBodyDeclaration.DeclarationKind;\n+\n+public class Java15PreviewTest {\n+    private final JavaParsingHelper java15p =\n+            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion(\"15-preview\")\n+                                             .withResourceContext(Java15PreviewTest.class, \"jdkversiontests/java15p/\");\n+\n+    private final JavaParsingHelper java15 = java15p.withDefaultVersion(\"15\");\n+\n+    @Test\n+    public void patternMatchingInstanceof() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"PatternMatchingInstanceof.java\");\n+        List<ASTInstanceOfExpression> instanceOfExpressions = compilationUnit.findDescendantsOfType(ASTInstanceOfExpression.class);\n+        Assert.assertEquals(4, instanceOfExpressions.size());\n+        for (ASTInstanceOfExpression expr : instanceOfExpressions) {\n+            Assert.assertTrue(expr.getChild(1) instanceof ASTTypeTestPattern);\n+            ASTVariableDeclaratorId variable = expr.getChild(1).getFirstChildOfType(ASTVariableDeclaratorId.class);\n+            Assert.assertEquals(String.class, variable.getType());\n+            Assert.assertEquals(\"s\", variable.getVariableName());\n+            Assert.assertTrue(variable.isPatternBinding());\n+            Assert.assertTrue(variable.isFinal());\n+            // Note: these variables are not part of the symbol table\n+            // See ScopeAndDeclarationFinder#visit(ASTVariableDeclaratorId, Object)\n+            Assert.assertNull(variable.getNameDeclaration());\n+        }\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void patternMatchingInstanceofBeforeJava15PreviewShouldFail() {\n+        java15.parseResource(\"PatternMatchingInstanceof.java\");\n+    }\n+\n+    @Test\n+    public void recordPoint() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"Point.java\");\n+        ASTRecordDeclaration recordDecl = compilationUnit.getFirstDescendantOfType(ASTRecordDeclaration.class);\n+        Assert.assertEquals(\"Point\", recordDecl.getImage());\n+        Assert.assertFalse(recordDecl.isNested());\n+        Assert.assertFalse(recordDecl.isLocal());\n+        Assert.assertTrue(\"Records are implicitly always final\", recordDecl.isFinal());\n+        List<ASTRecordComponent> components = recordDecl.getFirstChildOfType(ASTRecordComponentList.class)\n+                                                        .findChildrenOfType(ASTRecordComponent.class);\n+        Assert.assertEquals(2, components.size());\n+        Assert.assertEquals(\"x\", components.get(0).getVarId().getImage());\n+        Assert.assertEquals(\"y\", components.get(1).getVarId().getImage());\n+        Assert.assertNull(components.get(0).getVarId().getNameDeclaration().getAccessNodeParent());\n+        Assert.assertEquals(Integer.TYPE, components.get(0).getVarId().getNameDeclaration().getType());\n+        Assert.assertEquals(\"int\", components.get(0).getVarId().getNameDeclaration().getTypeImage());\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordPointBeforeJava15PreviewShouldFail() {\n+        java15.parseResource(\"Point.java\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordCtorWithThrowsShouldFail() {\n+        java15p.parse(\"  record R {\"\n+                          + \"   R throws IOException {}\"\n+                          + \"  }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordMustNotExtend() {\n+        java15p.parse(\"record RecordEx(int x) extends Number { }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    @Ignore(\"Should we check this?\")\n+    public void recordCannotBeAbstract() {\n+        java15p.parse(\"abstract record RecordEx(int x) { }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    @Ignore(\"Should we check this?\")\n+    public void recordCannotHaveInstanceFields() {\n+        java15p.parse(\"record RecordFields(int x) { private int y = 1; }\");\n+    }\n+\n+    @Test\n+    public void innerRecords() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"Records.java\");\n+        List<ASTRecordDeclaration> recordDecls = compilationUnit.findDescendantsOfType(ASTRecordDeclaration.class, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMjE3Mw=="}, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjA0NzIwNg==", "bodyText": "There's also the possibility of writing tests like #2445, which looks useful since your test data is already in separate files. This doesn't need to be in kotlin\nThese kind of java tests where you manually extract some nodes with eg findDescendantsOfType and hardcoded indices are very error prone to write, unreadable, and hard to update. They also don't test much of the structure compare to #2445 or a kotlin test. I think it would be better to use #2445 as a blanket test to assert the structure, and then some more focused unit tests to test the methods, if you want to write them in java.", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r472047206", "createdAt": "2020-08-18T09:33:56Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/ast/Java15PreviewTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import java.util.List;\n+\n+import org.junit.Assert;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import net.sourceforge.pmd.lang.ast.ParseException;\n+import net.sourceforge.pmd.lang.java.JavaParsingHelper;\n+import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeBodyDeclaration.DeclarationKind;\n+\n+public class Java15PreviewTest {\n+    private final JavaParsingHelper java15p =\n+            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion(\"15-preview\")\n+                                             .withResourceContext(Java15PreviewTest.class, \"jdkversiontests/java15p/\");\n+\n+    private final JavaParsingHelper java15 = java15p.withDefaultVersion(\"15\");\n+\n+    @Test\n+    public void patternMatchingInstanceof() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"PatternMatchingInstanceof.java\");\n+        List<ASTInstanceOfExpression> instanceOfExpressions = compilationUnit.findDescendantsOfType(ASTInstanceOfExpression.class);\n+        Assert.assertEquals(4, instanceOfExpressions.size());\n+        for (ASTInstanceOfExpression expr : instanceOfExpressions) {\n+            Assert.assertTrue(expr.getChild(1) instanceof ASTTypeTestPattern);\n+            ASTVariableDeclaratorId variable = expr.getChild(1).getFirstChildOfType(ASTVariableDeclaratorId.class);\n+            Assert.assertEquals(String.class, variable.getType());\n+            Assert.assertEquals(\"s\", variable.getVariableName());\n+            Assert.assertTrue(variable.isPatternBinding());\n+            Assert.assertTrue(variable.isFinal());\n+            // Note: these variables are not part of the symbol table\n+            // See ScopeAndDeclarationFinder#visit(ASTVariableDeclaratorId, Object)\n+            Assert.assertNull(variable.getNameDeclaration());\n+        }\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void patternMatchingInstanceofBeforeJava15PreviewShouldFail() {\n+        java15.parseResource(\"PatternMatchingInstanceof.java\");\n+    }\n+\n+    @Test\n+    public void recordPoint() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"Point.java\");\n+        ASTRecordDeclaration recordDecl = compilationUnit.getFirstDescendantOfType(ASTRecordDeclaration.class);\n+        Assert.assertEquals(\"Point\", recordDecl.getImage());\n+        Assert.assertFalse(recordDecl.isNested());\n+        Assert.assertFalse(recordDecl.isLocal());\n+        Assert.assertTrue(\"Records are implicitly always final\", recordDecl.isFinal());\n+        List<ASTRecordComponent> components = recordDecl.getFirstChildOfType(ASTRecordComponentList.class)\n+                                                        .findChildrenOfType(ASTRecordComponent.class);\n+        Assert.assertEquals(2, components.size());\n+        Assert.assertEquals(\"x\", components.get(0).getVarId().getImage());\n+        Assert.assertEquals(\"y\", components.get(1).getVarId().getImage());\n+        Assert.assertNull(components.get(0).getVarId().getNameDeclaration().getAccessNodeParent());\n+        Assert.assertEquals(Integer.TYPE, components.get(0).getVarId().getNameDeclaration().getType());\n+        Assert.assertEquals(\"int\", components.get(0).getVarId().getNameDeclaration().getTypeImage());\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordPointBeforeJava15PreviewShouldFail() {\n+        java15.parseResource(\"Point.java\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordCtorWithThrowsShouldFail() {\n+        java15p.parse(\"  record R {\"\n+                          + \"   R throws IOException {}\"\n+                          + \"  }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordMustNotExtend() {\n+        java15p.parse(\"record RecordEx(int x) extends Number { }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    @Ignore(\"Should we check this?\")\n+    public void recordCannotBeAbstract() {\n+        java15p.parse(\"abstract record RecordEx(int x) { }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    @Ignore(\"Should we check this?\")\n+    public void recordCannotHaveInstanceFields() {\n+        java15p.parse(\"record RecordFields(int x) { private int y = 1; }\");\n+    }\n+\n+    @Test\n+    public void innerRecords() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"Records.java\");\n+        List<ASTRecordDeclaration> recordDecls = compilationUnit.findDescendantsOfType(ASTRecordDeclaration.class, true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMjE3Mw=="}, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjk2OTY0Njg4OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPermittedSubclasses.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxMTowMzoxN1rOHFEhpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxNzoxMDozM1rOHFGcpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA3OTA3OA==", "bodyText": "Maybe, this node should be renamed to ASTPermitsList. On the java-grammar branch we already have many kinds of *List: ExtendsList, ImplementsList, ArgumentsList, ThrowsList, ResourceList, etc. Those extend ASTList. The relation to ASTList will probably be more obvious if this node also ends with \"List\".", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r475079078", "createdAt": "2020-08-22T11:03:17Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPermittedSubclasses.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import java.util.Iterator;\n+\n+import net.sourceforge.pmd.annotation.Experimental;\n+\n+\n+/**\n+ * Represents the {@code permits} clause of a (sealed) class declaration.\n+ *\n+ * <p>This is a Java 15 Preview feature.\n+ *\n+ * <p>See https://openjdk.java.net/jeps/360\n+ *\n+ * <pre class=\"grammar\">\n+ *  PermittedSubclasses ::= \"permits\" (TypeAnnotation)* ClassOrInterfaceType\n+ *                ( \",\" (TypeAnnotation)* ClassOrInterfaceType )*\n+ * </pre>\n+ */\n+@Experimental\n+public final class ASTPermittedSubclasses extends AbstractJavaNode implements Iterable<ASTClassOrInterfaceType> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04850c69bc2002aeef4dbd778771cd0d8fa4ba91"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExMDM4Ng==", "bodyText": "Renaming it to ASTPermitsList makes sense, yes.\nShall I do it or will you rename it?", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r475110386", "createdAt": "2020-08-22T17:08:44Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPermittedSubclasses.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import java.util.Iterator;\n+\n+import net.sourceforge.pmd.annotation.Experimental;\n+\n+\n+/**\n+ * Represents the {@code permits} clause of a (sealed) class declaration.\n+ *\n+ * <p>This is a Java 15 Preview feature.\n+ *\n+ * <p>See https://openjdk.java.net/jeps/360\n+ *\n+ * <pre class=\"grammar\">\n+ *  PermittedSubclasses ::= \"permits\" (TypeAnnotation)* ClassOrInterfaceType\n+ *                ( \",\" (TypeAnnotation)* ClassOrInterfaceType )*\n+ * </pre>\n+ */\n+@Experimental\n+public final class ASTPermittedSubclasses extends AbstractJavaNode implements Iterable<ASTClassOrInterfaceType> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA3OTA3OA=="}, "originalCommit": {"oid": "04850c69bc2002aeef4dbd778771cd0d8fa4ba91"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTExMDU2Nw==", "bodyText": "I can do it when I merge", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r475110567", "createdAt": "2020-08-22T17:10:33Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPermittedSubclasses.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import java.util.Iterator;\n+\n+import net.sourceforge.pmd.annotation.Experimental;\n+\n+\n+/**\n+ * Represents the {@code permits} clause of a (sealed) class declaration.\n+ *\n+ * <p>This is a Java 15 Preview feature.\n+ *\n+ * <p>See https://openjdk.java.net/jeps/360\n+ *\n+ * <pre class=\"grammar\">\n+ *  PermittedSubclasses ::= \"permits\" (TypeAnnotation)* ClassOrInterfaceType\n+ *                ( \",\" (TypeAnnotation)* ClassOrInterfaceType )*\n+ * </pre>\n+ */\n+@Experimental\n+public final class ASTPermittedSubclasses extends AbstractJavaNode implements Iterable<ASTClassOrInterfaceType> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA3OTA3OA=="}, "originalCommit": {"oid": "04850c69bc2002aeef4dbd778771cd0d8fa4ba91"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 302, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}