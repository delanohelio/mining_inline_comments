{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE0Mjc2OTEx", "number": 2897, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzowOTo0OVrOE2FG1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzowOTo0OVrOE2FG1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI1MTQyMjI4OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryFullyQualifiedNameRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzowOTo0OVrOHutaJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wNlQxMzowOTo0OVrOHutaJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODc0MDUxNg==", "bodyText": "\ud83d\ude04", "url": "https://github.com/pmd/pmd/pull/2897#discussion_r518740516", "createdAt": "2020-11-06T13:09:49Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/codestyle/UnnecessaryFullyQualifiedNameRule.java", "diffHunk": "@@ -4,427 +4,252 @@\n \n package net.sourceforge.pmd.lang.java.rule.codestyle;\n \n-import java.lang.reflect.Method;\n-import java.util.ArrayList;\n+import static net.sourceforge.pmd.properties.PropertyFactory.booleanProperty;\n+\n import java.util.List;\n-import java.util.Map.Entry;\n-import java.util.Objects;\n-import java.util.Set;\n-import java.util.logging.Level;\n-import java.util.logging.Logger;\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n \n-import org.apache.commons.lang3.StringUtils;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n \n-import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.internal.util.AssertionUtil;\n import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceType;\n-import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\n-import net.sourceforge.pmd.lang.java.ast.ASTName;\n-import net.sourceforge.pmd.lang.java.ast.ASTNameList;\n-import net.sourceforge.pmd.lang.java.ast.ASTPackageDeclaration;\n-import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n-import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n-import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.ASTFieldAccess;\n+import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;\n+import net.sourceforge.pmd.lang.java.ast.ASTTypeExpression;\n import net.sourceforge.pmd.lang.java.ast.JavaNode;\n-import net.sourceforge.pmd.lang.java.ast.TypeNode;\n-import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n-import net.sourceforge.pmd.lang.java.symboltable.SourceFileScope;\n-import net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\n-import net.sourceforge.pmd.lang.symboltable.NameOccurrence;\n-import net.sourceforge.pmd.lang.symboltable.Scope;\n-\n-public class UnnecessaryFullyQualifiedNameRule extends AbstractJavaRule {\n-    private static final Logger LOG = Logger.getLogger(UnnecessaryFullyQualifiedNameRule.class.getName());\n-\n-    private List<ASTImportDeclaration> imports = new ArrayList<>();\n-    private String currentPackage;\n+import net.sourceforge.pmd.lang.java.rule.AbstractJavaRulechainRule;\n+import net.sourceforge.pmd.lang.java.symbols.JAccessibleElementSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JElementSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JFieldSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.table.JSymbolTable;\n+import net.sourceforge.pmd.lang.java.symbols.table.ScopeInfo;\n+import net.sourceforge.pmd.lang.java.symbols.table.coreimpl.ShadowChain;\n+import net.sourceforge.pmd.lang.java.symbols.table.coreimpl.ShadowChainIterator;\n+import net.sourceforge.pmd.lang.java.types.JMethodSig;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+\n+public class UnnecessaryFullyQualifiedNameRule extends AbstractJavaRulechainRule {\n+\n+    private static final PropertyDescriptor<Boolean> REPORT_METHODS =\n+        booleanProperty(\"reportStaticMethods\")\n+            .desc(\"Report unnecessary static method qualifiers like in `Collections.emptyList()`, if the method is imported or inherited.\")\n+            .defaultValue(true)\n+            .build();\n+\n+    private static final PropertyDescriptor<Boolean> REPORT_FIELDS =\n+        booleanProperty(\"reportStaticFields\")\n+            .desc(\"Report unnecessary static field qualifiers like in `Math.PI`, if the field is imported or inherited.\")\n+            .defaultValue(true)\n+            .build();\n \n     public UnnecessaryFullyQualifiedNameRule() {\n-        super.addRuleChainVisit(ASTPackageDeclaration.class);\n-        super.addRuleChainVisit(ASTImportDeclaration.class);\n-        super.addRuleChainVisit(ASTClassOrInterfaceType.class);\n-        super.addRuleChainVisit(ASTName.class);\n-    }\n-\n-    @Override\n-    public void start(final RuleContext ctx) {\n-        imports.clear();\n-        currentPackage = null;\n-    }\n-\n-    @Override\n-    public Object visit(ASTPackageDeclaration node, Object data) {\n-        currentPackage = node.getPackageNameImage();\n-        return data;\n+        super(ASTClassOrInterfaceType.class);\n+        definePropertyDescriptor(REPORT_METHODS);\n+        definePropertyDescriptor(REPORT_FIELDS);\n     }\n \n     @Override\n-    public Object visit(ASTImportDeclaration node, Object data) {\n-        imports.add(node);\n-        return data;\n-    }\n-\n-    @Override\n-    public Object visit(ASTClassOrInterfaceType node, Object data) {\n-        // This name has no qualification, it can't be unnecessarily qualified\n-        if (node.getImage().indexOf('.') < 0) {\n+    public Object visit(final ASTClassOrInterfaceType deepest, Object data) {\n+        if (deepest.getQualifier() != null) {\n+            // the child will be visited instead\n             return data;\n         }\n-        checkImports(node, data);\n-        return data;\n-    }\n \n-    @Override\n-    public Object visit(ASTName node, Object data) {\n-        if (!(node.getParent() instanceof ASTImportDeclaration)\n-                && !(node.getParent() instanceof ASTPackageDeclaration)) {\n-            // This name has no qualification, it can't be unnecessarily qualified\n-            if (node.getImage().indexOf('.') < 0) {\n-                return data;\n-            }\n-            checkImports(node, data);\n+        ASTClassOrInterfaceType next = deepest;\n+        ScopeInfo bestReason = null;\n+        if (next.isFullyQualified()) {\n+            bestReason = typeMeansSame(next);\n         }\n-        return data;\n-    }\n \n-\n-    /**\n-     * Returns true if the name could be imported by this declaration.\n-     * The name must be fully qualified, the import is either on-demand\n-     * or static, that is its {@link ASTImportDeclaration#getImportedName()}\n-     * is the enclosing package or type name of the imported type or static member.\n-     */\n-    private boolean declarationMatches(ASTImportDeclaration decl, String name) {\n-        return name.startsWith(decl.getImportedName())\n-                && name.lastIndexOf('.') == decl.getImportedName().length();\n-    }\n-\n-    private boolean couldBeMethodCall(JavaNode node) {\n-        if (node.getNthParent(2) instanceof ASTPrimaryExpression && node.getNthParent(1) instanceof ASTPrimaryPrefix) {\n-            int nextSibling = node.getParent().getIndexInParent() + 1;\n-            if (node.getNthParent(2).getNumChildren() > nextSibling) {\n-                return node.getNthParent(2).getChild(nextSibling) instanceof ASTPrimarySuffix;\n+        // try to find the longest prefix that can be removed\n+        while (bestReason != null && segmentIsIrrelevant(next) && next.getParent() instanceof ASTClassOrInterfaceType) {\n+            ASTClassOrInterfaceType nextParent = (ASTClassOrInterfaceType) next.getParent();\n+            ScopeInfo newBestReason = typeMeansSame(nextParent);\n+            if (newBestReason == null) {\n+                break;\n+            } else {\n+                bestReason = newBestReason;\n+                next = nextParent;\n             }\n         }\n-        return false;\n-    }\n \n-    private void checkImports(TypeNode node, Object data) {\n-        final String name = node.getImage();\n+        // maybe a method call/field can still take precedence\n+        if (next.getParent() instanceof ASTTypeExpression) {\n \n-        // variable names shadow everything else\n-        // If the first segment is a variable, then all\n-        // the following are field accesses and it's not an FQCN\n-        if (isVariable(node.getScope(), name)) {\n-            return;\n-        }\n-\n-        List<ASTImportDeclaration> matches = new ArrayList<>();\n-\n-        // Find all \"matching\" import declarations\n-        for (ASTImportDeclaration importDeclaration : imports) {\n-            if (!importDeclaration.isImportOnDemand()) {\n-                // Exact match of imported class\n-                if (name.equals(importDeclaration.getImportedName())) {\n-                    matches.add(importDeclaration);\n-                    continue;\n+            JavaNode opa = next.getParent().getParent();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b661abe3bda85c75a2d8e5af60f3c15b1b629534"}, "originalPosition": 184}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 195, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}