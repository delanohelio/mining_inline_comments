{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE5NTI0NDM0", "number": 2490, "reviewThreads": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzoxNDoxNVrOEJBzTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODozMTozOFrOEJDMRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTAyMTU4OnYy", "diffSide": "RIGHT", "path": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/bestpractices/AvoidLogicInTriggerRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzoxNDoxNlrOGpWNCA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDo0NjowNVrOGpjqJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwODU4NA==", "bodyText": "Just a question: This @NonNull here, is that a constraint, that the Rule API implementer must obey? Meaning - it should be part of the API and not part of impl? Otherwise, we can't rely on it and need a null check anyway....", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446008584", "createdAt": "2020-06-26T07:14:16Z", "author": {"login": "adangel"}, "path": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/bestpractices/AvoidLogicInTriggerRule.java", "diffHunk": "@@ -6,14 +6,18 @@\n \n import java.util.List;\n \n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n import net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;\n import net.sourceforge.pmd.lang.apex.ast.ASTUserTrigger;\n import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n+import net.sourceforge.pmd.lang.rule.RuleTargetSelector;\n \n public class AvoidLogicInTriggerRule extends AbstractApexRule {\n \n-    public AvoidLogicInTriggerRule() {\n-        addRuleChainVisit(ASTUserTrigger.class);\n+    @Override\n+    protected @NonNull RuleTargetSelector buildTargetSelector() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIyOTAyOQ==", "bodyText": "Not sure I follow... The super method has this annotation, which means implementations are expected to never return null too. So yes it's part of the API, or rather it's an explicit \"contract\" that the implementor must respect.\nBy copying it to the implementation we let static analysis tools make sure you respect the contract (eg the IDE, maybe PMD in the future?)", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446229029", "createdAt": "2020-06-26T14:46:05Z", "author": {"login": "oowekyala"}, "path": "pmd-apex/src/main/java/net/sourceforge/pmd/lang/apex/rule/bestpractices/AvoidLogicInTriggerRule.java", "diffHunk": "@@ -6,14 +6,18 @@\n \n import java.util.List;\n \n+import org.checkerframework.checker.nullness.qual.NonNull;\n+\n import net.sourceforge.pmd.lang.apex.ast.ASTBlockStatement;\n import net.sourceforge.pmd.lang.apex.ast.ASTUserTrigger;\n import net.sourceforge.pmd.lang.apex.rule.AbstractApexRule;\n+import net.sourceforge.pmd.lang.rule.RuleTargetSelector;\n \n public class AvoidLogicInTriggerRule extends AbstractApexRule {\n \n-    public AvoidLogicInTriggerRule() {\n-        addRuleChainVisit(ASTUserTrigger.class);\n+    @Override\n+    protected @NonNull RuleTargetSelector buildTargetSelector() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAwODU4NA=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTAzMjE3OnYy", "diffSide": "RIGHT", "path": "pmd-core/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzoxODoxNlrOGpWTdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDo0MzowNVrOGpjjMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxMDIzMQ==", "bodyText": "Do we need this? pcollections....", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446010231", "createdAt": "2020-06-26T07:18:16Z", "author": {"login": "adangel"}, "path": "pmd-core/pom.xml", "diffHunk": "@@ -149,6 +149,11 @@\n             <artifactId>checker-qual</artifactId>\n             <version>2.5.2</version>\n         </dependency>\n+        <dependency>\n+            <groupId>org.pcollections</groupId>\n+            <artifactId>pcollections</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIyNzI1MA==", "bodyText": "We could do without it in this PR, but I use it in the type resolution code, and I think it's better introduced now rather than later. This can have many many applications", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446227250", "createdAt": "2020-06-26T14:43:05Z", "author": {"login": "oowekyala"}, "path": "pmd-core/pom.xml", "diffHunk": "@@ -149,6 +149,11 @@\n             <artifactId>checker-qual</artifactId>\n             <version>2.5.2</version>\n         </dependency>\n+        <dependency>\n+            <groupId>org.pcollections</groupId>\n+            <artifactId>pcollections</artifactId>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxMDIzMQ=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTA0OTYyOnYy", "diffSide": "LEFT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/Rule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzoyNDozMVrOGpWd0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzoyNDozMVrOGpWd0Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxMjg4MQ==", "bodyText": "All this can't be deprecated on master, since there is no way to migrate before. I've added a point to #1139 for the migration documentation.\nWhen we have finished the changes on PMD 7, we can go back and look, whether we introduce e.g. RuleTargetSelector already in PMD 6.x and providing a compatibility API - that would allow us to deprecate this method in PMD 6.x. But - if we do that - only as a last step and maybe only as a small minor release for PMD 6.x after PMD 7 is out (for helping migration).", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446012881", "createdAt": "2020-06-26T07:24:31Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/Rule.java", "diffHunk": "@@ -287,56 +288,28 @@ default boolean dependsOn(AstProcessingStage<?> stage) {\n \n \n     /**\n-     * Gets whether this Rule uses the RuleChain.\n-     *\n-     * @return <code>true</code> if RuleChain is used.\n-     */\n-    boolean isRuleChain();\n-\n-    /**\n-     * Gets the collection of AST node names visited by the Rule on the\n-     * RuleChain.\n-     *\n-     * @return the list of AST node names\n+     * Returns the object that selects the nodes to which this rule applies.\n+     * The selected nodes will be handed to {@link #apply(Node, RuleContext)}.\n      */\n-    List<String> getRuleChainVisits();\n+    RuleTargetSelector getTargetSelector();\n \n-    /**\n-     * Adds an AST node by class to be visited by the Rule on the RuleChain.\n-     *\n-     * @param nodeClass\n-     *            the AST node to add to the RuleChain visit list\n-     */\n-    void addRuleChainVisit(Class<? extends Node> nodeClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 35}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTA1NzQwOnYy", "diffSide": "LEFT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/RuleChain.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzoyNzozMVrOGpWjHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzoyNzozMVrOGpWjHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNDIzNg==", "bodyText": "I'll @Deprecate and @InternalApi this on master... that's definitively internal and should not be used at all....", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446014236", "createdAt": "2020-06-26T07:27:31Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/RuleChain.java", "diffHunk": "@@ -1,85 +0,0 @@\n-/**\n- * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n- */\n-\n-package net.sourceforge.pmd;\n-\n-import java.util.HashMap;\n-import java.util.List;\n-import java.util.Map;\n-\n-import net.sourceforge.pmd.lang.Language;\n-import net.sourceforge.pmd.lang.ast.Node;\n-import net.sourceforge.pmd.lang.rule.RuleChainVisitor;\n-\n-/**\n- * The RuleChain is a means by which Rules can participate in a uniform\n- * visitation of the AST, and not need perform their own independent visitation.\n- * The RuleChain exists as a means to improve the speed of PMD when there are\n- * many Rules.\n- */\n-public class RuleChain {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTA3MTIzOnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSets.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzozMjoyNFrOGpWrkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzozMjoyNFrOGpWrkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAxNjQwMQ==", "bodyText": "That's btw something we need to think about: The comment probably was the intention, but was never implemented this way - all the rules are put together into the same list regardless of their language....\nSo, how do we deal with a ruleset that contains rules of multiple languages, etc.... (in terms of internal processing and expected unsurprising behavior of PMD).", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446016401", "createdAt": "2020-06-26T07:32:24Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSets.java", "diffHunk": "@@ -7,68 +7,57 @@\n import java.io.File;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n-import net.sourceforge.pmd.lang.Language;\n+import net.sourceforge.pmd.benchmark.TimeTracker;\n+import net.sourceforge.pmd.benchmark.TimedOperation;\n+import net.sourceforge.pmd.benchmark.TimedOperationCategory;\n import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.rule.internal.RuleApplicator;\n \n /**\n  * Grouping of Rules per Language in a RuleSet.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTEwMDcxOnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0MjozM1rOGpW9iw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDozNzowMFrOGpjVHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTAwMw==", "bodyText": "I assume, these classrulechainvisits are only there for compatibility, because not all rules are migrated yet?\nI'd expect the default implementation just to be return RuleTargetSelector.forRootOnly() eventually.", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446021003", "createdAt": "2020-06-26T07:42:33Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java", "diffHunk": "@@ -227,36 +232,42 @@ public ParserOptions getParserOptions() {\n         return new ParserOptions();\n     }\n \n-    @Override\n-    public boolean isRuleChain() {\n-        return !getRuleChainVisits().isEmpty();\n-    }\n \n-    @Override\n-    public List<String> getRuleChainVisits() {\n-        return ruleChainVisits;\n+    private Set<Class<? extends Node>> getClassRuleChainVisits() {\n+        if (classRuleChainVisits.isEmpty() && ruleChainVisits.isEmpty()) {\n+            return Collections.singleton(RootNode.class);\n+        }\n+        return classRuleChainVisits;\n     }\n \n-    @Override\n-    public void addRuleChainVisit(Class<? extends Node> nodeClass) {\n-        // FIXME : These assume the implementation of getXPathNodeName() for all nodes\u2026\n-        final String simpleName = nodeClass.getSimpleName();\n \n-        if (simpleName.startsWith(\"AST\")) { // JavaCC node\n-            // Classes under the Comment hierarchy and stuff need to be refactored in the Java AST\n-            addRuleChainVisit(nodeClass.getSimpleName().substring(\"AST\".length()));\n-        } else if (nodeClass.getSimpleName().endsWith(\"Context\")) { // Antlr node\n-            addRuleChainVisit(nodeClass.getSimpleName().substring(0, simpleName.length() - \"Context\".length()));\n-        } else {\n-            throw new IllegalArgumentException(\"Node class does not start with 'AST' prefix nor ends with 'Context' suffix: \" + nodeClass);\n-        }\n+    /**\n+     * @deprecated Override {@link #buildTargetSelector()}, this is\n+     *     provided for legacy compatibility\n+     */\n+    @Deprecated\n+    protected void addRuleChainVisit(Class<? extends Node> nodeClass) {\n+        classRuleChainVisits.add(nodeClass);\n     }\n \n     @Override\n-    public void addRuleChainVisit(String astNodeName) {\n-        if (!ruleChainVisits.contains(astNodeName)) {\n-            ruleChainVisits.add(astNodeName);\n+    public final RuleTargetSelector getTargetSelector() {\n+        if (myStrategy == null) {\n+            myStrategy = buildTargetSelector();\n         }\n+        return myStrategy;\n+    }\n+\n+    /**\n+     * Create the targeting strategy for this rule. Please override\n+     * this instead of using {@link #addRuleChainVisit(Class)}.\n+     * Use the factory methods of {@link RuleTargetSelector}.\n+     */\n+    @NonNull\n+    protected RuleTargetSelector buildTargetSelector() {\n+        Set<Class<? extends Node>> crvs = getClassRuleChainVisits();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIyMzY0NA==", "bodyText": "Yes :)", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446223644", "createdAt": "2020-06-26T14:37:00Z", "author": {"login": "oowekyala"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java", "diffHunk": "@@ -227,36 +232,42 @@ public ParserOptions getParserOptions() {\n         return new ParserOptions();\n     }\n \n-    @Override\n-    public boolean isRuleChain() {\n-        return !getRuleChainVisits().isEmpty();\n-    }\n \n-    @Override\n-    public List<String> getRuleChainVisits() {\n-        return ruleChainVisits;\n+    private Set<Class<? extends Node>> getClassRuleChainVisits() {\n+        if (classRuleChainVisits.isEmpty() && ruleChainVisits.isEmpty()) {\n+            return Collections.singleton(RootNode.class);\n+        }\n+        return classRuleChainVisits;\n     }\n \n-    @Override\n-    public void addRuleChainVisit(Class<? extends Node> nodeClass) {\n-        // FIXME : These assume the implementation of getXPathNodeName() for all nodes\u2026\n-        final String simpleName = nodeClass.getSimpleName();\n \n-        if (simpleName.startsWith(\"AST\")) { // JavaCC node\n-            // Classes under the Comment hierarchy and stuff need to be refactored in the Java AST\n-            addRuleChainVisit(nodeClass.getSimpleName().substring(\"AST\".length()));\n-        } else if (nodeClass.getSimpleName().endsWith(\"Context\")) { // Antlr node\n-            addRuleChainVisit(nodeClass.getSimpleName().substring(0, simpleName.length() - \"Context\".length()));\n-        } else {\n-            throw new IllegalArgumentException(\"Node class does not start with 'AST' prefix nor ends with 'Context' suffix: \" + nodeClass);\n-        }\n+    /**\n+     * @deprecated Override {@link #buildTargetSelector()}, this is\n+     *     provided for legacy compatibility\n+     */\n+    @Deprecated\n+    protected void addRuleChainVisit(Class<? extends Node> nodeClass) {\n+        classRuleChainVisits.add(nodeClass);\n     }\n \n     @Override\n-    public void addRuleChainVisit(String astNodeName) {\n-        if (!ruleChainVisits.contains(astNodeName)) {\n-            ruleChainVisits.add(astNodeName);\n+    public final RuleTargetSelector getTargetSelector() {\n+        if (myStrategy == null) {\n+            myStrategy = buildTargetSelector();\n         }\n+        return myStrategy;\n+    }\n+\n+    /**\n+     * Create the targeting strategy for this rule. Please override\n+     * this instead of using {@link #addRuleChainVisit(Class)}.\n+     * Use the factory methods of {@link RuleTargetSelector}.\n+     */\n+    @NonNull\n+    protected RuleTargetSelector buildTargetSelector() {\n+        Set<Class<? extends Node>> crvs = getClassRuleChainVisits();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMTAwMw=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTEwODY0OnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0NTowNFrOGpXCRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDo0MToyNlrOGpjfPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjIxMw==", "bodyText": "for consistency, shouldn't we simply copy the reference to myStrategy like all the other fields?", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446022213", "createdAt": "2020-06-26T07:45:04Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java", "diffHunk": "@@ -70,17 +78,14 @@ public void deepCopyValuesTo(AbstractRule otherRule) {\n         otherRule.priority = priority;\n         otherRule.propertyDescriptors = new ArrayList<>(getPropertyDescriptors());\n         otherRule.propertyValuesByDescriptor = copyPropertyValues();\n-        otherRule.ruleChainVisits = copyRuleChainVisits();\n+        otherRule.ruleChainVisits = new LinkedHashSet<>(ruleChainVisits);\n+        otherRule.classRuleChainVisits = new LinkedHashSet<>(classRuleChainVisits);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIyNjIzOQ==", "bodyText": "Could be... but since we don't know exactly how the caller uses the deepCopy, we can't assume that they won't call addRuleChainVisit. If we copy myStrategy, then if it was not null, buildTargetSelector will never be called.\nThis is only relevant while addRuleChainVisit exists, when it's removed there will be no way to override the target selector of the implementation, and then it can be copied.", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446226239", "createdAt": "2020-06-26T14:41:26Z", "author": {"login": "oowekyala"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/AbstractRule.java", "diffHunk": "@@ -70,17 +78,14 @@ public void deepCopyValuesTo(AbstractRule otherRule) {\n         otherRule.priority = priority;\n         otherRule.propertyDescriptors = new ArrayList<>(getPropertyDescriptors());\n         otherRule.propertyValuesByDescriptor = copyPropertyValues();\n-        otherRule.ruleChainVisits = copyRuleChainVisits();\n+        otherRule.ruleChainVisits = new LinkedHashSet<>(ruleChainVisits);\n+        otherRule.classRuleChainVisits = new LinkedHashSet<>(classRuleChainVisits);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyMjIxMw=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTEyMDIyOnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSets.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0OTowMlrOGpXJcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo0OTowMlrOGpXJcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyNDA0OQ==", "bodyText": "I'll @Deprecate and @InternalApi it on master....\nNote: there are quite some usages in the PMD Eclipse plugin. This is due to the unclear API on how to call PMD programmatically, e.g. how to provide programmatically the rulesets to be used for analyzing....", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446024049", "createdAt": "2020-06-26T07:49:02Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/RuleSets.java", "diffHunk": "@@ -7,68 +7,57 @@\n import java.io.File;\n import java.util.ArrayList;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n \n-import net.sourceforge.pmd.lang.Language;\n+import net.sourceforge.pmd.benchmark.TimeTracker;\n+import net.sourceforge.pmd.benchmark.TimedOperation;\n+import net.sourceforge.pmd.benchmark.TimedOperationCategory;\n import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.rule.internal.RuleApplicator;\n \n /**\n  * Grouping of Rules per Language in a RuleSet.\n  *\n  * @author pieter_van_raemdonck - Application Engineers NV/SA - www.ae.be\n  */\n public class RuleSets {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTEzNjIzOnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleTargetSelector.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwNzo1NDowNVrOGpXTig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDozNjoyMlrOGpjTng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyNjYzNA==", "bodyText": "This looks a bit weird... RuleTargetSelector is API, but the supertype is internal.... effectively, this makes the internal supertype API as well\nOk, the class is abstract and the constructor is hidden - so no one can implement their own RuleTargetSelector...\nRight now, RuleTargetSelector serves as a utility class, that provides defined (hidden) implementations of itself...\nNot sure yet, what to do here, but it still looks weird to me....", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446026634", "createdAt": "2020-06-26T07:54:05Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleTargetSelector.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.rule;\n+\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import net.sourceforge.pmd.Rule;\n+import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.ast.RootNode;\n+import net.sourceforge.pmd.lang.rule.internal.TargetSelectorInternal;\n+import net.sourceforge.pmd.lang.rule.internal.TreeIndex;\n+import net.sourceforge.pmd.util.CollectionUtil;\n+\n+/**\n+ * A strategy for selecting nodes that will be targeted by a rule.\n+ *\n+ * @see Rule#getTargetSelector()\n+ */\n+public abstract class RuleTargetSelector extends TargetSelectorInternal {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIyMzI2Mg==", "bodyText": "Yes this is super weird. I wanted to make RuleTargetSelector published because it's somewhere on the Rule interface, but still keep everything about TreeIndex internal... So no one can implement their RuleTargetSelector because that would require us to expose TreeIndex.\nI'm truly not sure this is the best way to do it, if you have a better idea go ahead", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446223262", "createdAt": "2020-06-26T14:36:22Z", "author": {"login": "oowekyala"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/RuleTargetSelector.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.rule;\n+\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import net.sourceforge.pmd.Rule;\n+import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.ast.RootNode;\n+import net.sourceforge.pmd.lang.rule.internal.TargetSelectorInternal;\n+import net.sourceforge.pmd.lang.rule.internal.TreeIndex;\n+import net.sourceforge.pmd.util.CollectionUtil;\n+\n+/**\n+ * A strategy for selecting nodes that will be targeted by a rule.\n+ *\n+ * @see Rule#getTargetSelector()\n+ */\n+public abstract class RuleTargetSelector extends TargetSelectorInternal {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAyNjYzNA=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTE3MTQxOnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/LatticeRelation.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODowNjozMVrOGpXqOA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDozNDoxOFrOGpjO6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAzMjQ0MA==", "bodyText": "Just a question: Do we really need to be that generic? We are dealing with AST Nodes, don't we?\nThat's btw one example for #2611 - it will be very difficult to understand this class without looking at many more classes in parallel to understand, what's going on....\nMaybe the question in a different way: Do we really implement it that abstract? We only need it for PMD purposes, not for general purpose....", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446032440", "createdAt": "2020-06-26T08:06:31Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/LatticeRelation.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.rule.internal;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static net.sourceforge.pmd.util.CollectionUtil.any;\n+import static net.sourceforge.pmd.util.CollectionUtil.finish;\n+import static net.sourceforge.pmd.util.CollectionUtil.map;\n+import static net.sourceforge.pmd.util.CollectionUtil.toMutableList;\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collector;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+import net.sourceforge.pmd.internal.util.AssertionUtil;\n+import net.sourceforge.pmd.lang.rule.internal.GraphUtils.DotColor;\n+\n+/**\n+ * Indexes data of type {@code <V>} with keys of type {@code <K>}, where", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAzMjg2OA==", "bodyText": "Ok, as far as I understand, that is your solution for dealing with Abstract node types.... right?", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446032868", "createdAt": "2020-06-26T08:07:27Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/LatticeRelation.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.rule.internal;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static net.sourceforge.pmd.util.CollectionUtil.any;\n+import static net.sourceforge.pmd.util.CollectionUtil.finish;\n+import static net.sourceforge.pmd.util.CollectionUtil.map;\n+import static net.sourceforge.pmd.util.CollectionUtil.toMutableList;\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collector;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+import net.sourceforge.pmd.internal.util.AssertionUtil;\n+import net.sourceforge.pmd.lang.rule.internal.GraphUtils.DotColor;\n+\n+/**\n+ * Indexes data of type {@code <V>} with keys of type {@code <K>}, where", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAzMjQ0MA=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIyMjA1OA==", "bodyText": "Ok, as far as I understand, that is your solution for dealing with Abstract node types.... right?\n\nYes that's it.\nHonestly making it generic is easy and makes tests much more comprehensive and easier to write. This data structure is a kind of multimap where values are added at once to several keys, doing minimal work. So we can add Node values to several Class keys at once, just by knowing node.getClass(), without having to traverse all the supertypes for every instance. We also don't accumulate values for keys that won't be queried (those Class instances for which no rulechain rule has added a visit request).\nThe API is really simple I think, you just use put and get as if it was a regular map.", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446222058", "createdAt": "2020-06-26T14:34:18Z", "author": {"login": "oowekyala"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/rule/internal/LatticeRelation.java", "diffHunk": "@@ -0,0 +1,339 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.rule.internal;\n+\n+import static java.util.stream.Collectors.toSet;\n+import static net.sourceforge.pmd.util.CollectionUtil.any;\n+import static net.sourceforge.pmd.util.CollectionUtil.finish;\n+import static net.sourceforge.pmd.util.CollectionUtil.map;\n+import static net.sourceforge.pmd.util.CollectionUtil.toMutableList;\n+\n+import java.util.ArrayDeque;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collector;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+import net.sourceforge.pmd.internal.util.AssertionUtil;\n+import net.sourceforge.pmd.lang.rule.internal.GraphUtils.DotColor;\n+\n+/**\n+ * Indexes data of type {@code <V>} with keys of type {@code <K>}, where", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAzMjQ0MA=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTIwMzA5OnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/util/CollectionUtil.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODoxNzowNVrOGpX-Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDoyMjo1MVrOGpiz2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAzNzU0Nw==", "bodyText": "Another example of overly used generics... What is T, U, A ,C?... Maybe I'm just not that into streams...", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446037547", "createdAt": "2020-06-26T08:17:05Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/util/CollectionUtil.java", "diffHunk": "@@ -532,6 +554,94 @@ public static boolean isNotEmpty(Object[] items) {\n         return Collections.unmodifiableList(res);\n     }\n \n+    /**\n+     * Map each element of the given iterable with the given function,\n+     * and accumulates it into the collector.\n+     */\n+    public static <T, U, A, C> C map(Collector<? super U, A, ? extends C> collector,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIxNTEyOQ==", "bodyText": "I think this is just \"used generics\" rather than overused... It's not my fault that the Collector API uses 3 type parameters...\nU, A, C in that order correspond to the T, A, R type parameters of Collector:\n\nT - the type of input elements to the reduction operation\nA - the mutable accumulation type of the reduction operation (often hidden as an implementation detail)\nR - the result type of the reduction operation\n\nOn this method we have a source of T elements, a mapper from T to U, and a collector that accumulates a bunch of Us to produce a C, which is generally a collection of U.\nThe A is an implementation detail, when you make methods that return collectors, this is generally some wildcard to not expose it to clients. But when you use the collector to perform the collection operation, then you need to declare A to capture it. You don't need to know that to use methods that use collectors, but the implementation of the method has to capture it.\nIt takes some time to get used to the collector API but once you get it there's really nothing voodoo happening.\nConsider that this method is super reusable, you can do map(toSet(), listOfT, t -> t.getU()) and end up with a Set<U>. You can use any of the standard collectors in Collectors.  It's much better than writing one specialized map function for each kind of result type (mapToSet, mapToList, etc).", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446215129", "createdAt": "2020-06-26T14:22:51Z", "author": {"login": "oowekyala"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/util/CollectionUtil.java", "diffHunk": "@@ -532,6 +554,94 @@ public static boolean isNotEmpty(Object[] items) {\n         return Collections.unmodifiableList(res);\n     }\n \n+    /**\n+     * Map each element of the given iterable with the given function,\n+     * and accumulates it into the collector.\n+     */\n+    public static <T, U, A, C> C map(Collector<? super U, A, ? extends C> collector,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjAzNzU0Nw=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc3OTI0OTM1OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRulechainRule.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQwODozMTozOFrOGpYbQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNlQxNDoyNDo0OFrOGpi4hQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NDk5Mg==", "bodyText": "Maybe we can get rid of this class eventually?", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446044992", "createdAt": "2020-06-26T08:31:38Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRulechainRule.java", "diffHunk": "@@ -18,32 +19,25 @@\n  */\n public abstract class AbstractJavaRulechainRule extends AbstractJavaRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjIxNjMyNQ==", "bodyText": "Probably yes. But the fact that rules also implement the visitor interface is a problem for that, as the default visit method traverses the tree, which we want to avoid.", "url": "https://github.com/pmd/pmd/pull/2490#discussion_r446216325", "createdAt": "2020-06-26T14:24:48Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/AbstractJavaRulechainRule.java", "diffHunk": "@@ -18,32 +19,25 @@\n  */\n public abstract class AbstractJavaRulechainRule extends AbstractJavaRule {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjA0NDk5Mg=="}, "originalCommit": {"oid": "843d645d8735fb3b191f5845a37b1b235e6a33f9"}, "originalPosition": 15}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 408, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}