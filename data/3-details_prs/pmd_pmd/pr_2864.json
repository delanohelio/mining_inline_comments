{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4NDk0Mzc4", "number": 2864, "title": "[vf] Provide expression type information to Visualforce rules to avoid false positives", "bodyText": "Describe the PR\nFixes false positives for VfUnescapeEl\nAddresses the general issue raised in Issue 1092 [vf] Id fields considered unescaped and is related to Issue 237 [core] RFC: Analyzing embedded snippets from other languages\nThis PR removes false positives from expressions in apex tags found in Visualforce pages for VfUnescapeElRule. The specific use case raised in 1092 isn't currently reproducible and represents a false negative that will be fixed separately by @rmohan20.\nThe existing Visualforce rules don't have any information about the data types referenced in the Visualforce page. This results in false positives when attempting to identify expressions that are vulnerable to XSS attacks. The rules should not warn about XSS attacks when the expression refers to a type such as Integer or Boolean.\nThe VfExpressionTypeVisitor visits the Visualforce page and extracts the datatypes from Salesforce metadata. Data type information can come from either Apex classes or Object Fields. The Salesforce metadata is generally located in a sibling directory of the Visualforce directory. By default the code looks in directories relative to the Visualforce file to find the metadata. The conventional locations for the metadata are \"../classes\" and \"../objects\", the user can override this default with other directories if required.\nThis change is similar to some of the ideas presented in #237 but is tactically focused on Visualforce. This code could be the basis of a more general approach or could be modified to conform to a more general approach when one becomes available.\nThe significant differences from #237 are\n\nThe referenced entities aren't required to be part of the files under analysis\nSome of the referenced entities(Custom Fields) aren't languages covered by PMD\nThe logic is a post-parser step instead of being embedded in the parser. This code could be moved into the parser, but the rule allows some configuration which is currently tied to Rules and not parsers.\nThe information is not stored in the AST. This was an intentional decision because the same rule could be configured multiple different ways via a rule ref. These different configurations would result in different data which would conflict since all rules share the same AST.\n\nRelated issues\n#1092\n#237\nReady?\n\n Added unit tests for fixed bug/feature\n Passing all unit tests\n Complete build ./mvnw clean verify passes (checked automatically by travis)\n Added (in-code) documentation (if needed)", "createdAt": "2020-10-22T18:56:42Z", "url": "https://github.com/pmd/pmd/pull/2864", "merged": true, "mergeCommit": {"oid": "f775d7905bee6ea75de45163b0cc048490c91feb"}, "closed": true, "closedAt": "2020-12-11T08:57:42Z", "author": {"login": "jbartolotta-sfdc"}, "timelineItems": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdVGT2AgH2gAyNTA4NDk0Mzc4OmRkZjU1YzdmODExNWJhNzlhNTk3Y2FiZmQxZTYyOWFjMzgyMmRmMzI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdlB08ZAH2gAyNTA4NDk0Mzc4OjRlMDBjMjA0OTkxYjhhM2JiZmY5MDEyYjFkNmYyNjRlMTRmODE2NmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "ddf55c7f8115ba79a597cabfd1e629ac3822df32", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/ddf55c7f8115ba79a597cabfd1e629ac3822df32", "committedDate": "2020-10-22T18:30:45Z", "message": "Provide type information to Visualforce rules\n\nAddresses the general issue raised in https://github.com/pmd/pmd/issues/1092 This commit removes false positives from expressions in apex tags. The specific use case raised in 1092 isn't reproducible and represents a false negative that will be fixed separately.\n\nThe existing Visualforce rules don't have any information about the data types referenced in the Visualforce page. This results in false positives when attempting to identify expressions that are vulnerable to XSS attacks. The rules should not warn about XSS attacks when the expression refers to a type such as Integer or Boolean.\n\nThe VfExpressionTypeVisitor visits the Visualforce page and extracts the datatypes from Salesforce metadata. Data type information can come from either Apex classes or Object Fields. The Salesforce metadata is generally located in a sibling directory of the Visualforce directory. By default the code looks in directories relative to the Visualforce file to find the metadata. The conventional locations for the metadata are \"../classes\" and \"../objects\", the user can override this default with other directories if required."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MDI4ODcw", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-515028870", "createdAt": "2020-10-22T18:57:41Z", "commit": {"oid": "ddf55c7f8115ba79a597cabfd1e629ac3822df32"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxODo1Nzo0MVrOHmvmfQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMlQxOTowMjo1M1rOHmvyZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NzgzNw==", "bodyText": "Is this OK? The Visualforce visitor needs the ability to compile the Apex class.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510387837", "createdAt": "2020-10-22T18:57:41Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/pom.xml", "diffHunk": "@@ -77,6 +77,12 @@\n             <artifactId>pmd-core</artifactId>\n         </dependency>\n \n+        <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf55c7f8115ba79a597cabfd1e629ac3822df32"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4ODUwNQ==", "bodyText": "This should be abstract, I will fix.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510388505", "createdAt": "2020-10-22T18:58:54Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/rule/security/AbstractVfTypedElExpressionRule.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf.rule.security;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.lang.vf.ExpressionType;\n+import net.sourceforge.pmd.lang.vf.VfExpressionTypeVisitor;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n+import net.sourceforge.pmd.lang.vf.rule.AbstractVfRule;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+\n+/**\n+ * Represents a rule where the {@link net.sourceforge.pmd.lang.vf.ast.ASTIdentifier} nodes are enhanced with the\n+ * node's {@link ExpressionType}. This is achieved by processing metadata files referenced by the Visualforce page.\n+ */\n+class AbstractVfTypedElExpressionRule extends AbstractVfRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf55c7f8115ba79a597cabfd1e629ac3822df32"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4OTA4OQ==", "bodyText": "This is the code that fixes the false positives for this rule.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510389089", "createdAt": "2020-10-22T18:59:46Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/rule/security/VfUnescapeElRule.java", "diffHunk": "@@ -412,6 +411,11 @@ private boolean doesElContainAnyUnescapedIdentifiers(final ASTElExpression elExp\n             final List<ASTIdentifier> ids = expr.findChildrenOfType(ASTIdentifier.class);\n \n             for (final ASTIdentifier id : ids) {\n+                ExpressionType expressionType = getExpressionType(id);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf55c7f8115ba79a597cabfd1e629ac3822df32"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM5MDg4NQ==", "bodyText": "Added methods that run rules against files found in the test/resources/ directory. I didn't add the runRule method to the base class because the use case is very specific to this change and I didn't want to confuse others that might be writing rule tests.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510390885", "createdAt": "2020-10-22T19:02:53Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/rule/security/VfUnescapeElTest.java", "diffHunk": "@@ -4,8 +4,162 @@\n \n package net.sourceforge.pmd.lang.vf.rule.security;\n \n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+import java.io.FileNotFoundException;\n+import java.io.FileReader;\n+import java.io.IOException;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import net.sourceforge.pmd.PMD;\n+import net.sourceforge.pmd.PMDException;\n+import net.sourceforge.pmd.Report;\n+import net.sourceforge.pmd.Rule;\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.RuleSet;\n+import net.sourceforge.pmd.RuleSets;\n+import net.sourceforge.pmd.RuleViolation;\n+import net.sourceforge.pmd.RulesetsFactoryUtils;\n+import net.sourceforge.pmd.lang.LanguageRegistry;\n+import net.sourceforge.pmd.lang.LanguageVersion;\n+import net.sourceforge.pmd.lang.Parser;\n+import net.sourceforge.pmd.lang.ParserOptions;\n+import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.vf.VFTestContstants;\n+import net.sourceforge.pmd.lang.vf.VfLanguageModule;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n import net.sourceforge.pmd.testframework.PmdRuleTst;\n \n public class VfUnescapeElTest extends PmdRuleTst {\n-    // no additional unit tests\n+    public static final String EXPECTED_RULE_MESSAGE = \"Avoid unescaped user controlled content in EL\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ddf55c7f8115ba79a597cabfd1e629ac3822df32"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef9e350fd53e3f6f00da34659ec8433ce398f9b6", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/ef9e350fd53e3f6f00da34659ec8433ce398f9b6", "committedDate": "2020-10-22T19:11:44Z", "message": "Mark AbstractVfTypedElExpressionRule as abstract"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE1MTk5ODQx", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-515199841", "createdAt": "2020-10-23T00:06:01Z", "commit": {"oid": "ef9e350fd53e3f6f00da34659ec8433ce398f9b6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDowNjowMlrOHm4Deg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yM1QwMDowNjowMlrOHm4Deg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDUyNjMzMA==", "bodyText": "It occurs to me that this should be renamed to IdentifierType. I will rename it.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r510526330", "createdAt": "2020-10-23T00:06:02Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ExpressionType.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.util.Arrays;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import apex.jorje.semantic.symbol.type.BasicType;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Sets;\n+\n+/**\n+ * Represents all data types that can be referenced from a Visualforce page. This enum consolidates the data types\n+ * available to CustomFields and Apex. It uses the naming convention of CustomFields.\n+ *\n+ * See https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_field_types.htm#meta_type_fieldtype\n+ */\n+public enum ExpressionType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef9e350fd53e3f6f00da34659ec8433ce398f9b6"}, "originalPosition": 24}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/f70b2e44fca1b364f14faa52a2eb456f7f2ecc76", "committedDate": "2020-10-27T23:23:14Z", "message": "Rename ExpressionType, remove google collections\n\nRenamed ExpressionType to IdentifierType since this is more accurate.\n\nRemoved usage of google.collect classes that were causing UnsupportedClassVersionError exception in the Travis CI run."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NjE0MzQ2", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-518614346", "createdAt": "2020-10-28T12:39:00Z", "commit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMjozOTowMFrOHpn-YA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxMzoyMjoxNlrOHppsfA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQwODYwOA==", "bodyText": "I think, we can do this. I assume, that apex and visualforce users are the same and anyway using at least java8. We'll need to add this potential breaking change to the release notes of course.\nWe might also consider to use java8 for the pmd-visualforce module already (like we do for pmd-apex).", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513408608", "createdAt": "2020-10-28T12:39:00Z", "author": {"login": "adangel"}, "path": "pmd-visualforce/pom.xml", "diffHunk": "@@ -77,6 +77,12 @@\n             <artifactId>pmd-core</artifactId>\n         </dependency>\n \n+        <dependency>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDM4NzgzNw=="}, "originalCommit": {"oid": "ddf55c7f8115ba79a597cabfd1e629ac3822df32"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyMTMwMw==", "bodyText": "VfExpressionTypeVisitor and this class are the API for custom rule implementers to use this new feature in own rules.\nBecause of that, I think, this abstract class will need to be public as well.\nOr the other way round: If we want to hide this feature a little for the beginning, we need to annotate VfExpressionTypeVisitor as @Experimental.\nI'm not sure, whether we should provide this as an abstract class and force using it through inheritance, which limits what the custom rule can inherit itself... (e.g. you cannot use this feature with an own rule inheritance hierarchy...).\nMaybe we can find an alternative way.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513421303", "createdAt": "2020-10-28T12:59:24Z", "author": {"login": "adangel"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/rule/security/AbstractVfTypedElExpressionRule.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf.rule.security;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.lang.vf.IdentifierType;\n+import net.sourceforge.pmd.lang.vf.VfExpressionTypeVisitor;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n+import net.sourceforge.pmd.lang.vf.rule.AbstractVfRule;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+\n+/**\n+ * Represents a rule where the {@link net.sourceforge.pmd.lang.vf.ast.ASTIdentifier} nodes are enhanced with the\n+ * node's {@link IdentifierType}. This is achieved by processing metadata files referenced by the Visualforce page.\n+ */\n+abstract class AbstractVfTypedElExpressionRule extends AbstractVfRule {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyODQwOA==", "bodyText": "I think, we should fix/improve AbstractRuleSetFactoryTest. I guess, both apex and visualforce rules are now tested, which is unnecessary.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513428408", "createdAt": "2020-10-28T13:10:24Z", "author": {"login": "adangel"}, "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/RuleSetFactoryTest.java", "diffHunk": "@@ -5,7 +5,13 @@\n package net.sourceforge.pmd.lang.vf;\n \n import net.sourceforge.pmd.AbstractRuleSetFactoryTest;\n+import net.sourceforge.pmd.lang.apex.rule.ApexXPathRule;\n \n public class RuleSetFactoryTest extends AbstractRuleSetFactoryTest {\n-    // no additional tests\n+    public RuleSetFactoryTest() {\n+        super();\n+        // Copied from net.sourceforge.pmd.lang.apex.RuleSetFactoryTest\n+        // Apex rules are found in the classpath because this module has a dependency on pmd-apex", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyOTI4Ng==", "bodyText": "The usual pattern is constant holding classes is to create a final class with a private constructor instead of an abstract class...", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513429286", "createdAt": "2020-10-28T13:11:43Z", "author": {"login": "adangel"}, "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/VFTestContstants.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class VFTestContstants {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQzNjc5Ng==", "bodyText": "I'd like to have the test resources in a more specific directory. If you just look at the directory listing now (e.g. \"src/test/resources/net/sourceforge/pmd/lang/vf/metadata-sfdx/pages/StandardAccount.page\") you have no clue, what this is for (in which unit test or rule test this is used, etc.). Maybe we keep adding files to these directories for multiple different rules (because there are already pages, so we add another page in the same directory, but test something completely independent)... IMHO we should avoid this. I'd prefer a own directory at least per test class (and the package/directory name gives a hint where the test class is and its name).", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513436796", "createdAt": "2020-10-28T13:22:16Z", "author": {"login": "adangel"}, "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/VFTestContstants.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.io.File;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public abstract class VFTestContstants {\n+    private static final Path ROOT_PATH = Paths.get(\"src\", \"test\", \"resources\", \"net\", \"sourceforge\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4MjQxODAy", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-518241802", "createdAt": "2020-10-28T00:21:08Z", "commit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQwMDoyMTowOFrOHpVl-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNTo1OTo1MFrOHpxeSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzEwNzQ1MA==", "bodyText": "You don't need concurrent maps since they are only modified during initialization.\nIn fact, maybe we could make a new rule for that, something like a \"StatefulEnum\" rule, that flags enums that look like they have mutable state (setters, concurrent map implementations)", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513107450", "createdAt": "2020-10-28T00:21:08Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/IdentifierType.java", "diffHunk": "@@ -0,0 +1,127 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.logging.Logger;\n+\n+import apex.jorje.semantic.symbol.type.BasicType;\n+\n+/**\n+ * Represents all data types that can be referenced from a Visualforce page. This enum consolidates the data types\n+ * available to CustomFields and Apex. It uses the naming convention of CustomFields.\n+ *\n+ * See https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_field_types.htm#meta_type_fieldtype\n+ */\n+public enum IdentifierType {\n+    AutoNumber(false),\n+    Checkbox(false, BasicType.BOOLEAN),\n+    Currency(false, BasicType.CURRENCY),\n+    Date(false, BasicType.DATE),\n+    DateTime(false, BasicType.DATE_TIME),\n+    Email(false),\n+    EncryptedText(true),\n+    ExternalLookup(true),\n+    File(false),\n+    Hierarchy(false),\n+    Html(true),\n+    IndirectLookup(false),\n+    Location(false),\n+    LongTextArea(true),\n+    Lookup(false, BasicType.ID),\n+    MasterDetail(false),\n+    MetadataRelationship(false),\n+    MultiselectPicklist(true),\n+    Note(true),\n+    Number(false, BasicType.DECIMAL, BasicType.DOUBLE, BasicType.INTEGER, BasicType.LONG),\n+    Percent(false),\n+    Phone(false),\n+    Picklist(true),\n+    Summary(false),\n+    Text(true, BasicType.STRING),\n+    TextArea(true),\n+    Time(false, BasicType.TIME),\n+    Url(false),\n+    Unknown(true);\n+\n+    private static final Logger LOGGER = Logger.getLogger(IdentifierType.class.getName());\n+\n+\n+    /**\n+     * True if this field is an XSS risk\n+     */\n+    public final boolean requiresEscaping;\n+\n+    /**\n+     * The set of {@link BasicType}s that map to this type. Multiple types can map to a single instance of this enum.\n+     */\n+    private final Set<BasicType> basicTypes;\n+\n+    /**\n+     * A case insensitive map of the enum name to its instance. The case metadata is not guaranteed to have the correct\n+     * case.\n+     */\n+    private static final Map<String, IdentifierType> CASE_INSENSITIVE_MAP = new ConcurrentHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU2NDIzMw==", "bodyText": "These look like new candidates for #2518. I think they're global to the analysed project, and should not be configured on a rule per rule basis (like the auxclasspath for java). This way the info could be added to the ast", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513564233", "createdAt": "2020-10-28T15:59:50Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/rule/security/AbstractVfTypedElExpressionRule.java", "diffHunk": "@@ -0,0 +1,89 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf.rule.security;\n+\n+import java.io.File;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.lang.vf.IdentifierType;\n+import net.sourceforge.pmd.lang.vf.VfExpressionTypeVisitor;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n+import net.sourceforge.pmd.lang.vf.rule.AbstractVfRule;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+\n+/**\n+ * Represents a rule where the {@link net.sourceforge.pmd.lang.vf.ast.ASTIdentifier} nodes are enhanced with the\n+ * node's {@link IdentifierType}. This is achieved by processing metadata files referenced by the Visualforce page.\n+ */\n+abstract class AbstractVfTypedElExpressionRule extends AbstractVfRule {\n+    /**\n+     * Directory that contains Apex classes that may be referenced from a Visualforce page.\n+     */\n+    private static final PropertyDescriptor<List<String>> APEX_DIRECTORIES_DESCRIPTOR =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f70b2e44fca1b364f14faa52a2eb456f7f2ecc76"}, "originalPosition": 30}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6f7bebcecd5bf976f0ba5bc48a72775bfaf88068", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/6f7bebcecd5bf976f0ba5bc48a72775bfaf88068", "committedDate": "2020-10-28T22:10:26Z", "message": "Configure visualforce to require Java 8\n\npmd-visualforce depends on pmd-apex. pmd-apex relies on Java 8. This change configures pmd-visualforce to also require Java 8.\n\nThis is a breaking change that will need to be documented."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MTI0NDM5", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-519124439", "createdAt": "2020-10-28T22:13:37Z", "commit": {"oid": "6f7bebcecd5bf976f0ba5bc48a72775bfaf88068"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjoxMzozN1rOHp_drw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQyMjoxMzozN1rOHp_drw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc5MzQ1NQ==", "bodyText": "Moved to the jdk8-modules node.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r513793455", "createdAt": "2020-10-28T22:13:37Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-dist/pom.xml", "diffHunk": "@@ -148,11 +148,6 @@\n             <artifactId>pmd-jsp</artifactId>\n             <version>${project.version}</version>\n         </dependency>\n-        <dependency>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6f7bebcecd5bf976f0ba5bc48a72775bfaf88068"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ba2e91b3a0857d67e47ffce6b9e6c18200558330", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/ba2e91b3a0857d67e47ffce6b9e6c18200558330", "committedDate": "2020-10-30T00:22:35Z", "message": "Exclude languages in AbstractRuleSetFactoryTest\n\nAllow subclasses of AbstractRuleSetFactoryTest to filter out languages\nthat show up in the classpath but should not be tested.\n\nChange VFTestContstants to final instead of abstract."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "06a6b8573673d5664b7bb97c71415d3076b994f8", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/06a6b8573673d5664b7bb97c71415d3076b994f8", "committedDate": "2020-11-11T04:58:04Z", "message": "WIP"}, "afterCommit": {"oid": "ba2e91b3a0857d67e47ffce6b9e6c18200558330", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/ba2e91b3a0857d67e47ffce6b9e6c18200558330", "committedDate": "2020-10-30T00:22:35Z", "message": "Exclude languages in AbstractRuleSetFactoryTest\n\nAllow subclasses of AbstractRuleSetFactoryTest to filter out languages\nthat show up in the classpath but should not be tested.\n\nChange VFTestContstants to final instead of abstract."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7", "committedDate": "2020-11-12T18:15:04Z", "message": "Store type information in AST instead of map\n\nStore the IdentifierType on ASTIdentifier node instead of in a separate map.\n\nUse the existing TypeResolution pattern to configure the visitor instead deriving from an abstract rule.\n\nChanged ParserOptions to extend AbstractPropertySource with the ability to override the defaults via environment variables."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0348b2c0d2ffefb08ea0b65a452d3746592771d8", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/0348b2c0d2ffefb08ea0b65a452d3746592771d8", "committedDate": "2020-11-12T18:39:10Z", "message": "Merge branch 'master' into issue1092-vf-escape-false-positives"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NDIwNzk0", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-529420794", "createdAt": "2020-11-12T19:24:22Z", "commit": {"oid": "0348b2c0d2ffefb08ea0b65a452d3746592771d8"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOToyNDoyMlrOHyKPkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQxOTozMzoxNlrOHyK7BA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM1ODY3NA==", "bodyText": "Added equals and hashCode based on the ParserOptions JavaDoc comment.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522358674", "createdAt": "2020-11-12T19:24:22Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/properties/AbstractPropertySource.java", "diffHunk": "@@ -252,4 +253,22 @@ public String dysfunctionReason() {\n     private <T> String errorForPropCapture(PropertyDescriptor<T> descriptor) {\n         return descriptor.errorFor(getProperty(descriptor));\n     }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0348b2c0d2ffefb08ea0b65a452d3746592771d8"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2MzgyMg==", "bodyText": "I was undecided if it was better to declare this here or in VfParserOptions. I chose here because it is closer to its usage.\nWhere should I add documentation for these new properties and the fact that they can be set via environment variables?", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522363822", "createdAt": "2020-11-12T19:28:25Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfExpressionTypeVisitor.java", "diffHunk": "@@ -4,39 +4,69 @@\n \n package net.sourceforge.pmd.lang.vf;\n \n+import java.io.File;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.logging.Logger;\n \n+import net.sourceforge.pmd.lang.ast.AbstractTokenManager;\n import net.sourceforge.pmd.lang.vf.ast.ASTAttribute;\n import net.sourceforge.pmd.lang.vf.ast.ASTAttributeValue;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n import net.sourceforge.pmd.lang.vf.ast.ASTDotExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTElExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTElement;\n import net.sourceforge.pmd.lang.vf.ast.ASTExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n import net.sourceforge.pmd.lang.vf.ast.ASTText;\n import net.sourceforge.pmd.lang.vf.ast.VfParserVisitorAdapter;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+import net.sourceforge.pmd.properties.PropertySource;\n \n /**\n  * Visits {@link ASTElExpression} nodes and stores type information for all {@link ASTIdentifier} child nodes.\n  */\n public class VfExpressionTypeVisitor extends VfParserVisitorAdapter {\n     private static final Logger LOGGER = Logger.getLogger(VfExpressionTypeVisitor.class.getName());\n \n+    static final List<String> DEFAULT_APEX_DIRECTORIES = Collections.singletonList(\"..\" + File.separator + \"classes\");\n+    static final List<String> DEFAULT_OBJECT_DIRECTORIES = Collections.singletonList(\"..\" + File.separator + \"objects\");\n+\n+    /**\n+     * Directory that contains Apex classes that may be referenced from a Visualforce page.\n+     */\n+    public static final PropertyDescriptor<List<String>> APEX_DIRECTORIES_DESCRIPTOR =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2NTg0NQ==", "bodyText": "This is where it is stored on the AST.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522365845", "createdAt": "2020-11-12T19:29:51Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfExpressionTypeVisitor.java", "diffHunk": "@@ -139,7 +169,7 @@ public Object visit(ASTElExpression node, Object data) {\n             }\n \n             if (type != null) {\n-                identifierTypes.put(entry.getKey(), type);\n+                entry.getKey().setIdentifierType(type);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7"}, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2ODE0OA==", "bodyText": "This pattern seemed like the correct way to invoke the visitor. I hadn't noticed it in my previous commit.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522368148", "createdAt": "2020-11-12T19:31:24Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfHandler.java", "diffHunk": "@@ -28,6 +29,23 @@ public Parser getParser(ParserOptions parserOptions) {\n         return new VfParser(parserOptions);\n     }\n \n+    @Override\n+    public VisitorStarter getTypeResolutionFacade(ClassLoader classLoader) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2OTc5Ng==", "bodyText": "Added more formal structure to the test files.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522369796", "createdAt": "2020-11-12T19:33:16Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/test/java/net/sourceforge/pmd/lang/vf/VFTestUtils.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+\n+public final class VFTestUtils {\n+    /**\n+     * Salesforce metadata is stored in two different formats, the newer sfdx form and the older mdapi format. Used to\n+     * locate metadata on the file system during unit tests.\n+     */\n+    public enum MetadataFormat {\n+        SFDX(\"sfdx\"),\n+        MDAPI(\"mdapi\");\n+\n+        public final String directoryName;\n+\n+        MetadataFormat(String directoryName) {\n+            this.directoryName = directoryName;\n+        }\n+    }\n+\n+    /**\n+     * Represents the metadata types that are referenced from unit tests. Used to locate metadata on the file system\n+     * during unit tests.\n+     */\n+    public enum MetadataType {\n+        Apex(\"classes\"),\n+        Objects(\"objects\"),\n+        Vf(\"pages\");\n+\n+        public final String directoryName;\n+\n+        MetadataType(String directoryName) {\n+            this.directoryName = directoryName;\n+        }\n+    }\n+\n+    /**\n+     * @return the path of the directory that matches the given parameters. The directory path is constructed using the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI5NTgwMTU0", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-529580154", "createdAt": "2020-11-12T23:21:10Z", "commit": {"oid": "0348b2c0d2ffefb08ea0b65a452d3746592771d8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzoyMToxMVrOHyStpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xMlQyMzoyMToxMVrOHyStpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ5NzQ0NQ==", "bodyText": "I just found ParserOptionsTest in the pmd-test project I will move these tests over. This class is not currently running as a unit test because it is in the src/main hierarchy. All of the other classes in pmd-test/src/main are abstract classes meant to be extended. ParserOptionsTest#verifyOptionsEqualsHashcode is referenced from XmlParserOptionsTest\nI will refactor #verifyOptionsEqualsHashcode into a utils class and move the test methods over to pmd-test so that they are run.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r522497445", "createdAt": "2020-11-12T23:21:11Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-core/src/test/java/net/sourceforge/pmd/lang/ParserOptionsTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0348b2c0d2ffefb08ea0b65a452d3746592771d8"}, "originalPosition": 1}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/e1c42a10ec32403cc1ccae82bce4c420694f3e2c", "committedDate": "2020-11-13T04:13:19Z", "message": "Move visitor to VfParser#parse\n\nLanguageVersionHandler#getTypeResolutionFacade is deprecated. Moved the VfExpressionTypeVisitor creation and execution to VfParser#parse instead.\n\nParsingOptionsTest located in pmd-test wasn't running previously because it was in the src/main hierarchy. Moved this test into the src/test hierarchy and consolidated the methods from the\nsimilarly named class from pmd-core."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTMwNTY5NjM1", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-530569635", "createdAt": "2020-11-14T10:37:01Z", "commit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c"}, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQxMDozNzowMVrOHzKGkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xNFQxMTowOTo0OVrOHzKRxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNDk0NA==", "bodyText": "This comment should be moved to the getter, otherwise the info is not available to users of the API\nAlso since IdentifierType is an enum the getter will also be available as an XPath attribute. Maybe the comment should say as much", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523404944", "createdAt": "2020-11-14T10:37:01Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ast/ASTIdentifier.java", "diffHunk": "@@ -5,8 +5,14 @@\n package net.sourceforge.pmd.lang.vf.ast;\n \n import net.sourceforge.pmd.annotation.InternalApi;\n+import net.sourceforge.pmd.lang.vf.IdentifierType;\n \n public class ASTIdentifier extends AbstractVFNode {\n+    /**\n+     * The data type that this identifier refers to. May be null.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNTQ0NA==", "bodyText": "This looks like a partial duplicate of", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523405444", "createdAt": "2020-11-14T10:42:30Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ApexClassPropertyTypes.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.io.BufferedReader;\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+\n+import net.sourceforge.pmd.lang.LanguageRegistry;\n+import net.sourceforge.pmd.lang.LanguageVersion;\n+import net.sourceforge.pmd.lang.Parser;\n+import net.sourceforge.pmd.lang.ParserOptions;\n+import net.sourceforge.pmd.lang.apex.ApexLanguageModule;\n+import net.sourceforge.pmd.lang.apex.ast.ApexNode;\n+import net.sourceforge.pmd.lang.ast.Node;\n+\n+import apex.jorje.semantic.symbol.type.BasicType;\n+\n+/**\n+ * Responsible for storing a mapping of Apex Class properties that can be referenced from Visualforce to the type of the\n+ * property.\n+ */\n+class ApexClassPropertyTypes {\n+    private static final Logger LOGGER = Logger.getLogger(ApexClassPropertyTypes.class.getName());\n+    private static final String APEX_CLASS_FILE_SUFFIX = \".cls\";\n+\n+    private final Map<String, IdentifierType> variableNameToVariableType;\n+    private final Set<String> variableNameProcessed;\n+\n+    ApexClassPropertyTypes() {\n+        this.variableNameToVariableType = new HashMap<>();\n+        this.variableNameProcessed = new HashSet<>();\n+    }\n+\n+    /**\n+     * Looks in {@code apexDirectories} for an Apex property identified by {@code expression}.\n+     *\n+     * @return the IdentifierType for the property represented by {@code expression} or null if not found.\n+     */\n+    public IdentifierType getVariableType(String expression, String vfFileName, List<String> apexDirectories) {\n+        String lowerExpression = expression.toLowerCase(Locale.ROOT);\n+        if (variableNameToVariableType.containsKey(lowerExpression)) {\n+            // The expression has been previously retrieved\n+            return variableNameToVariableType.get(lowerExpression);\n+        } else if (variableNameProcessed.contains(lowerExpression)) {\n+            // The expression has been previously requested, but was not found\n+            return null;\n+        } else {\n+            String[] parts = expression.split(\"\\\\.\");\n+            if (parts.length >= 2) {\n+                // Load the class and parse it\n+                String className = parts[0];\n+\n+                Path vfFilePath = Paths.get(vfFileName);\n+                for (String apexDirectory : apexDirectories) {\n+                    Path candidateDirectory;\n+                    if (Paths.get(apexDirectory).isAbsolute()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNTQ1Mw==", "bodyText": "this", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523405453", "createdAt": "2020-11-14T10:42:37Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ObjectFieldTypes.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Responsible for storing a mapping of Fields that can be referenced from Visualforce to the type of the field.\n+ */\n+class ObjectFieldTypes {\n+    private static final Logger LOGGER = Logger.getLogger(ObjectFieldTypes.class.getName());\n+\n+    public static final String CUSTOM_OBJECT_SUFFIX = \"__c\";\n+    private static final String FIELDS_DIRECTORY = \"fields\";\n+    private static final String MDAPI_OBJECT_FILE_SUFFIX = \".object\";\n+    private static final String SFDX_FIELD_FILE_SUFFIX = \".field-meta.xml\";\n+\n+    private static final Map<String, IdentifierType> STANDARD_FIELD_TYPES;\n+\n+    static {\n+        STANDARD_FIELD_TYPES = new HashMap<>();\n+        STANDARD_FIELD_TYPES.put(\"createdbyid\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"createddate\", IdentifierType.DateTime);\n+        STANDARD_FIELD_TYPES.put(\"id\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"isdeleted\", IdentifierType.Checkbox);\n+        STANDARD_FIELD_TYPES.put(\"lastmodifiedbyid\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"lastmodifieddate\", IdentifierType.DateTime);\n+        STANDARD_FIELD_TYPES.put(\"systemmodstamp\", IdentifierType.DateTime);\n+    }\n+\n+    /**\n+     * Cache of lowercase variable names to the variable type declared in the field's metadata file.\n+     */\n+    private final Map<String, IdentifierType> variableNameToVariableType;\n+\n+    /**\n+     * Keep track of which variables were already processed. Avoid processing if a page repeatedly asks for an entry\n+     * which we haven't previously found.\n+     */\n+    private final Set<String> variableNameProcessed;\n+\n+    /**\n+     * Keep track of which \".object\" files have already been processed. All fields are processed at once. If an object\n+     * file has been processed\n+     */\n+    private final Set<String> objectFileProcessed;\n+\n+    // XML Parsing objects\n+    private final DocumentBuilder documentBuilder;\n+    private final XPathExpression customObjectFieldsExpression;\n+    private final XPathExpression customFieldFullNameExpression;\n+    private final XPathExpression customFieldTypeExpression;\n+    private final XPathExpression sfdxCustomFieldFullNameExpression;\n+    private final XPathExpression sfdxCustomFieldTypeExpression;\n+\n+    ObjectFieldTypes() {\n+        this.variableNameToVariableType = new HashMap<>();\n+        this.variableNameProcessed = new HashSet<>();\n+        this.objectFileProcessed = new HashSet<>();\n+\n+        try {\n+            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+            documentBuilderFactory.setNamespaceAware(false);\n+            documentBuilderFactory.setValidating(false);\n+            documentBuilderFactory.setIgnoringComments(true);\n+            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n+            documentBuilderFactory.setExpandEntityReferences(false);\n+            documentBuilderFactory.setCoalescing(false);\n+            documentBuilderFactory.setXIncludeAware(false);\n+            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+        } catch (ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            XPath xPath = XPathFactory.newInstance().newXPath();\n+            this.customObjectFieldsExpression = xPath.compile(\"/CustomObject/fields\");\n+            this.customFieldFullNameExpression = xPath.compile(\"fullName/text()\");\n+            this.customFieldTypeExpression = xPath.compile(\"type/text()\");\n+            this.sfdxCustomFieldFullNameExpression = xPath.compile(\"/CustomField/fullName/text()\");\n+            this.sfdxCustomFieldTypeExpression = xPath.compile(\"/CustomField/type/text()\");\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Looks in {@code objectsDirectories} for a custom field identified by {@code expression}.\n+     *\n+     * @return the IdentifierType for the field represented by {@code expression} or null the custom field isn't found.\n+     */\n+    public IdentifierType getVariableType(String expression, String vfFileName, List<String> objectsDirectories) {\n+        String lowerExpression = expression.toLowerCase(Locale.ROOT);\n+\n+        if (variableNameToVariableType.containsKey(lowerExpression)) {\n+            // The expression has been previously retrieved\n+            return variableNameToVariableType.get(lowerExpression);\n+        } else if (variableNameProcessed.contains(lowerExpression)) {\n+            // The expression has been previously requested, but was not found\n+            return null;\n+        } else {\n+            // The expression should be in the form <objectName>.<fieldName>\n+            String[] parts = expression.split(\"\\\\.\");\n+            if (parts.length == 1) {\n+                throw new RuntimeException(\"Malformed identifier: \" + expression);\n+            } else if (parts.length == 2) {\n+                String objectName = parts[0];\n+                String fieldName = parts[1];\n+\n+                addStandardFields(objectName);\n+\n+                // Attempt to find a metadata file that contains the custom field. The information will be located in a\n+                // file located at <objectDirectory>/<objectName>.object or in an file located at\n+                // <objectDirectory>/<objectName>/fields/<fieldName>.field-meta.xml. The list of object directories\n+                // defaults to the [<vfFileName>/../objects] but can be overridden by the user.\n+                Path vfFilePath = Paths.get(vfFileName);\n+                for (String objectsDirectory : objectsDirectories) {\n+                    Path candidateDirectory;\n+                    if (Paths.get(objectsDirectory).isAbsolute()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c"}, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNjExMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        } catch (Exception e) {\n          \n          \n            \n                        } catch (IOException | XPathExpressionException | SAXException e) {\n          \n      \n    \n    \n  \n\nOtherwise you'll wrap your runtime exceptions several times. (i just noticed, you'd need a new import for this)\nAlso it would be nice to add some context to the exception. You can use ContextedRuntimeException like so:\nnew ContextedRuntimeException(e).addContextValue(\"object\", customObjectName)\nand add as much relevant info as you want.\nThis applies to more places and is maybe out of the scope of the review. Fix if you want.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523406110", "createdAt": "2020-11-14T10:50:06Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ObjectFieldTypes.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.xpath.XPath;\n+import javax.xml.xpath.XPathConstants;\n+import javax.xml.xpath.XPathExpression;\n+import javax.xml.xpath.XPathExpressionException;\n+import javax.xml.xpath.XPathFactory;\n+\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+\n+/**\n+ * Responsible for storing a mapping of Fields that can be referenced from Visualforce to the type of the field.\n+ */\n+class ObjectFieldTypes {\n+    private static final Logger LOGGER = Logger.getLogger(ObjectFieldTypes.class.getName());\n+\n+    public static final String CUSTOM_OBJECT_SUFFIX = \"__c\";\n+    private static final String FIELDS_DIRECTORY = \"fields\";\n+    private static final String MDAPI_OBJECT_FILE_SUFFIX = \".object\";\n+    private static final String SFDX_FIELD_FILE_SUFFIX = \".field-meta.xml\";\n+\n+    private static final Map<String, IdentifierType> STANDARD_FIELD_TYPES;\n+\n+    static {\n+        STANDARD_FIELD_TYPES = new HashMap<>();\n+        STANDARD_FIELD_TYPES.put(\"createdbyid\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"createddate\", IdentifierType.DateTime);\n+        STANDARD_FIELD_TYPES.put(\"id\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"isdeleted\", IdentifierType.Checkbox);\n+        STANDARD_FIELD_TYPES.put(\"lastmodifiedbyid\", IdentifierType.Lookup);\n+        STANDARD_FIELD_TYPES.put(\"lastmodifieddate\", IdentifierType.DateTime);\n+        STANDARD_FIELD_TYPES.put(\"systemmodstamp\", IdentifierType.DateTime);\n+    }\n+\n+    /**\n+     * Cache of lowercase variable names to the variable type declared in the field's metadata file.\n+     */\n+    private final Map<String, IdentifierType> variableNameToVariableType;\n+\n+    /**\n+     * Keep track of which variables were already processed. Avoid processing if a page repeatedly asks for an entry\n+     * which we haven't previously found.\n+     */\n+    private final Set<String> variableNameProcessed;\n+\n+    /**\n+     * Keep track of which \".object\" files have already been processed. All fields are processed at once. If an object\n+     * file has been processed\n+     */\n+    private final Set<String> objectFileProcessed;\n+\n+    // XML Parsing objects\n+    private final DocumentBuilder documentBuilder;\n+    private final XPathExpression customObjectFieldsExpression;\n+    private final XPathExpression customFieldFullNameExpression;\n+    private final XPathExpression customFieldTypeExpression;\n+    private final XPathExpression sfdxCustomFieldFullNameExpression;\n+    private final XPathExpression sfdxCustomFieldTypeExpression;\n+\n+    ObjectFieldTypes() {\n+        this.variableNameToVariableType = new HashMap<>();\n+        this.variableNameProcessed = new HashSet<>();\n+        this.objectFileProcessed = new HashSet<>();\n+\n+        try {\n+            DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+            documentBuilderFactory.setNamespaceAware(false);\n+            documentBuilderFactory.setValidating(false);\n+            documentBuilderFactory.setIgnoringComments(true);\n+            documentBuilderFactory.setIgnoringElementContentWhitespace(true);\n+            documentBuilderFactory.setExpandEntityReferences(false);\n+            documentBuilderFactory.setCoalescing(false);\n+            documentBuilderFactory.setXIncludeAware(false);\n+            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            documentBuilderFactory.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n+            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n+        } catch (ParserConfigurationException e) {\n+            throw new RuntimeException(e);\n+        }\n+\n+        try {\n+            XPath xPath = XPathFactory.newInstance().newXPath();\n+            this.customObjectFieldsExpression = xPath.compile(\"/CustomObject/fields\");\n+            this.customFieldFullNameExpression = xPath.compile(\"fullName/text()\");\n+            this.customFieldTypeExpression = xPath.compile(\"type/text()\");\n+            this.sfdxCustomFieldFullNameExpression = xPath.compile(\"/CustomField/fullName/text()\");\n+            this.sfdxCustomFieldTypeExpression = xPath.compile(\"/CustomField/type/text()\");\n+        } catch (XPathExpressionException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Looks in {@code objectsDirectories} for a custom field identified by {@code expression}.\n+     *\n+     * @return the IdentifierType for the field represented by {@code expression} or null the custom field isn't found.\n+     */\n+    public IdentifierType getVariableType(String expression, String vfFileName, List<String> objectsDirectories) {\n+        String lowerExpression = expression.toLowerCase(Locale.ROOT);\n+\n+        if (variableNameToVariableType.containsKey(lowerExpression)) {\n+            // The expression has been previously retrieved\n+            return variableNameToVariableType.get(lowerExpression);\n+        } else if (variableNameProcessed.contains(lowerExpression)) {\n+            // The expression has been previously requested, but was not found\n+            return null;\n+        } else {\n+            // The expression should be in the form <objectName>.<fieldName>\n+            String[] parts = expression.split(\"\\\\.\");\n+            if (parts.length == 1) {\n+                throw new RuntimeException(\"Malformed identifier: \" + expression);\n+            } else if (parts.length == 2) {\n+                String objectName = parts[0];\n+                String fieldName = parts[1];\n+\n+                addStandardFields(objectName);\n+\n+                // Attempt to find a metadata file that contains the custom field. The information will be located in a\n+                // file located at <objectDirectory>/<objectName>.object or in an file located at\n+                // <objectDirectory>/<objectName>/fields/<fieldName>.field-meta.xml. The list of object directories\n+                // defaults to the [<vfFileName>/../objects] but can be overridden by the user.\n+                Path vfFilePath = Paths.get(vfFileName);\n+                for (String objectsDirectory : objectsDirectories) {\n+                    Path candidateDirectory;\n+                    if (Paths.get(objectsDirectory).isAbsolute()) {\n+                        candidateDirectory = Paths.get(objectsDirectory);\n+                    } else {\n+                        candidateDirectory = vfFilePath.getParent().resolve(objectsDirectory);\n+                    }\n+\n+                    Path sfdxCustomFieldPath = getSfdxCustomFieldPath(candidateDirectory, objectName, fieldName);\n+                    if (sfdxCustomFieldPath != null) {\n+                        // SFDX Format\n+                        parseSfdxCustomField(objectName, sfdxCustomFieldPath);\n+                    } else {\n+                        // MDAPI Format\n+                        String fileName = objectName + MDAPI_OBJECT_FILE_SUFFIX;\n+                        Path mdapiPath = candidateDirectory.resolve(fileName);\n+                        if (Files.exists(mdapiPath) && Files.isRegularFile(mdapiPath)) {\n+                            parseMdapiCustomObject(mdapiPath);\n+                        }\n+                    }\n+\n+                    if (variableNameToVariableType.containsKey(lowerExpression)) {\n+                        // Break out of the loop if a variable was found\n+                        break;\n+                    }\n+                }\n+                variableNameProcessed.add(lowerExpression);\n+            } else {\n+                // TODO: Support cross object relationships, these are expressions that contain \"__r\"\n+                LOGGER.fine(\"Expression does not have two parts: \" + expression);\n+            }\n+        }\n+\n+        return variableNameToVariableType.get(lowerExpression);\n+    }\n+\n+    /**\n+     * Sfdx projects decompose custom fields into individual files. This method will return the individual file that\n+     * corresponds to &lt;objectName&gt;.&lt;fieldName&gt; if it exists.\n+     *\n+     * @return path to the metadata file for the Custom Field or null if not found\n+     */\n+    private Path getSfdxCustomFieldPath(Path objectsDirectory, String objectName, String fieldName) {\n+        Path fieldsDirectoryPath = Paths.get(objectsDirectory.toString(), objectName, FIELDS_DIRECTORY);\n+        if (Files.exists(fieldsDirectoryPath) && Files.isDirectory(fieldsDirectoryPath)) {\n+            Path sfdxFieldPath = Paths.get(fieldsDirectoryPath.toString(), fieldName + SFDX_FIELD_FILE_SUFFIX);\n+            if (Files.exists(sfdxFieldPath) && Files.isRegularFile(sfdxFieldPath)) {\n+                return sfdxFieldPath;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Determine the type of the custom field.\n+     */\n+    private void parseSfdxCustomField(String customObjectName, Path sfdxCustomFieldPath) {\n+        try {\n+            Document document = documentBuilder.parse(sfdxCustomFieldPath.toFile());\n+            Node fullNameNode = (Node) sfdxCustomFieldFullNameExpression.evaluate(document, XPathConstants.NODE);\n+            Node typeNode = (Node) sfdxCustomFieldTypeExpression.evaluate(document, XPathConstants.NODE);\n+            String type = typeNode.getNodeValue();\n+            IdentifierType identifierType = IdentifierType.fromString(type);\n+\n+            String key = customObjectName + \".\" + fullNameNode.getNodeValue();\n+            setVariableType(key, identifierType);\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    /**\n+     * Parse the custom object path and determine the type of all of its custom fields.\n+     */\n+    private void parseMdapiCustomObject(Path mdapiObjectFile) {\n+        String fileName = mdapiObjectFile.getFileName().toString();\n+\n+        String customObjectName = fileName.substring(0, fileName.lastIndexOf(MDAPI_OBJECT_FILE_SUFFIX));\n+        if (!objectFileProcessed.contains(customObjectName)) {\n+            try {\n+                Document document = documentBuilder.parse(mdapiObjectFile.toFile());\n+                NodeList fieldsNodes = (NodeList) customObjectFieldsExpression.evaluate(document, XPathConstants.NODESET);\n+                for (int i = 0; i < fieldsNodes.getLength(); i++) {\n+                    Node fieldsNode = fieldsNodes.item(i);\n+                    Node fullNameNode = (Node) customFieldFullNameExpression.evaluate(fieldsNode, XPathConstants.NODE);\n+                    if (fullNameNode == null) {\n+                        throw new RuntimeException(\"fullName evaluate failed for \" + customObjectName + \" \" + fieldsNode.getTextContent());\n+                    }\n+                    String name = fullNameNode.getNodeValue();\n+                    if (endsWithIgnoreCase(name, CUSTOM_OBJECT_SUFFIX)) {\n+                        Node typeNode = (Node) customFieldTypeExpression.evaluate(fieldsNode, XPathConstants.NODE);\n+                        if (typeNode == null) {\n+                            throw new RuntimeException(\"type evaluate failed for object=\" + customObjectName + \", field=\" + name + \" \" + fieldsNode.getTextContent());\n+                        }\n+                        String type = typeNode.getNodeValue();\n+                        IdentifierType identifierType = IdentifierType.fromString(type);\n+                        String key = customObjectName + \".\" + fullNameNode.getNodeValue();\n+                        setVariableType(key, identifierType);\n+                    }\n+                }\n+            } catch (Exception e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c"}, "originalPosition": 242}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNjQxMQ==", "bodyText": "I think actually it would be better to put them in VfParserOptions, because otherwise VfParserOptions is a bit opaque", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523406411", "createdAt": "2020-11-14T10:53:39Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfExpressionTypeVisitor.java", "diffHunk": "@@ -4,39 +4,69 @@\n \n package net.sourceforge.pmd.lang.vf;\n \n+import java.io.File;\n import java.util.ArrayList;\n+import java.util.Collections;\n import java.util.IdentityHashMap;\n import java.util.List;\n import java.util.Locale;\n import java.util.Map;\n import java.util.logging.Logger;\n \n+import net.sourceforge.pmd.lang.ast.AbstractTokenManager;\n import net.sourceforge.pmd.lang.vf.ast.ASTAttribute;\n import net.sourceforge.pmd.lang.vf.ast.ASTAttributeValue;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n import net.sourceforge.pmd.lang.vf.ast.ASTDotExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTElExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTElement;\n import net.sourceforge.pmd.lang.vf.ast.ASTExpression;\n import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n import net.sourceforge.pmd.lang.vf.ast.ASTText;\n import net.sourceforge.pmd.lang.vf.ast.VfParserVisitorAdapter;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+import net.sourceforge.pmd.properties.PropertySource;\n \n /**\n  * Visits {@link ASTElExpression} nodes and stores type information for all {@link ASTIdentifier} child nodes.\n  */\n public class VfExpressionTypeVisitor extends VfParserVisitorAdapter {\n     private static final Logger LOGGER = Logger.getLogger(VfExpressionTypeVisitor.class.getName());\n \n+    static final List<String> DEFAULT_APEX_DIRECTORIES = Collections.singletonList(\"..\" + File.separator + \"classes\");\n+    static final List<String> DEFAULT_OBJECT_DIRECTORIES = Collections.singletonList(\"..\" + File.separator + \"objects\");\n+\n+    /**\n+     * Directory that contains Apex classes that may be referenced from a Visualforce page.\n+     */\n+    public static final PropertyDescriptor<List<String>> APEX_DIRECTORIES_DESCRIPTOR =", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM2MzgyMg=="}, "originalCommit": {"oid": "db7bf0a786954ee065a1ac0f4959cd9ac13cfbc7"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNjU2NQ==", "bodyText": "I think this could be package-private\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public class VfExpressionTypeVisitor extends VfParserVisitorAdapter {\n          \n          \n            \n            class VfExpressionTypeVisitor extends VfParserVisitorAdapter {", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523406565", "createdAt": "2020-11-14T10:55:08Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/VfExpressionTypeVisitor.java", "diffHunk": "@@ -0,0 +1,217 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.IdentityHashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+\n+import net.sourceforge.pmd.lang.ast.AbstractTokenManager;\n+import net.sourceforge.pmd.lang.vf.ast.ASTAttribute;\n+import net.sourceforge.pmd.lang.vf.ast.ASTAttributeValue;\n+import net.sourceforge.pmd.lang.vf.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.vf.ast.ASTDotExpression;\n+import net.sourceforge.pmd.lang.vf.ast.ASTElExpression;\n+import net.sourceforge.pmd.lang.vf.ast.ASTElement;\n+import net.sourceforge.pmd.lang.vf.ast.ASTExpression;\n+import net.sourceforge.pmd.lang.vf.ast.ASTIdentifier;\n+import net.sourceforge.pmd.lang.vf.ast.ASTText;\n+import net.sourceforge.pmd.lang.vf.ast.VfParserVisitorAdapter;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+import net.sourceforge.pmd.properties.PropertySource;\n+\n+/**\n+ * Visits {@link ASTElExpression} nodes and stores type information for all {@link ASTIdentifier} child nodes.\n+ */\n+public class VfExpressionTypeVisitor extends VfParserVisitorAdapter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNzM2NQ==", "bodyText": "I think it would be a better idea to hide the property source inside the parser options instead of using inheritance. This would avoid eg splitting your equals method with that super call. I'd like to remove AbstractPropertySource eventually, the inheritance is really causing problems.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523407365", "createdAt": "2020-11-14T11:04:43Z", "author": {"login": "oowekyala"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/lang/ParserOptions.java", "diffHunk": "@@ -4,19 +4,38 @@\n \n package net.sourceforge.pmd.lang;\n \n+import java.util.Locale;\n+import java.util.Objects;\n+\n+import net.sourceforge.pmd.properties.AbstractPropertySource;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+\n /**\n  * Represents a set of configuration options for a {@link Parser}. For each\n  * unique combination of ParserOptions a Parser will be used to create an AST.\n  * Therefore, implementations must implement {@link Object#equals(Object)} and\n  * {@link Object#hashCode()}.\n  */\n-public class ParserOptions {\n+public class ParserOptions extends AbstractPropertySource {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzQwNzgxMg==", "bodyText": "The renaming and the new constructor are binary-incompatible changes. To preserve binary compatibility we can declare this ParserOptionTestUtils next to ParserOptionsTest, give it a package-private constructor, and make ParserOptionsTest extend from it. And deprecate ParserOptionsTest.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r523407812", "createdAt": "2020-11-14T11:09:49Z", "author": {"login": "oowekyala"}, "path": "pmd-test/src/main/java/net/sourceforge/pmd/lang/ParserOptionsTestUtils.java", "diffHunk": "@@ -5,38 +5,9 @@\n package net.sourceforge.pmd.lang;\n \n import org.junit.Assert;\n-import org.junit.Test;\n \n-/**\n- * Unit tests for {@link ParserOptions}.\n- */\n-public class ParserOptionsTest {\n-\n-    /**\n-     * SuppressMarker should be initially null and changeable.\n-     */\n-    @Test\n-    public void testSuppressMarker() {\n-        ParserOptions parserOptions = new ParserOptions();\n-        Assert.assertNull(parserOptions.getSuppressMarker());\n-        parserOptions.setSuppressMarker(\"foo\");\n-        Assert.assertEquals(\"foo\", parserOptions.getSuppressMarker());\n-    }\n-\n-    /**\n-     * Verify that the equals and hashCode methods work as expected.\n-     */\n-    @Test\n-    public void testEqualsHashcode() {\n-        ParserOptions options1 = new ParserOptions();\n-        options1.setSuppressMarker(\"foo\");\n-        ParserOptions options2 = new ParserOptions();\n-        options2.setSuppressMarker(\"bar\");\n-        ParserOptions options3 = new ParserOptions();\n-        options3.setSuppressMarker(\"foo\");\n-        ParserOptions options4 = new ParserOptions();\n-        options4.setSuppressMarker(\"bar\");\n-        verifyOptionsEqualsHashcode(options1, options2, options3, options4);\n+public final class ParserOptionsTestUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1c42a10ec32403cc1ccae82bce4c420694f3e2c"}, "originalPosition": 36}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "86b5948f072a789d4a95b7934c0b0814021088e2", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/86b5948f072a789d4a95b7934c0b0814021088e2", "committedDate": "2020-11-20T19:59:23Z", "message": "Update the way nodes with data are identified\n\nChanged method for how the Visualforce strings are reconstructed from the AST. The previous implementation had incorrect assumptions about the structure of the AST. Added tests to more thoroughly test these situations.\n\nChanged name of IdentifierType to DataType. This information can be stored on either ASTIdentifier or ASTLiteral nodes.\n\nChanges based on PR feedgack:\n- Restored ParserOptionsTest in order to avoid binary compatibilty issues.\n- Changed ParserOptions to contain a PropertySource instead of extending AbtractPropertySource."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM1NzgyNTUw", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-535782550", "createdAt": "2020-11-20T21:18:16Z", "commit": {"oid": "86b5948f072a789d4a95b7934c0b0814021088e2"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMToxODoxNlrOH3hAyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQyMToyMzozOFrOH3hJvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3NDYwMw==", "bodyText": "I renamed this from IdentifierType. This value can be stored on both ASTIdentifier and ASTLiteral nodes.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527974603", "createdAt": "2020-11-20T21:18:16Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/DataType.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.logging.Logger;\n+\n+import apex.jorje.semantic.symbol.type.BasicType;\n+\n+/**\n+ * Represents all data types that can be referenced from a Visualforce page. This enum consolidates the data types\n+ * available to CustomFields and Apex. It uses the naming convention of CustomFields.\n+ *\n+ * See https://developer.salesforce.com/docs/atlas.en-us.api_meta.meta/api_meta/meta_field_types.htm#meta_type_fieldtype\n+ */\n+public enum DataType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b5948f072a789d4a95b7934c0b0814021088e2"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3NTQ0Ng==", "bodyText": "New common class for ASTIdentifier and ASTLiteral.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527975446", "createdAt": "2020-11-20T21:20:07Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ast/AbstractVFDataNode.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b5948f072a789d4a95b7934c0b0814021088e2"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3NjMzOA==", "bodyText": "Common code for ApexClassPropertyTypes and ObjectFieldTypes.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527976338", "createdAt": "2020-11-20T21:22:16Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/SalesforceFieldTypes.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf;\n+\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Responsible for storing a mapping of Fields that can be referenced from Visualforce to the type of the field. The\n+ * fields are identified by in a case insensitive manner.\n+ */\n+abstract class SalesforceFieldTypes {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b5948f072a789d4a95b7934c0b0814021088e2"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzk3Njg5Mw==", "bodyText": "This method can be iterated on over time to handle the cases listed in the Javadoc.", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r527976893", "createdAt": "2020-11-20T21:23:38Z", "author": {"login": "jbartolotta-sfdc"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ast/ASTExpression.java", "diffHunk": "@@ -23,4 +41,120 @@ public ASTExpression(VfParser p, int id) {\n     public Object jjtAccept(VfParserVisitor visitor, Object data) {\n         return visitor.visit(this, data);\n     }\n+\n+    private void logWarning(String warning, Node node) {\n+        LOGGER.warning(warning\n+                + \". nodeClass=\" + node.getClass().getSimpleName()\n+                + \", fileName=\" + AbstractTokenManager.getFileName()\n+                + \", beginLine=\" + node.getBeginLine()\n+                + \", image=\" + node.getImage());\n+    }\n+\n+    /**\n+     * <p>\n+     * An Expression can contain one or more strings that map to a piece of data. This method maps the string\n+     * from the Visualforce page to terminal AST node that the string represents. The terminal node will be either an\n+     * ASTIdentifier or ASTLiteral. It is the terminal node that is most important since it represents the type of data\n+     * that will be displayed in the page.\n+     * </p>\n+     * <p>\n+     * The string representation can be reconstructed by starting at the {@code Identifier} node and traversing its\n+     * siblings until a node other than a {@code DotExpression} is encountered. Some more advanced situations aren't\n+     * currently handled by this method. The method will throw an exception in such cases.\n+     * </p>\n+     * <pre>{@code\n+     * <apex:outputText value=\"{!MyValue}\" /> results in AST\n+     * <Identifier Image='MyValue'/>\n+     * The method would return key=ASTIdentifier(Image='MyValue'), value=\"MyValue\"\n+     * }</pre>\n+     * <pre>{@code\n+     * <apex:outputText value=\"{!MyObject__c.Text__c}\" /> results in AST (It's important to notice that DotExpression is\n+     * a sibling of Identifier.\n+     * <Identifier Image='MyObject__c'/>\n+     * <DotExpression Image=''>\n+     *     <Identifier Image='Text__c'/>\n+     * </DotExpression>\n+     * This method would return key=ASTIdentifier(Image='Text__c'), value=\"MyObject__c.Text__c\"\n+     * }</pre>\n+     *\n+     * THE FOLLOWING SITUATIONS ARE NOT HANDLED AND WILL THROW AN EXCEPTION.\n+     * This syntax causes ambiguities with Apex Controller methods that return Maps versus accessing a CustomObject's\n+     * field via array notation. This may be addressed in a future release.\n+     *\n+     * <pre>{@code\n+     * <apex:outputText value=\"{!MyObject__c['Text__c']}\" /> results in AST\n+     * <Identifier Image='MyObject__c'/>\n+     * <Expression Image=''>\n+     *     <Literal Image='&apos;Text__c&apos;'>\n+     * </Expression>\n+\n+     * <apex:outputText value=\"{!MyObject__c[AnotherObject__c.Id]}\" /> results in AST\n+     * <Identifier Image='MyObject__c'/>\n+     * <Expression Image=''>\n+     *     <Identifier Image='AnotherObject__c'/>\n+     *         <DotExpression Image=''>\n+     *             <Identifier Image='Id'/>\n+     *         </DotExpression>\n+     *     </Identifier>\n+     * </Expression>\n+     * }</pre>\n+     *\n+     * @throws DataNodeStateException if the results of this method could have been incorrect. Callers should typically\n+     * not rethrow this exception, as it will happen often and doesn't represent a terminal exception.\n+     */\n+    public Map<AbstractVFDataNode, String> getDataNodes() throws DataNodeStateException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "86b5948f072a789d4a95b7934c0b0814021088e2"}, "originalPosition": 93}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "21506cea859cc1dec6ce2d71c339be219568be87", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/21506cea859cc1dec6ce2d71c339be219568be87", "committedDate": "2020-11-24T10:39:59Z", "message": "Cleanup languages to skip"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fabf2cf6db516fe5c9717be9162f677c969e77f3", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/fabf2cf6db516fe5c9717be9162f677c969e77f3", "committedDate": "2020-11-24T10:53:45Z", "message": "Make the parser options properties private"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58cf6cbc96f3afb0960b1798b39d6040b62d46db", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/58cf6cbc96f3afb0960b1798b39d6040b62d46db", "committedDate": "2020-11-24T10:55:09Z", "message": "Remove AbstractPropertySource equals/hashCode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0ad1f47b29e7ef5683729530cc434fa07623320f", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/0ad1f47b29e7ef5683729530cc434fa07623320f", "committedDate": "2020-11-24T11:02:32Z", "message": "Use interface instead of deprecated abstract class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "898c301ce0d25db08f9be225d25181e63fce0214", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/898c301ce0d25db08f9be225d25181e63fce0214", "committedDate": "2020-11-24T11:06:07Z", "message": "Merge branch 'master' into pr/2864"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b94ac4f0180a476ed5f883d987f42cd61371c0ee", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/b94ac4f0180a476ed5f883d987f42cd61371c0ee", "committedDate": "2020-11-24T11:09:25Z", "message": "Don't create a vf language module per parser options"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4efe1493a597ba012ad9f6d0d3361928c9952096", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/4efe1493a597ba012ad9f6d0d3361928c9952096", "committedDate": "2020-11-24T11:12:32Z", "message": "Remove some unchecked warnings"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2d5781482eddbd67568c01da584305fa117a794e", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/2d5781482eddbd67568c01da584305fa117a794e", "committedDate": "2020-11-24T11:22:32Z", "message": "Fix tests"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM3Mzk4MTQ1", "url": "https://github.com/pmd/pmd/pull/2864#pullrequestreview-537398145", "createdAt": "2020-11-24T11:28:09Z", "commit": {"oid": "2d5781482eddbd67568c01da584305fa117a794e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMToyODowOVrOH48h_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMToyODowOVrOH48h_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTQ3NDA0Nw==", "bodyText": "I replaced your AbstractVfDataNode with this interface (your abstract class was deprecated). Maybe the name VfDataNode is more appropriate, feel free to rename it", "url": "https://github.com/pmd/pmd/pull/2864#discussion_r529474047", "createdAt": "2020-11-24T11:28:09Z", "author": {"login": "oowekyala"}, "path": "pmd-visualforce/src/main/java/net/sourceforge/pmd/lang/vf/ast/VfTypedNode.java", "diffHunk": "@@ -0,0 +1,22 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.vf.ast;\n+\n+import net.sourceforge.pmd.lang.vf.DataType;\n+\n+/**\n+ * Represents a node that displays a piece of data.\n+ */\n+public interface VfTypedNode extends VfNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2d5781482eddbd67568c01da584305fa117a794e"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f805b858504191c38c752578f8aac544f917f6fd", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/f805b858504191c38c752578f8aac544f917f6fd", "committedDate": "2020-12-10T04:11:25Z", "message": "Fix Html DataType\n\nThis DataType does not need to be escaped, it is always escaped by the\nserver."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e7f7f7184e20edbb496561ecdcad84fef8f50cd6", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/e7f7f7184e20edbb496561ecdcad84fef8f50cd6", "committedDate": "2020-12-10T18:56:08Z", "message": "Merge branch 'master' into pr/2864"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f7829531c966c2e3bff97e08e0cc0c49ab500976", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/f7829531c966c2e3bff97e08e0cc0c49ab500976", "committedDate": "2020-12-10T19:17:51Z", "message": "Add some doc"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aaa540af7b7e742c47db8e02b68564e3fd931e79", "author": {"user": {"login": "oowekyala", "name": "Cl\u00e9ment Fournier"}}, "url": "https://github.com/pmd/pmd/commit/aaa540af7b7e742c47db8e02b68564e3fd931e79", "committedDate": "2020-12-10T19:27:13Z", "message": "Update release notes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e00c204991b8a3bbff9012b1d6f264e14f8166e", "author": {"user": {"login": "jbartolotta-sfdc", "name": "Jeff Bartolotta"}}, "url": "https://github.com/pmd/pmd/commit/4e00c204991b8a3bbff9012b1d6f264e14f8166e", "committedDate": "2020-12-11T06:20:10Z", "message": "Small comment and doc edits"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4555, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}