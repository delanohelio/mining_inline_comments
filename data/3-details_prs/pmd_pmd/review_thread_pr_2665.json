{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU2NzU3MTUw", "number": 2665, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToxMjo1MVrOETmO4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNTo1MToxOFrOETvXGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTg0ODAxOnYy", "diffSide": "LEFT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToxMjo1MVrOG5a1Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToxMjo1MVrOG5a1Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2MTYzNQ==", "bodyText": "Would it make sense to keep a deprecated getAnnotationName() method around (DeprecatedUntil700)?", "url": "https://github.com/pmd/pmd/pull/2665#discussion_r462861635", "createdAt": "2020-07-30T09:12:51Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTAnnotation.java", "diffHunk": "@@ -9,45 +9,47 @@\n import org.checkerframework.checker.nullness.qual.Nullable;\n \n import net.sourceforge.pmd.lang.ast.NodeStream;\n-import net.sourceforge.pmd.util.StringUtil;\n+import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\n \n /**\n  * Represents an annotation.\n  *\n  * <pre class=\"grammar\">\n  *\n- * Annotation ::= \"@\" Name {@link ASTAnnotationMemberList AnnotationMemberList}?\n+ * Annotation ::= \"@\" {@link ASTClassOrInterfaceType ClassName} {@link ASTAnnotationMemberList AnnotationMemberList}?\n  *\n  * </pre>\n  */\n public final class ASTAnnotation extends AbstractJavaTypeNode implements TypeNode, ASTMemberValue, Iterable<ASTMemberValuePair> {\n \n-    String name;\n-\n     ASTAnnotation(int id) {\n         super(id);\n     }\n \n \n     /**\n-     * Returns the name of the annotation as it is used,\n-     * eg {@code java.lang.Override} or {@code Override}.\n+     * Returns the node that represents the name of the annotation.\n      */\n-    public String getAnnotationName() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4febe7fdd212ab73fd5d4abbaa12d116174eaa4"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTg2NzEzOnYy", "diffSide": "LEFT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowStatement.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToxODoyNVrOG5bBYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxMDoxMToyNVrOG5c0VA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2NDczNw==", "bodyText": "I guess, we should deprecate this method on master. It seems to be used only by one rule - ExceptionAsFlowControl", "url": "https://github.com/pmd/pmd/pull/2665#discussion_r462864737", "createdAt": "2020-07-30T09:18:25Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowStatement.java", "diffHunk": "@@ -32,23 +32,4 @@ public ASTExpression getExpr() {\n         return (ASTExpression) getFirstChild();\n     }\n \n-    /**\n-     * Gets the image of the first ASTClassOrInterfaceType child or\n-     * <code>null</code> if none is found. Note that when the statement is\n-     * something like throw new Exception, this method returns 'Exception' and\n-     * if the throw statement is like throw e: this method returns 'e'. A\n-     * special case of returning <code>null</code> is when the throws is like\n-     * throw this.e or throw this.\n-     *\n-     * This is too specific\n-     *\n-     * <p>TODO - use symbol table (?)</p>\n-     *\n-     * @return the image of the first ASTClassOrInterfaceType node found or\n-     *     <code>null</code>\n-     */\n-    public String getFirstClassOrInterfaceTypeImage() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4febe7fdd212ab73fd5d4abbaa12d116174eaa4"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg5NDE2NA==", "bodyText": "Done: a5eb602", "url": "https://github.com/pmd/pmd/pull/2665#discussion_r462894164", "createdAt": "2020-07-30T10:11:25Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTThrowStatement.java", "diffHunk": "@@ -32,23 +32,4 @@ public ASTExpression getExpr() {\n         return (ASTExpression) getFirstChild();\n     }\n \n-    /**\n-     * Gets the image of the first ASTClassOrInterfaceType child or\n-     * <code>null</code> if none is found. Note that when the statement is\n-     * something like throw new Exception, this method returns 'Exception' and\n-     * if the throw statement is like throw e: this method returns 'e'. A\n-     * special case of returning <code>null</code> is when the throws is like\n-     * throw this.e or throw this.\n-     *\n-     * This is too specific\n-     *\n-     * <p>TODO - use symbol table (?)</p>\n-     *\n-     * @return the image of the first ASTClassOrInterfaceType node found or\n-     *     <code>null</code>\n-     */\n-    public String getFirstClassOrInterfaceTypeImage() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2NDczNw=="}, "originalCommit": {"oid": "d4febe7fdd212ab73fd5d4abbaa12d116174eaa4"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTg3NTE4OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/AnnotationSuppressionUtil.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToyMDo0MlrOG5bGbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwOToyMDo0MlrOG5bGbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjg2NjAzMQ==", "bodyText": "We'll get a PositionLiteralFirstInComparison violation\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (annotation.getSymbol().getBinaryName().equals(\"java.lang.SuppressWarnings\")) {\n          \n          \n            \n                    if (\"java.lang.SuppressWarnings\".equals(annotation.getSymbol().getBinaryName())) {", "url": "https://github.com/pmd/pmd/pull/2665#discussion_r462866031", "createdAt": "2020-07-30T09:20:42Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/internal/AnnotationSuppressionUtil.java", "diffHunk": "@@ -107,9 +106,8 @@ private static boolean hasSuppressWarningsAnnotationFor(final Annotatable node,\n \n     // @formatter:on\n     private static boolean annotationSuppresses(ASTAnnotation annotation, Rule rule) {\n-        // if (SuppressWarnings.class.equals(getType())) { // typeres is not always on\n-        if (TypeHelper.isA(annotation, SuppressWarnings.class)) {\n-            for (ASTLiteral element : annotation.findDescendantsOfType(ASTLiteral.class)) {\n+        if (annotation.getSymbol().getBinaryName().equals(\"java.lang.SuppressWarnings\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4febe7fdd212ab73fd5d4abbaa12d116174eaa4"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg5MTM0MzYxOnYy", "diffSide": "RIGHT", "path": "pmd-java/src/test/kotlin/net/sourceforge/pmd/lang/java/ast/TypeDisambiguationTest.kt", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNTo1MToxOFrOG5pNYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQxNTo1MToxOFrOG5pNYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzA5NzE4Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        val err = logger.errors[SemanticChecksLogger.MALFORMED_GENERIC_TYPE]?.firstOrNull { it.first == t }\n          \n          \n            \n                        val err = logger.errors[SemanticChecksLogger.EXPECTED_ANNOTATION_TYPE]?.firstOrNull { it.first == t }", "url": "https://github.com/pmd/pmd/pull/2665#discussion_r463097187", "createdAt": "2020-07-30T15:51:18Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/test/kotlin/net/sourceforge/pmd/lang/java/ast/TypeDisambiguationTest.kt", "diffHunk": "@@ -133,4 +137,101 @@ class TypeDisambiguationTest : ParserTestSpec({\n             refInScratch.referencedSym shouldBe aMem\n         }\n     }\n+\n+    parserTest(\"Malformed types\") {\n+        val logger = enableProcessing()\n+\n+        val acu = parser.parse(\"\"\"\n+           package p;\n+           class Scratch<X> {\n+               static class K {}\n+               static class Foo<Y, X> {}\n+               class Inner<Y> {} // non-static\n+\n+               Scratch.Foo<K, K>        m0; // ok\n+               Scratch.K<K>             m1; // error\n+               Scratch.K                m2; // ok\n+               Scratch.Foo<K>           m3; // error\n+               Scratch.Foo<K, K, K>     m4; // error\n+               Scratch.Foo              m5; // raw type, ok\n+\n+               Scratch<K>               s0; // ok\n+               Scratch<K, K>            s1; // error\n+               Scratch                  s2; // raw type, ok\n+\n+               // Scratch<K>.Foo        m6; // todo error: Foo is static\n+               // Scratch<K>.Foo<K, K>  m7; // todo error: Foo is static\n+\n+               // Scratch<K>.Inner<K, K>    m; // ok, fully parameterized\n+               // Scratch.Inner<K, K>       m; // todo error: Scratch must be parameterized \n+               // Scratch.Inner             m; // ok, raw type\n+           }\n+        \"\"\")\n+\n+        val (m0, m1, m2, m3, m4, m5, s0, s1, s2) =\n+                acu.descendants(ASTFieldDeclaration::class.java).map { it.typeNode as ASTClassOrInterfaceType }.toList()\n+\n+        fun assertErrored(t: ASTClassOrInterfaceType, expected: Int, actual: Int) {\n+            val errs = logger.errors[SemanticChecksLogger.MALFORMED_GENERIC_TYPE]?.filter { it.first == t } ?: emptyList()\n+            assertEquals(errs.size, 1, \"`${t.text}` should have produced a single error\")\n+            errs.single().second.toList() shouldBe listOf(expected, actual)\n+        }\n+\n+        fun assertNoError(t: ASTClassOrInterfaceType) {\n+            val err = logger.errors[SemanticChecksLogger.MALFORMED_GENERIC_TYPE]?.firstOrNull { it.first == t }\n+            assertNull(err, \"`${t.text}` should not have produced an error\")\n+        }\n+\n+        assertNoError(m0)\n+        assertErrored(m1, expected = 0, actual = 1)\n+        assertNoError(m2)\n+        assertErrored(m3, expected = 2, actual = 1)\n+        assertErrored(m4, expected = 2, actual = 3)\n+        assertNoError(m5)\n+\n+        assertNoError(s0)\n+        assertErrored(s1, expected = 1, actual = 2)\n+        assertNoError(s2)\n+    }\n+\n+    parserTest(\"Invalid annotations\") {\n+        val logger = enableProcessing()\n+\n+        val acu = parser.parse(\"\"\"\n+           package p;\n+           class C<T> {\n+                @interface A { }\n+                interface I { }\n+\n+\n+                @T\n+                @C\n+                @I\n+                @Unresolved\n+                @A\n+                int field;\n+           }\n+        \"\"\")\n+\n+        val (aT, aC, aI, aUnresolved, aOk) =\n+                acu.descendants(ASTAnnotation::class.java).map { it.typeNode }.toList()\n+\n+        fun assertErrored(t: ASTClassOrInterfaceType) {\n+            val errs = logger.errors[SemanticChecksLogger.EXPECTED_ANNOTATION_TYPE]?.filter { it.first == t } ?: emptyList()\n+            assertEquals(errs.size, 1, \"`${t.text}` should have produced a single error\")\n+            errs.single().second.toList() shouldBe emptyList()\n+        }\n+\n+        fun assertNoError(t: ASTClassOrInterfaceType) {\n+            val err = logger.errors[SemanticChecksLogger.MALFORMED_GENERIC_TYPE]?.firstOrNull { it.first == t }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d4febe7fdd212ab73fd5d4abbaa12d116174eaa4"}, "originalPosition": 145}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 269, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}