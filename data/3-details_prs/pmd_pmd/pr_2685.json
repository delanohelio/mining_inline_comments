{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYwMDE0ODg5", "number": 2685, "title": "[java] Fix NoClassDefFoundErrors", "bodyText": "Describe the PR\nWhen determining methods/fields by reflection, we could run into situations, that the classes, that are referenced in the methods (e.g. parameter types, return types) are not on the auxclasspath. Then a LinkageError is thrown, which was not handled before.\nThe reason, why the types are missing on the auxclasspath is actually a valid case: As long as the methods are not used in the code, the referenced classes neither need to be on the compile classpath. And we use the compile classpath as our auxclasspath.\nThis can happen, if a project uses a provided dependency and this dependency has other transitive dependencies. These transitive dependencies are not on the compile classpath.\nThis PR fixes the problem in ImportWrapper as well as in two other cases, where we use reflection.\nRelated issues\n\nFixes #2663\n\nReady?\n\n Added unit tests for fixed bug/feature - I only tested it with the integration test from #2663\n Passing all unit tests\n Complete build ./mvnw clean verify passes (checked automatically by travis)\n Added (in-code) documentation (if needed)", "createdAt": "2020-07-31T10:33:45Z", "url": "https://github.com/pmd/pmd/pull/2685", "merged": true, "mergeCommit": {"oid": "86cfa9a952e77c370ff6e438d07979db1ef3e841"}, "closed": true, "closedAt": "2020-08-21T08:59:37Z", "author": {"login": "adangel"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc6RC78gH2gAyNDYwMDE0ODg5OjRjZTM5NGVjYTNjYTQ3Mjk0Yzg0NGZiYjRlNDA0MTE2ZmQwMzU3MDA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc_ddG0gH2gAyNDYwMDE0ODg5OjgzOTk0MWQ0ZWJhZDEzNTAzNzczMzBlN2NiNjU4ZTBlYmVlODUxMjE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4ce394eca3ca47294c844fbb4e404116fd035700", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/4ce394eca3ca47294c844fbb4e404116fd035700", "committedDate": "2020-07-31T09:45:17Z", "message": "[java] ImportWrapper - only consider static fields/methods\n\nFixes #2663"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "693613a6a8df96e0040673d62378a11e9c41f560", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/693613a6a8df96e0040673d62378a11e9c41f560", "committedDate": "2020-07-31T10:13:24Z", "message": "[java] ImportWrapper - catch and report LinkageErrors"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "08b922429ca944cf4d469837ffaa43f309d57766", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/08b922429ca944cf4d469837ffaa43f309d57766", "committedDate": "2020-07-31T10:23:59Z", "message": "[java] Catch possible LinkageErrors for other rules"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "22c3ce92ce53c9fa80c334f4c40aa79b7dd7351f", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/22c3ce92ce53c9fa80c334f4c40aa79b7dd7351f", "committedDate": "2020-07-31T10:28:29Z", "message": "[doc] Update release notes, fixes #2663"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1MDMzMDgw", "url": "https://github.com/pmd/pmd/pull/2685#pullrequestreview-465033080", "createdAt": "2020-08-11T12:52:05Z", "commit": {"oid": "22c3ce92ce53c9fa80c334f4c40aa79b7dd7351f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1MjowNVrOG-2V7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xMVQxMjo1MjowNVrOG-2V7A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODU1NTI0NA==", "bodyText": "I'm not sure adding a processing error is appropriate here. I don't think we currently log missing classes to the report right? And for now, processing errors indicate errors in PMD code, the kind of errors people should report as bugs. Currently, a processing error may very well mean that the file was not processed by rules at all, and so, violations may be missing from the report. Whereas missing dependencies is more akin to a warning, ie, we can continue analysis (and we do), but results of some rules may be somewhat inaccurate. And users shouldn't think this is a bug on our side.\nI would say a log call would be more appropriate, as it's possible to disable it, and it makes it clearer that this is just a warning. In PMD 7 this will be handled by the semantic checker, which is also akin to a logger, and won't touch the report.", "url": "https://github.com/pmd/pmd/pull/2685#discussion_r468555244", "createdAt": "2020-08-11T12:52:05Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/internal/ImportWrapper.java", "diffHunk": "@@ -8,57 +8,78 @@\n import java.lang.reflect.Field;\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n+import java.util.Collections;\n import java.util.HashSet;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n \n+import net.sourceforge.pmd.Report.ProcessingError;\n+import net.sourceforge.pmd.RuleContext;\n import net.sourceforge.pmd.lang.ast.Node;\n import net.sourceforge.pmd.lang.java.ast.ASTImportDeclaration;\n \n /**\n  * Helper class to analyze {@link ASTImportDeclaration}s.\n  */\n public class ImportWrapper {\n-    private ASTImportDeclaration node;\n-    private String name;\n-    private String fullname;\n-    private boolean isStaticDemand;\n-    private Set<String> allDemands = new HashSet<>();\n+    private static final Logger LOG = Logger.getLogger(ImportWrapper.class.getName());\n+\n+    private final ASTImportDeclaration node;\n+    private final String name;\n+    private final String fullname;\n+    private final boolean isStaticDemand;\n+    private final Set<String> allStaticDemands;\n \n     public ImportWrapper(String fullname, String name) {\n         this(fullname, name, null);\n     }\n \n     public ImportWrapper(String fullname, String name, ASTImportDeclaration node) {\n-        this(fullname, name, node, false);\n+        this(fullname, name, node, false, null);\n     }\n \n-    public ImportWrapper(String fullname, String name, ASTImportDeclaration node, boolean isStaticDemand) {\n+    public ImportWrapper(String fullname, String name, ASTImportDeclaration node, boolean isStaticDemand, RuleContext ctx) {\n         this.fullname = fullname;\n         this.name = name;\n         this.node = node;\n         this.isStaticDemand = isStaticDemand;\n+        this.allStaticDemands = collectStaticFieldsAndMethods(node, ctx);\n+\n+    }\n+\n+    /**\n+     * @param node\n+     */\n+    private Set<String> collectStaticFieldsAndMethods(ASTImportDeclaration node, RuleContext ctx) {\n+        if (!this.isStaticDemand || node == null || node.getType() == null) {\n+            return Collections.emptySet();\n+        }\n \n-        if (node != null && node.getType() != null) {\n+        try {\n+            Set<String> names = new HashSet<>();\n             Class<?> type = node.getType();\n-            for (Method m : type.getMethods()) {\n-                allDemands.add(m.getName());\n-            }\n-            for (Field f : type.getFields()) {\n-                allDemands.add(f.getName());\n-            }\n-            // also consider static fields, that are not public\n+            // consider static fields, public and non-public\n             for (Field f : type.getDeclaredFields()) {\n                 if (Modifier.isStatic(f.getModifiers())) {\n-                    allDemands.add(f.getName());\n+                    names.add(f.getName());\n                 }\n             }\n             // and methods, too\n             for (Method m : type.getDeclaredMethods()) {\n                 if (Modifier.isStatic(m.getModifiers())) {\n-                    allDemands.add(m.getName());\n+                    names.add(m.getName());\n                 }\n             }\n+            return names;\n+        } catch (LinkageError e) {\n+            if (ctx != null) {\n+                ctx.getReport().addError(new ProcessingError(e, String.valueOf(ctx.getSourceCodeFile())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "22c3ce92ce53c9fa80c334f4c40aa79b7dd7351f"}, "originalPosition": 88}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "839941d4ebad1350377330e7cb658e0ebee85121", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/839941d4ebad1350377330e7cb658e0ebee85121", "committedDate": "2020-08-16T13:02:21Z", "message": "[java] Don't add linkage errors as processing errors, just log"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4672, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}