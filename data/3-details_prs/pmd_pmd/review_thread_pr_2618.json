{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQwOTM3ODMy", "number": 2618, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjo1OToyNVrOEPOBWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowMjozNFrOEPOGEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0MzkzODE4OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedAssignmentRule.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNjo1OToyNVrOGy0Clg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzo1NzozNlrOGy2MBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNDYxNA==", "bodyText": "I think, we can use rule chain, then? I'll try it before I merge....", "url": "https://github.com/pmd/pmd/pull/2618#discussion_r455934614", "createdAt": "2020-07-16T16:59:25Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedAssignmentRule.java", "diffHunk": "@@ -0,0 +1,1343 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.rule.bestpractices;\n+\n+\n+import static net.sourceforge.pmd.lang.java.rule.codestyle.ConfusingTernaryRule.unwrapParentheses;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeBodyDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTAssignmentOperator;\n+import net.sourceforge.pmd.lang.java.ast.ASTBlock;\n+import net.sourceforge.pmd.lang.java.ast.ASTBlockStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTBreakStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTCatchStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;\n+import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.java.ast.ASTConditionalAndExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTConditionalExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTConditionalOrExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTContinueStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTDoStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTEnumBody;\n+import net.sourceforge.pmd.lang.java.ast.ASTExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTFinallyStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTForInit;\n+import net.sourceforge.pmd.lang.java.ast.ASTForStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTForUpdate;\n+import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\n+import net.sourceforge.pmd.lang.java.ast.ASTIfStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTInitializer;\n+import net.sourceforge.pmd.lang.java.ast.ASTLabeledStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTName;\n+import net.sourceforge.pmd.lang.java.ast.ASTPostfixExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTPreDecrementExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTPreIncrementExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n+import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.ASTResourceSpecification;\n+import net.sourceforge.pmd.lang.java.ast.ASTReturnStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTSwitchExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTSwitchLabel;\n+import net.sourceforge.pmd.lang.java.ast.ASTSwitchLabeledRule;\n+import net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTTryStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\n+import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\n+import net.sourceforge.pmd.lang.java.ast.ASTVariableInitializer;\n+import net.sourceforge.pmd.lang.java.ast.ASTWhileStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTYieldStatement;\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n+import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;\n+import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n+import net.sourceforge.pmd.lang.java.symboltable.ClassScope;\n+import net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\n+import net.sourceforge.pmd.lang.symboltable.Scope;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+\n+public class UnusedAssignmentRule extends AbstractJavaRule {\n+\n+    /*\n+        Detects unused assignments. This performs a reaching definition\n+        analysis. This makes the assumption that there is no dead code.\n+\n+        Since we have the reaching definitions at each variable usage, we\n+        could also use that to detect other kinds of bug, eg conditions\n+        that are always true, or dereferences that will always NPE. In\n+        the general case though, this is complicated and better left to\n+        a DFA library, eg google Z3.\n+\n+        This analysis may be used as-is to detect switch labels that\n+        fall-through, which could be useful to improve accuracy of other\n+        rules.\n+\n+        TODO\n+           * labels on arbitrary statements (currently only loops)\n+           * explicit ctor call (hard to impossible without type res,\n+             or at least proper graph algorithms like toposort)\n+                -> this is pretty invisible as it causes false negatives, not FPs\n+           * test ternary expr\n+\n+        DONE\n+           * conditionals\n+           * loops\n+           * switch\n+           * loop labels\n+           * try/catch/finally\n+           * lambdas\n+           * constructors + initializers\n+           * anon class\n+           * test this.field in ctors\n+           * foreach var should be reassigned from one iter to another\n+           * test local class/anonymous class\n+           * shortcut conditionals have their own control-flow\n+           * parenthesized expressions\n+           * conditional exprs in loops\n+           * ignore variables that start with 'ignore'\n+\n+     */\n+\n+    private static final PropertyDescriptor<Boolean> CHECK_PREFIX_INCREMENT =\n+        PropertyFactory.booleanProperty(\"checkUnusedPrefixIncrement\")\n+                       .desc(\"Report expressions like ++i that may be replaced with (i + 1)\")\n+                       .defaultValue(false)\n+                       .build();\n+\n+    private static final PropertyDescriptor<Boolean> REPORT_UNUSED_VARS =\n+        PropertyFactory.booleanProperty(\"reportUnusedVariables\")\n+                       .desc(\"Report variables that are only initialized, and never read at all. \"\n+                                 + \"The rule UnusedVariable already cares for that, but you can enable it if needed\")\n+                       .defaultValue(false)\n+                       .build();\n+\n+    public UnusedAssignmentRule() {\n+        definePropertyDescriptor(CHECK_PREFIX_INCREMENT);\n+        definePropertyDescriptor(REPORT_UNUSED_VARS);\n+    }\n+\n+    @Override\n+    public Object visit(ASTCompilationUnit node, Object data) {\n+        for (JavaNode child : node.children()) {\n+            if (child instanceof ASTTypeDeclaration) {\n+\n+                ASTAnyTypeDeclaration typeDecl = (ASTAnyTypeDeclaration) child.getChild(child.getNumChildren() - 1);\n+                GlobalAlgoState result = new GlobalAlgoState();\n+                typeDecl.jjtAccept(ReachingDefsVisitor.ONLY_LOCALS, new SpanInfo(result));\n+\n+                reportFinished(result, (RuleContext) data);\n+            }\n+        }\n+\n+        return data;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "556685de1b7e4e96f8c84388be7fa024f4a4d02f"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk2OTc5Ng==", "bodyText": "I've added the rule chain visit, but it probably doesn't make any difference anyway.", "url": "https://github.com/pmd/pmd/pull/2618#discussion_r455969796", "createdAt": "2020-07-16T17:57:36Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/bestpractices/UnusedAssignmentRule.java", "diffHunk": "@@ -0,0 +1,1343 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.rule.bestpractices;\n+\n+\n+import static net.sourceforge.pmd.lang.java.rule.codestyle.ConfusingTernaryRule.unwrapParentheses;\n+\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import net.sourceforge.pmd.RuleContext;\n+import net.sourceforge.pmd.lang.ast.Node;\n+import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeBodyDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTAssignmentOperator;\n+import net.sourceforge.pmd.lang.java.ast.ASTBlock;\n+import net.sourceforge.pmd.lang.java.ast.ASTBlockStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTBreakStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTCatchStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTClassOrInterfaceBody;\n+import net.sourceforge.pmd.lang.java.ast.ASTCompilationUnit;\n+import net.sourceforge.pmd.lang.java.ast.ASTConditionalAndExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTConditionalExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTConditionalOrExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTConstructorDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTContinueStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTDoStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTEnumBody;\n+import net.sourceforge.pmd.lang.java.ast.ASTExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTFieldDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTFinallyStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTForInit;\n+import net.sourceforge.pmd.lang.java.ast.ASTForStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTForUpdate;\n+import net.sourceforge.pmd.lang.java.ast.ASTFormalParameter;\n+import net.sourceforge.pmd.lang.java.ast.ASTIfStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTInitializer;\n+import net.sourceforge.pmd.lang.java.ast.ASTLabeledStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTLambdaExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTLocalVariableDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTMethodDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTName;\n+import net.sourceforge.pmd.lang.java.ast.ASTPostfixExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTPreDecrementExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTPreIncrementExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTPrimaryExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTPrimaryPrefix;\n+import net.sourceforge.pmd.lang.java.ast.ASTPrimarySuffix;\n+import net.sourceforge.pmd.lang.java.ast.ASTResourceSpecification;\n+import net.sourceforge.pmd.lang.java.ast.ASTReturnStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTStatementExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTSwitchExpression;\n+import net.sourceforge.pmd.lang.java.ast.ASTSwitchLabel;\n+import net.sourceforge.pmd.lang.java.ast.ASTSwitchLabeledRule;\n+import net.sourceforge.pmd.lang.java.ast.ASTSwitchStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTThrowStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTTryStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTTypeDeclaration;\n+import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclarator;\n+import net.sourceforge.pmd.lang.java.ast.ASTVariableDeclaratorId;\n+import net.sourceforge.pmd.lang.java.ast.ASTVariableInitializer;\n+import net.sourceforge.pmd.lang.java.ast.ASTWhileStatement;\n+import net.sourceforge.pmd.lang.java.ast.ASTYieldStatement;\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n+import net.sourceforge.pmd.lang.java.ast.JavaParserVisitorAdapter;\n+import net.sourceforge.pmd.lang.java.rule.AbstractJavaRule;\n+import net.sourceforge.pmd.lang.java.symboltable.ClassScope;\n+import net.sourceforge.pmd.lang.java.symboltable.VariableNameDeclaration;\n+import net.sourceforge.pmd.lang.symboltable.Scope;\n+import net.sourceforge.pmd.properties.PropertyDescriptor;\n+import net.sourceforge.pmd.properties.PropertyFactory;\n+\n+public class UnusedAssignmentRule extends AbstractJavaRule {\n+\n+    /*\n+        Detects unused assignments. This performs a reaching definition\n+        analysis. This makes the assumption that there is no dead code.\n+\n+        Since we have the reaching definitions at each variable usage, we\n+        could also use that to detect other kinds of bug, eg conditions\n+        that are always true, or dereferences that will always NPE. In\n+        the general case though, this is complicated and better left to\n+        a DFA library, eg google Z3.\n+\n+        This analysis may be used as-is to detect switch labels that\n+        fall-through, which could be useful to improve accuracy of other\n+        rules.\n+\n+        TODO\n+           * labels on arbitrary statements (currently only loops)\n+           * explicit ctor call (hard to impossible without type res,\n+             or at least proper graph algorithms like toposort)\n+                -> this is pretty invisible as it causes false negatives, not FPs\n+           * test ternary expr\n+\n+        DONE\n+           * conditionals\n+           * loops\n+           * switch\n+           * loop labels\n+           * try/catch/finally\n+           * lambdas\n+           * constructors + initializers\n+           * anon class\n+           * test this.field in ctors\n+           * foreach var should be reassigned from one iter to another\n+           * test local class/anonymous class\n+           * shortcut conditionals have their own control-flow\n+           * parenthesized expressions\n+           * conditional exprs in loops\n+           * ignore variables that start with 'ignore'\n+\n+     */\n+\n+    private static final PropertyDescriptor<Boolean> CHECK_PREFIX_INCREMENT =\n+        PropertyFactory.booleanProperty(\"checkUnusedPrefixIncrement\")\n+                       .desc(\"Report expressions like ++i that may be replaced with (i + 1)\")\n+                       .defaultValue(false)\n+                       .build();\n+\n+    private static final PropertyDescriptor<Boolean> REPORT_UNUSED_VARS =\n+        PropertyFactory.booleanProperty(\"reportUnusedVariables\")\n+                       .desc(\"Report variables that are only initialized, and never read at all. \"\n+                                 + \"The rule UnusedVariable already cares for that, but you can enable it if needed\")\n+                       .defaultValue(false)\n+                       .build();\n+\n+    public UnusedAssignmentRule() {\n+        definePropertyDescriptor(CHECK_PREFIX_INCREMENT);\n+        definePropertyDescriptor(REPORT_UNUSED_VARS);\n+    }\n+\n+    @Override\n+    public Object visit(ASTCompilationUnit node, Object data) {\n+        for (JavaNode child : node.children()) {\n+            if (child instanceof ASTTypeDeclaration) {\n+\n+                ASTAnyTypeDeclaration typeDecl = (ASTAnyTypeDeclaration) child.getChild(child.getNumChildren() - 1);\n+                GlobalAlgoState result = new GlobalAlgoState();\n+                typeDecl.jjtAccept(ReachingDefsVisitor.ONLY_LOCALS, new SpanInfo(result));\n+\n+                reportFinished(result, (RuleContext) data);\n+            }\n+        }\n+\n+        return data;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNDYxNA=="}, "originalCommit": {"oid": "556685de1b7e4e96f8c84388be7fa024f4a4d02f"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg0Mzk1MDI3OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/resources/category/java/bestpractices.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowMjozNFrOGy0KLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xNlQxNzowMjozNFrOGy0KLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNjU1OA==", "bodyText": "I'll try to make the rule names actual links. Hopefully the {% rule notation will work here....", "url": "https://github.com/pmd/pmd/pull/2618#discussion_r455936558", "createdAt": "2020-07-16T17:02:34Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/resources/category/java/bestpractices.xml", "diffHunk": "@@ -1298,6 +1298,120 @@ class Foo{\n         </example>\n     </rule>\n \n+    <rule name=\"UnusedAssignment\"\n+          language=\"java\"\n+          since=\"6.26.0\"\n+          message=\"The value assigned to this variable is never used or always overwritten\"\n+          class=\"net.sourceforge.pmd.lang.java.rule.bestpractices.UnusedAssignmentRule\"\n+          externalInfoUrl=\"${pmd.website.baseurl}/pmd_rules_java_bestpractices.html#unusedassignment\">\n+        <description>\n+            Reports assignments to variables that are never used before the variable is overwritten,\n+            or goes out of scope. Unused assignments are those for which\n+            1. The variable is never read after the assignment, or\n+            2. The assigned value is always overwritten by other assignments before the next read of\n+            the variable.\n+\n+            The rule doesn't consider assignments to fields except for those of `this` in a constructor,\n+            or static fields of the current class in static initializers.\n+\n+            The rule may be suppressed with the standard `@SuppressWarnings(\"unused\")` tag.\n+\n+            The rule subsumes UnusedLocalVariable, and UnusedFormalParameter. Those violations are filtered", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "556685de1b7e4e96f8c84388be7fa024f4a4d02f"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 442, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}