{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIwNTk2Nzgy", "number": 2917, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODozMjowNlrOE8koBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODo0NzozOFrOE8lAMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTUwMDg2OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeTestUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODozMjowNlrOH4xRaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODozMjowNlrOH4xRaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI4OTU3OQ==", "bodyText": "It might be better, to have the class InvocationMatcher in a separate file instead in TypeTestUtil.... something we can consider later, though. It's new API, so we can still move it around.", "url": "https://github.com/pmd/pmd/pull/2917#discussion_r529289579", "createdAt": "2020-11-24T08:32:06Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/TypeTestUtil.java", "diffHunk": "@@ -184,53 +218,309 @@ private static boolean isExactlyA(@NonNull Class<?> klass, @Nullable JTypeDeclSy\n         return symClass.getBinaryName().equals(klass.getName());\n     }\n \n+    /**\n+     * Returns true if the signature is that of a method declared in the\n+     * given class.\n+     *\n+     * @param klass Class\n+     * @param sig   Method signature to test\n+     *\n+     * @throws NullPointerException If any argument is null\n+     */\n+    public static boolean isDeclaredInClass(@NonNull Class<?> klass, @NonNull JMethodSig sig) {\n+        return isExactlyA(klass, sig.getDeclaringType().getSymbol());\n+    }\n+\n \n     /**\n      * Checks whether the static type of the node is exactly the type\n-     * given by the name. This ignores strict supertypes, and type arguments\n-     * if the type of the node is parameterized.\n-     *\n-     * <pre>{@code\n-     * isExactlyA(List.class, <new ArrayList<String>()>)      = false\n-     * isExactlyA(ArrayList.class, <new ArrayList<String>()>) = true\n-     * isExactlyA(int[].class, <new int[0]>)                  = true\n-     * isExactlyA(Object[].class, <new String[0]>)            = false\n-     * isExactlyA(_, null) = false\n-     * isExactlyA(null, _) = NullPointerException\n-     * }</pre>\n+     * given by the name. See {@link #isExactlyA(Class, TypeNode)} for\n+     * examples and more info.\n      *\n      * @param canonicalName a canonical name of a class or array type\n      * @param node          the type node to check\n      *\n      * @return true if the node is non-null and has the given type\n      *\n-     * @throws NullPointerException if the class name parameter is null\n+     * @throws NullPointerException     if the class name parameter is null\n+     * @throws IllegalArgumentException if the class name parameter is not a valid java binary name,\n+     *                                  eg it has type arguments\n+     * @see #isExactlyA(Class, TypeNode)\n      */\n     public static boolean isExactlyA(@NonNull String canonicalName, final @Nullable TypeNode node) {\n-        AssertionUtil.requireParamNotNull(\"canonicalName\", canonicalName);\n         if (node == null) {\n             return false;\n         }\n+        return isExactlyAOrAnon(canonicalName, node.getTypeMirror()) == OptionalBool.YES;\n+    }\n+\n+    private static OptionalBool isExactlyAOrAnon(@NonNull String canonicalName, final @NonNull JTypeMirror node) {\n+        AssertionUtil.requireParamNotNull(\"canonicalName\", canonicalName);\n \n-        JTypeDeclSymbol sym = node.getTypeMirror().getSymbol();\n+        JTypeDeclSymbol sym = node.getSymbol();\n         if (sym == null || sym instanceof JTypeParameterSymbol) {\n-            return false;\n+            return OptionalBool.NO;\n         }\n \n         canonicalName = StringUtils.deleteWhitespace(canonicalName);\n \n         JClassSymbol klass = (JClassSymbol) sym;\n         String canonical = klass.getCanonicalName();\n-        return canonical != null && canonical.equals(canonicalName);\n+        if (canonical == null) {\n+            return OptionalBool.UNKNOWN; // anonymous\n+        }\n+        return OptionalBool.definitely(canonical.equals(canonicalName));\n     }\n \n \n-\n     private static boolean hasNoSubtypes(Class<?> clazz) {\n         // Neither final nor an annotation. Enums & records have ACC_FINAL\n         // Note: arrays have ACC_FINAL, but have subtypes by covariance\n         // Note: annotations may be implemented by classes\n-        return Modifier.isFinal(clazz.getModifiers()) && !clazz.isArray();\n+        return Modifier.isFinal(clazz.getModifiers()) && !clazz.isArray() || clazz.isPrimitive();\n+    }\n+\n+\n+    /**\n+     * Matches a method or constructor call against a particular overload.\n+     * Use {@link #parse(String)} to create one. For example,\n+     *\n+     * <pre>\n+     *     java.lang.String#toString()   // match calls to toString on String instances\n+     *     _#toString()                  // match calls to toString on any receiver\n+     *     _#_()                         // match all calls to a method with no parameters\n+     *     _#toString(_*)                // match calls to a \"toString\" method with any number of parameters\n+     *     _#eq(_, _)                    // match calls to an \"eq\" method that has 2 parameters of unspecified type\n+     *     _#eq(java.lang.String, _)     // like the previous, but the first parameter must be String\n+     *     java.util.ArrayList#new(int)  // match constructor calls of this overload of the ArrayList constructor\n+     * </pre>\n+     *\n+     * <p>The receiver matcher (first half) is matched against the\n+     * static type of the <i>receiver</i> of the call, and not the\n+     * declaration site of the method, unless the called method is\n+     * static, or a constructor.\n+     *\n+     * <p>The parameters are matched against the declared parameters\n+     * types of the called overload, and not the actual argument types.\n+     * In particular, for vararg methods, the signature should mention\n+     * a single parameter, with an array type.\n+     *\n+     * <p>For example {@code Integer.valueOf('0')} will be matched by\n+     * {@code _#valueOf(int)} but not {@code _#valueOf(char)}, which is\n+     * an overload that does not exist (the char is widened to an int,\n+     * so the int overload is selected).\n+     *\n+     * <h5 id='ebnf'>Full EBNF grammar</h5>\n+     *\n+     * <p>(no whitespace is tolerated anywhere):\n+     * <pre>{@code\n+     * sig         ::= type '#' method_name param_list\n+     * type        ::= qname ( '[]' )* | '_'\n+     * method_name ::= '_' | ident | 'new'\n+     * param_list  ::= '(_*)' | '(' type (',' type )* ')'\n+     * qname       ::= java binary name\n+     * }</pre>\n+     */\n+    public static final class InvocationMatcher {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3651e66c126c801283dbcb3722a11483fbc7ce5c"}, "originalPosition": 296}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTUxODA3OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/NodeIsFunction.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODozNjo0OFrOH4xcfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODozNjo0OFrOH4xcfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5MjQxNQ==", "bodyText": "This provides the \"nodeIs\" function for java. The issue #1787 describes this actually as a general, core function, available for all languages. I think, it would be not too hard to port this class + BaseRewrittenFunction to core. But IMHO we should wait with that for later.\nTherefore I'll keep #1787 open, as it is only fixed for java.", "url": "https://github.com/pmd/pmd/pull/2917#discussion_r529292415", "createdAt": "2020-11-24T08:36:48Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/NodeIsFunction.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.rule.xpath.internal;\n+\n+import net.sourceforge.pmd.lang.java.ast.JavaNode;\n+\n+import net.sf.saxon.trans.XPathException;\n+\n+public final class NodeIsFunction extends BaseRewrittenFunction<Class<?>, JavaNode> {\n+\n+    public static final NodeIsFunction INSTANCE = new NodeIsFunction();\n+\n+    private NodeIsFunction() {\n+        super(\"nodeIs\", JavaNode.class);\n+    }\n+\n+    @Override\n+    protected Class<?> parseArgument(String constantArg) throws XPathException {\n+        try {\n+            return Class.forName(\"net.sourceforge.pmd.lang.java.ast.AST\" + constantArg);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3651e66c126c801283dbcb3722a11483fbc7ce5c"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTU0NzAwOnYy", "diffSide": "RIGHT", "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/BaseXPathFunctionTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODo0Mzo1NlrOH4xuYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODo0Mzo1NlrOH4xuYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5Njk5NQ==", "bodyText": "7.0.0 \ud83d\ude04", "url": "https://github.com/pmd/pmd/pull/2917#discussion_r529296995", "createdAt": "2020-11-24T08:43:56Z", "author": {"login": "adangel"}, "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/rule/xpath/internal/BaseXPathFunctionTest.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.rule.xpath.internal;\n+\n+import static org.hamcrest.CoreMatchers.equalTo;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import java.util.function.Consumer;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.junit.Assert;\n+\n+import net.sourceforge.pmd.Report;\n+import net.sourceforge.pmd.Rule;\n+import net.sourceforge.pmd.lang.LanguageRegistry;\n+import net.sourceforge.pmd.lang.ast.test.TestUtilsKt;\n+import net.sourceforge.pmd.lang.java.JavaLanguageModule;\n+import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\n+import net.sourceforge.pmd.lang.rule.XPathRule;\n+import net.sourceforge.pmd.lang.rule.xpath.PmdXPathException;\n+import net.sourceforge.pmd.lang.rule.xpath.XPathVersion;\n+\n+/**\n+ * @author Cl\u00e9ment Fournier\n+ * @since 6.0.0", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3651e66c126c801283dbcb3722a11483fbc7ce5c"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxOTU2Mjc0OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/InvocationMatcherTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODo0NzozOFrOH4x3zA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwODo0NzozOFrOH4x3zA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTI5OTQwNA==", "bodyText": "Is this still needed, since you use already assertThrows?", "url": "https://github.com/pmd/pmd/pull/2917#discussion_r529299404", "createdAt": "2020-11-24T08:47:38Z", "author": {"login": "adangel"}, "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/types/InvocationMatcherTest.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.types;\n+\n+import static net.sourceforge.pmd.lang.java.types.TypeTestUtil.InvocationMatcher.parse;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+import org.hamcrest.MatcherAssert;\n+import org.junit.Assert;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+\n+import net.sourceforge.pmd.lang.java.ast.ASTConstructorCall;\n+import net.sourceforge.pmd.lang.java.ast.ASTMethodCall;\n+import net.sourceforge.pmd.lang.java.ast.InvocationNode;\n+import net.sourceforge.pmd.lang.java.symboltable.BaseNonParserTest;\n+\n+public class InvocationMatcherTest extends BaseNonParserTest {\n+\n+    @Rule\n+    public final ExpectedException expect = ExpectedException.none();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3651e66c126c801283dbcb3722a11483fbc7ce5c"}, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 204, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}