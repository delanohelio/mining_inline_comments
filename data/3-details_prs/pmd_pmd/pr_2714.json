{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY3NTc1ODM0", "number": 2714, "title": "[java] Support JDK 15", "bodyText": "Describe the PR\nUpdate PMD Java to support Java 15.\nRelated issues\n\nFixes #2646\n\nReady?\n\n\n Added unit tests for fixed bug/feature\n Passing all unit tests\n Complete build ./mvnw clean verify passes (checked automatically by travis)\n Added (in-code) documentation (if needed)", "createdAt": "2020-08-13T18:56:52Z", "url": "https://github.com/pmd/pmd/pull/2714", "merged": true, "mergeCommit": {"oid": "04850c69bc2002aeef4dbd778771cd0d8fa4ba91"}, "closed": true, "closedAt": "2020-08-22T17:42:47Z", "author": {"login": "adangel"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc-jRXfAH2gAyNDY3NTc1ODM0OjAyYTc4ZjViZWEwMTg5ZmJmOWUyNWIzODNhOWRmMThmMjk0NGY2YjA=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdBXZs9gFqTQ3MjkxODk1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "02a78f5bea0189fbf9e25b383a9df18f2944f6b0", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/02a78f5bea0189fbf9e25b383a9df18f2944f6b0", "committedDate": "2020-08-13T17:15:02Z", "message": "[java] Add versions 15 (new default) and 15-preview, remove 13-preview"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2a2fa20883f6d24df5e901967bd3b0297edb5182", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/2a2fa20883f6d24df5e901967bd3b0297edb5182", "committedDate": "2020-08-13T17:29:45Z", "message": "[java] Update ASM for bytecode parsing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "40f0eedf888e8cca1218903bdfe59c3f47ad89bc", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/40f0eedf888e8cca1218903bdfe59c3f47ad89bc", "committedDate": "2020-08-13T18:05:54Z", "message": "[java] Text Blocks are now a permanent language feature with JDK 15"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e596a6729789aec7c4b0dedd0f691657f246100a", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/e596a6729789aec7c4b0dedd0f691657f246100a", "committedDate": "2020-08-13T18:11:25Z", "message": "[java] Support Pattern Matching for instanceof with Java 15 Preview."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e51519c5fd90216c85b51e1fa0c2d39c13ecaaf8", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/e51519c5fd90216c85b51e1fa0c2d39c13ecaaf8", "committedDate": "2020-08-13T18:42:08Z", "message": "[java] Support Records with Java 15 Preview"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0a297329098eb7d5f5ff9d31b1bc3ddb4ce6af00", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/0a297329098eb7d5f5ff9d31b1bc3ddb4ce6af00", "committedDate": "2020-08-13T18:54:34Z", "message": "Fix Kotlin Tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4d2853ccc4377aaf8944d02937342f46c7efca43", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/4d2853ccc4377aaf8944d02937342f46c7efca43", "committedDate": "2020-08-14T16:55:00Z", "message": "[java] Add support for local records (Java 15 Preview)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cda155891ac20af53d6c550b254a91675935d6d2", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/cda155891ac20af53d6c550b254a91675935d6d2", "committedDate": "2020-08-14T18:56:26Z", "message": "[java] Add ugly lookahead for local record declarations\n\nso that it can be distinguished from local var decl or other\nstatements."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0d9b5a7c3b27063d4393de62d123d9ce3208d682", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/0d9b5a7c3b27063d4393de62d123d9ce3208d682", "committedDate": "2020-08-14T20:16:41Z", "message": "[java] Support Sealed Classes with Java 15 Preview"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b159f389a9614a88cf80038a9bd57af6c8bab0f", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/8b159f389a9614a88cf80038a9bd57af6c8bab0f", "committedDate": "2020-08-14T20:20:40Z", "message": "[java] Remove Experimental for TextBlocks, Update javadoc for Java15 Preview"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/28aaeefdd95fae504a57b88f54e36943dbf761c1", "committedDate": "2020-08-14T20:26:54Z", "message": "[doc] Update release notes, fixes #2646"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3OTI3NzI5", "url": "https://github.com/pmd/pmd/pull/2714#pullrequestreview-467927729", "createdAt": "2020-08-15T00:07:35Z", "commit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMDowNzozNVrOHBGISw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0xNVQwMTozNzozOVrOHBGzvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxMTA1MQ==", "bodyText": "I'm not sure this works. non - sealed is a valid subtraction expression, even without the spaces, and should remain so. By the maximal munch rule, this token would match  the expression non-sealed, and also cut the identifier if the second variable name is longer: tokenizing non-sealedNumber as [non-sealed, Number] instead of [non, -, sealedNumber]\nAnyway, one solution would be to match this as three tokens in a production. Eg something like\nvoid Modifiers(): {} {\n( \"public\"\n| ...\n|  LOOKAHEAD({isNonSealedMod()}) <IDENTIFIER> \"-\" <IDENTIFIER>\n)*\n}\n\n// in the java\n\n    boolean isToken(int index, int kind) {\n        return getToken(index).kind == kind;\n    }\n    \n    boolean isKeyword(int index, String image) {\n        Token tok = getToken(index);\n        return tok.kind == IDENTIFIER && tok.getImage().equals(image);\n    }\n    \n    // matches \"non-$name\"\n    boolean isNonSealedMod() {\n        return isKeyword(1, \"non\")\n            && isToken(2, MINUS)\n            && isKeyword(3, \"sealed\");\n    }\n\nI'm not sure how to constrain this so that there is no space between the tokens. Maybe just comparing columns", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470911051", "createdAt": "2020-08-15T00:07:35Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -980,6 +1024,14 @@ TOKEN :\n | < GT: \">\" >\n }\n \n+// Note: New token need to be added at the very end in order to\n+// keep (binary) compatibility with the generated token ids\n+// see JavaParserConstants\n+TOKEN :\n+{\n+  < NON_SEALED: \"non-sealed\" >", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNDE4Mg==", "bodyText": "I don't like this very much. There may be an arbitrary amount of annotations before the record. See my comment in BlockStatement", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470914182", "createdAt": "2020-08-15T00:28:44Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -432,45 +449,66 @@ public class JavaParser {\n    */\n   private boolean inSwitchLabel = false;\n \n-  private boolean isJava13PreviewOr14() {\n-      return jdkVersion >= 14 || jdkVersion >= 13 && preview;\n-  }\n-\n   private void checkForSwitchRules() {\n-    if (!isJava13PreviewOr14()) {\n-      throwParseException(\"Switch rules in switch statements are only supported with Java 13 Preview, or Java >= 14\");\n+    if (jdkVersion < 14) {\n+      throwParseException(\"Switch rules in switch statements are only supported with Java >= 14\");\n     }\n   }\n   private void checkForSwitchExpression() {\n-    if (!isJava13PreviewOr14()) {\n-      throwParseException(\"Switch expressions are only supported with Java 13 Preview, or Java >= 14\");\n+    if (jdkVersion < 14) {\n+      throwParseException(\"Switch expressions are only supported with Java >= 14\");\n     }\n   }\n \n   private void checkForYieldStatement() {\n-    if (!isJava13PreviewOr14()) {\n-      throwParseException(\"Yield statements are only supported with Java 13 Preview or Java >= 14\");\n+    if (jdkVersion < 14) {\n+      throwParseException(\"Yield statements are only supported with Java >= 14\");\n     }\n   }\n \n   private void checkForTextBlockLiteral() {\n-    if (jdkVersion != 13 && jdkVersion != 14 || !preview) {\n-      throwParseException(\"Text block literals are only supported with Java 13 Preview or Java 14 Preview\");\n+    if (jdkVersion < 15 && !preview) {\n+      throwParseException(\"Text block literals are only supported with Java 14 Preview and Java >= 15\");\n     }\n   }\n \n   private void checkForNewStringSpaceEscape(String s) {\n-    if ((jdkVersion != 14 || !preview) && s.contains(\"\\\\s\") && !s.contains(\"\\\\\\\\s\")) {\n-      throwParseException(\"The escape sequence \\\"\\\\s\\\" is only supported with Java 14 Preview\");\n+    if ((jdkVersion < 15 && !preview) && s.contains(\"\\\\s\") && !s.contains(\"\\\\\\\\s\")) {\n+      throwParseException(\"The escape sequence \\\"\\\\s\\\" is only supported with Java 14 Preview and Java >= 15\");\n     }\n   }\n \n   private void checkForRecordType() {\n-    if (jdkVersion != 14 || !preview) {\n-      throwParseException(\"Records are only supported with Java 14 Preview\");\n+    if (!isRecordTypeSupported()) {\n+      throwParseException(\"Records are only supported with Java 14 Preview and Java 15 Preview\");\n+    }\n+  }\n+\n+  private boolean isRecordTypeSupported() {\n+    return (jdkVersion == 14 || jdkVersion == 15) && preview;\n+  }\n+\n+  private boolean isRecordDeclarationAhead() {\n+    int amount = 1;\n+    while (amount < 10) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNDUzOA==", "bodyText": "Maybe rename this to LocalTypeDecl.\nThe javac parser names this production classOrRecordOrInterfaceOrEnumDeclaration... your pick", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470914538", "createdAt": "2020-08-15T00:31:13Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1879,22 +1949,25 @@ void BlockStatement():\n   LOOKAHEAD( { isNextTokenAnAssert() } ) AssertStatement()\n | LOOKAHEAD( { isYieldStart() } ) YieldStatement()\n |\n-  LOOKAHEAD(( \"final\" | Annotation() )* Type() <IDENTIFIER>)\n+  LOOKAHEAD(2147483647, ( \"final\" | Annotation() )* Type() <IDENTIFIER>, {isRecordTypeSupported() && !isRecordDeclarationAhead() || !isRecordTypeSupported()})\n   LocalVariableDeclaration() \";\"\n |\n+  LOOKAHEAD(1, {isRecordTypeSupported() && !isRecordDeclarationAhead() || !isRecordTypeSupported()})\n   Statement()\n |\n   // we don't need to lookahead further here\n   // the ambiguity between start of local class and local variable decl\n-  // is already handled in the lookahead guarding LocalVariableDeclaration above.\n-  LocalClassDecl()\n+  // and start of local record and local variable decl or statement\n+  // is already handled in the lookahead guarding LocalVariableDeclaration\n+  // and Statement above.\n+  LocalClassOrRecordDecl()\n }\n \n-void LocalClassDecl() #void:\n+void LocalClassOrRecordDecl() #void:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkxNjQxNw==", "bodyText": "The lookaheads would be easier if this was lifted to BlockStatement to dominate both LocalVariableDeclaration and this production. But you'll maybe have to define an auxilliary LocalVariableDeclaration that has no modifiers. So it would allow local variables to have disallowed modifiers, but it's already the case for all other declarations, and it's not like we care anywhere", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470916417", "createdAt": "2020-08-15T00:45:55Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1903,7 +1976,11 @@ void LocalClassDecl() #void:\n     // In particular, it unfortunately allows local class declarations to start\n     // with a \"default\" modifier, which introduces an ambiguity with default\n     // switch labels. This is guarded by a custom lookahead around SwitchLabel\n-    mods=Modifiers() ClassOrInterfaceDeclaration(mods)\n+    mods=Modifiers()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMTc0Mg==", "bodyText": "These lookaheads seem a bit too complicated, and isRecordStart is limited to 10 tokens. We could simplify it that way (looking into the javac parser):\n\nIf the statement starts with @ of final, then what follows is necessarily a local declaration (variable or type). We can parse modifiers for both, and then parse the rest of the declaration.\n\nAfter modifiers, the check isRecordStart() is O(1), as it just tests for \"record\" <IDENTIFIER>. It doesn't require a lookahead limit\n\n\nIf the statement starts with an identifier, we must differentiate between several special identifiers (all of which are somewhat conditioned by jdk version + following tokens)\n\nnon-sealed. This is a semantic error, but for resilience, we can still parse Modifiers() LocalTypeDecl()\nrecord -> RecordDeclaration()\nenum -> EnumDeclaration()\nassert -> AssertStatement()\nyield -> YieldStatement()\nanything else:\n\nLookeahead for ClassOrInterfaceType() <IDENTIFIER> -> local variable declaration\n\nOtherwise, either labeled statement or statement expression (both are in Statement)\n\n\n\n\n\n\nIf the statement starts with any modifier token other than final, eg public, then what follows is Modifiers() LocalTypeDecl()\nIf the statement starts with a primitive type token, we must lookahead for Type() <IDENTIFIER> and parse a local variable declaration\nIf the statement starts with anything else, Statement will catch it", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470921742", "createdAt": "2020-08-15T01:33:31Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1879,22 +1949,25 @@ void BlockStatement():\n   LOOKAHEAD( { isNextTokenAnAssert() } ) AssertStatement()\n | LOOKAHEAD( { isYieldStart() } ) YieldStatement()\n |\n-  LOOKAHEAD(( \"final\" | Annotation() )* Type() <IDENTIFIER>)\n+  LOOKAHEAD(2147483647, ( \"final\" | Annotation() )* Type() <IDENTIFIER>, {isRecordTypeSupported() && !isRecordDeclarationAhead() || !isRecordTypeSupported()})", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 214}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDkyMjE3Mw==", "bodyText": "Do we need to continue writing grammar tests this way? This is really inferior to the kotlin tests, and hard to update to java-grammar...", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r470922173", "createdAt": "2020-08-15T01:37:39Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/ast/Java15PreviewTest.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import java.util.List;\n+\n+import org.junit.Assert;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+\n+import net.sourceforge.pmd.lang.ast.ParseException;\n+import net.sourceforge.pmd.lang.java.JavaParsingHelper;\n+import net.sourceforge.pmd.lang.java.ast.ASTAnyTypeBodyDeclaration.DeclarationKind;\n+\n+public class Java15PreviewTest {\n+    private final JavaParsingHelper java15p =\n+            JavaParsingHelper.WITH_PROCESSING.withDefaultVersion(\"15-preview\")\n+                                             .withResourceContext(Java15PreviewTest.class, \"jdkversiontests/java15p/\");\n+\n+    private final JavaParsingHelper java15 = java15p.withDefaultVersion(\"15\");\n+\n+    @Test\n+    public void patternMatchingInstanceof() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"PatternMatchingInstanceof.java\");\n+        List<ASTInstanceOfExpression> instanceOfExpressions = compilationUnit.findDescendantsOfType(ASTInstanceOfExpression.class);\n+        Assert.assertEquals(4, instanceOfExpressions.size());\n+        for (ASTInstanceOfExpression expr : instanceOfExpressions) {\n+            Assert.assertTrue(expr.getChild(1) instanceof ASTTypeTestPattern);\n+            ASTVariableDeclaratorId variable = expr.getChild(1).getFirstChildOfType(ASTVariableDeclaratorId.class);\n+            Assert.assertEquals(String.class, variable.getType());\n+            Assert.assertEquals(\"s\", variable.getVariableName());\n+            Assert.assertTrue(variable.isPatternBinding());\n+            Assert.assertTrue(variable.isFinal());\n+            // Note: these variables are not part of the symbol table\n+            // See ScopeAndDeclarationFinder#visit(ASTVariableDeclaratorId, Object)\n+            Assert.assertNull(variable.getNameDeclaration());\n+        }\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void patternMatchingInstanceofBeforeJava15PreviewShouldFail() {\n+        java15.parseResource(\"PatternMatchingInstanceof.java\");\n+    }\n+\n+    @Test\n+    public void recordPoint() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"Point.java\");\n+        ASTRecordDeclaration recordDecl = compilationUnit.getFirstDescendantOfType(ASTRecordDeclaration.class);\n+        Assert.assertEquals(\"Point\", recordDecl.getImage());\n+        Assert.assertFalse(recordDecl.isNested());\n+        Assert.assertFalse(recordDecl.isLocal());\n+        Assert.assertTrue(\"Records are implicitly always final\", recordDecl.isFinal());\n+        List<ASTRecordComponent> components = recordDecl.getFirstChildOfType(ASTRecordComponentList.class)\n+                                                        .findChildrenOfType(ASTRecordComponent.class);\n+        Assert.assertEquals(2, components.size());\n+        Assert.assertEquals(\"x\", components.get(0).getVarId().getImage());\n+        Assert.assertEquals(\"y\", components.get(1).getVarId().getImage());\n+        Assert.assertNull(components.get(0).getVarId().getNameDeclaration().getAccessNodeParent());\n+        Assert.assertEquals(Integer.TYPE, components.get(0).getVarId().getNameDeclaration().getType());\n+        Assert.assertEquals(\"int\", components.get(0).getVarId().getNameDeclaration().getTypeImage());\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordPointBeforeJava15PreviewShouldFail() {\n+        java15.parseResource(\"Point.java\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordCtorWithThrowsShouldFail() {\n+        java15p.parse(\"  record R {\"\n+                          + \"   R throws IOException {}\"\n+                          + \"  }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    public void recordMustNotExtend() {\n+        java15p.parse(\"record RecordEx(int x) extends Number { }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    @Ignore(\"Should we check this?\")\n+    public void recordCannotBeAbstract() {\n+        java15p.parse(\"abstract record RecordEx(int x) { }\");\n+    }\n+\n+    @Test(expected = ParseException.class)\n+    @Ignore(\"Should we check this?\")\n+    public void recordCannotHaveInstanceFields() {\n+        java15p.parse(\"record RecordFields(int x) { private int y = 1; }\");\n+    }\n+\n+    @Test\n+    public void innerRecords() {\n+        ASTCompilationUnit compilationUnit = java15p.parseResource(\"Records.java\");\n+        List<ASTRecordDeclaration> recordDecls = compilationUnit.findDescendantsOfType(ASTRecordDeclaration.class, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "28aaeefdd95fae504a57b88f54e36943dbf761c1"}, "originalPosition": 97}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fceb474df00cbdf456b488188076d73b2d4c37b7", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/fceb474df00cbdf456b488188076d73b2d4c37b7", "committedDate": "2020-08-16T16:22:45Z", "message": "[java] Remove \"non-sealed\" token and use semantic lookahead instead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "67b37de334fedd97bcefa8bb62c6318b56e82338", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/67b37de334fedd97bcefa8bb62c6318b56e82338", "committedDate": "2020-08-16T19:42:36Z", "message": "[java] Rework BlockStatement to allow local interfaces, enums, ..."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "04850c69bc2002aeef4dbd778771cd0d8fa4ba91", "author": {"user": {"login": "adangel", "name": "Andreas Dangel"}}, "url": "https://github.com/pmd/pmd/commit/04850c69bc2002aeef4dbd778771cd0d8fa4ba91", "committedDate": "2020-08-19T16:54:00Z", "message": "[java] Rework tests for Java 15 and Java 15 Preview"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcyOTE4OTU3", "url": "https://github.com/pmd/pmd/pull/2714#pullrequestreview-472918957", "createdAt": "2020-08-22T11:03:17Z", "commit": {"oid": "04850c69bc2002aeef4dbd778771cd0d8fa4ba91"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxMTowMzoxN1rOHFEhpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0yMlQxMTowMzoxN1rOHFEhpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTA3OTA3OA==", "bodyText": "Maybe, this node should be renamed to ASTPermitsList. On the java-grammar branch we already have many kinds of *List: ExtendsList, ImplementsList, ArgumentsList, ThrowsList, ResourceList, etc. Those extend ASTList. The relation to ASTList will probably be more obvious if this node also ends with \"List\".", "url": "https://github.com/pmd/pmd/pull/2714#discussion_r475079078", "createdAt": "2020-08-22T11:03:17Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTPermittedSubclasses.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import java.util.Iterator;\n+\n+import net.sourceforge.pmd.annotation.Experimental;\n+\n+\n+/**\n+ * Represents the {@code permits} clause of a (sealed) class declaration.\n+ *\n+ * <p>This is a Java 15 Preview feature.\n+ *\n+ * <p>See https://openjdk.java.net/jeps/360\n+ *\n+ * <pre class=\"grammar\">\n+ *  PermittedSubclasses ::= \"permits\" (TypeAnnotation)* ClassOrInterfaceType\n+ *                ( \",\" (TypeAnnotation)* ClassOrInterfaceType )*\n+ * </pre>\n+ */\n+@Experimental\n+public final class ASTPermittedSubclasses extends AbstractJavaNode implements Iterable<ASTClassOrInterfaceType> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04850c69bc2002aeef4dbd778771cd0d8fa4ba91"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4691, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}