{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYxMTAzOTM2", "number": 2689, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwODo0Njo1N1rOEf45Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo0MjoxNVrOEihxng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAxODczNDE1OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExplicitConstructorInvocation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwODo0Njo1N1rOHMcivA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wM1QwOToxODowN1rOHMdxOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgxMjYwNA==", "bodyText": "I think, we should be careful to add such side effects.... getTypeMirror() sounds innocent, but obviously it calls back setOverload... so it really does resolve types+overloads and then returns the resolved type... that's probably a result of doing lazy typeres, isn't it?\nbtw: this method throw a NPE, if no overloadselectionresult could be resolved, but the previous class returns null (with an assert check). Is this intended?", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r482812604", "createdAt": "2020-09-03T08:46:57Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExplicitConstructorInvocation.java", "diffHunk": "@@ -96,4 +100,15 @@ public ASTTypeArguments getExplicitTypeArguments() {\n     public ASTExpression getQualifier() {\n         return AstImplUtil.getChildAs(this, 0, ASTExpression.class);\n     }\n+\n+    @Override\n+    public OverloadSelectionResult getOverloadSelectionInfo() {\n+        getTypeMirror(); // force evaluation", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5bb0079ff9025ece1c0b2e69e91e72012774e337"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgzMjY5Ng==", "bodyText": "getTypeMirror() sounds innocent, but obviously it calls back setOverload... so it really does resolve types+overloads and then returns the resolved type... that's probably a result of doing lazy typeres, isn't it?\n\nYes, the only entry point to trigger lazy typeres is getTypeMirror. For invocation nodes, this will start an overload resolution, as in the general case, this is the only way to get the return type of a method for example. The \"good\" thing about using getTypeMirror to force the evaluation, is that it is already guarded and will execute at most once. We could have another method forceTypeRes, just to make the intention clearer..\n\nbtw: this method throw a NPE, if no overloadselectionresult could be resolved, but the previous class returns null (with an assert check). Is this intended?\n\nNormally even if no overload can be found, setOverload will be set anyway with a failed (but non-null) result. So it would be a bug if it was null after overload resolution. We can probably be more consistent with what exceptions we use (whether NPE or assert)...\nHere is the logic that sets the overload selection info (where NO_CTDECL is the sentinel for a failed overload selection):\nhttps://github.com/pmd/pmd/pull/2689/files#diff-d86db01bfc649e5de55423a6d27f09c1R165", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r482832696", "createdAt": "2020-09-03T09:18:07Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTExplicitConstructorInvocation.java", "diffHunk": "@@ -96,4 +100,15 @@ public ASTTypeArguments getExplicitTypeArguments() {\n     public ASTExpression getQualifier() {\n         return AstImplUtil.getChildAs(this, 0, ASTExpression.class);\n     }\n+\n+    @Override\n+    public OverloadSelectionResult getOverloadSelectionInfo() {\n+        getTypeMirror(); // force evaluation", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjgxMjYwNA=="}, "originalCommit": {"oid": "5bb0079ff9025ece1c0b2e69e91e72012774e337"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTQ0MzgwOnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypeNode.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODozNToyMVrOHQTqcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODozNToyMVrOHQTqcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2MTQyNw==", "bodyText": "Maybe deprecated until PMD 7?\nI like the fact, that PMD now doesn't load the classes anymore, very much, good job!", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r486861427", "createdAt": "2020-09-11T08:35:21Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/TypeNode.java", "diffHunk": "@@ -4,36 +4,55 @@\n \n package net.sourceforge.pmd.lang.java.ast;\n \n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.checkerframework.checker.nullness.qual.Nullable;\n \n-import net.sourceforge.pmd.lang.java.typeresolution.typedefinition.JavaTypeDefinition;\n+import net.sourceforge.pmd.lang.java.types.JTypeMirror;\n+import net.sourceforge.pmd.lang.java.types.TypeSystem;\n \n /**\n- * This interface allows a Java Class to be associated with a node.\n+ * A node that has a statically known type. This includes e.g.\n+ * {@linkplain ASTType type}s, which are explicitly written types,\n+ * and {@linkplain ASTExpression expressions}, whose types is determined\n+ * from their form, or through type inference.\n  */\n public interface TypeNode extends JavaNode {\n \n     /**\n-     * Get the Java Class associated with this node.\n+     * Returns the compile-time type of this node. For example, for a\n+     * string literal, returns the type mirror for {@link String}, for\n+     * a method call, returns the return type of the call, etc.\n      *\n-     * @return The Java Class, may return <code>null</code>.\n+     * <p>This method ignores conversions applied to the value of the\n+     * node because of its context. For example, in {@code 1 + \"\"}, the\n+     * numeric literal will have type {@code int}, but it is converted\n+     * to {@code String} by the surrounding concatenation expression.\n+     * Similarly, in {@code Collections.singletonList(1)}, the {@link ASTNumericLiteral}\n+     * node has type {@code int}, but the type of the method formal is\n+     * {@link Integer}, and boxing is applied at runtime. Possibly, an\n+     * API will be added to expose this information.\n+     *\n+     * @return The type mirror. Never returns null; if the type is unresolved, returns\n+     *         {@link TypeSystem#UNKNOWN}.\n      */\n-    @Nullable\n-    default Class<?> getType() {\n-        JavaTypeDefinition td = getTypeDefinition();\n-        return td == null ? null : td.getType();\n-    }\n+    @NonNull\n+    JTypeMirror getTypeMirror();\n \n \n     /**\n-     * Get the TypeDefinition associated with this node. The Class object\n-     * contained in the TypeDefinition will always be equal to that which\n-     * is returned by <code>getType()</code>.\n+     * Get the Java Class associated with this node.\n+     *\n+     * @return The Java Class, may return <code>null</code>.\n      *\n-     * @return The TypeDefinition, may return <code>null</code>\n+     * @deprecated This doesn't work. PMD doesn't load classes, it just\n+     *         reads the bytecode. Compare the symbol of the {@link #getTypeMirror() type mirror}\n+     *         instead.\n      */\n     @Nullable\n-    JavaTypeDefinition getTypeDefinition();\n+    @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTQ3Njc4OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/TypeResTestRule.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODo0NDoyMFrOHQT-ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwODo0NDoyMFrOHQT-ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2NjU1NQ==", "bodyText": "Maybe we could move this later to package \"internal\" - security doesn't seem to fit. Maybe a ruleset/category \"diagnostics\" is a better name?", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r486866555", "createdAt": "2020-09-11T08:44:20Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/rule/security/TypeResTestRule.java", "diffHunk": "@@ -0,0 +1,138 @@\n+/**\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.rule.security;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTYxNDc0OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/ClassTypeResolver.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOToxMTozMlrOHQVa8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOToxMTozMlrOHQVa8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg5MDIyNQ==", "bodyText": "DeprecatedUntil700", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r486890225", "createdAt": "2020-09-11T09:11:32Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/typeresolution/ClassTypeResolver.java", "diffHunk": "@@ -94,1348 +15,23 @@\n // http://java.sun.com/docs/books/jls/second_edition/html/conversions.doc.html\n //\n \n+/**\n+ * @deprecated Some rules still use this so we keep it around, but it's dysfunctional\n+ */\n @Deprecated", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTY2MDMyOnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeMirror.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOToxOTozMFrOHQV6Kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMzozNzo0MFrOHQfLuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg5ODIxOQ==", "bodyText": "Should we allow this in the future - TypesFromReflection? I think, we should remove this possibility in the end to avoid mixing auxclasspath and PMD's runtime classpath...", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r486898219", "createdAt": "2020-09-11T09:19:30Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeMirror.java", "diffHunk": "@@ -0,0 +1,449 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.types;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+import net.sourceforge.pmd.annotation.Experimental;\n+import net.sourceforge.pmd.lang.java.ast.TypeNode;\n+import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\n+import net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\n+import net.sourceforge.pmd.lang.java.types.TypeOps.Convertibility;\n+import net.sourceforge.pmd.lang.java.types.internal.infer.InferenceVar;\n+\n+/**\n+ * Type mirrors represent Java types. They are created by a {@link TypeSystem}\n+ * from {@link JTypeDeclSymbol symbols}, a layer of abstraction above reflection\n+ * classes.\n+ *\n+ * <p>Type mirrors can be obtained {@linkplain TypesFromReflection from reflected types},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzA1MDE2OA==", "bodyText": "Actually I think TypesFromReflection doesn't use the Class instances directly. It will ask the TypeSystem to resolve the class name, and gives up if that class is not on the classpath of the typesystem.\nThis is a remnant of an early version of the framework, where it was still using the reflected symbol implementation and not ASM. So this was effectively depended on by the reflected symbol implementation to get the type of eg a method parameter, and was important.\nI figured, if we keep it we can build complex types with eg typeSystem.fromReflect(new TypeLiteral<List<String>>() { }) (which would produce the type for List<String>) without having to go through hoops with parameterize and such. But it's not a crucial piece of the framework and could be removed. I think, we should decide when we try to port rules, to see if it carries its weight.", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r487050168", "createdAt": "2020-09-11T13:37:40Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/JTypeMirror.java", "diffHunk": "@@ -0,0 +1,449 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.types;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+\n+import net.sourceforge.pmd.annotation.Experimental;\n+import net.sourceforge.pmd.lang.java.ast.TypeNode;\n+import net.sourceforge.pmd.lang.java.symbols.JClassSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JExecutableSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JMethodSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JTypeDeclSymbol;\n+import net.sourceforge.pmd.lang.java.symbols.JTypeParameterSymbol;\n+import net.sourceforge.pmd.lang.java.types.JPrimitiveType.PrimitiveTypeKind;\n+import net.sourceforge.pmd.lang.java.types.TypeOps.Convertibility;\n+import net.sourceforge.pmd.lang.java.types.internal.infer.InferenceVar;\n+\n+/**\n+ * Type mirrors represent Java types. They are created by a {@link TypeSystem}\n+ * from {@link JTypeDeclSymbol symbols}, a layer of abstraction above reflection\n+ * classes.\n+ *\n+ * <p>Type mirrors can be obtained {@linkplain TypesFromReflection from reflected types},", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg5ODIxOQ=="}, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 33}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NTcwMzc0OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/Lub.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOToyNzowM1rOHQWYiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQwOToyNzowM1rOHQWYiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkwNTk5Mw==", "bodyText": "I had to lookup what \"Lub\" stands for - we should at least mention it once in full for me \ud83d\ude04 : Least Upper Bound", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r486905993", "createdAt": "2020-09-11T09:27:03Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/types/Lub.java", "diffHunk": "@@ -0,0 +1,453 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+package net.sourceforge.pmd.lang.java.types;\n+\n+import static net.sourceforge.pmd.lang.java.types.TypeOps.typeArgContains;\n+import static net.sourceforge.pmd.util.OptionalBool.NO;\n+import static net.sourceforge.pmd.util.OptionalBool.UNKNOWN;\n+import static net.sourceforge.pmd.util.OptionalBool.YES;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Set;\n+\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.pcollections.ConsPStack;\n+import org.pcollections.HashTreePSet;\n+import org.pcollections.PSet;\n+import org.pcollections.PStack;\n+\n+import net.sourceforge.pmd.lang.java.types.internal.infer.InferenceVar;\n+import net.sourceforge.pmd.util.CollectionUtil;\n+import net.sourceforge.pmd.util.OptionalBool;\n+\n+/**\n+ * Helper class for {@link TypeSystem#lub(Collection)} and {@link TypeSystem#glb(Collection)}.\n+ */\n+final class Lub {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjM2NTQ0OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/resources/category/java/security.xml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjozMDoxNVrOHQc3Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjozMDoxNVrOHQc3Ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxMjExNQ==", "bodyText": "I'd change that to 7.0.0 :)", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r487012115", "createdAt": "2020-09-11T12:30:15Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/resources/category/java/security.xml", "diffHunk": "@@ -29,6 +29,30 @@ public class Foo {\n         SecretKeySpec secretKeySpec = new SecretKeySpec(\"my secret here\".getBytes(), \"AES\");\n     }\n }\n+]]>\n+        </example>\n+    </rule>\n+    <rule name=\"TypeResTest\"\n+          language=\"java\"\n+          since=\"6.4.0\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjM3Mzc1OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/ast/Java10Test.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjozMjo0M1rOHQc8Bw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjozMjo0M1rOHQc8Bw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxMzM4Mw==", "bodyText": "cool, this TODO is now solved :)", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r487013383", "createdAt": "2020-09-11T12:32:43Z", "author": {"login": "adangel"}, "path": "pmd-java/src/test/java/net/sourceforge/pmd/lang/java/ast/Java10Test.java", "diffHunk": "@@ -60,30 +57,26 @@ public void testLocalVarInferenceCanBeParsedJava10() {\n         List<ASTLocalVariableDeclaration> localVars = compilationUnit.findDescendantsOfType(ASTLocalVariableDeclaration.class);\n         assertEquals(3, localVars.size());\n \n+        TypeSystem ts = compilationUnit.getTypeSystem();\n+        JClassType stringT = (JClassType) ts.typeOf(ts.getClassSymbol(String.class), false);\n+\n         // first: var list = new ArrayList<String>();\n         assertNull(localVars.get(0).getTypeNode());\n-        ASTVariableDeclarator varDecl = localVars.get(0).getFirstChildOfType(ASTVariableDeclarator.class);\n-        assertSame(\"type should be ArrayList\", ArrayList.class, varDecl.getType());\n-        assertEquals(\"type should be ArrayList<String>\", JavaTypeDefinition.forClass(ArrayList.class, JavaTypeDefinition.forClass(String.class)),\n-                varDecl.getTypeDefinition());\n-        ASTVariableDeclaratorId varId = varDecl.getFirstChildOfType(ASTVariableDeclaratorId.class);\n-        assertEquals(\"type should be equal\", varDecl.getTypeDefinition(), varId.getTypeDefinition());\n+        ASTVariableDeclaratorId varDecl = localVars.get(0).getVarIds().firstOrThrow();\n+        assertEquals(\"type should be ArrayList<String>\", ts.parameterise(ts.getClassSymbol(ArrayList.class), listOf(stringT)), varDecl.getTypeMirror());\n \n         // second: var stream = list.stream();\n         assertNull(localVars.get(1).getTypeNode());\n-        //ASTVariableDeclarator varDecl2 = localVars.get(1).getFirstChildOfType(ASTVariableDeclarator.class);\n+        ASTVariableDeclaratorId varDecl2 = localVars.get(1).getVarIds().firstOrThrow();\n         // TODO: return type of method call is unknown", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 79}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0NjQwNDE0OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/test/kotlin/net/sourceforge/pmd/lang/java/ast/ASTSwitchExpressionTests.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo0MjoxNVrOHQdOrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMVQxMjo0MjoxNVrOHQdOrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzAxODE1Nw==", "bodyText": "I'll add a TODO here...", "url": "https://github.com/pmd/pmd/pull/2689#discussion_r487018157", "createdAt": "2020-09-11T12:42:15Z", "author": {"login": "adangel"}, "path": "pmd-java/src/test/kotlin/net/sourceforge/pmd/lang/java/ast/ASTSwitchExpressionTests.kt", "diffHunk": "@@ -247,7 +330,8 @@ class ASTSwitchExpressionTests : ParserTestSpec({\n         \"\"\" should parseAs {\n                 switchStmt {\n \n-                    it::isExhaustiveEnumSwitch shouldBe false\n+                    // Needs typeres", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6253b696ea9b04ecf4a0c832473a178ade97f32d"}, "originalPosition": 102}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 293, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}