{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDc3MTk4NTEz", "number": 2758, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNjoyNzo0OFrOEe_M3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzowMjoxNFrOEiyyTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwOTI4MjIyOnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/util/StringUtil.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNjoyNzo0OFrOHK-1xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQxNjoyNzo0OFrOHK-1xg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MTI3NzM4Mg==", "bodyText": "Note that those utilities and their tests are already on the 7.0.x branch", "url": "https://github.com/pmd/pmd/pull/2758#discussion_r481277382", "createdAt": "2020-09-01T16:27:48Z", "author": {"login": "oowekyala"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/util/StringUtil.java", "diffHunk": "@@ -38,6 +38,114 @@\n     private StringUtil() {\n     }\n \n+\n+    /**\n+     * Returns the (1-based) line number of the character at the given index.\n+     * Line terminators (\\r, \\n) are assumed to be on the line they *end*\n+     * and not on the following line. The method also accepts that the given\n+     * offset be the length of the string (in which case there's no targeted character),\n+     * to get the line number of a character that would be inserted at\n+     * the end of the string.\n+     *\n+     * <pre>\n+     *\n+     *     lineNumberAt(\"a\\nb\", 0)  = 1\n+     *     lineNumberAt(\"a\\nb\", 1)  = 1\n+     *     lineNumberAt(\"a\\nb\", 2)  = 2\n+     *     lineNumberAt(\"a\\nb\", 3)  = 2  // charAt(3) doesn't exist though\n+     *     lineNumberAt(\"a\\nb\", 4)  = -1\n+     *\n+     *     lineNumberAt(\"\", 0) = 1\n+     *     lineNumberAt(\"\", _) = -1\n+     *\n+     * </pre>\n+     *\n+     * @param charSeq         Char sequence\n+     * @param offsetInclusive Offset in the sequence of the targeted character.\n+     *                        May be the length of the sequence.\n+     * @return -1 if the offset is not in {@code [0, length]}, otherwise\n+     * the line number\n+     */\n+    public static int lineNumberAt(CharSequence charSeq, int offsetInclusive) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "24f3017109d46b1604da6a2a86cc66993bb6e2ee"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTE3OTY5OnYy", "diffSide": "RIGHT", "path": "docs/pages/release_notes.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNjo0NjowOVrOHQ2MSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNjo0NjowOVrOHQ2MSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyNzE0Ng==", "bodyText": "I'll add here: \"use AnyTokenizer instead\". It's nice to have this info right at hand in the release notes.\nI'll also add FortranTokenizer and PerlTokenizer and RubyTokenizer here.", "url": "https://github.com/pmd/pmd/pull/2758#discussion_r487427146", "createdAt": "2020-09-12T16:46:09Z", "author": {"login": "adangel"}, "path": "docs/pages/release_notes.md", "diffHunk": "@@ -18,6 +18,10 @@ This is a {{ site.pmd.release_type }} release.\n \n ### API Changes\n \n+#### Deprecated API\n+\n+* {% core::cpd.AbstractTokenizer %}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43dea916deab5f271af430ef17b767dc37e4783"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzA0OTE5MTE2OnYy", "diffSide": "RIGHT", "path": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/AnyTokenizer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzowMjoxNFrOHQ2RuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0xMlQxNzowMjoxNFrOHQ2RuA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzQyODUzNg==", "bodyText": "TODO", "url": "https://github.com/pmd/pmd/pull/2758#discussion_r487428536", "createdAt": "2020-09-12T17:02:14Z", "author": {"login": "adangel"}, "path": "pmd-core/src/main/java/net/sourceforge/pmd/cpd/AnyTokenizer.java", "diffHunk": "@@ -4,44 +4,98 @@\n \n package net.sourceforge.pmd.cpd;\n \n-import java.io.BufferedReader;\n-import java.io.CharArrayReader;\n-import java.io.IOException;\n-import java.util.StringTokenizer;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+import net.sourceforge.pmd.util.StringUtil;\n \n /**\n- * This class does a best-guess try-anything tokenization.\n+ * Simple tokenization into words and separators. Can ignore end-of-line\n+ * comments and recognize double/single quoted string literals. It is\n+ * not a goal to be very customizable, or have very high quality.\n+ * Higher-quality lexers should be implemented with a lexer generator.\n  *\n- * @author jheintz\n+ * <p>In PMD 7, this replaces AbstractTokenizer, which provided nearly\n+ * no more functionality.\n  */\n public class AnyTokenizer implements Tokenizer {\n-    public static final String TOKENS = \" \\t!#$%^&*(){}-=+<>/\\\\`~;:\";\n+\n+    private static final Pattern DEFAULT_PATTERN = makePattern(\"\");\n+\n+    private static Pattern makePattern(String singleLineCommentStart) {\n+        return Pattern.compile(\n+            \"\\\\w++\" // either a word\n+                + eolCommentFragment(singleLineCommentStart) // a comment\n+                + \"|[^\\\"'\\\\s]\" // a single separator char\n+                + \"|\\\"(?:[^\\\"\\\\\\\\]++|\\\\\\\\.)*+\\\"\" // a double-quoted string\n+                + \"|'(?:[^'\\\\\\\\]++|\\\\\\\\.)*+'\" // a single-quoted string\n+                + \"|\\n\" // or a newline (to count lines), note that sourcecode normalizes line endings\n+        );\n+    }\n+\n+    private final Pattern pattern;\n+    private final String commentStart;\n+\n+    public AnyTokenizer() {\n+        this(DEFAULT_PATTERN, \"\");\n+    }\n+\n+    public AnyTokenizer(String eolCommentStart) {\n+        this(makePattern(eolCommentStart), eolCommentStart);\n+    }\n+\n+    private AnyTokenizer(Pattern pattern, String commentStart) {\n+        this.pattern = pattern;\n+        this.commentStart = commentStart;\n+    }\n+\n+    private static String eolCommentFragment(String start) {\n+        if (StringUtils.isBlank(start)) {\n+            return \"\";\n+        } else {\n+            return \"|(?:\" + Pattern.quote(start) + \"[^\\n]*+)\"; // note: sourcecode normalizes line endings\n+        }\n+    }\n \n     @Override\n     public void tokenize(SourceCode sourceCode, Tokens tokenEntries) {\n-        StringBuilder sb = sourceCode.getCodeBuffer();\n-        try (BufferedReader reader = new BufferedReader(new CharArrayReader(sb.toString().toCharArray()))) {\n-            int lineNumber = 1;\n-            int colNumber = 1;\n-            String line = reader.readLine();\n-            while (line != null) {\n-                StringTokenizer tokenizer = new StringTokenizer(line, TOKENS, true);\n-                while (tokenizer.hasMoreTokens()) {\n-                    String token = tokenizer.nextToken();\n-                    int endCol = colNumber + token.length() - 1; // -1 because inclusive\n-                    if (!\" \".equals(token) && !\"\\t\".equals(token)) {\n-                        tokenEntries.add(new TokenEntry(token, sourceCode.getFileName(), lineNumber, colNumber, endCol));\n-                    }\n-                    colNumber = endCol + 1;\n+        CharSequence text = sourceCode.getCodeBuffer();\n+        Matcher matcher = pattern.matcher(text);\n+        int lineNo = 1;\n+        int lastLineStart = 0;\n+        try {\n+            while (matcher.find()) {\n+                String image = matcher.group();\n+                if (isComment(image)) {\n+                    continue;\n+                } else if (StringUtils.isWhitespace(image)) {\n+                    lineNo++;\n+                    lastLineStart = matcher.end();\n+                    continue;\n                 }\n-                // advance iteration variables\n-                line = reader.readLine();\n-                lineNumber++;\n+\n+                int bline = lineNo;\n+                int bcol = 1 + matcher.start() - lastLineStart; // + 1 because columns are 1 based\n+                int ecol = StringUtil.columnNumberAt(image, image.length()); // this already outputs a 1-based column\n+                if (ecol == image.length() + 1) {\n+                    ecol = bcol + image.length(); // single-line token\n+                } else {\n+                    // multiline, need to update the line count\n+                    lineNo += StringUtil.lineNumberAt(image, image.length()) - 1;\n+                    lastLineStart = matcher.start() + image.length() - ecol + 1;\n+                }\n+                // note: remove this -1 on the 7.0.x branch, this is here because in PMD 6, end columns are inclusive", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a43dea916deab5f271af430ef17b767dc37e4783"}, "originalPosition": 110}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 331, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}