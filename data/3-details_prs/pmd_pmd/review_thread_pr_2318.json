{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgxMDU5Mjc4", "number": 2318, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMToxMjoxN1rODjnNlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxODowMjoxNlrODkXdTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjY5MjA0OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMToxMjoxN1rOFvhWdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMToxMjoxN1rOFvhWdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3MzgxMg==", "bodyText": "I think it would be nice to extract the rest of this routine into a static method. That way we can test on strings instead of having to parse a text block.", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r385373812", "createdAt": "2020-02-27T21:12:17Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "diffHunk": "@@ -252,6 +258,100 @@ public boolean isSingleCharacterStringLiteral() {\n     }\n \n     public boolean isTextBlock() {\n-        return isString && getImage().startsWith(\"\\\"\\\"\\\"\");\n+        return isString && getImage().startsWith(TEXTBLOCK_DELIMITER);\n+    }\n+\n+    /**\n+     * Returns the content of the text block after normalizing line endings to LF,\n+     * removing incidental white space surrounding the text block and interpreting\n+     * escape sequences.\n+     */\n+    @Experimental\n+    public String getTextBlockContent() {\n+        if (!isTextBlock()) {\n+            throw new IllegalArgumentException(\"This is not a text block\");\n+        }\n+\n+        int start = determineContentStart(getImage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16751d136fe4c6e4baf2a8c91b4abe69c3b5298"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjcwMTIxOnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMToxNTowM1rOFvhbxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQwOTo1NzoyM1rOFvvYhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3NTE3NA==", "bodyText": "Does this work with CRLF delimited strings? It looks like it's not going past the LF. Maybe you just need to call this method on the normalized string, and stop caring about CR.\nAlso maybe it would be clearer to just return start + 1; here instead of breaking on the next iteration.", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r385375174", "createdAt": "2020-02-27T21:15:03Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "diffHunk": "@@ -252,6 +258,100 @@ public boolean isSingleCharacterStringLiteral() {\n     }\n \n     public boolean isTextBlock() {\n-        return isString && getImage().startsWith(\"\\\"\\\"\\\"\");\n+        return isString && getImage().startsWith(TEXTBLOCK_DELIMITER);\n+    }\n+\n+    /**\n+     * Returns the content of the text block after normalizing line endings to LF,\n+     * removing incidental white space surrounding the text block and interpreting\n+     * escape sequences.\n+     */\n+    @Experimental\n+    public String getTextBlockContent() {\n+        if (!isTextBlock()) {\n+            throw new IllegalArgumentException(\"This is not a text block\");\n+        }\n+\n+        int start = determineContentStart(getImage());\n+        String content = getImage().substring(start, getImage().length() - TEXTBLOCK_DELIMITER.length());\n+        // normalize line endings to LF\n+        content = content.replaceAll(\"\\r\\n|\\r\", \"\\n\");\n+\n+        int prefixLength = Integer.MAX_VALUE;\n+        List<String> lines = Arrays.asList(content.split(\"\\\\n\"));\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // compute common prefix\n+            if (!StringUtils.isAllBlank(line) || i == lines.size() - 1) {\n+                prefixLength = Math.min(prefixLength, countLeadingWhitespace(line));\n+            }\n+        }\n+        if (prefixLength == Integer.MAX_VALUE) {\n+            // common prefix not found\n+            prefixLength = 0;\n+        }\n+        StringBuilder sb = new StringBuilder(content.length());\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // remove common whitespace prefix\n+            if (!StringUtils.isAllBlank(line) && line.length() >= prefixLength) {\n+                line = line.substring(prefixLength);\n+            }\n+            line = removeTrailingWhitespace(line);\n+            sb.append(line);\n+\n+            boolean isLastLine = i == lines.size() - 1;\n+            boolean isFirstLine = i == 0;\n+            if (!isLastLine || !isFirstLine && !StringUtils.isAllBlank(line)) {\n+                sb.append('\\n');\n+            }\n+        }\n+        String result = sb.toString();\n+\n+        // interpret escape sequences \"\\NL\" \"n\",\"t\",\"b\",\"r\",\"f\", \"s\", \"\\\"\", \"\\'\"\n+        result = result\n+                    .replaceAll(\"\\\\\\\\\\n\", \"\")\n+                    .replaceAll(\"\\\\\\\\n\", \"\\n\")\n+                    .replaceAll(\"\\\\\\\\t\", \"\\t\")\n+                    .replaceAll(\"\\\\\\\\b\", \"\\b\")\n+                    .replaceAll(\"\\\\\\\\r\", \"\\r\")\n+                    .replaceAll(\"\\\\\\\\f\", \"\\f\")\n+                    .replaceAll(\"\\\\\\\\s\", \" \")\n+                    .replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n+                    .replaceAll(\"\\\\\\\\'\", \"'\");\n+        return result;\n+    }\n+\n+    private static int determineContentStart(String s) {\n+        int start = TEXTBLOCK_DELIMITER.length(); // this is the opening delimiter\n+        boolean lineTerminator = false;\n+        // the content begins after at the first character after the line terminator\n+        // of the opening delimiter\n+        while (start < s.length() && Character.isWhitespace(s.charAt(start))) {\n+            if (s.charAt(start) == '\\r' || s.charAt(start) == '\\n') {\n+                lineTerminator = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d16751d136fe4c6e4baf2a8c91b4abe69c3b5298"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYwMzcxOQ==", "bodyText": "There was a problem with a corner case: If the content starts with LF, so that the literal looks like this: \"\"\"<LF><LF>foo<LF>\"\"\", then we would have read passed the 2nd LF and missed that... I've fixed it.", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r385603719", "createdAt": "2020-02-28T09:57:23Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "diffHunk": "@@ -252,6 +258,100 @@ public boolean isSingleCharacterStringLiteral() {\n     }\n \n     public boolean isTextBlock() {\n-        return isString && getImage().startsWith(\"\\\"\\\"\\\"\");\n+        return isString && getImage().startsWith(TEXTBLOCK_DELIMITER);\n+    }\n+\n+    /**\n+     * Returns the content of the text block after normalizing line endings to LF,\n+     * removing incidental white space surrounding the text block and interpreting\n+     * escape sequences.\n+     */\n+    @Experimental\n+    public String getTextBlockContent() {\n+        if (!isTextBlock()) {\n+            throw new IllegalArgumentException(\"This is not a text block\");\n+        }\n+\n+        int start = determineContentStart(getImage());\n+        String content = getImage().substring(start, getImage().length() - TEXTBLOCK_DELIMITER.length());\n+        // normalize line endings to LF\n+        content = content.replaceAll(\"\\r\\n|\\r\", \"\\n\");\n+\n+        int prefixLength = Integer.MAX_VALUE;\n+        List<String> lines = Arrays.asList(content.split(\"\\\\n\"));\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // compute common prefix\n+            if (!StringUtils.isAllBlank(line) || i == lines.size() - 1) {\n+                prefixLength = Math.min(prefixLength, countLeadingWhitespace(line));\n+            }\n+        }\n+        if (prefixLength == Integer.MAX_VALUE) {\n+            // common prefix not found\n+            prefixLength = 0;\n+        }\n+        StringBuilder sb = new StringBuilder(content.length());\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // remove common whitespace prefix\n+            if (!StringUtils.isAllBlank(line) && line.length() >= prefixLength) {\n+                line = line.substring(prefixLength);\n+            }\n+            line = removeTrailingWhitespace(line);\n+            sb.append(line);\n+\n+            boolean isLastLine = i == lines.size() - 1;\n+            boolean isFirstLine = i == 0;\n+            if (!isLastLine || !isFirstLine && !StringUtils.isAllBlank(line)) {\n+                sb.append('\\n');\n+            }\n+        }\n+        String result = sb.toString();\n+\n+        // interpret escape sequences \"\\NL\" \"n\",\"t\",\"b\",\"r\",\"f\", \"s\", \"\\\"\", \"\\'\"\n+        result = result\n+                    .replaceAll(\"\\\\\\\\\\n\", \"\")\n+                    .replaceAll(\"\\\\\\\\n\", \"\\n\")\n+                    .replaceAll(\"\\\\\\\\t\", \"\\t\")\n+                    .replaceAll(\"\\\\\\\\b\", \"\\b\")\n+                    .replaceAll(\"\\\\\\\\r\", \"\\r\")\n+                    .replaceAll(\"\\\\\\\\f\", \"\\f\")\n+                    .replaceAll(\"\\\\\\\\s\", \" \")\n+                    .replaceAll(\"\\\\\\\\\\\"\", \"\\\"\")\n+                    .replaceAll(\"\\\\\\\\'\", \"'\");\n+        return result;\n+    }\n+\n+    private static int determineContentStart(String s) {\n+        int start = TEXTBLOCK_DELIMITER.length(); // this is the opening delimiter\n+        boolean lineTerminator = false;\n+        // the content begins after at the first character after the line terminator\n+        // of the opening delimiter\n+        while (start < s.length() && Character.isWhitespace(s.charAt(start))) {\n+            if (s.charAt(start) == '\\r' || s.charAt(start) == '\\n') {\n+                lineTerminator = true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3NTE3NA=="}, "originalCommit": {"oid": "d16751d136fe4c6e4baf2a8c91b4abe69c3b5298"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NjcyMTIzOnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QyMToyMToyNVrOFvhnnA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxMDozMzowNlrOFvwbVA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3ODIwNA==", "bodyText": "I think this is missing \\\\ for a backslash", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r385378204", "createdAt": "2020-02-27T21:21:25Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "diffHunk": "@@ -252,6 +258,100 @@ public boolean isSingleCharacterStringLiteral() {\n     }\n \n     public boolean isTextBlock() {\n-        return isString && getImage().startsWith(\"\\\"\\\"\\\"\");\n+        return isString && getImage().startsWith(TEXTBLOCK_DELIMITER);\n+    }\n+\n+    /**\n+     * Returns the content of the text block after normalizing line endings to LF,\n+     * removing incidental white space surrounding the text block and interpreting\n+     * escape sequences.\n+     */\n+    @Experimental\n+    public String getTextBlockContent() {\n+        if (!isTextBlock()) {\n+            return getImage();\n+        }\n+\n+        int start = determineContentStart(getImage());\n+        String content = getImage().substring(start, getImage().length() - TEXTBLOCK_DELIMITER.length());\n+        // normalize line endings to LF\n+        content = content.replaceAll(\"\\r\\n|\\r\", \"\\n\");\n+\n+        int prefixLength = Integer.MAX_VALUE;\n+        List<String> lines = Arrays.asList(content.split(\"\\\\n\"));\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // compute common prefix\n+            if (!StringUtils.isAllBlank(line) || i == lines.size() - 1) {\n+                prefixLength = Math.min(prefixLength, countLeadingWhitespace(line));\n+            }\n+        }\n+        if (prefixLength == Integer.MAX_VALUE) {\n+            // common prefix not found\n+            prefixLength = 0;\n+        }\n+        StringBuilder sb = new StringBuilder(content.length());\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // remove common whitespace prefix\n+            if (!StringUtils.isAllBlank(line) && line.length() >= prefixLength) {\n+                line = line.substring(prefixLength);\n+            }\n+            line = removeTrailingWhitespace(line);\n+            sb.append(line);\n+\n+            boolean isLastLine = i == lines.size() - 1;\n+            boolean isFirstLine = i == 0;\n+            if (!isLastLine || !isFirstLine && !StringUtils.isAllBlank(line)) {\n+                sb.append('\\n');\n+            }\n+        }\n+        String result = sb.toString();\n+\n+        // interpret escape sequences \"\\NL\" \"n\",\"t\",\"b\",\"r\",\"f\", \"s\", \"\\\"\", \"\\'\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "01db024df75baa0634c83ba26961672411d75fc5"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTYyMDgyMA==", "bodyText": "Good catch!", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r385620820", "createdAt": "2020-02-28T10:33:06Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "diffHunk": "@@ -252,6 +258,100 @@ public boolean isSingleCharacterStringLiteral() {\n     }\n \n     public boolean isTextBlock() {\n-        return isString && getImage().startsWith(\"\\\"\\\"\\\"\");\n+        return isString && getImage().startsWith(TEXTBLOCK_DELIMITER);\n+    }\n+\n+    /**\n+     * Returns the content of the text block after normalizing line endings to LF,\n+     * removing incidental white space surrounding the text block and interpreting\n+     * escape sequences.\n+     */\n+    @Experimental\n+    public String getTextBlockContent() {\n+        if (!isTextBlock()) {\n+            return getImage();\n+        }\n+\n+        int start = determineContentStart(getImage());\n+        String content = getImage().substring(start, getImage().length() - TEXTBLOCK_DELIMITER.length());\n+        // normalize line endings to LF\n+        content = content.replaceAll(\"\\r\\n|\\r\", \"\\n\");\n+\n+        int prefixLength = Integer.MAX_VALUE;\n+        List<String> lines = Arrays.asList(content.split(\"\\\\n\"));\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // compute common prefix\n+            if (!StringUtils.isAllBlank(line) || i == lines.size() - 1) {\n+                prefixLength = Math.min(prefixLength, countLeadingWhitespace(line));\n+            }\n+        }\n+        if (prefixLength == Integer.MAX_VALUE) {\n+            // common prefix not found\n+            prefixLength = 0;\n+        }\n+        StringBuilder sb = new StringBuilder(content.length());\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // remove common whitespace prefix\n+            if (!StringUtils.isAllBlank(line) && line.length() >= prefixLength) {\n+                line = line.substring(prefixLength);\n+            }\n+            line = removeTrailingWhitespace(line);\n+            sb.append(line);\n+\n+            boolean isLastLine = i == lines.size() - 1;\n+            boolean isFirstLine = i == 0;\n+            if (!isLastLine || !isFirstLine && !StringUtils.isAllBlank(line)) {\n+                sb.append('\\n');\n+            }\n+        }\n+        String result = sb.toString();\n+\n+        // interpret escape sequences \"\\NL\" \"n\",\"t\",\"b\",\"r\",\"f\", \"s\", \"\\\"\", \"\\'\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTM3ODIwNA=="}, "originalCommit": {"oid": "01db024df75baa0634c83ba26961672411d75fc5"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDg4OTk1OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordBody.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwOTozMjowMlrOFwIhTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwOTozMjowMlrOFwIhTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAxNTU2NA==", "bodyText": "Hm... I guess, these AST nodes should be final....", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r386015564", "createdAt": "2020-02-29T09:32:02Z", "author": {"login": "adangel"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTRecordBody.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * BSD-style license; for more info see http://pmd.sourceforge.net/license.html\n+ */\n+\n+\n+package net.sourceforge.pmd.lang.java.ast;\n+\n+import net.sourceforge.pmd.annotation.Experimental;\n+\n+/**\n+ * Defines the body of a {@linkplain ASTRecordDeclaration RecordDeclaration} (JDK 14 preview feature).\n+ * This can contain additional methods and or constructors.\n+ *\n+ * <pre class=\"grammar\">\n+ *\n+ * RecordBody ::= \"{\" (   {@linkplain ASTRecordConstructorDeclaration RecordConstructorDeclaration}\n+ *                      | {@linkplain ASTClassOrInterfaceBodyDeclaration ClassOrInterfaceBodyDeclaration} )* \"}\"\n+ *\n+ * </pre>\n+ *\n+ */\n+@Experimental\n+public class ASTRecordBody extends AbstractJavaNode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0bcfda5619ce75c701e4b201f1ff6253d4343dd8"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDU0NzI3OnYy", "diffSide": "RIGHT", "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzo0Nzo1M1rOFwpAsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxNzo0Nzo1M1rOFwpAsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU0Nzg4OA==", "bodyText": "Right, they all need to be interpreted in one pass", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r386547888", "createdAt": "2020-03-02T17:47:53Z", "author": {"login": "oowekyala"}, "path": "pmd-java/src/main/java/net/sourceforge/pmd/lang/java/ast/ASTLiteral.java", "diffHunk": "@@ -252,6 +258,143 @@ public boolean isSingleCharacterStringLiteral() {\n     }\n \n     public boolean isTextBlock() {\n-        return isString && getImage().startsWith(\"\\\"\\\"\\\"\");\n+        return isString && getImage().startsWith(TEXTBLOCK_DELIMITER);\n+    }\n+\n+    /**\n+     * Returns the content of the text block after normalizing line endings to LF,\n+     * removing incidental white space surrounding the text block and interpreting\n+     * escape sequences.\n+     *\n+     * <p>Note: This is a Java 14 Preview Feature.\n+     */\n+    @Experimental\n+    public String getTextBlockContent() {\n+        if (!isTextBlock()) {\n+            return getImage();\n+        }\n+        return determineTextBlockContent(getImage());\n+    }\n+\n+    static String determineTextBlockContent(String image) {\n+        // normalize line endings to LF\n+        String content = image.replaceAll(\"\\r\\n|\\r\", \"\\n\");\n+        int start = determineContentStart(content);\n+        content = content.substring(start, content.length() - TEXTBLOCK_DELIMITER.length());\n+\n+        int prefixLength = Integer.MAX_VALUE;\n+        List<String> lines = Arrays.asList(content.split(\"\\\\n\"));\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // compute common prefix\n+            if (!StringUtils.isAllBlank(line) || i == lines.size() - 1) {\n+                prefixLength = Math.min(prefixLength, countLeadingWhitespace(line));\n+            }\n+        }\n+        if (prefixLength == Integer.MAX_VALUE) {\n+            // common prefix not found\n+            prefixLength = 0;\n+        }\n+        StringBuilder sb = new StringBuilder(content.length());\n+        for (int i = 0; i < lines.size(); i++) {\n+            String line = lines.get(i);\n+            // remove common whitespace prefix\n+            if (!StringUtils.isAllBlank(line) && line.length() >= prefixLength) {\n+                line = line.substring(prefixLength);\n+            }\n+            line = removeTrailingWhitespace(line);\n+            sb.append(line);\n+\n+            boolean isLastLine = i == lines.size() - 1;\n+            boolean isFirstLine = i == 0;\n+            if (!isLastLine || !isFirstLine && !StringUtils.isAllBlank(line)) {\n+                sb.append('\\n');\n+            }\n+        }\n+\n+        interpretEscapeSequences(sb);\n+        return sb.toString();\n+    }\n+\n+    private static void interpretEscapeSequences(StringBuilder sb) {\n+        // interpret escape sequences \"\\<LF>\" (line continuation), \"n\",\"t\",\"b\",\"r\",\"f\", \"s\", \"\\\"\", \"\\'\", \"\\\\\"\n+        for (int i = 0; i < sb.length(); i++) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f49a6dbc3d0872e345ecea6c13926dd939bc119d"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5NDU5NjYzOnYy", "diffSide": "RIGHT", "path": "pmd-java/etc/grammar/Java.jjt", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxODowMjoxNlrOFwpflg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMlQxOTo0Mjo0MVrOFwswgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU1NTc5OA==", "bodyText": "Actually a record ctor may have a throws list. I'll fix that shortly.", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r386555798", "createdAt": "2020-03-02T18:02:16Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1073,6 +1107,67 @@ void EnumConstant():\n   t=<IDENTIFIER> {jjtThis.setImage(t.image);} [ Arguments() ] [ ClassOrInterfaceBody() ]\n }\n \n+void RecordDeclaration(int modifiers):\n+{\n+    Token t;\n+    jjtThis.setModifiers(modifiers);\n+    checkForRecordType();\n+}\n+{\n+  t = <IDENTIFIER> {\n+    if (!\"record\".equals(t.image)) {\n+      throw new ParseException(\"ERROR: expecting record\");\n+    }\n+  }\n+  t=<IDENTIFIER> {checkForBadTypeIdentifierUsage(t.image); jjtThis.setImage(t.image);}\n+  [ TypeParameters() ]\n+  RecordComponentList()\n+  [ ImplementsList() ]\n+  RecordBody()\n+}\n+\n+void RecordComponentList() :\n+{}\n+{\n+  \"(\" [ RecordComponent() (\",\" RecordComponent())* ] \")\"\n+}\n+\n+void RecordComponent():\n+{}\n+{\n+  (Annotation())*\n+  Type()\n+  [ \"...\" {jjtThis.setVarargs();} ]\n+  VariableDeclaratorId()\n+}\n+\n+void RecordBody():\n+{}\n+{\n+  \"{\"\n+    ( RecordBodyDeclaration() )*\n+  \"}\"\n+}\n+\n+void RecordBodyDeclaration() #void :\n+{}\n+{\n+  LOOKAHEAD(ClassOrInterfaceBodyDeclaration()) ClassOrInterfaceBodyDeclaration()\n+  |\n+  RecordConstructorDeclaration()\n+}\n+\n+void RecordConstructorDeclaration():\n+{\n+  int modifiers;\n+}\n+{\n+  modifiers = Modifiers() { jjtThis.setModifiers(modifiers); }\n+  [TypeParameters()]\n+  <IDENTIFIER> { jjtThis.setImage(token.image); }\n+  \"{\" ( BlockStatement() )* \"}\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f49a6dbc3d0872e345ecea6c13926dd939bc119d"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU4ODg2MA==", "bodyText": "I think I've removed this, because the EA build didn't compile it - at least with the version I used (build 14+36-1461). The JEPs actually mentions the throws clause in the grammar, but not the JLS update - we need to see, whether other exceptions than runtime exceptions are actually allowed in a record constructor...", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r386588860", "createdAt": "2020-03-02T19:04:27Z", "author": {"login": "adangel"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1073,6 +1107,67 @@ void EnumConstant():\n   t=<IDENTIFIER> {jjtThis.setImage(t.image);} [ Arguments() ] [ ClassOrInterfaceBody() ]\n }\n \n+void RecordDeclaration(int modifiers):\n+{\n+    Token t;\n+    jjtThis.setModifiers(modifiers);\n+    checkForRecordType();\n+}\n+{\n+  t = <IDENTIFIER> {\n+    if (!\"record\".equals(t.image)) {\n+      throw new ParseException(\"ERROR: expecting record\");\n+    }\n+  }\n+  t=<IDENTIFIER> {checkForBadTypeIdentifierUsage(t.image); jjtThis.setImage(t.image);}\n+  [ TypeParameters() ]\n+  RecordComponentList()\n+  [ ImplementsList() ]\n+  RecordBody()\n+}\n+\n+void RecordComponentList() :\n+{}\n+{\n+  \"(\" [ RecordComponent() (\",\" RecordComponent())* ] \")\"\n+}\n+\n+void RecordComponent():\n+{}\n+{\n+  (Annotation())*\n+  Type()\n+  [ \"...\" {jjtThis.setVarargs();} ]\n+  VariableDeclaratorId()\n+}\n+\n+void RecordBody():\n+{}\n+{\n+  \"{\"\n+    ( RecordBodyDeclaration() )*\n+  \"}\"\n+}\n+\n+void RecordBodyDeclaration() #void :\n+{}\n+{\n+  LOOKAHEAD(ClassOrInterfaceBodyDeclaration()) ClassOrInterfaceBodyDeclaration()\n+  |\n+  RecordConstructorDeclaration()\n+}\n+\n+void RecordConstructorDeclaration():\n+{\n+  int modifiers;\n+}\n+{\n+  modifiers = Modifiers() { jjtThis.setModifiers(modifiers); }\n+  [TypeParameters()]\n+  <IDENTIFIER> { jjtThis.setImage(token.image); }\n+  \"{\" ( BlockStatement() )* \"}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU1NTc5OA=="}, "originalCommit": {"oid": "f49a6dbc3d0872e345ecea6c13926dd939bc119d"}, "originalPosition": 241}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYwOTI4MA==", "bodyText": "Ah I see! I found, that they talked about this, and you're right:\nhttps://mail.openjdk.java.net/pipermail/amber-spec-experts/2020-February/002009.html", "url": "https://github.com/pmd/pmd/pull/2318#discussion_r386609280", "createdAt": "2020-03-02T19:42:41Z", "author": {"login": "oowekyala"}, "path": "pmd-java/etc/grammar/Java.jjt", "diffHunk": "@@ -1073,6 +1107,67 @@ void EnumConstant():\n   t=<IDENTIFIER> {jjtThis.setImage(t.image);} [ Arguments() ] [ ClassOrInterfaceBody() ]\n }\n \n+void RecordDeclaration(int modifiers):\n+{\n+    Token t;\n+    jjtThis.setModifiers(modifiers);\n+    checkForRecordType();\n+}\n+{\n+  t = <IDENTIFIER> {\n+    if (!\"record\".equals(t.image)) {\n+      throw new ParseException(\"ERROR: expecting record\");\n+    }\n+  }\n+  t=<IDENTIFIER> {checkForBadTypeIdentifierUsage(t.image); jjtThis.setImage(t.image);}\n+  [ TypeParameters() ]\n+  RecordComponentList()\n+  [ ImplementsList() ]\n+  RecordBody()\n+}\n+\n+void RecordComponentList() :\n+{}\n+{\n+  \"(\" [ RecordComponent() (\",\" RecordComponent())* ] \")\"\n+}\n+\n+void RecordComponent():\n+{}\n+{\n+  (Annotation())*\n+  Type()\n+  [ \"...\" {jjtThis.setVarargs();} ]\n+  VariableDeclaratorId()\n+}\n+\n+void RecordBody():\n+{}\n+{\n+  \"{\"\n+    ( RecordBodyDeclaration() )*\n+  \"}\"\n+}\n+\n+void RecordBodyDeclaration() #void :\n+{}\n+{\n+  LOOKAHEAD(ClassOrInterfaceBodyDeclaration()) ClassOrInterfaceBodyDeclaration()\n+  |\n+  RecordConstructorDeclaration()\n+}\n+\n+void RecordConstructorDeclaration():\n+{\n+  int modifiers;\n+}\n+{\n+  modifiers = Modifiers() { jjtThis.setModifiers(modifiers); }\n+  [TypeParameters()]\n+  <IDENTIFIER> { jjtThis.setImage(token.image); }\n+  \"{\" ( BlockStatement() )* \"}\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjU1NTc5OA=="}, "originalCommit": {"oid": "f49a6dbc3d0872e345ecea6c13926dd939bc119d"}, "originalPosition": 241}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 520, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}