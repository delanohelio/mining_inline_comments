{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQyNzcyNzc3", "number": 891, "reviewThreads": {"totalCount": 92, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyMjowM1rOFHbgQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo1NTowMFrOF3zPUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM0OTc2OnYy", "diffSide": "RIGHT", "path": "etc/conf.templates/distributed/70--extensions.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyMjowM1rOII6Biw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyMjowM1rOII6Biw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDE4Nw==", "bodyText": "Must be commented by default.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546210187", "createdAt": "2020-12-19T08:22:03Z", "author": {"login": "hbs"}, "path": "etc/conf.templates/distributed/70--extensions.conf.template", "diffHunk": "@@ -58,6 +58,8 @@\n #token.secret = ....\n // URLFETCH, MAXURLFETCHCOUNT, MAXURLFETCHSIZE\n #warpscript.extension.urlfetch = io.warp10.script.ext.urlfetch.UrlFetchWarpScriptExtension\n+// HTTP, MAXURLCOUNT, MAXDOWNLOADSIZE\n+warpscript.extension.http = io.warp10.script.ext.http.HttpWarpScriptExtension", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM0OTkzOnYy", "diffSide": "RIGHT", "path": "etc/conf.templates/standalone/70--extensions.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyMjoxNlrOII6Bng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyMjoxNlrOII6Bng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDIwNg==", "bodyText": "Must be commented by default.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546210206", "createdAt": "2020-12-19T08:22:16Z", "author": {"login": "hbs"}, "path": "etc/conf.templates/standalone/70--extensions.conf.template", "diffHunk": "@@ -58,6 +58,8 @@\n #token.secret = ....\n // URLFETCH, MAXURLFETCHCOUNT, MAXURLFETCHSIZE\n #warpscript.extension.urlfetch = io.warp10.script.ext.urlfetch.UrlFetchWarpScriptExtension\n+// HTTP, MAXURLCOUNT, MAXDOWNLOADSIZE\n+warpscript.extension.http = io.warp10.script.ext.http.HttpWarpScriptExtension", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM0OTk3OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyMjoyNFrOII6Bpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyMjoyNFrOII6Bpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDIxNQ==", "bodyText": "2020", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546210215", "createdAt": "2020-12-19T08:22:24Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM1MDk0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyMzozM1rOII6CFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwOTo0MjowMVrOII6eHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDMyNQ==", "bodyText": "Use extends NamedWarpScriptFunction implements WarpScriptStackFunction for clarity. The FormattedWarpScriptFunction approach does cripple the overall readability and may be removed in future versions of Warp 10.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546210325", "createdAt": "2020-12-19T08:23:33Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxNzUwMg==", "bodyText": "I think after knowing how to use the FormattedWarpScriptFunction class it is the opposite. I find it handy to declare functions with multiple arguments to retrieve from the stack and handle defaults, while also hiding the stack syntax particularity. Also it is convenient to generate documentation files.\nMaybe the logic of this class can be transferred to a stack method: stack.retrieveArguments(args)\nAnd documentation generation to a function of args, output and function.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546217502", "createdAt": "2020-12-19T09:42:01Z", "author": {"login": "randomboolean"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDMyNQ=="}, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM1MjAyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyNDo1NFrOII6Ckw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyNDo1NFrOII6Ckw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDQ1MQ==", "bodyText": "The documentation will be elsewhere but this is no longer limited to the GET method.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546210451", "createdAt": "2020-12-19T08:24:54Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM1Mjk4OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyNTo1OFrOII6C_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyNTo1OFrOII6C_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDU1OA==", "bodyText": "The content must be returned as BYTES, not base 64 encoded as STRING. And returning a MAP is probably wiser.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546210558", "createdAt": "2020-12-19T08:25:58Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM1NDQ0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyNzoxN1rOII6Dow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyNzoxN1rOII6Dow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDcyMw==", "bodyText": "This must not be called at each invocation. Extract the capability name once at instantiation time and refer to that in apply.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546210723", "createdAt": "2020-12-19T08:27:17Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM1NTYwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyODo0NlrOII6ELw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODoyODo0NlrOII6ELw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMDg2Mw==", "bodyText": "Capabilities are checked using Capabilities#get", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546210863", "createdAt": "2020-12-19T08:28:46Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM1NzA0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozMDo1N1rOII6E1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwOTo0NjowNVrOII6fyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTAzMA==", "bodyText": "The authorization type should be configurable, either none, i.e. the function can be used by anyone if the extension is loaded, authenticated, AUTHENTICATE must have been called, and capability to inspect a capability.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546211030", "createdAt": "2020-12-19T08:30:57Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 121}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxNzkzMQ==", "bodyText": "I was thinking of enforcing authentication in each case (capability or not), since it allows for checking if another thread in the jvm has a stack that is authenticated with the same token and also try to use HTTP, so that we can prevent nested call of HTTP and network loops.\nIs it a valid concern?", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546217931", "createdAt": "2020-12-19T09:46:05Z", "author": {"login": "randomboolean"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTAzMA=="}, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM1ODMzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozMzoxOVrOII6Faw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozMzoxOVrOII6Faw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTE3OQ==", "bodyText": "We don't need synchronization, the rare cases where the count would be incorrect (use in CEVAL) don't need to be handled as their consequence is not important.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546211179", "createdAt": "2020-12-19T08:33:19Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> properties = (Map) formattedArgs.get(HEADER);\n+    String body = (String) formattedArgs.get(BODY);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    try {\n+      stackCountersLock.lockInterruptibly();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 153}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM1OTUyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozNDo0NlrOII6F8A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozNDo0NlrOII6F8A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTMxMg==", "bodyText": "Simply do the check with  addAndGet(1), it is an AtomicLong", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546211312", "createdAt": "2020-12-19T08:34:46Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> properties = (Map) formattedArgs.get(HEADER);\n+    String body = (String) formattedArgs.get(BODY);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    try {\n+      stackCountersLock.lockInterruptibly();\n+\n+      Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT);\n+      Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+      if (null == ufCount || null == ufSize) {\n+        urlCount = new AtomicLong();\n+        downloadSize = new AtomicLong();\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT, urlCount);\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+      } else {\n+        urlCount = (AtomicLong) ufCount;\n+        downloadSize = (AtomicLong) ufSize;\n+      }\n+    } catch (InterruptedException ie) {\n+      throw new WarpScriptException(getName() + \" thread has been interrupted\", ie);\n+    } finally {\n+      if (stackCountersLock.isHeldByCurrentThread()) {\n+        stackCountersLock.unlock();\n+      }\n+    }\n+\n+    if (urlCount.get() + 1 > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    // Recheck the count here in case of concurrent runs", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 179}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2MDUzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozNTo0OFrOII6GYA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozNTo0OFrOII6GYA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTQyNA==", "bodyText": "I think it it better to disallow user infos in the URL and to provide a macro to encode basic authentication which can then be passed in the headers.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546211424", "createdAt": "2020-12-19T08:35:48Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> properties = (Map) formattedArgs.get(HEADER);\n+    String body = (String) formattedArgs.get(BODY);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    try {\n+      stackCountersLock.lockInterruptibly();\n+\n+      Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT);\n+      Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+      if (null == ufCount || null == ufSize) {\n+        urlCount = new AtomicLong();\n+        downloadSize = new AtomicLong();\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT, urlCount);\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+      } else {\n+        urlCount = (AtomicLong) ufCount;\n+        downloadSize = (AtomicLong) ufSize;\n+      }\n+    } catch (InterruptedException ie) {\n+      throw new WarpScriptException(getName() + \" thread has been interrupted\", ie);\n+    } finally {\n+      if (stackCountersLock.isHeldByCurrentThread()) {\n+        stackCountersLock.unlock();\n+      }\n+    }\n+\n+    if (urlCount.get() + 1 > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    // Recheck the count here in case of concurrent runs\n+    if (urlCount.addAndGet(1) > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    HttpURLConnection conn = null;\n+\n+    List<Object> res = new ArrayList<Object>();\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      if (null != url.getUserInfo()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 191}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2MTMzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozNjoyOVrOII6Gug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozNjoyOVrOII6Gug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTUxNA==", "bodyText": "Call them headers", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546211514", "createdAt": "2020-12-19T08:36:29Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> properties = (Map) formattedArgs.get(HEADER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2NDEyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozOToxNlrOII6H8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozOToxNlrOII6H8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTgyNg==", "bodyText": "the body parameter could contain a STRING or BYTES to let the user choose the charset used.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546211826", "createdAt": "2020-12-19T08:39:16Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> properties = (Map) formattedArgs.get(HEADER);\n+    String body = (String) formattedArgs.get(BODY);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2NDIyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozOTozN1rOII6IAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODozOTozN1rOII6IAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTg0Mw==", "bodyText": "body could be a STRING or BYTES", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546211843", "createdAt": "2020-12-19T08:39:37Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> properties = (Map) formattedArgs.get(HEADER);\n+    String body = (String) formattedArgs.get(BODY);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    try {\n+      stackCountersLock.lockInterruptibly();\n+\n+      Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT);\n+      Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+      if (null == ufCount || null == ufSize) {\n+        urlCount = new AtomicLong();\n+        downloadSize = new AtomicLong();\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT, urlCount);\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+      } else {\n+        urlCount = (AtomicLong) ufCount;\n+        downloadSize = (AtomicLong) ufSize;\n+      }\n+    } catch (InterruptedException ie) {\n+      throw new WarpScriptException(getName() + \" thread has been interrupted\", ie);\n+    } finally {\n+      if (stackCountersLock.isHeldByCurrentThread()) {\n+        stackCountersLock.unlock();\n+      }\n+    }\n+\n+    if (urlCount.get() + 1 > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    // Recheck the count here in case of concurrent runs\n+    if (urlCount.addAndGet(1) > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    HttpURLConnection conn = null;\n+\n+    List<Object> res = new ArrayList<Object>();\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      if (null != url.getUserInfo()) {\n+        String basicAuth = \"Basic \" + new String(Base64.encodeBase64String(url.getUserInfo().getBytes(StandardCharsets.UTF_8)));\n+        properties.put(\"Authorization\", basicAuth);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: properties.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setDoOutput(body.length() > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2NDU1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0MDowMFrOII6IKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0MDowMFrOII6IKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMTg4Mw==", "bodyText": "Use StandardCharsets.UTF8 explicitely", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546211883", "createdAt": "2020-12-19T08:40:00Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> properties = (Map) formattedArgs.get(HEADER);\n+    String body = (String) formattedArgs.get(BODY);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    try {\n+      stackCountersLock.lockInterruptibly();\n+\n+      Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT);\n+      Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+      if (null == ufCount || null == ufSize) {\n+        urlCount = new AtomicLong();\n+        downloadSize = new AtomicLong();\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT, urlCount);\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+      } else {\n+        urlCount = (AtomicLong) ufCount;\n+        downloadSize = (AtomicLong) ufSize;\n+      }\n+    } catch (InterruptedException ie) {\n+      throw new WarpScriptException(getName() + \" thread has been interrupted\", ie);\n+    } finally {\n+      if (stackCountersLock.isHeldByCurrentThread()) {\n+        stackCountersLock.unlock();\n+      }\n+    }\n+\n+    if (urlCount.get() + 1 > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    // Recheck the count here in case of concurrent runs\n+    if (urlCount.addAndGet(1) > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    HttpURLConnection conn = null;\n+\n+    List<Object> res = new ArrayList<Object>();\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      if (null != url.getUserInfo()) {\n+        String basicAuth = \"Basic \" + new String(Base64.encodeBase64String(url.getUserInfo().getBytes(StandardCharsets.UTF_8)));\n+        properties.put(\"Authorization\", basicAuth);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: properties.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setDoOutput(body.length() > 0);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      if (body.length() > 0) {\n+        try (OutputStream os = conn.getOutputStream()) {\n+          os.write(body.getBytes());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 206}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2NTU3OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0MjowMlrOII6IqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0MjowMlrOII6IqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjAwOQ==", "bodyText": "request to", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212009", "createdAt": "2020-12-19T08:42:02Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,278 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+/**\n+ * Apply an HTTP method over an url\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADER = \"header\";\n+  public static final String BODY = \"body\";\n+  public static final String RESPONSE = \"response\";\n+\n+  private final Arguments args;\n+  private final Arguments output;\n+\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final ReentrantLock stackCountersLock = new ReentrantLock();\n+  private final WebAccessController webAccessController;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the GET request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADER, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(String.class, BODY, \"An optional body\", \"\")\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(List.class, RESPONSE, \"A list containing, for each URL, a 4-element list. These 4-element lists contain, in this order, a LONG status code, a STRING status message or an empty STRING if not available, a MAP of headers and a STRING representing a bytes array encoded as base 64.\")\n+      .build();\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check capability if set in configuration, or else check stack authentication\n+    //\n+\n+    Properties props = WarpConfig.getProperties();\n+\n+    if (props.containsKey(HttpWarpScriptExtension.HTTP_CAPABILITY)) {\n+      if (stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR) instanceof Capabilities) {\n+        Capabilities capabilities = (Capabilities) stack.getAttribute(WarpScriptStack.CAPABILITIES_ATTR);\n+\n+        if (!(capabilities.containsKey(props.getProperty(HttpWarpScriptExtension.HTTP_CAPABILITY)))) {\n+          throw new WarpScriptException(\"Capability \" + HttpWarpScriptExtension.HTTP_CAPABILITY + \" is required by function \" + getName());\n+        }\n+      }\n+\n+    } else if (!stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> properties = (Map) formattedArgs.get(HEADER);\n+    String body = (String) formattedArgs.get(BODY);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    try {\n+      stackCountersLock.lockInterruptibly();\n+\n+      Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT);\n+      Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+      if (null == ufCount || null == ufSize) {\n+        urlCount = new AtomicLong();\n+        downloadSize = new AtomicLong();\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_COUNT, urlCount);\n+        stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+      } else {\n+        urlCount = (AtomicLong) ufCount;\n+        downloadSize = (AtomicLong) ufSize;\n+      }\n+    } catch (InterruptedException ie) {\n+      throw new WarpScriptException(getName() + \" thread has been interrupted\", ie);\n+    } finally {\n+      if (stackCountersLock.isHeldByCurrentThread()) {\n+        stackCountersLock.unlock();\n+      }\n+    }\n+\n+    if (urlCount.get() + 1 > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    // Recheck the count here in case of concurrent runs\n+    if (urlCount.addAndGet(1) > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT)) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_LIMIT) + \" calls.\");\n+    }\n+\n+    HttpURLConnection conn = null;\n+\n+    List<Object> res = new ArrayList<Object>();\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      if (null != url.getUserInfo()) {\n+        String basicAuth = \"Basic \" + new String(Base64.encodeBase64String(url.getUserInfo().getBytes(StandardCharsets.UTF_8)));\n+        properties.put(\"Authorization\", basicAuth);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: properties.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setDoOutput(body.length() > 0);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      if (body.length() > 0) {\n+        try (OutputStream os = conn.getOutputStream()) {\n+          os.write(body.getBytes());\n+        }\n+      }\n+\n+      byte[] buf = new byte[8192];\n+\n+      ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+      InputStream in = null;\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      while (true) {\n+        int len = in.read(buf);\n+\n+        if (len < 0) {\n+          break;\n+        }\n+\n+        if (downloadSize.get() + baos.size() + len > (long) HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_MAXSIZE)) {\n+          throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + HttpWarpScriptExtension.getLongAttribute(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_MAXSIZE) + \" bytes)\");\n+        }\n+\n+        baos.write(buf, 0, len);\n+      }\n+\n+      downloadSize.addAndGet(baos.size());\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.add(conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.add(statusMsg.get(0));\n+        } else {\n+          res.add(\"\");\n+        }\n+      } else {\n+        res.add(\"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new HashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.add(hdrs);\n+      res.add(Base64.encodeBase64String(baos.toByteArray()));\n+\n+    } catch (IOException ioe) {\n+      throw new WarpScriptException(getName() + \" encountered an error while making an HTTP \" + method + \" request over '\" + url + \"'\", ioe);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 267}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2NzIxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NDoyMlrOII6JbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NDoyMlrOII6JbQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjIwNQ==", "bodyText": "These functions do not need to exist. Rely on capabilities to modify the limits.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212205", "createdAt": "2020-12-19T08:44:22Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2ODA2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NToyM1rOII6Jzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NToyM1rOII6Jzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjMwMg==", "bodyText": "change the name to maxrequests", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212302", "createdAt": "2020-12-19T08:45:23Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2ODY2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NTo1MFrOII6KDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NTo1MFrOII6KDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjM2Nw==", "bodyText": "remove the hard limit and use token capabilities.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212367", "createdAt": "2020-12-19T08:45:50Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2ODcxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NTo1N1rOII6KFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NTo1N1rOII6KFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjM3Mg==", "bodyText": "remove hard limit", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212372", "createdAt": "2020-12-19T08:45:57Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE = \"warpscript.http.maxsize\";\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE_HARD = \"warpscript.http.maxsize.hard\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2OTM0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NjozMFrOII6KVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0NjozMFrOII6KVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjQzOA==", "bodyText": "rename to http.requests", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212438", "createdAt": "2020-12-19T08:46:30Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE = \"warpscript.http.maxsize\";\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE_HARD = \"warpscript.http.maxsize.hard\";\n+\n+  /**\n+   * Allowed and excluded host patterns.\n+   */\n+  public static final String WARPSCRIPT_HTTP_HOST_PATTERNS = \"warpscript.http.host.patterns\";\n+\n+  //\n+  // STACK\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_LIMIT = \"http.limit\";\n+  public static final String ATTRIBUTE_HTTP_LIMIT_HARD = \"http.limit.hard\";\n+\n+  /**\n+   * Number of calls to HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_COUNT = \"http.count\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 75}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM2OTYyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0Njo0NFrOII6KdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0Njo0NFrOII6KdA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjQ2OA==", "bodyText": "rename to http.maxrequests", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212468", "createdAt": "2020-12-19T08:46:44Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE = \"warpscript.http.maxsize\";\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE_HARD = \"warpscript.http.maxsize.hard\";\n+\n+  /**\n+   * Allowed and excluded host patterns.\n+   */\n+  public static final String WARPSCRIPT_HTTP_HOST_PATTERNS = \"warpscript.http.host.patterns\";\n+\n+  //\n+  // STACK\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_LIMIT = \"http.limit\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM3MDY5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0ODowMVrOII6K6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0ODowMVrOII6K6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjU4NQ==", "bodyText": "remove hard limit", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212585", "createdAt": "2020-12-19T08:48:01Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE = \"warpscript.http.maxsize\";\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE_HARD = \"warpscript.http.maxsize.hard\";\n+\n+  /**\n+   * Allowed and excluded host patterns.\n+   */\n+  public static final String WARPSCRIPT_HTTP_HOST_PATTERNS = \"warpscript.http.host.patterns\";\n+\n+  //\n+  // STACK\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_LIMIT = \"http.limit\";\n+  public static final String ATTRIBUTE_HTTP_LIMIT_HARD = \"http.limit.hard\";\n+\n+  /**\n+   * Number of calls to HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_COUNT = \"http.count\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE = \"http.maxsize\";\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE_HARD = \"http.maxsize.hard\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM3MTczOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0OTowMFrOII6LXw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0xOVQxMzowMTo1NlrOI5-N0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjcwMw==", "bodyText": "this is too high, limit to 1 so users explicitly set the configuration.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212703", "createdAt": "2020-12-19T08:49:00Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE = \"warpscript.http.maxsize\";\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE_HARD = \"warpscript.http.maxsize.hard\";\n+\n+  /**\n+   * Allowed and excluded host patterns.\n+   */\n+  public static final String WARPSCRIPT_HTTP_HOST_PATTERNS = \"warpscript.http.host.patterns\";\n+\n+  //\n+  // STACK\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_LIMIT = \"http.limit\";\n+  public static final String ATTRIBUTE_HTTP_LIMIT_HARD = \"http.limit.hard\";\n+\n+  /**\n+   * Number of calls to HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_COUNT = \"http.count\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE = \"http.maxsize\";\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE_HARD = \"http.maxsize.hard\";\n+\n+  /**\n+   * Current  HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_SIZE = \"http.size\";\n+\n+  //\n+  // DEFAULTS\n+  //\n+\n+  public static final long DEFAULT_HTTP_LIMIT = 64L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5NzY1OTA5MQ==", "bodyText": "Limit has been set to 1L. But since auth_macro may need to make requests as well (e.g. digest authentication), should we raise this default to a few more ?", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r597659091", "createdAt": "2021-03-19T13:01:56Z", "author": {"login": "randomboolean"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE = \"warpscript.http.maxsize\";\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE_HARD = \"warpscript.http.maxsize.hard\";\n+\n+  /**\n+   * Allowed and excluded host patterns.\n+   */\n+  public static final String WARPSCRIPT_HTTP_HOST_PATTERNS = \"warpscript.http.host.patterns\";\n+\n+  //\n+  // STACK\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_LIMIT = \"http.limit\";\n+  public static final String ATTRIBUTE_HTTP_LIMIT_HARD = \"http.limit.hard\";\n+\n+  /**\n+   * Number of calls to HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_COUNT = \"http.count\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE = \"http.maxsize\";\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE_HARD = \"http.maxsize.hard\";\n+\n+  /**\n+   * Current  HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_SIZE = \"http.size\";\n+\n+  //\n+  // DEFAULTS\n+  //\n+\n+  public static final long DEFAULT_HTTP_LIMIT = 64L;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjcwMw=="}, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM3MTg5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0OToxN1rOII6Lcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo0OToxN1rOII6Lcg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjcyMg==", "bodyText": "Lower that to 65536", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212722", "createdAt": "2020-12-19T08:49:17Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE = \"warpscript.http.maxsize\";\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE_HARD = \"warpscript.http.maxsize.hard\";\n+\n+  /**\n+   * Allowed and excluded host patterns.\n+   */\n+  public static final String WARPSCRIPT_HTTP_HOST_PATTERNS = \"warpscript.http.host.patterns\";\n+\n+  //\n+  // STACK\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_LIMIT = \"http.limit\";\n+  public static final String ATTRIBUTE_HTTP_LIMIT_HARD = \"http.limit.hard\";\n+\n+  /**\n+   * Number of calls to HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_COUNT = \"http.count\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE = \"http.maxsize\";\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE_HARD = \"http.maxsize.hard\";\n+\n+  /**\n+   * Current  HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_SIZE = \"http.size\";\n+\n+  //\n+  // DEFAULTS\n+  //\n+\n+  public static final long DEFAULT_HTTP_LIMIT = 64L;\n+  public static final long DEFAULT_HTTP_MAXSIZE = 1000000L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM3MzA1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo1MTo0OFrOII6MAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo1MTo0OFrOII6MAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjg2NA==", "bodyText": "Remove this. We can consider adding a method to StackUtils to enforce a similar logic but with a simpler behavior, i.e. no attributeToConf structure but simply an extraneous parameter to the call.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212864", "createdAt": "2020-12-19T08:51:48Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.warp.sdk.WarpScriptExtension;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Extension for HTTP and the associated function to change limits: MAXURLCOUNT and MAXDOWNLOADSIZE\n+ */\n+public class HttpWarpScriptExtension extends WarpScriptExtension {\n+\n+  //\n+  // CAPABILITIES\n+  //\n+\n+  /**\n+   * If this configuration is set, then HTTP function will check for this capability.\n+   */\n+  public static final String HTTP_CAPABILITY = \"warpscript.http.capability\";\n+\n+  //\n+  // CONFIGURATION\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_LIMIT = \"warpscript.http.limit\";\n+  public static final String WARPSCRIPT_HTTP_LIMIT_HARD = \"warpscript.http.limit.hard\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE = \"warpscript.http.maxsize\";\n+  public static final String WARPSCRIPT_HTTP_MAXSIZE_HARD = \"warpscript.http.maxsize.hard\";\n+\n+  /**\n+   * Allowed and excluded host patterns.\n+   */\n+  public static final String WARPSCRIPT_HTTP_HOST_PATTERNS = \"warpscript.http.host.patterns\";\n+\n+  //\n+  // STACK\n+  //\n+\n+  /**\n+   * Maximum number of calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_LIMIT = \"http.limit\";\n+  public static final String ATTRIBUTE_HTTP_LIMIT_HARD = \"http.limit.hard\";\n+\n+  /**\n+   * Number of calls to HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_COUNT = \"http.count\";\n+\n+  /**\n+   * Maximum cumulative size of content retrieved via calls to HTTP in a session\n+   */\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE = \"http.maxsize\";\n+  public static final String ATTRIBUTE_HTTP_MAXSIZE_HARD = \"http.maxsize.hard\";\n+\n+  /**\n+   * Current  HTTP so far in the sessions\n+   */\n+  public static final String ATTRIBUTE_HTTP_SIZE = \"http.size\";\n+\n+  //\n+  // DEFAULTS\n+  //\n+\n+  public static final long DEFAULT_HTTP_LIMIT = 64L;\n+  public static final long DEFAULT_HTTP_MAXSIZE = 1000000L;\n+\n+  //\n+  // ASSOCIATIONS attributes to either configuration or defaults\n+  //\n+\n+  /**\n+   * Associates the attribute name to the configuration name\n+   */\n+  private static final Map<String, String> attributeToConf;\n+\n+  /**\n+   * Associates the attribute name to its default value\n+   */\n+  private static final Map<String, Long> attributeToDefault;\n+\n+  private static final Map<String, Object> functions;\n+\n+  static {\n+    // Initialize attribute->configuration\n+    Map<String, String> a2c = new HashMap<String, String>();\n+    a2c.put(ATTRIBUTE_HTTP_LIMIT, WARPSCRIPT_HTTP_LIMIT);\n+    a2c.put(ATTRIBUTE_HTTP_MAXSIZE, WARPSCRIPT_HTTP_MAXSIZE);\n+    a2c.put(ATTRIBUTE_HTTP_LIMIT_HARD, WARPSCRIPT_HTTP_LIMIT_HARD);\n+    a2c.put(ATTRIBUTE_HTTP_MAXSIZE_HARD, WARPSCRIPT_HTTP_MAXSIZE_HARD);\n+    attributeToConf = Collections.unmodifiableMap(a2c);\n+\n+    // Initialize attribute->default\n+    Map<String, Long> a2d = new HashMap<String, Long>();\n+    a2d.put(ATTRIBUTE_HTTP_LIMIT, DEFAULT_HTTP_LIMIT);\n+    a2d.put(ATTRIBUTE_HTTP_MAXSIZE, DEFAULT_HTTP_MAXSIZE);\n+    a2d.put(ATTRIBUTE_HTTP_LIMIT_HARD, DEFAULT_HTTP_LIMIT);\n+    a2d.put(ATTRIBUTE_HTTP_MAXSIZE_HARD, DEFAULT_HTTP_MAXSIZE);\n+    attributeToDefault = Collections.unmodifiableMap(a2d);\n+\n+    // Create functions and map\n+    functions = new HashMap<String, Object>();\n+\n+    functions.put(\"HTTP\", new HTTP(\"HTTP\"));\n+    functions.put(\"MAXURLCOUNT\", new MAXURLCOUNT(\"MAXURLCOUNT\"));\n+    functions.put(\"MAXDOWNLOADSIZE\", new MAXDOWNLOADSIZE(\"MAXDOWNLOADSIZE\"));\n+  }\n+\n+  public Map<String, Object> getFunctions() {\n+    return functions;\n+  }\n+\n+  /**\n+   * Get the value of the attribute in the stack, if not present get the value in the configuration and it not present either, get the default value.\n+   * Also set the attribute in the stack once the value is found.\n+   *\n+   * @param stack     The stack the get the attribute from, if present.\n+   * @param attribute The attribute name to get.\n+   * @return The first available value in the list: attribute value, configuration value, default.\n+   */\n+  public static Long getLongAttribute(WarpScriptStack stack, String attribute) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 148}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQzMzM3MzM0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo1MjoxMlrOII6MIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOVQwODo1MjoxMlrOII6MIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NjIxMjg5OA==", "bodyText": "2020", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r546212898", "createdAt": "2020-12-19T08:52:12Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HttpWarpScriptExtension.java", "diffHunk": "@@ -0,0 +1,172 @@\n+//\n+//   Copyright 2021  SenX S.A.S.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "822e405ec4807f902d2e351d438174bd0ab9678a"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4NzgzNzExOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjoxMjoxOFrOI7vTpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzowODozNFrOI7xrsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUxMTk3Mg==", "bodyText": "Do not prefix with WarpScriptStack.CAPABILITIES_PREFIX.\nIf a token has the attribute .cap:http you're looking for the http capability, not the .cap:http capability.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599511972", "createdAt": "2021-03-23T12:12:18Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 140}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU1MDg5Ng==", "bodyText": "Fixing this will make the if useless.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599550896", "createdAt": "2021-03-23T13:08:34Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUxMTk3Mg=="}, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzg2NjU2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjoxOToyNlrOI7vlfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjoxOToyNlrOI7vlfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUxNjU0Mg==", "bodyText": "Do not prefix with WarpScriptStack.CAPABILITIES_PREFIX (x2).", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599516542", "createdAt": "2021-03-23T12:19:26Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzg2Njk5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjoxOTozM1rOI7vlwg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjoxOTozM1rOI7vlwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUxNjYxMA==", "bodyText": "Do not prefix with WarpScriptStack.CAPABILITIES_PREFIX (x2).", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599516610", "createdAt": "2021-03-23T12:19:33Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = base_maxrequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzk1MzExOnYy", "diffSide": "RIGHT", "path": "etc/conf.templates/distributed/20-warpscript.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjozOToxMVrOI7wX-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjozOToxMVrOI7wX-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUyOTQ2NQ==", "bodyText": "\"inspected\" is too vague, I'd prefer \"checked\" to stick with the CAPCHECK terminology.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599529465", "createdAt": "2021-03-23T12:39:11Z", "author": {"login": "ftence"}, "path": "etc/conf.templates/distributed/20-warpscript.conf.template", "diffHunk": "@@ -218,6 +218,21 @@ warpscript.mobius.pool = 16\n // List of patterns to include/exclude for hosts, works the same way as webcall.host.patterns. Defaults to the value of webcall.host.patterns.\n #warpscript.urlfetch.host.patterns =\n \n+//\n+// HTTP extension\n+//\n+\n+// If set to true, HTTP requires the stack to be authenticated\n+#warpscript.http.authentication.required =\n+// If set, the capability .cap:<warpscript.http.capability> is inspected to grant access to HTTP function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzk2MDk0OnYy", "diffSide": "RIGHT", "path": "etc/conf.templates/standalone/20-warpscript.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0MDo1MlrOI7wclg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0MDo1MlrOI7wclg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzMDY0Ng==", "bodyText": "Same here with \"inspected\".", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599530646", "createdAt": "2021-03-23T12:40:52Z", "author": {"login": "ftence"}, "path": "etc/conf.templates/standalone/20-warpscript.conf.template", "diffHunk": "@@ -216,6 +216,21 @@ warpscript.runner.bootstrap.period = 120000\n // List of patterns to include/exclude for hosts, works the same way as webcall.host.patterns. Defaults to the value of webcall.host.patterns.\n #warpscript.urlfetch.host.patterns =\n \n+//\n+// HTTP extension\n+//\n+\n+// If set to true, HTTP requires the stack to be authenticated\n+#warpscript.http.authentication.required =\n+// If set, the capability .cap:<warpscript.http.capability> is inspected to grant access to HTTP function", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzk3MTMwOnYy", "diffSide": "RIGHT", "path": "etc/conf.templates/distributed/20-warpscript.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0MzoyMlrOI7wjBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0MzoyMlrOI7wjBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzMjI5Mg==", "bodyText": "Do not prefix capabilities with \".cap\". This prefix is only to store them in tokens, the capabilities are \"<warpscript.http.capability>\", \"http.requests\" and \"http.size\".", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599532292", "createdAt": "2021-03-23T12:43:22Z", "author": {"login": "ftence"}, "path": "etc/conf.templates/distributed/20-warpscript.conf.template", "diffHunk": "@@ -218,6 +218,21 @@ warpscript.mobius.pool = 16\n // List of patterns to include/exclude for hosts, works the same way as webcall.host.patterns. Defaults to the value of webcall.host.patterns.\n #warpscript.urlfetch.host.patterns =\n \n+//\n+// HTTP extension\n+//\n+\n+// If set to true, HTTP requires the stack to be authenticated\n+#warpscript.http.authentication.required =\n+// If set, the capability .cap:<warpscript.http.capability> is inspected to grant access to HTTP function\n+#warpscript.http.capability =\n+// Maximum number of HTTP calls, 1 by default, can be raised with capability .cap:http.requests\n+#warpscript.http.requests =\n+// Maximum downloaded bytes by HTTP, 65536 by default, can be raised with capability .cap:http.size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzk3Mjc5OnYy", "diffSide": "RIGHT", "path": "etc/conf.templates/standalone/20-warpscript.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0Mzo0MFrOI7wj2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0Mzo0MFrOI7wj2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzMjUwNw==", "bodyText": "Same here with \".cap:\" prefix.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599532507", "createdAt": "2021-03-23T12:43:40Z", "author": {"login": "ftence"}, "path": "etc/conf.templates/standalone/20-warpscript.conf.template", "diffHunk": "@@ -216,6 +216,21 @@ warpscript.runner.bootstrap.period = 120000\n // List of patterns to include/exclude for hosts, works the same way as webcall.host.patterns. Defaults to the value of webcall.host.patterns.\n #warpscript.urlfetch.host.patterns =\n \n+//\n+// HTTP extension\n+//\n+\n+// If set to true, HTTP requires the stack to be authenticated\n+#warpscript.http.authentication.required =\n+// If set, the capability .cap:<warpscript.http.capability> is inspected to grant access to HTTP function\n+#warpscript.http.capability =\n+// Maximum number of HTTP calls, 1 by default, can be raised with capability .cap:http.requests\n+#warpscript.http.requests =\n+// Maximum downloaded bytes by HTTP, 65536 by default, can be raised with capability .cap:http.size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzk3OTM4OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0NTowM1rOI7wntw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0NTowM1rOI7wntw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzMzQ5NQ==", "bodyText": "No \".cap:\" prefix.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599533495", "createdAt": "2021-03-23T12:45:03Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzk5MjcwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0Nzo0MVrOI7wvWg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0Nzo0MVrOI7wvWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzNTQ1MA==", "bodyText": "Parameter names do not have spaces in other functions, I'd go with dots instead, ie \"auth.info\", etc.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599535450", "createdAt": "2021-03-23T12:47:41Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 62}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4Nzk5NTU2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0ODoxOVrOI7ww9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo0ODoxOVrOI7ww9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzNTg2Mw==", "bodyText": "Same here with spaces in keys, prefer dots.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599535863", "createdAt": "2021-03-23T12:48:19Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODAxMDEzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo1MDo1MlrOI7w5JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMjo1MDo1MlrOI7w5JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzNzk1Nw==", "bodyText": "Use camelCase.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599537957", "createdAt": "2021-03-23T12:50:52Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODA4NjQ2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzowNjo1OFrOI7xm8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzowNjo1OFrOI7xm8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU0OTY4Mw==", "bodyText": "Use parseLong to avoid unnecessary boxing.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599549683", "createdAt": "2021-03-23T13:06:58Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 150}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODA4NzA1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzowNzowNlrOI7xnRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzowNzowNlrOI7xnRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU0OTc2Nw==", "bodyText": "Ditto.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599549767", "createdAt": "2021-03-23T13:07:06Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODEyOTkzOnYy", "diffSide": "RIGHT", "path": "etc/conf.templates/distributed/20-warpscript.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzoxNjowMVrOI7yBrQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzoxNjowMVrOI7yBrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU1NjUyNQ==", "bodyText": "\"maxrequests\" or \"requests.max\" may be more self-explanatory.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599556525", "createdAt": "2021-03-23T13:16:01Z", "author": {"login": "ftence"}, "path": "etc/conf.templates/distributed/20-warpscript.conf.template", "diffHunk": "@@ -218,6 +218,21 @@ warpscript.mobius.pool = 16\n // List of patterns to include/exclude for hosts, works the same way as webcall.host.patterns. Defaults to the value of webcall.host.patterns.\n #warpscript.urlfetch.host.patterns =\n \n+//\n+// HTTP extension\n+//\n+\n+// If set to true, HTTP requires the stack to be authenticated\n+#warpscript.http.authentication.required =\n+// If set, the capability .cap:<warpscript.http.capability> is inspected to grant access to HTTP function\n+#warpscript.http.capability =\n+// Maximum number of HTTP calls, 1 by default, can be raised with capability .cap:http.requests\n+#warpscript.http.requests =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODEzMjQ3OnYy", "diffSide": "RIGHT", "path": "etc/conf.templates/standalone/20-warpscript.conf.template", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzoxNjozNFrOI7yDSQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzoxNjozNFrOI7yDSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU1NjkzNw==", "bodyText": "Same here, \"maxrequests\" or something else?", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599556937", "createdAt": "2021-03-23T13:16:34Z", "author": {"login": "ftence"}, "path": "etc/conf.templates/standalone/20-warpscript.conf.template", "diffHunk": "@@ -216,6 +216,21 @@ warpscript.runner.bootstrap.period = 120000\n // List of patterns to include/exclude for hosts, works the same way as webcall.host.patterns. Defaults to the value of webcall.host.patterns.\n #warpscript.urlfetch.host.patterns =\n \n+//\n+// HTTP extension\n+//\n+\n+// If set to true, HTTP requires the stack to be authenticated\n+#warpscript.http.authentication.required =\n+// If set, the capability .cap:<warpscript.http.capability> is inspected to grant access to HTTP function\n+#warpscript.http.capability =\n+// Maximum number of HTTP calls, 1 by default, can be raised with capability .cap:http.requests\n+#warpscript.http.requests =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODE3Mzc5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzoyNDoyNVrOI7ycAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzoyNDoyNVrOI7ycAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU2MzI2Nw==", "bodyText": "Can throw NPE because conn.getErrorStream(); can return null.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599563267", "createdAt": "2021-03-23T13:24:25Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = base_maxrequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = base_maxsize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> headers = (Map) formattedArgs.get(HEADERS);\n+    Object body = formattedArgs.get(BODY);\n+    List authInfo = (List) formattedArgs.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) formattedArgs.get(AUTH_MACRO);\n+    Long chunkSize = (Long) formattedArgs.get(CHUNK_SIZE);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) formattedArgs.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new HashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {\n+        byte[] buf = new byte[8192];\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        while (true) {\n+          int len = in.read(buf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 369}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODIyMzc0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzozMzoyNlrOI7y6aQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxMzozMzoyNlrOI7y6aQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU3MTA0OQ==", "bodyText": "Already checked by webAccessController.checkURL.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599571049", "createdAt": "2021-03-23T13:33:26Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = base_maxrequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = base_maxsize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> headers = (Map) formattedArgs.get(HEADERS);\n+    Object body = formattedArgs.get(BODY);\n+    List authInfo = (List) formattedArgs.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) formattedArgs.get(AUTH_MACRO);\n+    Long chunkSize = (Long) formattedArgs.get(CHUNK_SIZE);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) formattedArgs.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 223}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODM3OTE0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNDowMjowOVrOI70bIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNDowMjowOVrOI70bIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU5NTgxMA==", "bodyText": "This will leak headers between calls, use null or do not use FormattedWarpScriptFunction.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599595810", "createdAt": "2021-03-23T14:02:09Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODQ4NzQ2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNDoyMTowNFrOI71d3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNjowNDoxNFrOI77c4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTYxMjg5NA==", "bodyText": "I'm not convinced by the usefulness of this.\nFor the simple auth, one can do\n  'headers' {\n    'Authorization' 'Basic ' 'user:password' ->B64 +\n  }\n\nand for the macro case, the macro can directly update the headers.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599612894", "createdAt": "2021-03-23T14:21:04Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = base_maxrequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = base_maxsize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> headers = (Map) formattedArgs.get(HEADERS);\n+    Object body = formattedArgs.get(BODY);\n+    List authInfo = (List) formattedArgs.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) formattedArgs.get(AUTH_MACRO);\n+    Long chunkSize = (Long) formattedArgs.get(CHUNK_SIZE);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) formattedArgs.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 296}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTcxMDk0NA==", "bodyText": "IMO basic authentication is so common that saving a few lines and hiding the encoding is worth it", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599710944", "createdAt": "2021-03-23T16:04:14Z", "author": {"login": "randomboolean"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = base_maxrequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = base_maxsize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> headers = (Map) formattedArgs.get(HEADERS);\n+    Object body = formattedArgs.get(BODY);\n+    List authInfo = (List) formattedArgs.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) formattedArgs.get(AUTH_MACRO);\n+    Long chunkSize = (Long) formattedArgs.get(CHUNK_SIZE);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) formattedArgs.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTYxMjg5NA=="}, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 296}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODY1NzU1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNDo0Nzo1N1rOI73FbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNDo0Nzo1N1rOI73FbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTYzOTQwNA==", "bodyText": "Use System.arraycopy(buf, 0, buf2, 0, buf2.length);", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599639404", "createdAt": "2021-03-23T14:47:57Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,430 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.script.formatted.FormattedWarpScriptFunction;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ */\n+public class HTTP extends FormattedWarpScriptFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  private final Arguments args;\n+  protected Arguments getArguments() {\n+    return args;\n+  }\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  private final Arguments output;\n+  protected Arguments getOutput() {\n+    return output;\n+  }\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    getDocstring().append(\"Apply an HTTP method over an url and fetch response.\");\n+\n+    args = new ArgumentsBuilder()\n+      .addArgument(String.class, METHOD, \"The http method.\")\n+      .addArgument(String.class, URL, \"The URL to send the request to. Must begin with http:// or https://.\")\n+      .addOptionalArgument(Map.class, HEADERS, \"An optional header.\", new HashMap<>())\n+      .addOptionalArgument(Object.class, BODY, \"An optional body. STRING or BYTES.\", \"\")\n+      .addOptionalArgument(List.class, AUTH_INFO, \"Authentication arguments. For example for basic authentication, provide [username, password].\", null)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, AUTH_MACRO, \"A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication.\", null)\n+      .addOptionalArgument(Long.class, CHUNK_SIZE, \"Chunk size\", -1L)\n+      .addOptionalArgument(WarpScriptStack.Macro.class, CHUNK_MACRO, \"A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects).\", new WarpScriptStack.Macro())\n+      .build();\n+\n+    output = new ArgumentsBuilder()\n+      .addArgument(Map.class, RESPONSE, \"A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used.\")\n+      .build();\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public WarpScriptStack apply(Map<String, Object> formattedArgs, WarpScriptStack stack) throws WarpScriptException {\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = base_maxrequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = base_maxsize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) formattedArgs.get(METHOD);\n+    Map<Object, Object> headers = (Map) formattedArgs.get(HEADERS);\n+    Object body = formattedArgs.get(BODY);\n+    List authInfo = (List) formattedArgs.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) formattedArgs.get(AUTH_MACRO);\n+    Long chunkSize = (Long) formattedArgs.get(CHUNK_SIZE);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) formattedArgs.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) formattedArgs.get(URL));\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new HashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {\n+        byte[] buf = new byte[8192];\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        while (true) {\n+          int len = in.read(buf);\n+          if (len < 0) {\n+            break;\n+          }\n+\n+          if (downloadSize.get() + baos.size() + len > maxsize) {\n+            throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+          }\n+\n+          baos.write(buf, 0, len);\n+        }\n+\n+        downloadSize.addAndGet(baos.size());\n+        res.put(CONTENT, baos.toByteArray());\n+\n+      } else {\n+        byte[] buf = new byte[chunkSize.intValue()];\n+        Map<String, Object> chunkRes = new HashMap<>(res);\n+\n+        int chunkNumber = 0;\n+        while (true) {\n+          chunkNumber++;\n+\n+          int len = in.read(buf);\n+          if (len < 0) {\n+            break;\n+          }\n+\n+          if (downloadSize.addAndGet(len) > maxsize) {\n+            throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+          }\n+\n+          if (len == chunkSize) {\n+            chunkRes.put(CONTENT, buf);\n+          } else {\n+            byte[] buf2 = new byte[len];\n+            for (int i = 0; i < buf2.length; i++) {\n+              buf2[i] = buf[i];\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fe84c89749836226e250b13c2ff55a9a83e94ce1"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODgzNTE4OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNToxNzo0MVrOI740_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNToxNzo0MVrOI740_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTY2Nzk2Ng==", "bodyText": "You should always make a copy.\nThis isn't great performance-wise but if someone leave the byte[] on the stack, it will be modified and will confuse the user.\nIt may be OK to reuse the same Map but I think this should be discussed.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599667966", "createdAt": "2021-03-23T15:17:41Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,437 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = base_maxrequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = base_maxsize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.getOrDefault(BODY,\"\");\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new HashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {\n+        byte[] buf = new byte[8192];\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        while (true) {\n+          int len = in.read(buf);\n+          if (len < 0) {\n+            break;\n+          }\n+\n+          if (downloadSize.get() + baos.size() + len > maxsize) {\n+            throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+          }\n+\n+          baos.write(buf, 0, len);\n+        }\n+\n+        downloadSize.addAndGet(baos.size());\n+        res.put(CONTENT, baos.toByteArray());\n+\n+      } else {\n+        byte[] buf = new byte[chunkSize.intValue()];\n+        Map<String, Object> chunkRes = new HashMap<>(res);\n+\n+        int chunkNumber = 0;\n+        while (true) {\n+          chunkNumber++;\n+\n+          int len = in.read(buf);\n+          if (len < 0) {\n+            break;\n+          }\n+\n+          if (downloadSize.addAndGet(len) > maxsize) {\n+            throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+          }\n+\n+          if (len == chunkSize) {\n+            chunkRes.put(CONTENT, buf);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5b43b1d7000032e8dd12fad9c477bbfe63a8ff"}, "originalPosition": 407}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc4ODg2NDMyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNToyMjo0MVrOI75HFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yM1QxNToyMjo0MVrOI75HFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTY3MjU5OA==", "bodyText": "If you make the macro optional, the content Map must be a copy, like discussed above.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r599672598", "createdAt": "2021-03-23T15:22:41Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,437 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * .cap:http.requests\n+ * .cap:http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth info\";\n+  public static final String AUTH_MACRO = \"auth macro\";\n+  public static final String CHUNK_SIZE = \"chunk size\";\n+  public static final String CHUNK_MACRO = \"chunk macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status code\";\n+  public static final String STATUS_MESSAGE = \"status message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long base_maxrequests;\n+  private final long base_maxsize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    String capNameSuffix = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+    if (null != capNameSuffix) {\n+      capName = WarpScriptStack.CAPABILITIES_PREFIX + capNameSuffix;\n+    } else {\n+      capName = null;\n+    }\n+\n+    // retrieve limits\n+    Object conf_maxrequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == conf_maxrequests) {\n+      base_maxrequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      base_maxrequests = Long.valueOf((String) conf_maxrequests);\n+    }\n+\n+    Object conf_maxsize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == conf_maxsize) {\n+      base_maxsize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      base_maxsize = Long.valueOf((String) conf_maxsize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = base_maxrequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, WarpScriptStack.CAPABILITIES_PREFIX + HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = base_maxsize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.getOrDefault(BODY,\"\");\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new HashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {\n+        byte[] buf = new byte[8192];\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+        while (true) {\n+          int len = in.read(buf);\n+          if (len < 0) {\n+            break;\n+          }\n+\n+          if (downloadSize.get() + baos.size() + len > maxsize) {\n+            throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+          }\n+\n+          baos.write(buf, 0, len);\n+        }\n+\n+        downloadSize.addAndGet(baos.size());\n+        res.put(CONTENT, baos.toByteArray());\n+\n+      } else {\n+        byte[] buf = new byte[chunkSize.intValue()];\n+        Map<String, Object> chunkRes = new HashMap<>(res);\n+\n+        int chunkNumber = 0;\n+        while (true) {\n+          chunkNumber++;\n+\n+          int len = in.read(buf);\n+          if (len < 0) {\n+            break;\n+          }\n+\n+          if (downloadSize.addAndGet(len) > maxsize) {\n+            throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+          }\n+\n+          if (len == chunkSize) {\n+            chunkRes.put(CONTENT, buf);\n+          } else {\n+            byte[] buf2 = new byte[len];\n+            for (int i = 0; i < buf2.length; i++) {\n+              buf2[i] = buf[i];\n+            }\n+            chunkRes.put(CONTENT, buf2);\n+          }\n+          chunkRes.put(CHUNK_NUMBER, new Long(chunkNumber));\n+          stack.push(chunkRes);\n+          if (null != chunkMacro) {\n+            stack.exec(chunkMacro);\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5b43b1d7000032e8dd12fad9c477bbfe63a8ff"}, "originalPosition": 419}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc5NDc2NjcxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNTozNDo1NFrOI8xr7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNTozNDo1NFrOI8xr7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDU5OTUzNQ==", "bodyText": "You should return an empty content, like for the non-chunked case, and let the user handle the error. Throwing an exception will make it very difficult to debug why the stream is empty.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r600599535", "createdAt": "2021-03-24T15:34:54Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,442 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.getOrDefault(BODY,\"\");\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new HashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {\n+\n+        if (null != in) {\n+          byte[] buf = new byte[8192];\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+          while (true) {\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.get() + baos.size() + len > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+            }\n+\n+            baos.write(buf, 0, len);\n+          }\n+\n+          downloadSize.addAndGet(baos.size());\n+          res.put(CONTENT, baos.toByteArray());\n+\n+        } else {\n+          res.put(CONTENT, new byte[0]);\n+        }\n+\n+      } else {\n+\n+        if (null != in) {\n+\n+          int chunkNumber = 0;\n+          while (true) {\n+            chunkNumber++;\n+\n+            Map<String, Object> chunkRes = new HashMap<>(res);\n+            byte[] buf = new byte[chunkSize.intValue()];\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.addAndGet(len) > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+            }\n+\n+            if (len == chunkSize) {\n+              chunkRes.put(CONTENT, buf);\n+            } else {\n+              byte[] buf2 = new byte[len];\n+              System.arraycopy(buf, 0, buf2, 0, buf2.length);\n+              chunkRes.put(CONTENT, buf2);\n+            }\n+            chunkRes.put(CHUNK_NUMBER, new Long(chunkNumber));\n+            stack.push(chunkRes);\n+            if (null != chunkMacro) {\n+              stack.exec(chunkMacro);\n+            }\n+          }\n+\n+        } else {\n+          throw new WarpScriptException(getName() + \" expects a stream to be chunked, but input stream is empty.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d8ba19cf9b66d06017c236487a5b233b97c6956"}, "originalPosition": 424}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc5NDg4NTc5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNTo1Mzo0MVrOI8y3fw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNTo1Mzo0MVrOI8y3fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDYxODg3OQ==", "bodyText": "Use a LinkedHashMap instead of HashMap, because that's usually what is on the stack when we put a Map.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r600618879", "createdAt": "2021-03-24T15:53:41Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,442 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.getOrDefault(BODY,\"\");\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new HashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {\n+\n+        if (null != in) {\n+          byte[] buf = new byte[8192];\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+          while (true) {\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.get() + baos.size() + len > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+            }\n+\n+            baos.write(buf, 0, len);\n+          }\n+\n+          downloadSize.addAndGet(baos.size());\n+          res.put(CONTENT, baos.toByteArray());\n+\n+        } else {\n+          res.put(CONTENT, new byte[0]);\n+        }\n+\n+      } else {\n+\n+        if (null != in) {\n+\n+          int chunkNumber = 0;\n+          while (true) {\n+            chunkNumber++;\n+\n+            Map<String, Object> chunkRes = new HashMap<>(res);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d8ba19cf9b66d06017c236487a5b233b97c6956"}, "originalPosition": 398}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc5NDg4ODc5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNTo1NDoxNVrOI8y5XA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNTo1NDoxNVrOI8y5XA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDYxOTM1Ng==", "bodyText": "Use LinkedHashMap.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r600619356", "createdAt": "2021-03-24T15:54:15Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,442 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.getOrDefault(BODY,\"\");\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new HashMap<String, List<String>>(hdrs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d8ba19cf9b66d06017c236487a5b233b97c6956"}, "originalPosition": 346}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc5NDk2NzEwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNjowNjowM1rOI8zrnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNjowNjowM1rOI8zrnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDYzMjIyMw==", "bodyText": "You can simply use get, which will default to null, thus skipping both instanceof conditionals.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r600632223", "createdAt": "2021-03-24T16:06:03Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,442 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.getOrDefault(BODY,\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d8ba19cf9b66d06017c236487a5b233b97c6956"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzc5NTI1ODEyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNFQxNjo1Nzo1MFrOI82kFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxNDowMzo0NlrOI-arSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDY3OTQ0NA==", "bodyText": "I think the macro.auth mechanism will not add any value to the HTTP method. For instance, it will not help in generating the digest auth authorization header, especially when doing multiple authenticated requests.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r600679444", "createdAt": "2021-03-24T16:57:50Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,442 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.getOrDefault(BODY,\"\");\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8d8ba19cf9b66d06017c236487a5b233b97c6956"}, "originalPosition": 266}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjMxOTY4OA==", "bodyText": "I don't see why it can not be used to generate digest auth. But I see it can be painful to write the auth macro for digest auth without another extension (one could wraps another java function, like for example DigestScheme.authenticate)..", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602319688", "createdAt": "2021-03-26T14:03:46Z", "author": {"login": "randomboolean"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,442 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.getOrDefault(BODY,\"\");\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDY3OTQ0NA=="}, "originalCommit": {"oid": "8d8ba19cf9b66d06017c236487a5b233b97c6956"}, "originalPosition": 266}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjkxNzIzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNTo0MlrOI-laaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNTo0MlrOI-laaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5NTU5NQ==", "bodyText": "to a URL", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602495595", "createdAt": "2021-03-26T18:05:42Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjkxODc0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNjoxMVrOI-lbZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNjoxMVrOI-lbZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5NTg0NQ==", "bodyText": "The param names are in lower case", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602495845", "createdAt": "2021-03-26T18:06:11Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjkxOTczOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNjoyOFrOI-lcBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNjoyOFrOI-lcBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5NjAwNg==", "bodyText": "header map", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602496006", "createdAt": "2021-03-26T18:06:28Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 54}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjkyMDkwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNjo0MlrOI-lcsA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNjo0MlrOI-lcsA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5NjE3Ng==", "bodyText": "Specify the charset used if the body is a STRING", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602496176", "createdAt": "2021-03-26T18:06:42Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjkyNDkwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNzo0M1rOI-lfAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowNzo0M1rOI-lfAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5Njc3MQ==", "bodyText": "Since this ends up being a header, maybe it is better to provide a helper function or macro to pack username and password as a value suitable for a header", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602496771", "createdAt": "2021-03-26T18:07:43Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjkyNjk0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowODoxNVrOI-lgQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowODoxNVrOI-lgQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5NzA4OA==", "bodyText": "see above", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602497088", "createdAt": "2021-03-26T18:08:15Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjkyOTgxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowODo1OFrOI-liCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODowODo1OFrOI-liCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5NzU0NQ==", "bodyText": "The chunk size should have a configurable upper limit to avoid giant allocations", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602497545", "createdAt": "2021-03-26T18:08:58Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjkzODQyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMTowMlrOI-lm_w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMTowMlrOI-lm_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5ODgxNQ==", "bodyText": "Parameter extraction should be done in a static way so other instances of HTTP do not repeat it.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602498815", "createdAt": "2021-03-26T18:11:02Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk0MTA2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMTo1MVrOI-loqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMTo1MVrOI-loqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5OTI0Mw==", "bodyText": "missing function name", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602499243", "createdAt": "2021-03-26T18:11:51Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 164}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk0MzI2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMjoyOVrOI-lqBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMjoyOVrOI-lqBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5OTU4OQ==", "bodyText": "could default to GET", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602499589", "createdAt": "2021-03-26T18:12:29Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk0NTM2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMzowN1rOI-lrRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMzowN1rOI-lrRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjQ5OTkxMQ==", "bodyText": "You are not checking if the parameter is a Macro, this will throw an exception if that is not the case", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602499911", "createdAt": "2021-03-26T18:13:07Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk0NjA4OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMzoxOFrOI-lrrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxMzoxOFrOI-lrrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwMDAxNQ==", "bodyText": "a URL", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602500015", "createdAt": "2021-03-26T18:13:18Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk0OTE5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxNDoxNlrOI-lttQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxNDoxNlrOI-lttQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwMDUzMw==", "bodyText": "per script execution", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602500533", "createdAt": "2021-03-26T18:14:16Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 248}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk1NzIzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxNjoxNlrOI-lyRg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxNjoxNlrOI-lyRg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwMTcwMg==", "bodyText": "This will probably produce a weird behavior if method is not POST as setting doOutput to true normally forces the method to be POST", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602501702", "createdAt": "2021-03-26T18:16:16Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 305}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk1OTc1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxNjo1MFrOI-lztg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxNjo1MFrOI-lztg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwMjA3MA==", "bodyText": "ditto, body should be ignored if method is GET or another method which does not allow a body", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602502070", "createdAt": "2021-03-26T18:16:50Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 314}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk2NTc0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxODoxOFrOI-l3JQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxODoxOFrOI-l3JQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwMjk0OQ==", "bodyText": "are the lists inside of the original hdrs map modifiable?", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602502949", "createdAt": "2021-03-26T18:18:18Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new LinkedHashMap<String, List<String>>(hdrs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 347}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk2OTQ5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxOToxNlrOI-l5Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxOToxNlrOI-l5Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwMzQ5MQ==", "bodyText": "per script execution", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602503491", "createdAt": "2021-03-26T18:19:16Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new LinkedHashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {\n+\n+        if (null != in) {\n+          byte[] buf = new byte[8192];\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+          while (true) {\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.get() + baos.size() + len > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 378}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk3MTA3OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoxOTo0MVrOI-l6Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0zMVQxNjozNDoyOVrOJBBVlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwMzczOQ==", "bodyText": "what semantics does a negatice chunkSize have?", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602503739", "createdAt": "2021-03-26T18:19:41Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new LinkedHashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTA1MDI2MQ==", "bodyText": "none other than not using chunk option", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r605050261", "createdAt": "2021-03-31T16:34:29Z", "author": {"login": "randomboolean"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new LinkedHashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwMzczOQ=="}, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 365}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzgwNjk3ODA5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoyMTo0OFrOI-l-eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMy0yNlQxODoyMTo0OFrOI-l-eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjUwNDgyNQ==", "bodyText": "If EOF is reached while attempting to read buf.length bytes you will exit the loop and miss the last part of the data", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r602504825", "createdAt": "2021-03-26T18:21:48Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,449 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to an url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * METHOD The http method\n+ * URL The URL to send the request to. Must begin with http:// or https://\n+ * HEADERS An optional header\n+ * BODY An optional body. STRING or BYTES\n+ * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n+ * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n+ * CHUNK_SIZE Chunk size\n+ * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String AUTH_INFO = \"auth.info\";\n+  public static final String AUTH_MACRO = \"auth.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private final boolean auth;\n+  private final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private final long baseMaxRequests;\n+  private final long baseMaxSize;\n+\n+  public HTTP(String name) {\n+    super(name);\n+\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(\"Capability \" + capName + \" is required by function \" + getName());\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    String method = (String) params.get(METHOD);\n+    if (null == method) {\n+      throw new WarpScriptException(getName() + \" expects an http method.\");\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+    Object body = params.get(BODY);\n+\n+    List authInfo = (List) params.get(AUTH_INFO);\n+    WarpScriptStack.Macro authMacro = (WarpScriptStack.Macro) params.get(AUTH_MACRO);\n+    Long chunkSize = (Long) params.getOrDefault(CHUNK_SIZE, -1L);\n+    WarpScriptStack.Macro chunkMacro = (WarpScriptStack.Macro) params.get(CHUNK_MACRO);\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects an url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls.\");\n+    }\n+\n+    Map<String, Object> res = new HashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Encode userinfo and set headers\n+      //\n+\n+      if (null != authInfo) {\n+\n+        Map additionalHeaders;\n+        if (null != authMacro) {\n+          stack.push(authInfo);\n+          stack.exec(authMacro);\n+          additionalHeaders = (Map) stack.pop();\n+\n+        } else {\n+          // doing basic auth\n+          if (authInfo.size() != 2) {\n+            throw new WarpScriptException(getName() + \" expects a list with two items, username and password, in argument \" + authInfo + \".\");\n+          }\n+\n+          if (!(authInfo.get(0) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when using basic authentication.\");\n+          }\n+\n+          if (!(authInfo.get(1) instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when using basic authentication.\");\n+          }\n+\n+          String userInfo = authInfo.get(0) + \":\" + authInfo.get(1);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          additionalHeaders =  new HashMap<Object, Object>();\n+          additionalHeaders.put(\"Authorization\", basicAuth);\n+        }\n+\n+        headers.putAll(additionalHeaders);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (body instanceof String) {\n+        String bodyS = (String) body;\n+        conn.setDoOutput(bodyS.length() > 0);\n+        if (bodyS.length() > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+          }\n+        }\n+\n+      } else if (body instanceof byte[]) {\n+        byte[] bodyB = (byte[]) body;\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Make the headers map modifiable\n+      //\n+\n+      hdrs = new LinkedHashMap<String, List<String>>(hdrs);\n+      hdrs.remove(null);\n+\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (chunkSize <= 0) {\n+\n+        if (null != in) {\n+          byte[] buf = new byte[8192];\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+          while (true) {\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.get() + baos.size() + len > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+            }\n+\n+            baos.write(buf, 0, len);\n+          }\n+\n+          downloadSize.addAndGet(baos.size());\n+          res.put(CONTENT, baos.toByteArray());\n+\n+        } else {\n+          res.put(CONTENT, new byte[0]);\n+        }\n+\n+      } else {\n+\n+        if (null != in) {\n+\n+          int chunkNumber = 0;\n+          while (true) {\n+            chunkNumber++;\n+\n+            Map<String, Object> chunkRes = new LinkedHashMap<>(res);\n+            byte[] buf = new byte[chunkSize.intValue()];\n+            int len = in.read(buf);\n+            if (len < 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "29a75c953830c4f95ec65f63afac4e0d0904e179"}, "originalPosition": 402}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTA4NDc5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMjo0NjowNFrOJHQ2Lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMjo0NjowNFrOJHQ2Lw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTU5NTgyMw==", "bodyText": "An optional", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611595823", "createdAt": "2021-04-12T12:46:04Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -35,28 +35,30 @@\n import java.net.MalformedURLException;\n import java.net.URL;\n import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.LinkedHashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.atomic.AtomicLong;\n \n /**\n- * Send an HTTP request to an url\n+ * Send an HTTP request to a url\n  *\n  * To raise maximum number of calls and download size limit, use these capabilities:\n  * http.requests\n  * http.size\n  *\n  * Params:\n- * METHOD The http method\n- * URL The URL to send the request to. Must begin with http:// or https://\n- * HEADERS An optional header\n- * BODY An optional body. STRING or BYTES\n- * AUTH_INFO Authentication arguments. For example for basic authentication, provide [username, password]\n- * AUTH_MACRO A macro that expects \" + AUTH_INFO + \" on the stack, and returns a map to be appended with the headers. Default to basic authentication\n- * CHUNK_SIZE Chunk size\n- * CHUNK_MACRO A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTExNzEwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMjo1Mjo1MVrOJHRI5g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMjo1Mjo1MVrOJHRI5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYwMDYxNA==", "bodyText": "Maybe you could list all the capabilities related to this function?", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611600614", "createdAt": "2021-04-12T12:52:51Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTEyMDczOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMjo1Mzo0MlrOJHRLEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMjo1Mzo0MlrOJHRLEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYwMTE3MA==", "bodyText": "chunkSize can be null so it may throw a NPE.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611601170", "createdAt": "2021-04-12T12:53:42Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTIzOTMyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzoxNzowOVrOJHSRKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzoxNzowOVrOJHSRKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYxOTExNQ==", "bodyText": "Don't duplicate the code, simply convert the String to byte[], with bodyS.getBytes(StandardCharsets.UTF_8), then do the logic on the body as byte[].", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611619115", "createdAt": "2021-04-12T13:17:09Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {\n+\n+        Object username = params.get(USERNAME);\n+        Object password = params.get(PASSWORD);\n+\n+        if (null != username && null != password) {\n+\n+          //\n+          // Compute basic auth\n+          //\n+\n+          if (!(username instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+          }\n+\n+          if (!(password instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+          }\n+\n+          String userInfo = ((String) username) + \":\" + ((String) password);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          conn.setRequestProperty(\"Authorization\", basicAuth);\n+        }\n+\n+      } else {\n+\n+        stack.push(params);\n+        stack.exec(headersMacro);\n+        o = stack.pop();\n+\n+        if (!(o instanceof Map)) {\n+          throw new WarpScriptException(getName() + \" expects the \" + HEADERS_MACRO + \" to push a headers map onto the stack.\");\n+        }\n+\n+        headers = (Map) o;\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (\"GET\" != method && \"DELETE\" != method && \"TRACE\" != method && \"OPTIONS\" != method && \"HEAD\" != method) {\n+\n+        if (body instanceof String) {\n+          String bodyS = (String) body;\n+          conn.setDoOutput(bodyS.length() > 0);\n+          if (bodyS.length() > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+            }\n+          }\n+\n+        } else if (body instanceof byte[]) {\n+          byte[] bodyB = (byte[]) body;\n+          conn.setDoOutput(bodyB.length > 0);\n+          if (bodyB.length > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyB);\n+            }\n+          }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 381}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTI5NDI2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzoyNzozNlrOJHSyOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxMTozOToyOVrOJRReww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYyNzU3Nw==", "bodyText": "In fact, only TRACE cannot have a body, see the source code of HttpURLConnection. So either check for TRACE (using equals, not ==) or handle the IOException it may throw.\nThe method is changed from GET to POST if there is a body by the getOutputStream. My opinion is to let that happen. This is coherent with defaulting to \"POST\" if no method is defined and there is a body.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611627577", "createdAt": "2021-04-12T13:27:36Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {\n+\n+        Object username = params.get(USERNAME);\n+        Object password = params.get(PASSWORD);\n+\n+        if (null != username && null != password) {\n+\n+          //\n+          // Compute basic auth\n+          //\n+\n+          if (!(username instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+          }\n+\n+          if (!(password instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+          }\n+\n+          String userInfo = ((String) username) + \":\" + ((String) password);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          conn.setRequestProperty(\"Authorization\", basicAuth);\n+        }\n+\n+      } else {\n+\n+        stack.push(params);\n+        stack.exec(headersMacro);\n+        o = stack.pop();\n+\n+        if (!(o instanceof Map)) {\n+          throw new WarpScriptException(getName() + \" expects the \" + HEADERS_MACRO + \" to push a headers map onto the stack.\");\n+        }\n+\n+        headers = (Map) o;\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (\"GET\" != method && \"DELETE\" != method && \"TRACE\" != method && \"OPTIONS\" != method && \"HEAD\" != method) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTI3ODE1Nw==", "bodyText": "I think it can be confusing if a method is explicit in the arguments and it gets changed to POST.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r621278157", "createdAt": "2021-04-27T14:42:55Z", "author": {"login": "randomboolean"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {\n+\n+        Object username = params.get(USERNAME);\n+        Object password = params.get(PASSWORD);\n+\n+        if (null != username && null != password) {\n+\n+          //\n+          // Compute basic auth\n+          //\n+\n+          if (!(username instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+          }\n+\n+          if (!(password instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+          }\n+\n+          String userInfo = ((String) username) + \":\" + ((String) password);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          conn.setRequestProperty(\"Authorization\", basicAuth);\n+        }\n+\n+      } else {\n+\n+        stack.push(params);\n+        stack.exec(headersMacro);\n+        o = stack.pop();\n+\n+        if (!(o instanceof Map)) {\n+          throw new WarpScriptException(getName() + \" expects the \" + HEADERS_MACRO + \" to push a headers map onto the stack.\");\n+        }\n+\n+        headers = (Map) o;\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (\"GET\" != method && \"DELETE\" != method && \"TRACE\" != method && \"OPTIONS\" != method && \"HEAD\" != method) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYyNzU3Nw=="}, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjA5MTk3MQ==", "bodyText": "You're right. It that case, just check for TRACE and GET.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622091971", "createdAt": "2021-04-28T11:39:29Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {\n+\n+        Object username = params.get(USERNAME);\n+        Object password = params.get(PASSWORD);\n+\n+        if (null != username && null != password) {\n+\n+          //\n+          // Compute basic auth\n+          //\n+\n+          if (!(username instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+          }\n+\n+          if (!(password instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+          }\n+\n+          String userInfo = ((String) username) + \":\" + ((String) password);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          conn.setRequestProperty(\"Authorization\", basicAuth);\n+        }\n+\n+      } else {\n+\n+        stack.push(params);\n+        stack.exec(headersMacro);\n+        o = stack.pop();\n+\n+        if (!(o instanceof Map)) {\n+          throw new WarpScriptException(getName() + \" expects the \" + HEADERS_MACRO + \" to push a headers map onto the stack.\");\n+        }\n+\n+        headers = (Map) o;\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (\"GET\" != method && \"DELETE\" != method && \"TRACE\" != method && \"OPTIONS\" != method && \"HEAD\" != method) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYyNzU3Nw=="}, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 363}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTMzODcwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzozNTo1NFrOJHTNMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzozNTo1NFrOJHTNMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYzNDQ4MQ==", "bodyText": "I'm, again, not convinced by the usefulness of this parameter. This does not offer more feature or readability than coding that in WarpScript:\n{\n  /* All your HTTP parameters */\n}\n@your_macro_updating_headers\nHTTP", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611634481", "createdAt": "2021-04-12T13:35:54Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 77}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTM0ODIyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzozNzozOFrOJHTSzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzozNzozOFrOJHTSzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTYzNTkxOA==", "bodyText": "I don't see why basic auth and header modification should be exclusive.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611635918", "createdAt": "2021-04-12T13:37:38Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 315}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTM5MTMzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzo0NTo1MlrOJHTtPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxMTo0MTo0MFrOJRRkqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTY0MjY4NA==", "bodyText": "chunk.number is 1-indexed. I'm wondering if that's coherent with other indexes in WarpScript.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611642684", "createdAt": "2021-04-12T13:45:52Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {\n+\n+        Object username = params.get(USERNAME);\n+        Object password = params.get(PASSWORD);\n+\n+        if (null != username && null != password) {\n+\n+          //\n+          // Compute basic auth\n+          //\n+\n+          if (!(username instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+          }\n+\n+          if (!(password instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+          }\n+\n+          String userInfo = ((String) username) + \":\" + ((String) password);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          conn.setRequestProperty(\"Authorization\", basicAuth);\n+        }\n+\n+      } else {\n+\n+        stack.push(params);\n+        stack.exec(headersMacro);\n+        o = stack.pop();\n+\n+        if (!(o instanceof Map)) {\n+          throw new WarpScriptException(getName() + \" expects the \" + HEADERS_MACRO + \" to push a headers map onto the stack.\");\n+        }\n+\n+        headers = (Map) o;\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (\"GET\" != method && \"DELETE\" != method && \"TRACE\" != method && \"OPTIONS\" != method && \"HEAD\" != method) {\n+\n+        if (body instanceof String) {\n+          String bodyS = (String) body;\n+          conn.setDoOutput(bodyS.length() > 0);\n+          if (bodyS.length() > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+            }\n+          }\n+\n+        } else if (body instanceof byte[]) {\n+          byte[] bodyB = (byte[]) body;\n+          conn.setDoOutput(bodyB.length > 0);\n+          if (bodyB.length > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyB);\n+            }\n+          }\n+\n+        } else if (null != body) {\n+          throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" \" + method + \" cannot be used with a body.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      // headers map is immutable\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      // also put status_message in a separate field\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (null == chunkSize) {\n+\n+        if (null != in) {\n+          byte[] buf = new byte[8192];\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+          while (true) {\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.get() + baos.size() + len > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes) per script execution.\");\n+            }\n+\n+            baos.write(buf, 0, len);\n+          }\n+\n+          downloadSize.addAndGet(baos.size());\n+          res.put(CONTENT, baos.toByteArray());\n+\n+        } else {\n+          res.put(CONTENT, new byte[0]);\n+        }\n+\n+      } else {\n+\n+        //\n+        // Chunk processing\n+        //\n+\n+        if (null != in) {\n+\n+          int chunkNumber = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 460}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMTI3MjExMw==", "bodyText": "TIMESPLIT for example is 1-indexed, but CHUNK is indexed with the first tick of the partial GTS.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r621272113", "createdAt": "2021-04-27T14:36:47Z", "author": {"login": "randomboolean"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {\n+\n+        Object username = params.get(USERNAME);\n+        Object password = params.get(PASSWORD);\n+\n+        if (null != username && null != password) {\n+\n+          //\n+          // Compute basic auth\n+          //\n+\n+          if (!(username instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+          }\n+\n+          if (!(password instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+          }\n+\n+          String userInfo = ((String) username) + \":\" + ((String) password);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          conn.setRequestProperty(\"Authorization\", basicAuth);\n+        }\n+\n+      } else {\n+\n+        stack.push(params);\n+        stack.exec(headersMacro);\n+        o = stack.pop();\n+\n+        if (!(o instanceof Map)) {\n+          throw new WarpScriptException(getName() + \" expects the \" + HEADERS_MACRO + \" to push a headers map onto the stack.\");\n+        }\n+\n+        headers = (Map) o;\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (\"GET\" != method && \"DELETE\" != method && \"TRACE\" != method && \"OPTIONS\" != method && \"HEAD\" != method) {\n+\n+        if (body instanceof String) {\n+          String bodyS = (String) body;\n+          conn.setDoOutput(bodyS.length() > 0);\n+          if (bodyS.length() > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+            }\n+          }\n+\n+        } else if (body instanceof byte[]) {\n+          byte[] bodyB = (byte[]) body;\n+          conn.setDoOutput(bodyB.length > 0);\n+          if (bodyB.length > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyB);\n+            }\n+          }\n+\n+        } else if (null != body) {\n+          throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" \" + method + \" cannot be used with a body.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      // headers map is immutable\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      // also put status_message in a separate field\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (null == chunkSize) {\n+\n+        if (null != in) {\n+          byte[] buf = new byte[8192];\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+          while (true) {\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.get() + baos.size() + len > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes) per script execution.\");\n+            }\n+\n+            baos.write(buf, 0, len);\n+          }\n+\n+          downloadSize.addAndGet(baos.size());\n+          res.put(CONTENT, baos.toByteArray());\n+\n+        } else {\n+          res.put(CONTENT, new byte[0]);\n+        }\n+\n+      } else {\n+\n+        //\n+        // Chunk processing\n+        //\n+\n+        if (null != in) {\n+\n+          int chunkNumber = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTY0MjY4NA=="}, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 460}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjA5MzQ4MQ==", "bodyText": "OK, that's fine as long as it will be documented ;).", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622093481", "createdAt": "2021-04-28T11:41:40Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {\n+\n+        Object username = params.get(USERNAME);\n+        Object password = params.get(PASSWORD);\n+\n+        if (null != username && null != password) {\n+\n+          //\n+          // Compute basic auth\n+          //\n+\n+          if (!(username instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+          }\n+\n+          if (!(password instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+          }\n+\n+          String userInfo = ((String) username) + \":\" + ((String) password);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          conn.setRequestProperty(\"Authorization\", basicAuth);\n+        }\n+\n+      } else {\n+\n+        stack.push(params);\n+        stack.exec(headersMacro);\n+        o = stack.pop();\n+\n+        if (!(o instanceof Map)) {\n+          throw new WarpScriptException(getName() + \" expects the \" + HEADERS_MACRO + \" to push a headers map onto the stack.\");\n+        }\n+\n+        headers = (Map) o;\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (\"GET\" != method && \"DELETE\" != method && \"TRACE\" != method && \"OPTIONS\" != method && \"HEAD\" != method) {\n+\n+        if (body instanceof String) {\n+          String bodyS = (String) body;\n+          conn.setDoOutput(bodyS.length() > 0);\n+          if (bodyS.length() > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+            }\n+          }\n+\n+        } else if (body instanceof byte[]) {\n+          byte[] bodyB = (byte[]) body;\n+          conn.setDoOutput(bodyB.length > 0);\n+          if (bodyB.length > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyB);\n+            }\n+          }\n+\n+        } else if (null != body) {\n+          throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" \" + method + \" cannot be used with a body.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      // headers map is immutable\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      // also put status_message in a separate field\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (null == chunkSize) {\n+\n+        if (null != in) {\n+          byte[] buf = new byte[8192];\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+          while (true) {\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.get() + baos.size() + len > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes) per script execution.\");\n+            }\n+\n+            baos.write(buf, 0, len);\n+          }\n+\n+          downloadSize.addAndGet(baos.size());\n+          res.put(CONTENT, baos.toByteArray());\n+\n+        } else {\n+          res.put(CONTENT, new byte[0]);\n+        }\n+\n+      } else {\n+\n+        //\n+        // Chunk processing\n+        //\n+\n+        if (null != in) {\n+\n+          int chunkNumber = 0;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTY0MjY4NA=="}, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 460}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzg2OTM5ODYwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzo0NzowOVrOJHTxhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0xMlQxMzo0NzowOVrOJHTxhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTY0Mzc4Mw==", "bodyText": "You can also remove CONTENT.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r611643783", "createdAt": "2021-04-12T13:47:09Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,533 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * To raise maximum number of calls and download size limit, use these capabilities:\n+ * http.requests\n+ * http.size\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * headers.macro A optional macro that expects this input parameters map on the stack, and push back the headers. Convenient for custom authorization schemes\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ * password Optional field. If both username and password field are present and headers.macro is absent, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String HEADERS_MACRO = \"headers.macro\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    WarpScriptStack.Macro headersMacro = null;\n+    o = params.get(HEADERS_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + HEADERS_MACRO);\n+      }\n+       headersMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+    }\n+\n+    long maxChunkSize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+      maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+    } else {\n+      maxChunkSize = baseMaxChunkSize;\n+    }\n+    if (chunkSize > maxChunkSize) {\n+      throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      if (null == headersMacro) {\n+\n+        Object username = params.get(USERNAME);\n+        Object password = params.get(PASSWORD);\n+\n+        if (null != username && null != password) {\n+\n+          //\n+          // Compute basic auth\n+          //\n+\n+          if (!(username instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+          }\n+\n+          if (!(password instanceof String)) {\n+            throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+          }\n+\n+          String userInfo = ((String) username) + \":\" + ((String) password);\n+          String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+          conn.setRequestProperty(\"Authorization\", basicAuth);\n+        }\n+\n+      } else {\n+\n+        stack.push(params);\n+        stack.exec(headersMacro);\n+        o = stack.pop();\n+\n+        if (!(o instanceof Map)) {\n+          throw new WarpScriptException(getName() + \" expects the \" + HEADERS_MACRO + \" to push a headers map onto the stack.\");\n+        }\n+\n+        headers = (Map) o;\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (\"GET\" != method && \"DELETE\" != method && \"TRACE\" != method && \"OPTIONS\" != method && \"HEAD\" != method) {\n+\n+        if (body instanceof String) {\n+          String bodyS = (String) body;\n+          conn.setDoOutput(bodyS.length() > 0);\n+          if (bodyS.length() > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyS.getBytes(StandardCharsets.UTF_8));\n+            }\n+          }\n+\n+        } else if (body instanceof byte[]) {\n+          byte[] bodyB = (byte[]) body;\n+          conn.setDoOutput(bodyB.length > 0);\n+          if (bodyB.length > 0) {\n+            try (OutputStream os = conn.getOutputStream()) {\n+              os.write(bodyB);\n+            }\n+          }\n+\n+        } else if (null != body) {\n+          throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+        }\n+\n+      } else if (null != body) {\n+        throw new WarpScriptException(getName() + \" \" + method + \" cannot be used with a body.\");\n+      }\n+\n+      //\n+      // Form response\n+      //\n+\n+      res.put(STATUS_CODE, conn.getResponseCode());\n+      Map<String, List<String>> hdrs = conn.getHeaderFields();\n+\n+      // headers map is immutable\n+      res.put(RESPONSE_HEADERS, hdrs);\n+\n+      // also put status_message in a separate field\n+      if (hdrs.containsKey(null)) {\n+        List<String> statusMsg = hdrs.get(null);\n+        if (statusMsg.size() > 0) {\n+          res.put(STATUS_MESSAGE, statusMsg.get(0));\n+        } else {\n+          res.put(STATUS_MESSAGE, \"\");\n+        }\n+      } else {\n+        res.put(STATUS_MESSAGE, \"\");\n+      }\n+\n+      //\n+      // Read response\n+      //\n+\n+      InputStream in = null;\n+\n+      // When there is an error (response code is 404 for instance), body is in the error stream.\n+      try {\n+        in = conn.getInputStream();\n+      } catch (IOException ioe) {\n+        in = conn.getErrorStream();\n+      }\n+\n+      if (null == chunkSize) {\n+\n+        if (null != in) {\n+          byte[] buf = new byte[8192];\n+          ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+\n+          while (true) {\n+            int len = in.read(buf);\n+            if (len < 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.get() + baos.size() + len > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes) per script execution.\");\n+            }\n+\n+            baos.write(buf, 0, len);\n+          }\n+\n+          downloadSize.addAndGet(baos.size());\n+          res.put(CONTENT, baos.toByteArray());\n+\n+        } else {\n+          res.put(CONTENT, new byte[0]);\n+        }\n+\n+      } else {\n+\n+        //\n+        // Chunk processing\n+        //\n+\n+        if (null != in) {\n+\n+          int chunkNumber = 0;\n+          boolean eof = false;\n+\n+          while (!eof) {\n+            chunkNumber++;\n+\n+            byte[] buf = new byte[chunkSize.intValue()];\n+            int len = 0;\n+            while (len < chunkSize.intValue()) {\n+              int read = in.read(buf, len,chunkSize.intValue() - len);\n+              if (read <= 0) {\n+                eof = true;\n+                break;\n+              }\n+              len += read;\n+            }\n+            if (len <= 0) {\n+              break;\n+            }\n+\n+            if (downloadSize.addAndGet(len) > maxsize) {\n+              throw new WarpScriptException(getName() + \" would exceed maximum size of content which can be retrieved via this function (\" + maxsize + \" bytes)\");\n+            }\n+\n+            if (len == chunkSize) {\n+              res.put(CONTENT, buf);\n+            } else {\n+              byte[] buf2 = new byte[len];\n+              System.arraycopy(buf, 0, buf2, 0, buf2.length);\n+              res.put(CONTENT, buf2);\n+            }\n+            res.put(CHUNK_NUMBER, new Long(chunkNumber));\n+\n+            Map<String, Object> chunkRes = Collections.unmodifiableMap(res);\n+            stack.push(chunkRes);\n+            if (null != chunkMacro) {\n+              stack.exec(chunkMacro);\n+            }\n+          }\n+        }\n+\n+        //\n+        // Finalize chunk processing with a last execution of the chunk.macro\n+        // buffer is empty and chunk.number is set to -1 for this one\n+        //\n+\n+        res.put(CHUNK_NUMBER, -1L);\n+        res.put(CONTENT, new byte[0]);\n+        Map<String, Object> chunkRes = Collections.unmodifiableMap(res);\n+        stack.push(chunkRes);\n+        if (null != chunkMacro) {\n+          stack.exec(chunkMacro);\n+        }\n+\n+        //\n+        // End chunk processing\n+        //\n+\n+        res.remove(CHUNK_NUMBER);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6b7baad7163cb6011fc3b8a5c3cacfb2894d9fe"}, "originalPosition": 518}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDQ0NjA0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTozNTowNlrOJRePlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTozNTowNlrOJRePlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMwMTA3Ng==", "bodyText": "Check for bodyB nullity, else it can throw a NPE.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622301076", "createdAt": "2021-04-28T15:35:06Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+\n+      long maxChunkSize;\n+      if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+        maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+      } else {\n+        maxChunkSize = baseMaxChunkSize;\n+      }\n+      if (chunkSize > maxChunkSize) {\n+        throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+      }\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();\n+    HttpURLConnection conn = null;\n+\n+    try {\n+      conn = (HttpURLConnection) url.openConnection();\n+\n+      //\n+      // Set headers\n+      //\n+\n+      Object username = params.get(USERNAME);\n+      Object password = params.get(PASSWORD);\n+\n+      if (null != username && null != password) {\n+\n+        //\n+        // Compute basic auth\n+        //\n+\n+        if (!(username instanceof String)) {\n+          throw new WarpScriptException(getName() + \" expects a STRING username when doing basic authentication.\");\n+        }\n+\n+        if (!(password instanceof String)) {\n+          throw new WarpScriptException(getName() + \" expects a STRING password when doing basic authentication.\");\n+        }\n+\n+        String userInfo = ((String) username) + \":\" + ((String) password);\n+        String basicAuth = \"Basic \" + Base64.encodeBase64String(userInfo.getBytes(StandardCharsets.UTF_8));\n+        conn.setRequestProperty(\"Authorization\", basicAuth);\n+      }\n+\n+      for (Map.Entry<Object, Object> prop: headers.entrySet()) {\n+        conn.setRequestProperty(String.valueOf(prop.getKey()), String.valueOf(prop.getValue()));\n+      }\n+\n+      conn.setDoInput(true);\n+      conn.setRequestMethod(method.toUpperCase());\n+\n+      //\n+      // Set body\n+      //\n+\n+      if (!\"GET\".equals(method) && !\"TRACE\".equals(method)) {\n+\n+        byte[] bodyB = null;\n+        if (body instanceof String) {\n+          bodyB = ((String) body).getBytes(StandardCharsets.UTF_8);\n+\n+        } else if (body instanceof byte[]) {\n+          bodyB = (byte[]) body;\n+\n+        } else if (null != body) {\n+          throw new WarpScriptException(getName() + \" expects the body of the request to be a STRING or BYTES object.\");\n+        }\n+\n+        conn.setDoOutput(bodyB.length > 0);\n+        if (bodyB.length > 0) {\n+          try (OutputStream os = conn.getOutputStream()) {\n+            os.write(bodyB);\n+          }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 358}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDQ3NDM4OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTozOTo1OVrOJReg7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTozOTo1OVrOJReg7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMwNTUxNw==", "bodyText": "Make confMaxRequests a String and remove the cast.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622305517", "createdAt": "2021-04-28T15:39:59Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDQ3NTg1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo0MDoxNVrOJReh2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo0MDoxNVrOJReh2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMwNTc1Mw==", "bodyText": "Same with confMaxSize.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622305753", "createdAt": "2021-04-28T15:40:15Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 149}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDQ3Njg0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo0MDoyN1rOJReiew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo0MDoyN1rOJReiew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMwNTkxNQ==", "bodyText": "Same with confMaxChunkSize.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622305915", "createdAt": "2021-04-28T15:40:27Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDQ4ODA1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo0MjozM1rOJRep2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo1MzoxNVrOJRfNuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMwNzgwMg==", "bodyText": "new HashMap<Object, Object>", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622307802", "createdAt": "2021-04-28T15:42:33Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 220}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMxNjk4NQ==", "bodyText": "Also check the type before casting to Map.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622316985", "createdAt": "2021-04-28T15:53:15Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMwNzgwMg=="}, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 220}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDQ5MDc3OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo0MzowMlrOJRerjg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo0MzowMlrOJRerjg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMwODIzOA==", "bodyText": "new LinkedHashMap<String, Object>()", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622308238", "createdAt": "2021-04-28T15:43:02Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+\n+      long maxChunkSize;\n+      if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+        maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+      } else {\n+        maxChunkSize = baseMaxChunkSize;\n+      }\n+      if (chunkSize > maxChunkSize) {\n+        throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+      }\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);\n+    } catch (MalformedURLException mue) {\n+      throw new WarpScriptException(getName() + \" encountered an invalid URL.\", mue);\n+    }\n+\n+    if (!\"http\".equals(url.getProtocol()) && !\"https\".equals(url.getProtocol())) {\n+      throw new WarpScriptException(getName() + \" only supports http and https protocols.\");\n+    }\n+\n+    if (!webAccessController.checkURL(url)) {\n+      throw new WarpScriptException(getName() + \" invalid host or scheme in URL.\");\n+    }\n+\n+    //\n+    // Check that we do not exceed the limits\n+    //\n+\n+    // Get the current counters in the stack and initialize them if not present.\n+    AtomicLong urlCount;\n+    AtomicLong downloadSize;\n+\n+    Object ufCount = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS);\n+    Object ufSize = stack.getAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE);\n+\n+    if (null == ufCount || null == ufSize) {\n+      urlCount = new AtomicLong();\n+      downloadSize = new AtomicLong();\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS, urlCount);\n+      stack.setAttribute(HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE, downloadSize);\n+    } else {\n+      urlCount = (AtomicLong) ufCount;\n+      downloadSize = (AtomicLong) ufSize;\n+    }\n+\n+    if (urlCount.addAndGet(1) > maxrequests) {\n+      throw new WarpScriptException(getName() + \" is limited to \" + maxrequests + \" calls per script execution.\");\n+    }\n+\n+    Map<String, Object> res = new LinkedHashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 297}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDUzMTkwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo1MDo0MlrOJRfFZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo1MDo0MlrOJRfFZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMxNDg1Mg==", "bodyText": "Check type before casting to String.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622314852", "createdAt": "2021-04-28T15:50:42Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 208}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDU0NzQyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo1MzozNVrOJRfO1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo1MzozNVrOJRfO1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMxNzI2OQ==", "bodyText": "Check type before cast.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622317269", "createdAt": "2021-04-28T15:53:35Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 222}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzk0MDU1NTA0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo1NTowMFrOJRfTcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wNC0yOFQxNTo1NTowMFrOJRfTcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjMxODQ0OA==", "bodyText": "Check type before cast.", "url": "https://github.com/senx/warp10-platform/pull/891#discussion_r622318448", "createdAt": "2021-04-28T15:55:00Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/ext/http/HTTP.java", "diffHunk": "@@ -0,0 +1,507 @@\n+//\n+//   Copyright 2021  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.ext.http;\n+\n+import io.warp10.WarpConfig;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WebAccessController;\n+import io.warp10.standalone.StandaloneWebCallService;\n+import io.warp10.warp.sdk.Capabilities;\n+\n+import org.apache.commons.codec.binary.Base64;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.net.HttpURLConnection;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+/**\n+ * Send an HTTP request to a url\n+ *\n+ * Capabilities:\n+ * - http.requests (maximum number of calls)\n+ * - http.size (maximum download size in number of bytes)\n+ * - http.chunksize (maximum chunk size in number of bytes)\n+ * - if the configuration parameter warpscript.http.capability exists,\n+ *   then its value is a capability that is checked to enable usage of this function\n+ *\n+ * Params:\n+ * url The URL to send the request to. Must begin with http:// or https://\n+ * method The optional http method. Default to GET\n+ * headers An optional header map\n+ * body An optional body. UTF-8 STRING or BYTES\n+ * chunk.size Chunk size\n+ * chunk.macro A macro that is executed whenever a chunk has been downloaded. It expects a MAP that contains chunk number (a LONG), status code (a LONG), status message (a STRING), headers (a MAP), and chunk content (a BYTES objects)\n+ * username Optional field. If both username and password field are present, basic authentication will be performed\n+ * password Optional field. If both username and password field are present, basic authentication will be performed\n+ *\n+ * Output:\n+ * RESPONSE A map that contains status code (a LONG), status message (a STRING), headers (a MAP) and full content of the response (a BYTES objects). The content is empty if chunk option is used\n+ *\n+ */\n+public class HTTP extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  //\n+  // Arguments\n+  //\n+\n+  public static final String METHOD = \"method\";\n+  public static final String URL = \"url\";\n+  public static final String HEADERS = \"headers\";\n+  public static final String BODY = \"body\";\n+  public static final String CHUNK_SIZE = \"chunk.size\";\n+  public static final String CHUNK_MACRO = \"chunk.macro\";\n+  public static final String USERNAME = \"username\";\n+  public static final String PASSWORD = \"password\";\n+\n+  //\n+  // Output\n+  //\n+\n+  public static final String RESPONSE = \"response\";\n+  public static final String STATUS_CODE = \"status.code\";\n+  public static final String STATUS_MESSAGE = \"status.message\";\n+  public static final String RESPONSE_HEADERS = \"headers\";\n+  public static final String CONTENT = \"content\";\n+  public static final String CHUNK_NUMBER = \"chunk.number\";\n+\n+  //\n+  // Control\n+  //\n+\n+  private static final WebAccessController webAccessController;\n+\n+  //\n+  // Authorization\n+  //\n+\n+  private static final boolean auth;\n+  private static final String capName;\n+\n+  //\n+  // Limits\n+  //\n+\n+  private static final long baseMaxRequests;\n+  private static final long baseMaxSize;\n+  private static final long baseMaxChunkSize;\n+\n+  //\n+  // Parameter extraction\n+  //\n+\n+  static {\n+    String patternConf = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_HOST_PATTERNS);\n+\n+    // If not defined, use already existing StandaloneWebCallService webAccessController which uses Configuration.WEBCALL_HOST_PATTERNS\n+    if (null == patternConf) {\n+      webAccessController = StandaloneWebCallService.getWebAccessController();\n+    } else {\n+      webAccessController = new WebAccessController(patternConf);\n+    }\n+\n+    // retrieve authentication required\n+    auth = \"true\".equals(WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_AUTHENTICATION_REQUIRED));\n+\n+    // retrieve capName\n+    capName = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_CAPABILITY);\n+\n+    // retrieve limits\n+    Object confMaxRequests = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_REQUESTS);\n+    if (null == confMaxRequests) {\n+      baseMaxRequests = HttpWarpScriptExtension.DEFAULT_HTTP_REQUESTS;\n+    } else {\n+      baseMaxRequests = Long.parseLong((String) confMaxRequests);\n+    }\n+\n+    Object confMaxSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_HTTP_SIZE);\n+    if (null == confMaxSize) {\n+      baseMaxSize = HttpWarpScriptExtension.DEFAULT_HTTP_MAXSIZE;\n+    } else {\n+      baseMaxSize = Long.parseLong((String) confMaxSize);\n+    }\n+\n+    Object confMaxChunkSize = WarpConfig.getProperty(HttpWarpScriptExtension.WARPSCRIPT_CHUNK_SIZE);\n+    if (null == confMaxChunkSize) {\n+      baseMaxChunkSize = HttpWarpScriptExtension.DEFAULT_HTTP_CHUNK_SIZE;\n+    } else {\n+      baseMaxChunkSize = Long.parseLong((String) confMaxChunkSize);\n+    }\n+  }\n+\n+  public HTTP(String name) {\n+    super(name);\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+\n+    Object o = stack.pop();\n+    if (!(o instanceof Map)) {\n+      throw new WarpScriptException(getName() + \" expects a MAP as input.\");\n+    }\n+\n+    Map params = (Map) o;\n+\n+    //\n+    // Check authorization\n+    //\n+\n+    if (auth && !stack.isAuthenticated()) {\n+      throw new WarpScriptException(getName() + \" requires the stack to be authenticated.\");\n+    }\n+\n+    if (null != capName && null == Capabilities.get(stack, capName)) {\n+      throw new WarpScriptException(getName() + \" requires capability \" + capName + \".\");\n+    }\n+\n+    //\n+    // Retrieve call number limit and download size limit\n+    //\n+\n+    long maxrequests;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS)) {\n+      maxrequests = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_REQUESTS));\n+    } else {\n+      maxrequests = baseMaxRequests;\n+    }\n+\n+    long maxsize;\n+    if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE)) {\n+      maxsize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_HTTP_SIZE));\n+    } else {\n+      maxsize = baseMaxSize;\n+    }\n+\n+    //\n+    // Retrieve arguments\n+    //\n+\n+    Object body = params.get(BODY);\n+    String method = (String) params.get(METHOD);\n+\n+    if (null == method) {\n+\n+      if (null == body) {\n+        method = \"GET\";\n+\n+      } else {\n+        method = \"POST\";\n+      }\n+    }\n+\n+    Map<Object, Object> headers = (Map) params.getOrDefault(HEADERS, new HashMap<>());\n+\n+    Long chunkSize = (Long) params.get(CHUNK_SIZE);\n+    if (null != chunkSize) {\n+      if (0 >= chunkSize) {\n+        throw new WarpScriptException(getName() + \" expects \" + CHUNK_SIZE + \" value to be greater than 0.\");\n+      }\n+\n+      long maxChunkSize;\n+      if (null != Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE)) {\n+        maxChunkSize = Long.valueOf(Capabilities.get(stack, HttpWarpScriptExtension.ATTRIBUTE_CHUNK_SIZE));\n+      } else {\n+        maxChunkSize = baseMaxChunkSize;\n+      }\n+      if (chunkSize > maxChunkSize) {\n+        throw new WarpScriptException(getName() + \" expects a chunk size in number of bytes that do not exceed \" + maxChunkSize + \".\");\n+      }\n+    }\n+\n+    WarpScriptStack.Macro chunkMacro = null;\n+    o = params.get(CHUNK_MACRO);\n+    if (null != o) {\n+      if (!(o instanceof WarpScriptStack.Macro)) {\n+        throw new WarpScriptException(getName() + \" expects a macro in the input parameters map as value of \" + CHUNK_MACRO);\n+      }\n+      chunkMacro = (WarpScriptStack.Macro) o;\n+    }\n+\n+    //\n+    // Check URL\n+    //\n+\n+    Object urlParam = params.get(URL);\n+    if (null == urlParam) {\n+      throw new WarpScriptException(getName() + \" expects a url.\");\n+    }\n+\n+    URL url = null;\n+    try {\n+      url = new URL((String) urlParam);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f2d6d357d866539715bb76e6da8d79d2a4325079"}, "originalPosition": 259}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1202, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}