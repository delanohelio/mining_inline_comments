{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI4NzczMDE2", "number": 772, "reviewThreads": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwODozOTo1OFrOEGQNpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjo0NDoxMVrOEMDzyg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTkyNTQ5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwODozOTo1OFrOGk7s0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwODozOTo1OFrOGk7s0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MDA0OA==", "bodyText": "1 is a valid value, although it does nothing different than not specifying step at all.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441380048", "createdAt": "2020-06-17T08:39:58Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "diffHunk": "@@ -314,6 +343,38 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H\n         skip = Long.parseLong(skipParam);        \n       }\n       \n+      if (null != stepParam) {\n+        step = Long.parseLong(stepParam);\n+        if (step <= 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 112}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0OTkzODMzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwODo0MzowNFrOGk70uQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwODo0MzowNFrOGk70uQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTM4MjA3Mw==", "bodyText": "1 is valid.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441382073", "createdAt": "2020-06-17T08:43:04Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "diffHunk": "@@ -314,6 +343,38 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H\n         skip = Long.parseLong(skipParam);        \n       }\n       \n+      if (null != stepParam) {\n+        step = Long.parseLong(stepParam);\n+        if (step <= 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        }\n+      }\n+      \n+      if (null != timestepParam) {\n+        if (timestepParam.startsWith(\"P\")) {\n+          // Should be a ISO8601 duration\n+          ReadWritablePeriod period = new MutablePeriod();\n+\n+          ISOPeriodFormat.standard().getParser().parseInto(period, timestepParam, 0, Locale.US);\n+\n+          Period p = period.toPeriod();\n+\n+          if (p.getMonths() != 0 || p.getYears() != 0) {\n+            throw new WarpScriptException(\"No support for ambiguous durations containing years or months, please convert those to days.\");\n+          }\n+\n+          Duration duration = p.toDurationFrom(new Instant());\n+\n+          timestep = duration.getMillis() * Constants.TIME_UNITS_PER_MS;\n+        } else {\n+          timestep = Long.parseLong(timestepParam);\n+        }\n+        \n+        if (timestep <= 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_TIMESTEP + \"' cannot be <= 1.\");\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 137}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDA1MDg0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOToxMjowOVrOGk88kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOToxMjowOVrOGk88kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQwMDQ2Nw==", "bodyText": "Better use\nADDDURATION.ReadWritablePeriodWithSubSecondOffset periodWithSubSec = ADDDURATION.durationToPeriod(timestepParam);\n// Check that the period does not have months or year\ntimestep = periodWithSubSec.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + periodWithSubSec.getOffset();\n\nto allow sub-millisecond precision with ISO 8601 representation.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441400467", "createdAt": "2020-06-17T09:12:09Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/egress/EgressFetchHandler.java", "diffHunk": "@@ -314,6 +343,38 @@ public void handle(String target, Request baseRequest, HttpServletRequest req, H\n         skip = Long.parseLong(skipParam);        \n       }\n       \n+      if (null != stepParam) {\n+        step = Long.parseLong(stepParam);\n+        if (step <= 1) {\n+          throw new WarpScriptException(\"Parameter '\" + Constants.HTTP_PARAM_STEP + \"' cannot be <= 1.\");\n+        }\n+      }\n+      \n+      if (null != timestepParam) {\n+        if (timestepParam.startsWith(\"P\")) {\n+          // Should be a ISO8601 duration\n+          ReadWritablePeriod period = new MutablePeriod();\n+\n+          ISOPeriodFormat.standard().getParser().parseInto(period, timestepParam, 0, Locale.US);\n+\n+          Period p = period.toPeriod();\n+\n+          if (p.getMonths() != 0 || p.getYears() != 0) {\n+            throw new WarpScriptException(\"No support for ambiguous durations containing years or months, please convert those to days.\");\n+          }\n+\n+          Duration duration = p.toDurationFrom(new Instant());\n+\n+          timestep = duration.getMillis() * Constants.TIME_UNITS_PER_MS;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 130}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDA5OTEyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/StoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOToyNDo0OVrOGk9bUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QwOToyNDo0OVrOGk9bUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQwODMzOA==", "bodyText": "Update the javadoc to reflect that this function takes only one parameter, leaving the description of its fields.\nAlso change then to thents.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441408338", "createdAt": "2020-06-17T09:24:49Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/StoreClient.java", "diffHunk": "@@ -36,13 +35,15 @@\n    * @param then Start timestamp (included)\n    * @param count Number of datapoints to fetch. 0 is a valid value if you want to fetch only boundaries. Use -1 to specify you are not fetching by count.\n    * @param skip Number of datapoints to skip before returning values\n+   * @param step Index offset between two datapoints, defaults to 1, i.e. return every data point\n+   * @param timestep Minimum time offset between datapoints, defaults to 1 time unit\n    * @param sample Double value representing the sampling rate. Use 1.0D for returning all values. Valid values are ] 0.0D, 1.0D ]\n    * @param writeTimestamp Flag indicating we are interested in the HBase cell timestamp\n    * @param preBoundary Size of the pre boundary in number of values\n    * @param postBoundary Size of the post boundary in number of values\n    * @return\n    * @throws IOException\n    */\n-  public GTSDecoderIterator fetch(ReadToken token, final List<Metadata> metadatas, final long now, final long then, long count, long skip, double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) throws IOException;\n+  public GTSDecoderIterator fetch(FetchRequest req) throws IOException; //ReadToken token, final List<Metadata> metadatas, final long now, final long then, long count, long skip, long step, long timestep, double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) throws IOException;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY0Nzg0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxMjoyNVrOGlC3lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxMjoyNVrOGlC3lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5NzQ5Mg==", "bodyText": "You should factorize the FetchRequest construction, making sure to use the copy constructor.\nOnly preBoundary, postBoundary, step, timestep, sample, skip and count may have been modified, so setting the other fields after the copy constructor is not necessary.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441497492", "createdAt": "2020-06-17T12:12:25Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 178}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY1MjA0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxMzo0MFrOGlC6Jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxMzo0MFrOGlC6Jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODE1MQ==", "bodyText": "blockcacheThreshold comparison is not the exactly the same as the one used in OptimizedSlicedRowFilterGTSDecoderIterator.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441498151", "createdAt": "2020-06-17T12:13:40Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n       } else {\n-        return new MultiScanGTSDecoderIterator(token, now, then, count, skip, sample, metadatas, this.conn, this.tableName, colfam, writeTimestamp, this.keystore, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);      \n+        FetchRequest freq = new FetchRequest();\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 194}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY1MjM4OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxMzo0NlrOGlC6Xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxMzo0NlrOGlC6Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODIwNw==", "bodyText": "blockcacheThreshold comparison is not the exactly the same as the one used in OptimizedSlicedRowFilterGTSDecoderIterator.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441498207", "createdAt": "2020-06-17T12:13:46Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n       } else {\n-        return new MultiScanGTSDecoderIterator(token, now, then, count, skip, sample, metadatas, this.conn, this.tableName, colfam, writeTimestamp, this.keystore, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);      \n+        FetchRequest freq = new FetchRequest();\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n       }      \n     } else {\n-      return new ParallelGTSDecoderIteratorWrapper(optimized, token, now, then, count, skip, sample, metadatas, keystore, this.conn, this.tableName, this.colfam, writeTimestamp, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);\n+      FetchRequest freq = new FetchRequest();\n+      freq.setToken(req.getToken());\n+      freq.setNow(now);\n+      freq.setThents(then);\n+      freq.setCount(count);\n+      freq.setSkip(skip);\n+      freq.setStep(step);\n+      freq.setTimestep(timestep);\n+      freq.setSample(sample);\n+      freq.setMetadatas(metadatas);\n+      freq.setPreBoundary(preBoundary);\n+      freq.setPostBoundary(postBoundary);\n+      return new ParallelGTSDecoderIteratorWrapper(freq, optimized, keystore, this.conn, this.tableName, this.colfam, metadatas.size() < blockcacheThreshold);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 210}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY1NDU2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNDoyOFrOGlC7sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNDoyOFrOGlC7sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODU0Nw==", "bodyText": "Factorize or use copy constructor because writeTimestamp is not copied.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441498547", "createdAt": "2020-06-17T12:14:28Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n       } else {\n-        return new MultiScanGTSDecoderIterator(token, now, then, count, skip, sample, metadatas, this.conn, this.tableName, colfam, writeTimestamp, this.keystore, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);      \n+        FetchRequest freq = new FetchRequest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 182}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY1NDg4OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNDozM1rOGlC76g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNDozM1rOGlC76g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ5ODYwMg==", "bodyText": "Factorize or use copy constructor because writeTimestamp is not copied.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441498602", "createdAt": "2020-06-17T12:14:33Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/egress/HBaseStoreClient.java", "diffHunk": "@@ -209,48 +210,75 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n     // applied in order and the results returned by calls to 'next'.\n \n     //\n-    // DON'T use SlicedRowFilterGTSDecoterIterator when using a value count based approach with a value of 'now'\n-    // which is not congruent to 0 modulo DEFAULT_MODULUS, because we may then have datapoints after 'now' and would then\n-    // need to do a full scan of every classId/labelsId in metadatas as the SlicedRowFilter does not interpret the read data\n-    // and is thus unable to read the timestamp\n-    // Don't use the filter when skip is > 0 or sample < 1.0D\n-    //\n-    // Only use SlicedRowFilter when not having a value count approach or when 'now' is congruent to 0 modulo DEFAULT_MODULUS\n-    // or equal to Long.MAX_VALUE (EPOCHEND)\n+    // We cannot use SlicedRowFilterGTSDecoderIterator when fetching a pre or post boundary.\n+    // We cannot use it also when requesting a given number of values WITH the use of\n+    // either step/timestep/skip/sample.\n     //\n-    \n+\n     boolean optimized = false;\n     \n     if (useHBaseFilter && metadatas.size() > this.hbaseFilterThreshold) {\n       if (count > 0 && Long.MIN_VALUE == then) {\n         // If we are fetching per count only (i.e. time range ends at Long.MIN_VALUE)\n-        optimized = true;\n-      } else if (-1 == count) {\n+        // use the filter unless step/timestep/skip/sample are defined\n+        if (step <= 1L && timestep <= 1L && 1.0D == sample && 0L == skip) {\n+          optimized = true;\n+        }\n+      } else if (-1L == count) {\n         // When not fetching by count but by time range, use the filter\n         optimized = true;\n       }\n     }\n \n-    // If sampling or skipping, don't use the filter\n-    if (0 != skip || 1.0D != sample) {\n-      optimized = false;\n-    }\n-    \n     // When fetching boundaries, the optimized scanners cannot be used\n     if (preBoundary > 0 || postBoundary > 0) {\n       optimized = false;\n     }\n     \n     if (metadatas.size() < ParallelGTSDecoderIteratorWrapper.getMinGTSPerScanner() || !ParallelGTSDecoderIteratorWrapper.useParallelScanners()) {\n       if (optimized) {\n-        //return new SlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n-        long timespan = count > 0 ? -count : (now - then + 1);\n-        return new OptimizedSlicedRowFilterGTSDecoderIterator(now, timespan, metadatas, this.conn, this.tableName, this.colfam, writeTimestamp, this.keystore, metadatas.size() <= blockcacheThreshold);\n+        FetchRequest freq = new FetchRequest(req);\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new OptimizedSlicedRowFilterGTSDecoderIterator(freq, this.conn, this.tableName, this.colfam, this.keystore, metadatas.size() <= blockcacheThreshold);\n       } else {\n-        return new MultiScanGTSDecoderIterator(token, now, then, count, skip, sample, metadatas, this.conn, this.tableName, colfam, writeTimestamp, this.keystore, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);      \n+        FetchRequest freq = new FetchRequest();\n+        freq.setToken(req.getToken());\n+        freq.setNow(now);\n+        freq.setThents(then);\n+        freq.setCount(count);\n+        freq.setSkip(skip);\n+        freq.setStep(step);\n+        freq.setTimestep(timestep);\n+        freq.setSample(sample);\n+        freq.setMetadatas(metadatas);\n+        freq.setPreBoundary(preBoundary);\n+        freq.setPostBoundary(postBoundary);\n+        return new MultiScanGTSDecoderIterator(freq, this.conn, this.tableName, colfam, this.keystore, metadatas.size() < blockcacheThreshold);      \n       }      \n     } else {\n-      return new ParallelGTSDecoderIteratorWrapper(optimized, token, now, then, count, skip, sample, metadatas, keystore, this.conn, this.tableName, this.colfam, writeTimestamp, metadatas.size() < blockcacheThreshold, preBoundary, postBoundary);\n+      FetchRequest freq = new FetchRequest();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 198}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDY2MzgxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNzoxM1rOGlDBfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjoxNzoxM1rOGlDBfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUwMDAzMA==", "bodyText": "Is there a reason not to use the 1L default value?", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441500030", "createdAt": "2020-06-17T12:17:13Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -94,25 +95,36 @@\n   private long count = -1;\n   private long skip = 0;\n   private double sample = 1.0D;\n+  private long step = -1L;\n+  private long timestep = -1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDcyNzg1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjozNTo0MlrOGlDqGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjozNTo0MlrOGlDqGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxMDQyNw==", "bodyText": "Typo.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441510427", "createdAt": "2020-06-17T12:35:42Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -426,6 +514,7 @@ public boolean hasNext() {\n             return false;\n           }\n \n+          // 128buts", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDc2NTE2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo0NTo1OFrOGlEB-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xOVQxNTo0Mjo1M1rOGmZRgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjUzOQ==", "bodyText": "Shouldn't it be timestamp instead of basets?", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441516539", "createdAt": "2020-06-17T12:45:58Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjkxMzE1NQ==", "bodyText": "They are actually the same when DEFAULT_MODULUS==1", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r442913155", "createdAt": "2020-06-19T15:42:53Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjUzOQ=="}, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 86}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDc2NzEzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo0NjoyOFrOGlEDOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo0NjoyOFrOGlEDOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUxNjg1Nw==", "bodyText": "Shouldn't it be timestamp instead of basets?\nAlso why not use subtractExact?", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441516857", "createdAt": "2020-06-17T12:46:28Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n+                  continue;\n+                }\n+\n+                //\n+                // Compute the new value of nextTimestamp if timestep is set\n+                //\n+                if (hasTimestep) {\n+                  try {\n+                    nextTimestamp = Math.addExact(basets, -timestep);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDc4ODA3OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo1MjowNlrOGlEQbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo1MjowNlrOGlEQbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyMDIzNg==", "bodyText": "This is a valid timestamp, should we set nvalues to 0 to avoid returning the data at Long.MIN_VALUE timestamp?", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441520236", "createdAt": "2020-06-17T12:52:06Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n+                  continue;\n+                }\n+\n+                //\n+                // Compute the new value of nextTimestamp if timestep is set\n+                //\n+                if (hasTimestep) {\n+                  try {\n+                    nextTimestamp = Math.addExact(basets, -timestep);\n+                  } catch (ArithmeticException ae) {\n+                    nextTimestamp = Long.MIN_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDgwMTkzOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo1NTozN1rOGlEZHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMjo1NTozN1rOGlEZHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUyMjQ2Mw==", "bodyText": "I think && !preBoundaryScan && !postBoundaryScan should be added. Better, enclose the few conditionals sharing this.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441522463", "createdAt": "2020-06-17T12:55:37Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -414,10 +428,36 @@ public GTSDecoder next() {\n                   continue;\n                 }\n                 \n+                // The timestamp is still after the one we expect\n+                if (basets > nextTimestamp && !preBoundaryScan && !postBoundaryScan) {\n+                  continue;\n+                }\n+\n+                //\n+                // Compute the new value of nextTimestamp if timestep is set\n+                //\n+                if (hasTimestep) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDg5NzkxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoxOTozOVrOGlFWRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoxOTozOVrOGlFWRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTUzODExNw==", "bodyText": "this.count >= 0 ?", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441538117", "createdAt": "2020-06-17T13:19:39Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -93,24 +107,39 @@\n   private static byte[] prefix = Constants.HBASE_RAW_DATA_KEY_PREFIX;\n \n   private final boolean writeTimestamp;\n+  private final boolean hasStep;\n+  private final boolean hasTimestep;\n+  private final boolean hasSample;\n+  private long skip = 0L;\n+  private long steps = 0L;\n+  private final long step;\n+  private final long timestep;\n+  private long nextTimestamp = Long.MAX_VALUE;\n+  private final double sample;\n   \n-  public SlicedRowFilterGTSDecoderIterator(long now, long timespan, List<Metadata> metadatas, Connection conn, TableName tableName, byte[] colfam, boolean writeTimestamp, KeyStore keystore, boolean useBlockCache) {\n+  private Random prng = null;\n+\n+  public SlicedRowFilterGTSDecoderIterator(FetchRequest req, Connection conn, TableName tableName, byte[] colfam, KeyStore keystore, boolean useBlockCache) {\n       \n+    this.request = req;\n     this.keystore = keystore;\n-    this.now = now;\n-    this.timespan = timespan;\n+    this.now = req.getNow();\n+    this.then = req.getThents();\n+    this.count = req.getCount();\n+    this.sample = req.getSample();\n+    this.hasSample = this.sample < 1.0D;\n+    this.prng = hasSample ? new Random() : null;\n+    this.hasStep = req.getStep() > 1L;\n+    this.steps = req.getStep() - 1L;\n+    this.step = hasStep ? req.getStep() : 1L;\n+    this.hasTimestep = req.getTimestep() > 1L;\n+    this.timestep = this.hasTimestep ? req.getTimestep() : 1L;\n+    this.nextTimestamp = Long.MAX_VALUE;\n+    this.skip = req.getSkip();\n+    this.nvalues = this.count > 0 ? this.count : Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDkxNjgxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyMzo0OFrOGlFh6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyMzo0OFrOGlFh6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU0MTA5Ng==", "bodyText": "count >= 0 ?", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441541096", "createdAt": "2020-06-17T13:23:48Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -131,18 +160,19 @@ public SlicedRowFilterGTSDecoderIterator(long now, long timespan, List<Metadata>\n     List<Pair<byte[], byte[]>> ranges = new ArrayList<Pair<byte[], byte[]>>();\n     \n     for (Metadata metadata: metadatas) {\n-      byte[][] keys = getKeys(metadata, now, timespan);\n+      byte[][] keys = getKeys(metadata, now, then);\n       byte[] lower = keys[0];\n       byte[] upper = keys[1];\n       \n-      this.metadatas.put(new String(Arrays.copyOfRange(lower, prefix.length, prefix.length + 16), StandardCharsets.ISO_8859_1), metadata);\n+      // Store the Metadata under a key containing both class and labels id in a 16 character string\n+      this.metadatas.put(new String(lower, prefix.length, 16, StandardCharsets.ISO_8859_1), metadata);\n       \n       Pair<byte[],byte[]> range = new Pair<byte[],byte[]>(lower, upper);\n       \n       ranges.add(range);\n     }\n                 \n-    SlicedRowFilter filter = new SlicedRowFilter(bounds, ranges, timespan < 0 ? -timespan : Long.MAX_VALUE);\n+    SlicedRowFilter filter = new SlicedRowFilter(bounds, ranges, count > 0 ? count : Long.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 133}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MDkyNDU2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyNToyNVrOGlFmxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxMzoyNToyNVrOGlFmxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU0MjM0Mw==", "bodyText": "ZERO_BYTES and ONES_BYTES fields can now be removed.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441542343", "createdAt": "2020-06-17T13:25:25Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -192,21 +222,9 @@ public SlicedRowFilterGTSDecoderIterator(long now, long timespan, List<Metadata>\n     // Set lower/upper timestamps\n     //\n     \n-    long modulus = Constants.DEFAULT_MODULUS;\n-  \n-    if (Long.MAX_VALUE == now) {\n-      System.arraycopy(ZERO_BYTES, 0, lower, prefix.length + 16, 8);\n-    } else {\n-      System.arraycopy(Longs.toByteArray(Long.MAX_VALUE - (now - (now % modulus))), 0, lower, prefix.length + 16, 8);        \n-    }\n-    \n-    if (timespan < 0) {\n-      System.arraycopy(ONES_BYTES, 0, upper, prefix.length + 16, 8);                \n-    } else {\n-      // Last timestamp does not need to be offset by modulus as it is the case when using a scanner, because\n-      // SlicedRowFilter upper bound is included, not excluded.\n-      System.arraycopy(Longs.toByteArray(Long.MAX_VALUE - ((now - timespan) - ((now - timespan) % modulus))), 0, upper, prefix.length + 16, 8);        \n-    }\n+    System.arraycopy(Longs.toByteArray(Long.MAX_VALUE - now), 0, lower, prefix.length + 8 + 8, 8);        \n+    // SlicedRowFilter upper bound is included\n+    System.arraycopy(Longs.toByteArray(Long.MAX_VALUE - then), 0, upper, prefix.length + 8 + 8, 8);        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 167}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTE3NTAwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDoyMTo1OFrOGlIJeg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDoyMTo1OFrOGlIJeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTU4Mzk5NA==", "bodyText": "this.count >= 0 ?", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441583994", "createdAt": "2020-06-17T14:21:58Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -246,19 +269,42 @@ public GTSDecoder next() {\n         resultCount++;\n       }\n \n-      // Encode this in ISO_8859_1 so we are sure every possible byte sequence is valid\n-      // FIXME(hbs): instead of doing a Arrays.copyOfRange, use new String(byte[],offset,len,charset)\n-      String classlabelsid = new String(Arrays.copyOfRange(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 16), StandardCharsets.ISO_8859_1);\n+      //\n+      // Compare the class and labels id with those in currentGTS\n+      // If they differ, recompute currentGTSString\n+      //\n+      \n+      if (0 != Bytes.compareTo(currentGTS, 0, 16, result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, 16)) {\n+        System.arraycopy(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, currentGTS, 0, currentGTS.length);\n+        currentGTSString = new String(currentGTS, StandardCharsets.ISO_8859_1);\n+      }\n+\n+      String classlabelsid = currentGTSString;\n     \n+      //\n+      // Extract the Metadata associated with the current row\n+      //\n       Metadata metadata = this.metadatas.get(classlabelsid);\n \n       //\n-      // The current row is for a different GTS, return the current encoder and record the current result\n-      //\n-      \n-      if (encoder.size() > 0 && (encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+      // The current row is for a different GTS.\n+      // If the current encoder has data, return it and record the current result for the next call to 'next'\n+      // If the current encoder has no data (which could happen if we have reached the requested number of results),\n+      // update the metadata\n+      //      \n+      if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+        // Save result in pendingresult as we have not yet read the associated cells\n         this.pendingresult = result;\n-        return encoder.getDecoder();\n+        //\n+        // Reset fetch parameters\n+        //\n+        this.nvalues = this.count > 0 ? this.count : Long.MAX_VALUE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 236}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTI3NDI1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo0Mzo1MVrOGlJKJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNDo0Mzo1MVrOGlJKJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYwMDU0OA==", "bodyText": "If you want to remove this kind of code, you left it in MultiScanGTSDecoderIterator, lines 385-410.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441600548", "createdAt": "2020-06-17T14:43:51Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -276,40 +322,28 @@ public GTSDecoder next() {\n           Cell cell = cscanner.current();\n           cellCount++;\n           \n+          // Simply ignore the values if we already collected enough\n+          if (nvalues <= 0) {\n+            continue;\n+          }\n+          \n           //\n-          // Extract timestamp base from column qualifier\n-          // This is true even for packed readings, those have a base timestamp of 0L\n+          // Extract timestamp from row key\n           //\n \n-          long basets = Long.MAX_VALUE;\n-          \n-          if (1 == Constants.DEFAULT_MODULUS) {\n-            // 128BITS\n-            byte[] data = cell.getRowArray();\n-            int offset = cell.getRowOffset();\n-            offset += Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 8 + 8; // Add 'prefix' + 'classId' + 'labelsId' to row key offset\n-            long delta = data[offset] & 0xFF;\n-            delta <<= 8; delta |= (data[offset + 1] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 2] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 3] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 4] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 5] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 6] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 7] & 0xFFL);\n-            basets -= delta;              \n-          } else {\n-            byte[] data = cell.getQualifierArray();\n-            int offset = cell.getQualifierOffset();\n-            long delta = data[offset] & 0xFFL;\n-            delta <<= 8; delta |= (data[offset + 1] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 2] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 3] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 4] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 5] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 6] & 0xFFL);\n-            delta <<= 8; delta |= (data[offset + 7] & 0xFFL);\n-            basets -= delta;                            \n-          }\n+          // 128BITS\n+          byte[] data = cell.getRowArray();\n+          int offset = cell.getRowOffset();\n+          offset += Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 8 + 8; // Add 'prefix' + 'classId' + 'labelsId' to row key offset\n+          long delta = data[offset] & 0xFF;\n+          delta <<= 8; delta |= (data[offset + 1] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 2] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 3] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 4] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 5] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 6] & 0xFFL);\n+          delta <<= 8; delta |= (data[offset + 7] & 0xFFL);\n+          long basets = Long.MAX_VALUE - delta;              ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 302}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTM1OTY2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTowMTozMVrOGlKAhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTowMTozMVrOGlKAhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTYxNDQ2OA==", "bodyText": "Same comments:\n\nbasets vs timestamp\naddExact vs subtractExact\nLong.MIN_VALUE is a valid timestamp", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441614468", "createdAt": "2020-06-17T15:01:31Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -321,7 +355,63 @@ public GTSDecoder next() {\n                     \n           while(decoder.next() && nvalues > 0) {\n             long timestamp = decoder.getTimestamp();\n-            if (timestamp <= now && (timespan < 0 || (timestamp > (now - timespan)))) {\n+            \n+            //\n+            // Only consider values if they are within the requested range\n+            // This should always be the case but better err on the side of caution sometimes\n+            //\n+            if (timestamp <= now && timestamp >= then) {\n+\n+              //\n+              // Skip datapoints\n+              //\n+              \n+              if (this.skip > 0) {\n+                this.skip--;\n+                continue;\n+              }\n+              \n+              //\n+              // Check that the datapoint timestamp is compatible with the timestep parameter, i.e. it is at least\n+              // 'timestep' time units before the previous one we selected\n+              //\n+              \n+              if (basets > nextTimestamp) {\n+                continue;\n+              }\n+\n+              //\n+              // Compute the new value of nextTimestamp if timestep is set\n+              //\n+              if (hasTimestep) {\n+                try {\n+                  nextTimestamp = Math.addExact(basets, -this.timestep);\n+                } catch (ArithmeticException ae) {\n+                  nextTimestamp = Long.MIN_VALUE;\n+                }\n+              }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 345}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTU1MzY0OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo0NDo1MFrOGlL79g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo0NDo1MFrOGlL79g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0NjA3MA==", "bodyText": "Already tested in paramsFromMap.\n(Also used timestep instead of step).", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441646070", "createdAt": "2020-06-17T15:44:50Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -446,7 +449,24 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n         }\n \n         long then = (long) params.get(PARAM_START);\n-        long skip = (long) params.getOrDefault(PARAM_SKIP, 0L);        \n+        long skip = (long) params.getOrDefault(PARAM_SKIP, 0L);\n+        long timestep = 1L;\n+        long step = 1L;\n+        \n+        if (params.containsKey(PARAM_TIMESTEP)) {\n+          timestep = (long) params.get(PARAM_TIMESTEP);\n+          if (timestep <= 1) {\n+            throw new WarpScriptException(getName() + \" parameter '\" + PARAM_TIMESTEP + \"' cannot be <= 1.\");\n+          }\n+        }\n+        \n+        if (params.containsKey(PARAM_STEP)) {\n+          step = (long) params.get(PARAM_STEP);\n+          \n+          if (timestep <= 1) {\n+            throw new WarpScriptException(getName() + \" parameter '\" + PARAM_STEP + \"' cannot be <= 1.\");            \n+          }\n+        }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTU3NDIyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo0OTo1MVrOGlMJQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo0OTo1MVrOGlMJQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0OTQ3Mg==", "bodyText": "step < 1L", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441649472", "createdAt": "2020-06-17T15:49:51Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -127,6 +140,21 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n       throw new RuntimeException(\"No support for write timestamp retrieval.\");\n     }\n     \n+    if (step <= 1L) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTU3NTk3OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1MDoxNVrOGlMKXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1MDoxNVrOGlMKXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY0OTc1Nw==", "bodyText": "timestep < 1L", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441649757", "createdAt": "2020-06-17T15:50:15Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -127,6 +140,21 @@ public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> meta\n       throw new RuntimeException(\"No support for write timestamp retrieval.\");\n     }\n     \n+    if (step <= 1L) {\n+      step = 1L;\n+    }\n+    \n+    if (timestep <= 1L) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc1MTYxMDcxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1ODoxNlrOGlMfig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xN1QxNTo1ODoxNlrOGlMfig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTY1NTE3OA==", "bodyText": "Same comments:\n\nsubtractExact\nLong.MIN_VALUE is a valid timestamp", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r441655178", "createdAt": "2020-06-17T15:58:16Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -323,6 +355,62 @@ public GTSDecoder next() {\n               continue;\n             }\n             \n+            //\n+            // Check that the datapoint timestamp is compatible with the timestep parameter, i.e. it is at least\n+            // 'timestep' time units before the previous one we selected\n+            //\n+            \n+            if (basets > nextTimestamp) {\n+              continue;\n+            }\n+\n+            //\n+            // Compute the new value of nextTimestamp if timestep is set\n+            //\n+            if (hasTimestep) {\n+              try {\n+                nextTimestamp = Math.addExact(basets, -timestep);\n+              } catch (ArithmeticException ae) {\n+                nextTimestamp = Long.MIN_VALUE;\n+              }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e07598603051ad7fa838f08bfec01a2aa247f958"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODE0OTYxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMToxNDowNFrOGsIW9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMToxNDowNFrOGsIW9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODkyNzQ3OA==", "bodyText": "Should be initialized to 0L, else it will skip the first step - 1 points found.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r448927478", "createdAt": "2020-07-02T11:14:04Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/MultiScanGTSDecoderIterator.java", "diffHunk": "@@ -230,6 +242,8 @@ public boolean hasNext() {\n     \n     nvalues = count >= 0 ? count : Long.MAX_VALUE;\n     toskip = skip;\n+    steps = hasStep ? step - 1L : 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "879ad4092491eda3b08f942710d5bdc6b1e90c69"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5ODQyODc3OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo0MTozNVrOGsLE0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxMjo0MTozNVrOGsLE0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODk3MTk4Nw==", "bodyText": "Change getSkip to getStep.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r448971987", "createdAt": "2020-07-02T12:41:35Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/standalone/StandaloneStoreClient.java", "diffHunk": "@@ -88,8 +89,20 @@ public StandaloneStoreClient(DB db, KeyStore keystore, Properties properties) {\n   }\n   \n   @Override\n-  public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> metadatas, final long now, final long then, long count, long skip, double sample, boolean writeTimestamp, long preBoundary, long postBoundary) {\n-\n+  public GTSDecoderIterator fetch(FetchRequest req) {\n+    final ReadToken token = req.getToken();\n+    final List<Metadata> metadatas = req.getMetadatas();\n+    final long now = req.getNow();\n+    final long then = req.getThents();\n+    long count = req.getCount();\n+    long skip = req.getSkip();\n+    long step = req.getSkip();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "879ad4092491eda3b08f942710d5bdc6b1e90c69"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTIwMDMyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTozODo1N1rOGsSv2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTozODo1N1rOGsSv2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTA5NzY5MA==", "bodyText": "Initialize it to 0L else the first this.request.getStep() - 1 will be stepped over.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r449097690", "createdAt": "2020-07-02T15:38:57Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -246,19 +266,42 @@ public GTSDecoder next() {\n         resultCount++;\n       }\n \n-      // Encode this in ISO_8859_1 so we are sure every possible byte sequence is valid\n-      // FIXME(hbs): instead of doing a Arrays.copyOfRange, use new String(byte[],offset,len,charset)\n-      String classlabelsid = new String(Arrays.copyOfRange(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 16), StandardCharsets.ISO_8859_1);\n+      //\n+      // Compare the class and labels id with those in currentGTS\n+      // If they differ, recompute currentGTSString\n+      //\n+      \n+      if (0 != Bytes.compareTo(currentGTS, 0, 16, result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, 16)) {\n+        System.arraycopy(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, currentGTS, 0, currentGTS.length);\n+        currentGTSString = new String(currentGTS, StandardCharsets.ISO_8859_1);\n+      }\n+\n+      String classlabelsid = currentGTSString;\n     \n+      //\n+      // Extract the Metadata associated with the current row\n+      //\n       Metadata metadata = this.metadatas.get(classlabelsid);\n \n       //\n-      // The current row is for a different GTS, return the current encoder and record the current result\n-      //\n-      \n-      if (encoder.size() > 0 && (encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+      // The current row is for a different GTS.\n+      // If the current encoder has data, return it and record the current result for the next call to 'next'\n+      // If the current encoder has no data (which could happen if we have reached the requested number of results),\n+      // update the metadata\n+      //      \n+      if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+        // Save result in pendingresult as we have not yet read the associated cells\n         this.pendingresult = result;\n-        return encoder.getDecoder();\n+        //\n+        // Reset fetch parameters\n+        //\n+        this.nvalues = this.count >= 0 ? this.count : Long.MAX_VALUE;\n+        this.skip = this.request.getSkip();\n+        this.steps = this.hasStep ? this.request.getStep() - 1 : 0L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "879ad4092491eda3b08f942710d5bdc6b1e90c69"}, "originalPosition": 244}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc5OTI1MTcxOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxNTo0NjoxNlrOGsTS0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wMlQxODozOTo1NVrOGsZMEQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEwNjY0Mw==", "bodyText": "Do that only if encoder.size() > 0 ie. move that in the if few lines below.\nThis one is tricky and took me a lot of time to debug:\nIf encoder has empty metadata (first metadata in the list) it is considered as a change of metadata. Thus it will not trigger the return in the if below and result will be processed. However, result will be also stored in pendingresult so it will be reprocessed, resulting in duplicate datapoints in the resulting decoder.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r449106643", "createdAt": "2020-07-02T15:46:16Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -246,19 +266,42 @@ public GTSDecoder next() {\n         resultCount++;\n       }\n \n-      // Encode this in ISO_8859_1 so we are sure every possible byte sequence is valid\n-      // FIXME(hbs): instead of doing a Arrays.copyOfRange, use new String(byte[],offset,len,charset)\n-      String classlabelsid = new String(Arrays.copyOfRange(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 16), StandardCharsets.ISO_8859_1);\n+      //\n+      // Compare the class and labels id with those in currentGTS\n+      // If they differ, recompute currentGTSString\n+      //\n+      \n+      if (0 != Bytes.compareTo(currentGTS, 0, 16, result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, 16)) {\n+        System.arraycopy(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, currentGTS, 0, currentGTS.length);\n+        currentGTSString = new String(currentGTS, StandardCharsets.ISO_8859_1);\n+      }\n+\n+      String classlabelsid = currentGTSString;\n     \n+      //\n+      // Extract the Metadata associated with the current row\n+      //\n       Metadata metadata = this.metadatas.get(classlabelsid);\n \n       //\n-      // The current row is for a different GTS, return the current encoder and record the current result\n-      //\n-      \n-      if (encoder.size() > 0 && (encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+      // The current row is for a different GTS.\n+      // If the current encoder has data, return it and record the current result for the next call to 'next'\n+      // If the current encoder has no data (which could happen if we have reached the requested number of results),\n+      // update the metadata\n+      //      \n+      if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+        // Save result in pendingresult as we have not yet read the associated cells\n         this.pendingresult = result;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "879ad4092491eda3b08f942710d5bdc6b1e90c69"}, "originalPosition": 237}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTIwMzIxNw==", "bodyText": "Comment is for line this.pendingresult = result;, GitHub messed this up.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r449203217", "createdAt": "2020-07-02T18:39:55Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -246,19 +266,42 @@ public GTSDecoder next() {\n         resultCount++;\n       }\n \n-      // Encode this in ISO_8859_1 so we are sure every possible byte sequence is valid\n-      // FIXME(hbs): instead of doing a Arrays.copyOfRange, use new String(byte[],offset,len,charset)\n-      String classlabelsid = new String(Arrays.copyOfRange(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, Constants.HBASE_RAW_DATA_KEY_PREFIX.length + 16), StandardCharsets.ISO_8859_1);\n+      //\n+      // Compare the class and labels id with those in currentGTS\n+      // If they differ, recompute currentGTSString\n+      //\n+      \n+      if (0 != Bytes.compareTo(currentGTS, 0, 16, result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, 16)) {\n+        System.arraycopy(result.getRow(), Constants.HBASE_RAW_DATA_KEY_PREFIX.length, currentGTS, 0, currentGTS.length);\n+        currentGTSString = new String(currentGTS, StandardCharsets.ISO_8859_1);\n+      }\n+\n+      String classlabelsid = currentGTSString;\n     \n+      //\n+      // Extract the Metadata associated with the current row\n+      //\n       Metadata metadata = this.metadatas.get(classlabelsid);\n \n       //\n-      // The current row is for a different GTS, return the current encoder and record the current result\n-      //\n-      \n-      if (encoder.size() > 0 && (encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+      // The current row is for a different GTS.\n+      // If the current encoder has data, return it and record the current result for the next call to 'next'\n+      // If the current encoder has no data (which could happen if we have reached the requested number of results),\n+      // update the metadata\n+      //      \n+      if ((encoder.getClassId() != metadata.getClassId() || encoder.getLabelsId() != metadata.getLabelsId())) {\n+        // Save result in pendingresult as we have not yet read the associated cells\n         this.pendingresult = result;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTEwNjY0Mw=="}, "originalCommit": {"oid": "879ad4092491eda3b08f942710d5bdc6b1e90c69"}, "originalPosition": 237}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDc3NTM3OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjozNTozNFrOGt8eTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjozNTozNFrOGt8eTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgyOTkwMg==", "bodyText": "I forgot this one, initialize to 0L to avoid stepping over the first values, even if it's not used yet.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r450829902", "createdAt": "2020-07-07T12:35:34Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/continuum/store/SlicedRowFilterGTSDecoderIterator.java", "diffHunk": "@@ -87,30 +101,42 @@\n    */\n   private Result pendingresult = null;\n   \n-  private static final byte[] ZERO_BYTES = Longs.toByteArray(0L);\n-  private static final byte[] ONES_BYTES = Longs.toByteArray(0xffffffffffffffffL);\n-  \n   private static byte[] prefix = Constants.HBASE_RAW_DATA_KEY_PREFIX;\n \n   private final boolean writeTimestamp;\n+  private final boolean hasStep;\n+  private final boolean hasTimestep;\n+  private final boolean hasSample;\n+  private long skip = 0L;\n+  private long steps = 0L;\n+  private final long step;\n+  private final long timestep;\n+  private long nextTimestamp = Long.MAX_VALUE;\n+  private final double sample;\n   \n-  public SlicedRowFilterGTSDecoderIterator(long now, long timespan, List<Metadata> metadatas, Connection conn, TableName tableName, byte[] colfam, boolean writeTimestamp, KeyStore keystore, boolean useBlockCache) {\n+  private Random prng = null;\n+\n+  public SlicedRowFilterGTSDecoderIterator(FetchRequest req, Connection conn, TableName tableName, byte[] colfam, KeyStore keystore, boolean useBlockCache) {\n       \n+    this.request = req;\n     this.keystore = keystore;\n-    this.now = now;\n-    this.timespan = timespan;\n+    this.now = req.getNow();\n+    this.then = req.getThents();\n+    this.count = req.getCount();\n+    this.sample = req.getSample();\n+    this.hasSample = this.sample < 1.0D;\n+    this.prng = hasSample ? new Random() : null;\n+    this.hasStep = req.getStep() > 1L;\n+    this.steps = req.getStep() - 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8"}, "originalPosition": 96}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDc5NDk2OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneChunkedMemoryStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjo0MDo0OFrOGt8qKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjo0MDo0OFrOGt8qKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzMjkzOA==", "bodyText": "getStep instead of getSkip.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r450832938", "createdAt": "2020-07-07T12:40:48Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/standalone/StandaloneChunkedMemoryStore.java", "diffHunk": "@@ -146,8 +146,22 @@ public void run() {\n   }\n   \n   @Override\n-  public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> metadatas, final long now, final long then, final long count, final long skip, final double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) {\n-\n+  public GTSDecoderIterator fetch(FetchRequest req) {\n+    final List<Metadata> metadatas = req.getMetadatas();\n+    final long now = req.getNow();\n+    final long then = req.getThents();\n+    final long count = req.getCount();\n+    final long skip = req.getSkip();\n+    long step = req.getSkip();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8"}, "originalPosition": 67}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjgxMDgwNzc4OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/standalone/StandaloneMemoryStore.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjo0NDoxMVrOGt8yIw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wN1QxMjo0NDoxMVrOGt8yIw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDgzNDk3OQ==", "bodyText": "getStep instead of getSkip.", "url": "https://github.com/senx/warp10-platform/pull/772#discussion_r450834979", "createdAt": "2020-07-07T12:44:11Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/standalone/StandaloneMemoryStore.java", "diffHunk": "@@ -134,7 +134,17 @@ public void run() {\n   }\n   \n   @Override\n-  public GTSDecoderIterator fetch(final ReadToken token, final List<Metadata> metadatas, final long now, final long then, final long count, final long skip, final double sample, boolean writeTimestamp, final long preBoundary, final long postBoundary) {\n+  public GTSDecoderIterator fetch(FetchRequest req) {\n+    final List<Metadata> metadatas = req.getMetadatas();\n+    final long now = req.getNow();\n+    final long then = req.getThents();\n+    final long count = req.getCount();\n+    final long skip = req.getSkip();\n+    long step = req.getSkip();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "abe989e9748cdc10aca949f409ca0bbbf6a2b3a8"}, "originalPosition": 64}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1256, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}