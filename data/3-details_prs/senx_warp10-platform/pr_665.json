{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1NDE0Nzc4", "number": 665, "title": "Duration.bucketize", "bodyText": "", "createdAt": "2020-02-14T14:26:58Z", "url": "https://github.com/senx/warp10-platform/pull/665", "merged": true, "mergeCommit": {"oid": "041f262e8511f6a7c8d2220f299e54af625af152"}, "closed": true, "closedAt": "2020-02-27T14:28:16Z", "author": {"login": "randomboolean"}, "timelineItems": {"totalCount": 45, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcEQVBGgH2gAyMzc1NDE0Nzc4OjBhZDkwMWNiNDY1NzQxZGM0NjEyY2I1OWY1NTU1ZmFmNDU2NmNjNzQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIcLaYgFqTM2NTcyMzcwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "0ad901cb465741dc4612cb59f5555faf4566cc74", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/0ad901cb465741dc4612cb59f5555faf4566cc74", "committedDate": "2020-02-14T14:23:13Z", "message": "refactor ADDDURATION for optimized use in other functions"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c7d11c21c7973029790cb47668263d600a453a6", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/7c7d11c21c7973029790cb47668263d600a453a6", "committedDate": "2020-02-14T14:23:13Z", "message": "minor changes addduration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae6495d55ef12e512f56a71608926be2bbbf8910", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/ae6495d55ef12e512f56a71608926be2bbbf8910", "committedDate": "2020-02-14T14:23:13Z", "message": "add default method in bucketizer interface"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34c9c80509d096e6e59a34531ffe24fe6b4ace59", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/34c9c80509d096e6e59a34531ffe24fe6b4ace59", "committedDate": "2020-02-14T14:23:13Z", "message": "duration.BUCKETIZE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "055a5212db999e9608b6ac4a4cb608777bda7910", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/055a5212db999e9608b6ac4a4cb608777bda7910", "committedDate": "2020-02-14T14:23:13Z", "message": "to warpscriptlib"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7a9148840df6b42a6ece78e4792ec4702ec66f2a", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/7a9148840df6b42a6ece78e4792ec4702ec66f2a", "committedDate": "2020-02-14T14:23:13Z", "message": "bugfix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57487b799be1ee169dd6d4631f10f61ed89a5101", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/57487b799be1ee169dd6d4631f10f61ed89a5101", "committedDate": "2020-02-14T14:23:13Z", "message": "DURATION.UNBUCKETIZE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79e91277e7d7299cae51d47ddfc2d0fa6fb6393e", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/79e91277e7d7299cae51d47ddfc2d0fa6fb6393e", "committedDate": "2020-02-14T14:23:13Z", "message": "update WarpScriptLib"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f42648207572f1850be981d25771eb9342019b69", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/f42648207572f1850be981d25771eb9342019b69", "committedDate": "2020-02-14T14:23:13Z", "message": "bugfix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "46be149c8797dc014e8905d414010db37364b1df", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/46be149c8797dc014e8905d414010db37364b1df", "committedDate": "2020-02-14T15:18:27Z", "message": "adapt to source 1.7"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/f8a5ecd6a6dff62faee2564121d0c539578e2f37", "committedDate": "2020-02-14T15:19:52Z", "message": "remove unecessary changes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5MDMzMDc2", "url": "https://github.com/senx/warp10-platform/pull/665#pullrequestreview-359033076", "createdAt": "2020-02-14T15:44:54Z", "commit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTo0NDo1NFrOFp66yg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xNFQxNTo1MjoxOVrOFp7LlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMTI1OA==", "bodyText": "No underscore in class names", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379501258", "createdAt": "2020-02-14T15:44:54Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMjI5Mw==", "bodyText": "or a Geo Time Serie", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379502293", "createdAt": "2020-02-14T15:46:37Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzA0NQ==", "bodyText": "\"are not set\"\n\"duration-unbucketize IT first\"", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379503045", "createdAt": "2020-02-14T15:47:58Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function, a macro, or NULL as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not be set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize them first before applying a new duration-bucketization.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzM1Mw==", "bodyText": "On line 90 you said you could use NULL", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379503353", "createdAt": "2020-02-14T15:48:31Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function, a macro, or NULL as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not be set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize them first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 154}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzY5OQ==", "bodyText": "Initialize it with the known size of series", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379503699", "createdAt": "2020-02-14T15:49:03Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function, a macro, or NULL as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not be set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize them first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 197}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwMzg5Mw==", "bodyText": "Use putToAttributes as attributes could be null", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379503893", "createdAt": "2020-02-14T15:49:24Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_BUCKETIZE.java", "diffHunk": "@@ -0,0 +1,368 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_BUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = \"DURATION.BUCKETIZE\";\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATION_BUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATION_BUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function, a macro, or NULL as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not be set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize them first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>();\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().getAttributes().put(DURATION_ATTRIBUTE_KEY, bucketduration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNDgxNw==", "bodyText": "Remove underscore", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379504817", "createdAt": "2020-02-14T15:51:00Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATION_UNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,81 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATION_UNBUCKETIZE extends GTSStackFunction {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNTIxMg==", "bodyText": "Better define the name here and reference it in the function", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379505212", "createdAt": "2020-02-14T15:51:41Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -806,6 +806,7 @@\n   public static final String BUCKETSPAN = \"BUCKETSPAN\";\n   public static final String BUCKETCOUNT = \"BUCKETCOUNT\";\n   public static final String UNBUCKETIZE = \"UNBUCKETIZE\";\n+  public static final String DURATION_UNBUCKETIZE = io.warp10.script.functions.DURATION_UNBUCKETIZE.getDefaultName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNTI4OA==", "bodyText": "ditto", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379505288", "createdAt": "2020-02-14T15:51:49Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/WarpScriptLib.java", "diffHunk": "@@ -868,6 +869,7 @@\n   public static final String NBOUNDS = \"NBOUNDS\";\n   public static final String LBOUNDS = \"LBOUNDS\";\n   public static final String BUCKETIZE = \"BUCKETIZE\";\n+  public static final String DURATION_BUCKETIZE = io.warp10.script.functions.DURATION_BUCKETIZE.getDefaultName();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTUwNTU1Ng==", "bodyText": "Use a constant known to be a valid timezone for the parsing library", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r379505556", "createdAt": "2020-02-14T15:52:19Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    if (null == tz) {\n+      tz = \"UTC\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f8a5ecd6a6dff62faee2564121d0c539578e2f37"}, "originalPosition": 9}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e0d018283de1c312e2e2913f213111929ce5a63", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/4e0d018283de1c312e2e2913f213111929ce5a63", "committedDate": "2020-02-14T16:03:48Z", "message": "renaming"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3cd5c179d602e0b69ade8412dcfae4f6f38f4fad", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/3cd5c179d602e0b69ade8412dcfae4f6f38f4fad", "committedDate": "2020-02-14T16:06:24Z", "message": "improve error messages"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2478fd914cfad5b725730e6b85f8ca2557e32f6e", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/2478fd914cfad5b725730e6b85f8ca2557e32f6e", "committedDate": "2020-02-14T16:10:39Z", "message": "fix put to attributes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/687c8238516a57d7f5c8abfbabe823cbc5f517b4", "committedDate": "2020-02-14T16:14:56Z", "message": "resolve string comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwNDY4MDA5", "url": "https://github.com/senx/warp10-platform/pull/665#pullrequestreview-360468009", "createdAt": "2020-02-18T16:07:57Z", "commit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 33, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xOFQxNjowNzo1OFrOFrIhuw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQwOTo0ODoyN1rOFsMsUA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3Mjc5NQ==", "bodyText": "@hbs Is UnsafeString allowed for new code?", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380772795", "createdAt": "2020-02-18T16:07:58Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period = durationToPeriod(duration);\n+\n+    //\n+    // Do the computation\n+    //\n+\n+    boolean tselements = false;\n+    if (stack.peek() instanceof List) {\n+      FROMTSELEMENTS.apply(stack);\n+      tselements = true;\n+    }\n+\n+    long instant = ((Number) stack.pop()).longValue();\n+    stack.push(addPeriod(instant, period, dtz, N));\n+\n+    if (tselements) {\n+      TSELEMENTS.apply(stack);\n+    }\n+\n+    return stack;\n+  }\n+\n+  /**\n+   * A joda time period with sub second precision (the long offset).\n+   */\n+  public static class ReadWritablePeriodWithSubSecondOffset  {\n+    private final ReadWritablePeriod period;\n+    private final long offset;\n+\n+    public ReadWritablePeriodWithSubSecondOffset(ReadWritablePeriod period, long offset) {\n+     this.period = period;\n+     this.offset = offset;\n+    }\n+\n+    public ReadWritablePeriod getPeriod() {\n+      return period;\n+    }\n+\n+    public long getOffset() {\n+      return offset;\n+    }\n+  }\n+\n+  /**\n+   * Convert an ISO8601 duration to a Period.\n+   * @param duration\n+   * @return\n+   * @throws WarpScriptException\n+   */\n+  public static ReadWritablePeriodWithSubSecondOffset durationToPeriod(String duration) throws WarpScriptException {\n     // Separate seconds from  digits below second precision\n     String[] tokens = UnsafeString.split(duration, '.');", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3NDI4Nw==", "bodyText": "Can throw a WarpScriptException without any info on the function name: rethrow with that info or add the function name to parameters of this method to build an exception with the function name.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380774287", "createdAt": "2020-02-18T16:10:04Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period = durationToPeriod(duration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3ODM4NA==", "bodyText": "Check returned code to see if the parsing failed or not and throw if it is the case.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380778384", "createdAt": "2020-02-18T16:16:14Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();\n     ISOPeriodFormat.standard().getParser().parseInto(period, duration, 0, Locale.US);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA==", "bodyText": "Handle exceptions coming from the Double d_offset = Double.valueOf(\"0.\" + tmp) * STU; line above.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380779978", "createdAt": "2020-02-18T16:18:33Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4MjIwOQ==", "bodyText": "Also d_offset does not follow naming conventions.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380782209", "createdAt": "2020-02-18T16:21:48Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA=="}, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4NTI2Ng==", "bodyText": "Also STU can be replaced by Constants.TIME_UNITS_PER_S and STU removed.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380785266", "createdAt": "2020-02-18T16:26:21Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA=="}, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4ODgxOQ==", "bodyText": "Indentation.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380788819", "createdAt": "2020-02-18T16:31:50Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period = durationToPeriod(duration);\n+\n+    //\n+    // Do the computation\n+    //\n+\n+    boolean tselements = false;\n+    if (stack.peek() instanceof List) {\n+      FROMTSELEMENTS.apply(stack);\n+      tselements = true;\n+    }\n+\n+    long instant = ((Number) stack.pop()).longValue();\n+    stack.push(addPeriod(instant, period, dtz, N));\n+\n+    if (tselements) {\n+      TSELEMENTS.apply(stack);\n+    }\n+\n+    return stack;\n+  }\n+\n+  /**\n+   * A joda time period with sub second precision (the long offset).\n+   */\n+  public static class ReadWritablePeriodWithSubSecondOffset  {\n+    private final ReadWritablePeriod period;\n+    private final long offset;\n+\n+    public ReadWritablePeriodWithSubSecondOffset(ReadWritablePeriod period, long offset) {\n+     this.period = period;\n+     this.offset = offset;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc4OTA3NA==", "bodyText": "Extra space before {.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380789074", "createdAt": "2020-02-18T16:32:14Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,16 +78,75 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period = durationToPeriod(duration);\n+\n+    //\n+    // Do the computation\n+    //\n+\n+    boolean tselements = false;\n+    if (stack.peek() instanceof List) {\n+      FROMTSELEMENTS.apply(stack);\n+      tselements = true;\n+    }\n+\n+    long instant = ((Number) stack.pop()).longValue();\n+    stack.push(addPeriod(instant, period, dtz, N));\n+\n+    if (tselements) {\n+      TSELEMENTS.apply(stack);\n+    }\n+\n+    return stack;\n+  }\n+\n+  /**\n+   * A joda time period with sub second precision (the long offset).\n+   */\n+  public static class ReadWritablePeriodWithSubSecondOffset  {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NDg4OA==", "bodyText": "Not thrown.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380794888", "createdAt": "2020-02-18T16:41:15Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();\n     ISOPeriodFormat.standard().getParser().parseInto(period, duration, 0, Locale.US);\n \n-    //\n-    // Handle time zone\n-    //\n+    return new ReadWritablePeriodWithSubSecondOffset(period, offset);\n+  }\n \n-    if (null == tz) {\n-      tz = \"UTC\";\n-    }\n-    DateTimeZone dtz = DateTimeZone.forID(tz);\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz) {\n+    return addPeriod(instant, period, dtz, 1);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz, long N) {\n+    return addPeriod(instant, new ReadWritablePeriodWithSubSecondOffset(period, 0), dtz, N);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriodWithSubSecondOffset periodAndOffset, DateTimeZone dtz) {\n+    return addPeriod(instant, periodAndOffset, dtz, 1);\n+  }\n+\n+  /**\n+   * Add a duration in ISO8601 duration format to a timestamp\n+   * @param instant a timestamp since Unix Epoch\n+   * @param periodAndOffset a period (with subsecond precision) to add\n+   * @param dtz timezone\n+   * @param N number of times the period is added\n+   * @return\n+   * @throws WarpScriptException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 110}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NTI3OA==", "bodyText": "Add @return info.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380795278", "createdAt": "2020-02-18T16:41:51Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();\n     ISOPeriodFormat.standard().getParser().parseInto(period, duration, 0, Locale.US);\n \n-    //\n-    // Handle time zone\n-    //\n+    return new ReadWritablePeriodWithSubSecondOffset(period, offset);\n+  }\n \n-    if (null == tz) {\n-      tz = \"UTC\";\n-    }\n-    DateTimeZone dtz = DateTimeZone.forID(tz);\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz) {\n+    return addPeriod(instant, period, dtz, 1);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz, long N) {\n+    return addPeriod(instant, new ReadWritablePeriodWithSubSecondOffset(period, 0), dtz, N);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriodWithSubSecondOffset periodAndOffset, DateTimeZone dtz) {\n+    return addPeriod(instant, periodAndOffset, dtz, 1);\n+  }\n+\n+  /**\n+   * Add a duration in ISO8601 duration format to a timestamp\n+   * @param instant a timestamp since Unix Epoch\n+   * @param periodAndOffset a period (with subsecond precision) to add\n+   * @param dtz timezone\n+   * @param N number of times the period is added\n+   * @return", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc5NjA5Ng==", "bodyText": "Below is non_negative which do not follow naming conventions and also avoid negative forms.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380796096", "createdAt": "2020-02-18T16:43:12Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();\n     ISOPeriodFormat.standard().getParser().parseInto(period, duration, 0, Locale.US);\n \n-    //\n-    // Handle time zone\n-    //\n+    return new ReadWritablePeriodWithSubSecondOffset(period, offset);\n+  }\n \n-    if (null == tz) {\n-      tz = \"UTC\";\n-    }\n-    DateTimeZone dtz = DateTimeZone.forID(tz);\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz) {\n+    return addPeriod(instant, period, dtz, 1);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriod period, DateTimeZone dtz, long N) {\n+    return addPeriod(instant, new ReadWritablePeriodWithSubSecondOffset(period, 0), dtz, N);\n+  }\n+\n+  public static long addPeriod(long instant, ReadWritablePeriodWithSubSecondOffset periodAndOffset, DateTimeZone dtz) {\n+    return addPeriod(instant, periodAndOffset, dtz, 1);\n+  }\n+\n+  /**\n+   * Add a duration in ISO8601 duration format to a timestamp\n+   * @param instant a timestamp since Unix Epoch\n+   * @param periodAndOffset a period (with subsecond precision) to add\n+   * @param dtz timezone\n+   * @param N number of times the period is added\n+   * @return\n+   * @throws WarpScriptException\n+   */\n+  public static long addPeriod(long instant, ReadWritablePeriodWithSubSecondOffset periodAndOffset, DateTimeZone dtz, long N) {\n+\n+    ReadWritablePeriod period = periodAndOffset.getPeriod();\n+    long offset = periodAndOffset.getOffset();\n \n     //\n     // Do the computation\n     //\n \n-    boolean tselements = false;\n-    if (stack.peek() instanceof List) {\n-      FROMTSELEMENTS.apply(stack);\n-      tselements = true;\n-    }\n-\n-    long instant = ((Number) stack.pop()).longValue();\n     DateTime dt = new DateTime(instant / Constants.TIME_UNITS_PER_MS, dtz);\n \n     //", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 130}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgwNzg3Mg==", "bodyText": "This is unclear what this class does with only this info. Maybe explaining the difference between duration and span can help.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380807872", "createdAt": "2020-02-18T17:01:55Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDQxMA==", "bodyText": "Instead of the negative lookahead, you can simply check that the length of the string is >2.\nThe (\\d+|\\d.(\\d)+) part is not good:\n\n\"1x234\" matches\n\"12.345\" does not matches", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r380810410", "createdAt": "2020-02-18T17:06:05Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTMxNDI4Mw==", "bodyText": "Missing space before \"expects\".", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381314283", "createdAt": "2020-02-19T14:12:09Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 163}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg0ODY5Ng==", "bodyText": "Naming convention.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381848696", "createdAt": "2020-02-20T08:32:46Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 172}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MDA4OQ==", "bodyText": "Will be checked in durationBucketize, is it really useful to pre-check here?", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381850089", "createdAt": "2020-02-20T08:35:54Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 156}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1MjM4NQ==", "bodyText": "Would be easier to read by using a variable to store the attributes instead of repeating gts.getMetadata().getAttributes().", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381852385", "createdAt": "2020-02-20T08:40:45Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 145}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1Mzg0Mg==", "bodyText": "You have to find another way or find an heuristic to speed-up this as it takes forever to run\n[\n  NEWGTS\n  bucketizer.last\n  NOW\n  'PT1.2S'\n  3\n]\nDURATION.BUCKETIZE", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381853842", "createdAt": "2020-02-20T08:43:44Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 192}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1NTA0Mw==", "bodyText": "Why do you rename this constant?", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381855043", "createdAt": "2020-02-20T08:46:03Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg1OTg0NQ==", "bodyText": "You could merge that with the filling of series.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381859845", "createdAt": "2020-02-20T08:55:09Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2MjI4NQ==", "bodyText": "Missing function name.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381862285", "createdAt": "2020-02-20T08:59:45Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg2OTg0NA==", "bodyText": "Is it useful to check the format as it will also be checked by durationToPeriod?", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381869844", "createdAt": "2020-02-20T09:13:56Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 162}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MDg4Mw==", "bodyText": "Make it static.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381870883", "createdAt": "2020-02-20T09:15:50Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 213}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MTU2OA==", "bodyText": "Make it static.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381871568", "createdAt": "2020-02-20T09:17:01Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MzIxOQ==", "bodyText": "Remove extra space.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381873219", "createdAt": "2020-02-20T09:20:09Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MzYwNA==", "bodyText": "Add space after [].", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381873604", "createdAt": "2020-02-20T09:20:49Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MDI5Ng==", "bodyText": "Typo: firstTick", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381880296", "createdAt": "2020-02-20T09:32:10Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {\n+\n+    long lastTick = GTSHelper.lasttick(gts);\n+    long firsTick = GTSHelper.firsttick(gts);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 268}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MTA2MA==", "bodyText": "Naming convention: lastbucket_index", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381881060", "createdAt": "2020-02-20T09:33:33Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg3MTU2OA=="}, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 265}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4MTgzNw==", "bodyText": "No need to call String.valueOf.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381881837", "createdAt": "2020-02-20T09:34:48Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {\n+\n+    long lastTick = GTSHelper.lasttick(gts);\n+    long firsTick = GTSHelper.firsttick(gts);\n+    int hint = Math.min(gts.size(), (int) (1.05 * (lastTick - firsTick) / ADDDURATION.addPeriod(0, bucketperiod, dtz)));\n+\n+    GeoTimeSerie durationBucketized = gts.cloneEmpty(hint);\n+\n+    //\n+    // We loop through the input GTS values in reverse order\n+    // We feed a buffer of values while traversing\n+    //\n+\n+    GTSHelper.sort(gts);\n+    GeoTimeSerie subgts = gts.cloneEmpty();\n+\n+    if (null != stack) {\n+      if (!(aggregator instanceof Macro)) {\n+        throw new WarpScriptException(\"Expected a macro as bucketizer.\");\n+      }\n+    } else {\n+      if (!(aggregator instanceof WarpScriptBucketizerFunction)) {\n+        throw new WarpScriptException(\"Invalid bucketizer function.\");\n+      }\n+    }\n+\n+    // initialize bucketstart (start boundary), and bucketindex of current tick\n+    long bucketstart = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz, -1) + 1;\n+    int bucketindex = lastbucket_index;\n+\n+    for (int i = gts.size() - 1; i >= 0; i--) {\n+      long tick = GTSHelper.tickAtIndex(gts, i);\n+\n+      if (tick < bucketstart) {\n+\n+        //\n+        // Break off the loop if bucketcount is exceeded (except if it is equal to 0)\n+        //\n+\n+        if (bucketcount != 0 && lastbucket_index - bucketindex + 1 >= bucketcount) {\n+          break;\n+        }\n+\n+        if (lastbucket_index - bucketindex + 2 > maxbuckets) {\n+          throw new WarpScriptException(\"Bucket count (\" + String.valueOf(lastbucket_index - bucketindex + 2) + \") is exceeding maximum value of \" + maxbuckets);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 309}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Njk0NQ==", "bodyText": "Does not throw.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381886945", "createdAt": "2020-02-20T09:43:49Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (!(params.get(i) instanceof GeoTimeSerie) && !(params.get(i) instanceof List)) {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      }\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(\"Bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      if (gts.getMetadata().getAttributes().get(DURATION_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(OFFSET_ATTRIBUTE_KEY) != null || gts.getMetadata().getAttributes().get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \"expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");\n+    }\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long bucketoffset;\n+    int lastbucket_index;\n+    if (lastbucket > 0) {\n+      long boundary = ADDDURATION.addPeriod(0, bucketperiod, dtz);\n+\n+      lastbucket_index = 0;\n+      while (boundary <= lastbucket) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+        lastbucket_index++;\n+      }\n+      bucketoffset = boundary - (lastbucket + 1);\n+\n+    } else {\n+      long boundary = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz);\n+\n+      lastbucket_index = -1;\n+      while (boundary < 0) {\n+        boundary = ADDDURATION.addPeriod(boundary, bucketperiod, dtz);\n+      }\n+      lastbucket_index--;\n+      bucketoffset = -(ADDDURATION.addPeriod(boundary, bucketperiod, dtz, -1) + 1);\n+    }\n+\n+    //\n+    // Duration-Bucketize\n+    //\n+\n+    List<GeoTimeSerie> bucketized = new ArrayList<GeoTimeSerie>(series.size());\n+    for (GeoTimeSerie gts : series) {\n+\n+      GeoTimeSerie b = durationBucketize(gts, bucketperiod, dtz, bucketcount, lastbucket, lastbucket_index, bucketizer, maxbuckets, bucketizer instanceof Macro ? stack : null);\n+      b.getMetadata().putToAttributes(DURATION_ATTRIBUTE_KEY, bucketduration);\n+      b.getMetadata().getAttributes().put(OFFSET_ATTRIBUTE_KEY, String.valueOf(bucketoffset));\n+      b.getMetadata().getAttributes().put(TIMEZONE_ATTRIBUTE_KEY, dtz.getID());\n+\n+      bucketized.add(b);\n+    }\n+\n+    stack.push(bucketized);\n+    return stack;\n+  }\n+\n+  private void aggregateAndSet(Object aggregator, GeoTimeSerie subgts, GeoTimeSerie bucketized, long bucketindex, WarpScriptStack stack) throws WarpScriptException {\n+    Object[] aggregated;\n+    if (null != stack) {\n+      stack.push(subgts);\n+      Object res = stack.peek();\n+\n+      if (res instanceof List) {\n+        aggregated = MACROMAPPER.listToObjects((List<Object>) stack.pop());\n+      } else {\n+        aggregated = MACROMAPPER.stackToObjects(stack);\n+      }\n+\n+    } else {\n+\n+      Object[] parms =  new Object[8];\n+\n+      parms[0] = bucketindex;\n+      parms[1] = new String[]{subgts.getName()};\n+      parms[2] = new Map[]{subgts.getLabels()};\n+      parms[3] = GTSHelper.getTicks(subgts);\n+      if (subgts.hasLocations()) {\n+        parms[4] = GTSHelper.getLocations(subgts);\n+      } else {\n+        parms[4] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[4], GeoTimeSerie.NO_LOCATION);\n+      }\n+      if (subgts.hasElevations()) {\n+        parms[5] = GTSHelper.getElevations(subgts);\n+      } else {\n+        parms[5] = new long[subgts.size()];\n+        Arrays.fill((long[]) parms[5], GeoTimeSerie.NO_ELEVATION);\n+      }\n+      parms[6] = new Object[subgts.size()];\n+      parms[7] = new long[] {0, -1, bucketindex, bucketindex};\n+\n+      for (int j = 0; j < subgts.size(); j++) {\n+        ((Object[]) parms[6])[j] = GTSHelper.valueAtIndex(subgts, j);\n+      }\n+\n+      aggregated = (Object[]) ((WarpScriptBucketizerFunction) aggregator).apply(parms);\n+    }\n+\n+    //\n+    // Only set value if it is non null\n+    //\n+\n+    if (null != aggregated[3]) {\n+      GTSHelper.setValue(bucketized, bucketindex, (long) aggregated[1], (long) aggregated[2], aggregated[3], false);\n+    }\n+  }\n+\n+\n+  public GeoTimeSerie durationBucketize(GeoTimeSerie gts, ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod, DateTimeZone dtz, long bucketcount, long lastbucket, int lastbucket_index, Object aggregator, long maxbuckets, WarpScriptStack stack) throws WarpScriptException {\n+\n+    long lastTick = GTSHelper.lasttick(gts);\n+    long firsTick = GTSHelper.firsttick(gts);\n+    int hint = Math.min(gts.size(), (int) (1.05 * (lastTick - firsTick) / ADDDURATION.addPeriod(0, bucketperiod, dtz)));\n+\n+    GeoTimeSerie durationBucketized = gts.cloneEmpty(hint);\n+\n+    //\n+    // We loop through the input GTS values in reverse order\n+    // We feed a buffer of values while traversing\n+    //\n+\n+    GTSHelper.sort(gts);\n+    GeoTimeSerie subgts = gts.cloneEmpty();\n+\n+    if (null != stack) {\n+      if (!(aggregator instanceof Macro)) {\n+        throw new WarpScriptException(\"Expected a macro as bucketizer.\");\n+      }\n+    } else {\n+      if (!(aggregator instanceof WarpScriptBucketizerFunction)) {\n+        throw new WarpScriptException(\"Invalid bucketizer function.\");\n+      }\n+    }\n+\n+    // initialize bucketstart (start boundary), and bucketindex of current tick\n+    long bucketstart = ADDDURATION.addPeriod(lastbucket, bucketperiod, dtz, -1) + 1;\n+    int bucketindex = lastbucket_index;\n+\n+    for (int i = gts.size() - 1; i >= 0; i--) {\n+      long tick = GTSHelper.tickAtIndex(gts, i);\n+\n+      if (tick < bucketstart) {\n+\n+        //\n+        // Break off the loop if bucketcount is exceeded (except if it is equal to 0)\n+        //\n+\n+        if (bucketcount != 0 && lastbucket_index - bucketindex + 1 >= bucketcount) {\n+          break;\n+        }\n+\n+        if (lastbucket_index - bucketindex + 2 > maxbuckets) {\n+          throw new WarpScriptException(\"Bucket count (\" + String.valueOf(lastbucket_index - bucketindex + 2) + \") is exceeding maximum value of \" + maxbuckets);\n+        }\n+\n+        //\n+        // Call the aggregation function on the last batch\n+        //\n+\n+        if (subgts.size() > 0) {\n+          aggregateAndSet(aggregator, subgts, durationBucketized, bucketindex, stack);\n+\n+          //\n+          // Reset buffer\n+          //\n+\n+          subgts = GTSHelper.shrinkTo(subgts, 0);\n+        }\n+      }\n+\n+      // update bucketstart and bucketindex\n+      while (tick < bucketstart) {\n+        bucketstart = ADDDURATION.addPeriod(bucketstart, bucketperiod, dtz, -1);\n+        bucketindex--;\n+      }\n+\n+      //  save value in subgts (if tick is not more recent than lastbucket)\n+      if (tick <= lastbucket) {\n+        GTSHelper.setValue(subgts, tick, GTSHelper.locationAtIndex(gts, i), GTSHelper.elevationAtIndex(gts, i), GTSHelper.valueAtIndex(gts, i), false);\n+      }\n+    }\n+\n+    //\n+    // Aggregate on the last batch\n+    //\n+\n+    if (subgts.size() > 0) {\n+      aggregateAndSet(aggregator, subgts, durationBucketized, bucketindex, stack);\n+    }\n+\n+    //\n+    // Set bucket parameters\n+    //\n+\n+    GTSHelper.setLastBucket(durationBucketized, lastbucket_index);\n+    GTSHelper.setBucketSpan(durationBucketized, 1);\n+    GTSHelper.setBucketCount(durationBucketized, bucketcount == 0 ? durationBucketized.size() : Math.toIntExact(bucketcount));\n+\n+    //\n+    // Reverse the order\n+    //\n+\n+    GTSHelper.sort(durationBucketized);\n+\n+    return durationBucketized;\n+  }\n+\n+  public static boolean isDurationBucketized(GeoTimeSerie gts) throws WarpScriptException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 364}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4Nzc3MA==", "bodyText": "Fix and make it clearer.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381887770", "createdAt": "2020-02-20T09:45:18Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONUNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,82 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4ODAxNg==", "bodyText": "Constant renaming?", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381888016", "createdAt": "2020-02-20T09:45:43Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONUNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,82 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONUNBUCKETIZE extends GTSStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_UNBUCKETIZE;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4OTYxNg==", "bodyText": "Handle exceptions if attributes have been tempered with.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r381889616", "createdAt": "2020-02-20T09:48:27Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONUNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,82 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONUNBUCKETIZE extends GTSStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_UNBUCKETIZE;\n+\n+  public DURATIONUNBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONUNBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  protected Map<String, Object> retrieveParameters(WarpScriptStack stack) throws WarpScriptException {\n+    return null;\n+  }\n+\n+  @Override\n+  protected Object gtsOp(Map<String, Object> params, GeoTimeSerie gts) throws WarpScriptException {\n+\n+    if (!GTSHelper.isBucketized(gts)) {\n+      throw new WarpScriptException(getName() + \" expects input GTS to be bucketized.\");\n+    }\n+\n+    if (!DURATIONBUCKETIZE.isDurationBucketized(gts)) {\n+      throw new WarpScriptException(getName() + \" expects input GTS to be duration-bucketized. This information is stored in attributes.\");\n+    }\n+\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.DURATION_ATTRIBUTE_KEY));\n+    long bucketoffset = Long.parseLong(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.OFFSET_ATTRIBUTE_KEY));\n+    DateTimeZone dtz = DateTimeZone.forID(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.TIMEZONE_ATTRIBUTE_KEY));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 66}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a51daf28d5dba7c00e0ad46209f2ae7f398a8a44", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/a51daf28d5dba7c00e0ad46209f2ae7f398a8a44", "committedDate": "2020-02-20T14:21:53Z", "message": "throw error on parsing fail"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "803b5ef1f2d386b22df4f9423ba5e7a02e56ef9c", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/803b5ef1f2d386b22df4f9423ba5e7a02e56ef9c", "committedDate": "2020-02-20T14:21:53Z", "message": "resolve pr comments on ADDDURATION"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47f44964e53780261be5fca9fecc711e454b40c7", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/47f44964e53780261be5fca9fecc711e454b40c7", "committedDate": "2020-02-20T14:21:53Z", "message": "resolve comments on DURATION.BUCKETIZE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8351b62c787f635e20bbb634e1098f57ad8503d", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/b8351b62c787f635e20bbb634e1098f57ad8503d", "committedDate": "2020-02-20T14:28:38Z", "message": "fix unresolved resolved comment"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d7f625810d19ee6b24c03214419bb9f6cf1c9e48", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/d7f625810d19ee6b24c03214419bb9f6cf1c9e48", "committedDate": "2020-02-20T14:32:45Z", "message": "resolve DURATION.UNBUCKETIZE comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "17d0263a7d9b1efcf2aac9fa216e0153f4fc6ecc", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/17d0263a7d9b1efcf2aac9fa216e0153f4fc6ecc", "committedDate": "2020-02-20T15:49:52Z", "message": "bugfix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c3dcda580245cbfe097d70ae9f3af9cc7aa9424e", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/c3dcda580245cbfe097d70ae9f3af9cc7aa9424e", "committedDate": "2020-02-20T15:57:16Z", "message": "more comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyMDY4MTkz", "url": "https://github.com/senx/warp10-platform/pull/665#pullrequestreview-362068193", "createdAt": "2020-02-20T16:53:40Z", "commit": {"oid": "c3dcda580245cbfe097d70ae9f3af9cc7aa9424e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjo1Mzo0MFrOFsbRJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yMFQxNjo1NDozNFrOFsbTIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyODQyMw==", "bodyText": "Actually checking that it starts with a P and can be parsed by a time library is probably safer.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382128423", "createdAt": "2020-02-20T16:53:40Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,369 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_BUCKETIZE;\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDgxMDQxMA=="}, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjEyODkyOA==", "bodyText": "Why positive coefficients? Wouldn't P1M-1d be legitimate to support?", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r382128928", "createdAt": "2020-02-20T16:54:34Z", "author": {"login": "hbs"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,370 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  private static final Matcher DURATION_RE = Pattern.compile(\"^P(?!$)(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(T(?=\\\\d)(\\\\d+H)?(\\\\d+M)?((\\\\d+|\\\\d.(\\\\d)+)S)?)?$\").matcher(\"\");\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(getName() + \" error: bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      Map<String, String> attributes = gts.getMetadata().getAttributes();\n+      if (attributes.get(DURATION_ATTRIBUTE_KEY) != null || attributes.get(OFFSET_ATTRIBUTE_KEY) != null || attributes.get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if (!DURATION_RE.reset(bucketduration).matches()) {\n+      throw new WarpScriptException(getName() + \" expects the bucketduration parameter to be a valid ISO8601 duration with positive coefficients.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c3dcda580245cbfe097d70ae9f3af9cc7aa9424e"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "728b40792447f0569e299dc4d2288e4fb1866557", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/728b40792447f0569e299dc4d2288e4fb1866557", "committedDate": "2020-02-20T17:28:24Z", "message": "speed up small bucketduration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "870fd8724e66277d8dbf1b2f4dd2310784d822c3", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/870fd8724e66277d8dbf1b2f4dd2310784d822c3", "committedDate": "2020-02-21T10:22:41Z", "message": "changes to checks on bucketduration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "243fd4675131fa5596146c570de2446b209ab360", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/243fd4675131fa5596146c570de2446b209ab360", "committedDate": "2020-02-21T10:38:55Z", "message": "improve error messages"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzNDYwOTQ4", "url": "https://github.com/senx/warp10-platform/pull/665#pullrequestreview-363460948", "createdAt": "2020-02-24T15:11:23Z", "commit": {"oid": "243fd4675131fa5596146c570de2446b209ab360"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNToxMToyM1rOFtkGbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yNFQxNjo1NjoxMlrOFtoLoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyMTcwOQ==", "bodyText": "Not if they have been modified (not removed).", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383321709", "createdAt": "2020-02-24T15:11:23Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONUNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,82 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONUNBUCKETIZE extends GTSStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_UNBUCKETIZE;\n+\n+  public DURATIONUNBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONUNBUCKETIZE() {\n+    super(DEFAULT_NAME);\n+  }\n+\n+  public static String getDefaultName() {\n+    return DEFAULT_NAME;\n+  }\n+\n+  @Override\n+  protected Map<String, Object> retrieveParameters(WarpScriptStack stack) throws WarpScriptException {\n+    return null;\n+  }\n+\n+  @Override\n+  protected Object gtsOp(Map<String, Object> params, GeoTimeSerie gts) throws WarpScriptException {\n+\n+    if (!GTSHelper.isBucketized(gts)) {\n+      throw new WarpScriptException(getName() + \" expects input GTS to be bucketized.\");\n+    }\n+\n+    if (!DURATIONBUCKETIZE.isDurationBucketized(gts)) {\n+      throw new WarpScriptException(getName() + \" expects input GTS to be duration-bucketized. This information is stored in attributes.\");\n+    }\n+\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod = ADDDURATION.durationToPeriod(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.DURATION_ATTRIBUTE_KEY));\n+    long bucketoffset = Long.parseLong(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.OFFSET_ATTRIBUTE_KEY));\n+    DateTimeZone dtz = DateTimeZone.forID(gts.getMetadata().getAttributes().get(DURATIONBUCKETIZE.TIMEZONE_ATTRIBUTE_KEY));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4OTYxNg=="}, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNDYyNA==", "bodyText": "Has not been addressed.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383324624", "createdAt": "2020-02-24T15:16:11Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONUNBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,82 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.script.GTSStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ */\n+public class DURATIONUNBUCKETIZE extends GTSStackFunction {\n+\n+  private static final String DEFAULT_NAME = WarpScriptLib.DURATION_UNBUCKETIZE;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTg4ODAxNg=="}, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyNjk2Nw==", "bodyText": "I think you should remove the space between oand :, correct me if I'm mistaken @hbs.\nSeveral occurrences in this PR.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383326967", "createdAt": "2020-02-24T15:19:59Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,420 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.continuum.store.Constants;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243fd4675131fa5596146c570de2446b209ab360"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMyOTcyOA==", "bodyText": "Remove boxing around Constants.TIME_UNITS_PER_S.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383329728", "createdAt": "2020-02-24T15:24:18Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA=="}, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMzNTM1NA==", "bodyText": "You can use Double.parseDouble instead of Double.valueOf to avoid boxing.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383335354", "createdAt": "2020-02-24T15:32:53Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -100,26 +159,39 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n     ReadWritablePeriod period = new MutablePeriod();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDc3OTk3OA=="}, "originalCommit": {"oid": "687c8238516a57d7f5c8abfbabe823cbc5f517b4"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NTIyOQ==", "bodyText": "Are you sure about creating a new Instant each time?\nCould it be better to chose a fixed instant away from known special dates for instance to avoid leap-second, February and daylight saving changes?", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383385229", "createdAt": "2020-02-24T16:50:35Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,420 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.continuum.store.Constants;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(getName() + \" error: bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      Map<String, String> attributes = gts.getMetadata().getAttributes();\n+      if (attributes.get(DURATION_ATTRIBUTE_KEY) != null || attributes.get(OFFSET_ATTRIBUTE_KEY) != null || attributes.get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if ('P' != bucketduration.charAt(0)) {\n+      throw new WarpScriptException(getName() + \" expects that the bucketduration is in ISO8601 duration format.\");\n+    }\n+\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod;\n+    try {\n+      bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" encountered an exception: \" + wse.getMessage());\n+    }\n+\n+    //\n+    // Check that the bucketduration is positive\n+    //\n+\n+    long averageSpan = bucketperiod.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + bucketperiod.getOffset();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243fd4675131fa5596146c570de2446b209ab360"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4ODU3Ng==", "bodyText": "That's working very well to speed-up things for small bucket durations, congrats.\nHowever it seems it is extremely slow with negative last bucket:\n-1582560100948303 'now' STORE\n\n[\n  NEWGTS\n  $now NaN NaN NaN T ADDVALUE\n  bucketizer.last\n  $now 1.2 s +\n  'PT1.2S'\n  3\n]\nDURATION.BUCKETIZE", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r383388576", "createdAt": "2020-02-24T16:56:12Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,420 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.continuum.store.Constants;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(getName() + \" error: bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      Map<String, String> attributes = gts.getMetadata().getAttributes();\n+      if (attributes.get(DURATION_ATTRIBUTE_KEY) != null || attributes.get(OFFSET_ATTRIBUTE_KEY) != null || attributes.get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if ('P' != bucketduration.charAt(0)) {\n+      throw new WarpScriptException(getName() + \" expects that the bucketduration is in ISO8601 duration format.\");\n+    }\n+\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod;\n+    try {\n+      bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" encountered an exception: \" + wse.getMessage());\n+    }\n+\n+    //\n+    // Check that the bucketduration is positive\n+    //\n+\n+    long averageSpan = bucketperiod.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + bucketperiod.getOffset();\n+    if (averageSpan < 0) {\n+      throw new WarpScriptException(getName() + \" expects the bucketduration parameter to be a positive ISO8601 duration.\");\n+    }\n+\n+    //\n+    // Compute bucketindex of lastbucket and compute bucketoffset\n+    //\n+\n+    long flag = 0; // always equal to epoch modulo period\n+    long bucketoffset;\n+    int lastbucketIndex;\n+\n+    //\n+    // Starting from Epoch, we make a hint and land the flag close to lastbucket\n+    //\n+\n+    if (lastbucket > 0) {\n+      int lastbucketIndexHint = Math.toIntExact(lastbucket / averageSpan);\n+      flag = addNonNegativePeriod(flag, bucketperiod, dtz, lastbucketIndexHint + 1);\n+      lastbucketIndex = lastbucketIndexHint;\n+\n+    } else {\n+      int lastbucketIndexHint = - Math.toIntExact(lastbucket / averageSpan);\n+      flag = addNonNegativePeriod(flag, bucketperiod, dtz, lastbucketIndexHint);\n+      lastbucketIndex = lastbucketIndexHint - 1;\n+    }\n+\n+    //\n+    // We move the flag left and right on the time axis to make sure lastbucket is its leftmost bucketend\n+    //\n+\n+    while (flag > lastbucket) {\n+      flag = addNonNegativePeriod(flag, bucketperiod, dtz, -1);\n+      lastbucketIndex--;\n+    }\n+\n+    while (flag <= lastbucket) {\n+      flag = addNonNegativePeriod(flag, bucketperiod, dtz, 1);\n+      lastbucketIndex++;\n+    }\n+\n+    bucketoffset = flag - (lastbucket + 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "243fd4675131fa5596146c570de2446b209ab360"}, "originalPosition": 216}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "66e1127765473f77e05f477de2872d5eb9f7c38f", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/66e1127765473f77e05f477de2872d5eb9f7c38f", "committedDate": "2020-02-26T09:06:52Z", "message": "Merge branch 'master' of github.com:senx/warp10-platform into DURATION.BUCKETIZE"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0709690162218106d638072bdecc420b73a48ec9", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/0709690162218106d638072bdecc420b73a48ec9", "committedDate": "2020-02-26T09:53:15Z", "message": "handle long indices in ADDDURATION"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ac3ddee77f4c9c250b9cf57ecf13d6514e78cd30", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/ac3ddee77f4c9c250b9cf57ecf13d6514e78cd30", "committedDate": "2020-02-26T09:53:55Z", "message": "bugfix negative timestamp"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b7ab4b76867bb7c32170836afc6f9a86b51765f3", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/b7ab4b76867bb7c32170836afc6f9a86b51765f3", "committedDate": "2020-02-26T13:47:18Z", "message": "handle very big and small lasbuckets"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9acd6b98df82230f445ce717d89e36734d2778eb", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/9acd6b98df82230f445ce717d89e36734d2778eb", "committedDate": "2020-02-26T14:06:00Z", "message": "default name Unbuck"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ab9215bd971e7e4a2bf7c968d0457cf9d5c0188d", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/ab9215bd971e7e4a2bf7c968d0457cf9d5c0188d", "committedDate": "2020-02-26T14:11:49Z", "message": "boxing"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5f81bb772e56a4e8ced2a3726d82587ea6c6f527", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/5f81bb772e56a4e8ced2a3726d82587ea6c6f527", "committedDate": "2020-02-26T14:16:36Z", "message": "semicolon"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NTQxMzk0", "url": "https://github.com/senx/warp10-platform/pull/665#pullrequestreview-365541394", "createdAt": "2020-02-27T09:49:05Z", "commit": {"oid": "5f81bb772e56a4e8ced2a3726d82587ea6c6f527"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QwOTo0OTowNlrOFvLi6w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMDo1Mzo1NVrOFvNvtw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAxNjU1NQ==", "bodyText": "Better to add wse as a cause to the new Exception than only getting the message.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r385016555", "createdAt": "2020-02-27T09:49:06Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/ADDDURATION.java", "diffHunk": "@@ -78,48 +77,130 @@ public WarpScriptStack apply(WarpScriptStack stack) throws WarpScriptException {\n       throw new WarpScriptException(getName() + \" operates on a tselements list, timestamp, or timestamp and timezone.\");\n     }\n \n+    //\n+    // Handle time zone\n+    //\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (null != tz) {\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n     //\n     // Handle duration\n     //\n \n+    ReadWritablePeriodWithSubSecondOffset period;\n+    try {\n+      period = durationToPeriod(duration);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" encountered an exception: \" + wse.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5f81bb772e56a4e8ced2a3726d82587ea6c6f527"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTA1MjU5OQ==", "bodyText": "While you're right about leap seconds (Joda doesn't even support it) and daylight saving time, there are still 2 issues:\n\nnew Instant() is set to the system current milliseconds, so if you have a period of 1 month and you run that in February, you won't have the same result as if you run than in January.\nYou are instantiating an object each time while a single instance (static or not) should be enough.", "url": "https://github.com/senx/warp10-platform/pull/665#discussion_r385052599", "createdAt": "2020-02-27T10:53:55Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/DURATIONBUCKETIZE.java", "diffHunk": "@@ -0,0 +1,420 @@\n+//\n+//   Copyright 2020  SenX S.A.S.\n+//\n+//   Licensed under the Apache License, Version 2.0 (the \"License\");\n+//   you may not use this file except in compliance with the License.\n+//   You may obtain a copy of the License at\n+//\n+//     http://www.apache.org/licenses/LICENSE-2.0\n+//\n+//   Unless required by applicable law or agreed to in writing, software\n+//   distributed under the License is distributed on an \"AS IS\" BASIS,\n+//   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+//   See the License for the specific language governing permissions and\n+//   limitations under the License.\n+//\n+\n+package io.warp10.script.functions;\n+\n+import io.warp10.continuum.gts.GTSHelper;\n+import io.warp10.continuum.gts.GeoTimeSerie;\n+import io.warp10.continuum.store.Constants;\n+import io.warp10.script.NamedWarpScriptFunction;\n+import io.warp10.script.WarpScriptBucketizerFunction;\n+import io.warp10.script.WarpScriptLib;\n+import io.warp10.script.WarpScriptStack.Macro;\n+import io.warp10.script.WarpScriptStackFunction;\n+import io.warp10.script.WarpScriptException;\n+import io.warp10.script.WarpScriptStack;\n+import org.joda.time.DateTimeZone;\n+import org.joda.time.Instant;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Bucketizes some GTS instances using a bucketduration rather than a bucketspan.\n+ * The tick of the resulting buckets will be their index (number of bucketduration since Unix Epoch).\n+ * The goal is to make possible to apply functions for bucketized series on a series with bucket of irregular calendar bucket span.\n+ * To restore timestamp for ticks, there is DURATION.UNBUCKETIZE.\n+ */\n+public class DURATIONBUCKETIZE extends NamedWarpScriptFunction implements WarpScriptStackFunction {\n+\n+  public static final String DURATION_ATTRIBUTE_KEY = \".bucketduration\";\n+  public static final String OFFSET_ATTRIBUTE_KEY = \".bucketoffset\";\n+  public static final String TIMEZONE_ATTRIBUTE_KEY = \".buckettimezone\";\n+\n+  public DURATIONBUCKETIZE(String name) {\n+    super(name);\n+  }\n+\n+  public DURATIONBUCKETIZE() {\n+    super(getDefaultName());\n+  }\n+\n+  public static String getDefaultName() {\n+    return WarpScriptLib.DURATION_BUCKETIZE;\n+  }\n+\n+  @Override\n+  public Object apply(WarpScriptStack stack) throws WarpScriptException {\n+    Object top = stack.pop();\n+\n+    //\n+    // Handle parameters\n+    //\n+\n+    if (!(top instanceof List)) {\n+      throw new WarpScriptException(getName() + \" expects a list as input.\");\n+    }\n+\n+    List<Object> params = (List<Object>) top;\n+\n+    if (5 > params.size()) {\n+      throw new WarpScriptException(getName() + \" needs a list of at least 5 parameters as input.\");\n+    }\n+\n+    DateTimeZone dtz = DateTimeZone.UTC;\n+    if (params.get(params.size() - 1) instanceof String) {\n+      String tz = (String) params.remove(params.size() - 1);\n+      dtz = DateTimeZone.forID(tz);\n+    }\n+\n+    List<GeoTimeSerie> series = new ArrayList<GeoTimeSerie>();\n+\n+    for (int i = 0; i < params.size() - 4; i++) {\n+      if (params.get(i) instanceof GeoTimeSerie) {\n+        series.add((GeoTimeSerie) params.get(i));\n+      } else if (params.get(i) instanceof List) {\n+        for (Object o : (List) params.get(i)) {\n+          if (!(o instanceof GeoTimeSerie)) {\n+            throw new WarpScriptException(getName() + \" expects a list of Geo Time Series as first parameter.\");\n+          }\n+          series.add((GeoTimeSerie) o);\n+        }\n+      } else {\n+        throw new WarpScriptException(getName() + \" expects a Geo Time Series or a list of Geo Time Series as first parameter.\");\n+      }\n+    }\n+\n+    if (!(params.get(params.size() - 4) instanceof WarpScriptBucketizerFunction) && !(params.get(params.size() - 4) instanceof Macro) && null != params.get(params.size() - 4)) {\n+      throw new WarpScriptException(getName() + \" expects a bucketizer function or a macro as fourth to last parameter.\");\n+    }\n+\n+    if (!(params.get(params.size() - 3) instanceof Long) || !(params.get(params.size() - 2) instanceof String) || !(params.get(params.size() - 1) instanceof Long)) {\n+      throw new WarpScriptException(getName() + \" expects lastbucket, bucketduration, bucketcount (and optionally timezone) as last parameters.\");\n+    }\n+\n+    Object bucketizer = params.get(params.size() - 4);\n+    long lastbucket = (long) params.get(params.size() - 3);\n+    String bucketduration = (String) params.get(params.size() - 2);\n+    long bucketcount = (long) params.get(params.size() - 1);\n+\n+    //\n+    // Check that lastbucket is not 0\n+    //\n+\n+    if (0 == lastbucket) {\n+      throw new WarpScriptException(getName() + \" does not allow lastbucket to be 0. It must be specified.\");\n+    }\n+\n+    //\n+    // Check that bucketcount is not negative or null and not over maxbuckets\n+    //\n+\n+    if (bucketcount < 0) {\n+      throw new WarpScriptException(getName() + \" expects a positive bucketcount.\");\n+    }\n+\n+    long maxbuckets = (long) stack.getAttribute(WarpScriptStack.ATTRIBUTE_MAX_BUCKETS);\n+    if (bucketcount > maxbuckets) {\n+      throw new WarpScriptException(getName() + \" error: bucket count (\" + bucketcount + \") would exceed maximum value of \" + maxbuckets);\n+    }\n+\n+    //\n+    // Check that input gts are not already duration-bucketized\n+    //\n+\n+    for (GeoTimeSerie gts : series) {\n+      Map<String, String> attributes = gts.getMetadata().getAttributes();\n+      if (attributes.get(DURATION_ATTRIBUTE_KEY) != null || attributes.get(OFFSET_ATTRIBUTE_KEY) != null || attributes.get(TIMEZONE_ATTRIBUTE_KEY) != null) {\n+        throw new WarpScriptException(getName() + \" expects GTS for which the attributes \" + DURATION_ATTRIBUTE_KEY + \", \" + OFFSET_ATTRIBUTE_KEY + \" and \" + TIMEZONE_ATTRIBUTE_KEY + \" are not set. If an input GTS is supposed to be already duration-bucketized, duration-unbucketize it first before applying a new duration-bucketization.\");\n+      }\n+    }\n+\n+    //\n+    // Check nullity of bucketizer\n+    //\n+\n+    if (null == bucketizer) {\n+      throw new WarpScriptException(getName() + \" expects a non null bucketizer.\");\n+    }\n+\n+    //\n+    // Convert duration to joda.time.Period\n+    //\n+\n+    if ('P' != bucketduration.charAt(0)) {\n+      throw new WarpScriptException(getName() + \" expects that the bucketduration is in ISO8601 duration format.\");\n+    }\n+\n+    ADDDURATION.ReadWritablePeriodWithSubSecondOffset bucketperiod;\n+    try {\n+      bucketperiod = ADDDURATION.durationToPeriod(bucketduration);\n+    } catch (WarpScriptException wse) {\n+      throw new WarpScriptException(getName() + \" encountered an exception: \" + wse.getMessage());\n+    }\n+\n+    //\n+    // Check that the bucketduration is positive\n+    //\n+\n+    long averageSpan = bucketperiod.getPeriod().toPeriod().toDurationFrom(new Instant()).getMillis() * Constants.TIME_UNITS_PER_MS + bucketperiod.getOffset();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzM4NTIyOQ=="}, "originalCommit": {"oid": "243fd4675131fa5596146c570de2446b209ab360"}, "originalPosition": 174}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b8a42caa4705afa345789e6216c3a87fee2bba83", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/b8a42caa4705afa345789e6216c3a87fee2bba83", "committedDate": "2020-02-27T11:14:37Z", "message": "get cause of wse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e6fbd9aea710ea989a5c8e5e2a01c01289dcd069", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/e6fbd9aea710ea989a5c8e5e2a01c01289dcd069", "committedDate": "2020-02-27T11:19:24Z", "message": "use EPOCH"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9fe160bbc1967ff9d7cf00f28d6c4f331137caee", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/9fe160bbc1967ff9d7cf00f28d6c4f331137caee", "committedDate": "2020-02-27T11:58:04Z", "message": "remove message in wse"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d965df7232dded18dd0c2364a581937eaf7221fc", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/d965df7232dded18dd0c2364a581937eaf7221fc", "committedDate": "2020-02-27T13:13:05Z", "message": "renaming by swapping DURATION from prefix to suffix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8f63fda8b7f82995b1fb4758b8371e087962e15e", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/8f63fda8b7f82995b1fb4758b8371e087962e15e", "committedDate": "2020-02-27T13:14:32Z", "message": "remove getCause()"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NjgyODY2", "url": "https://github.com/senx/warp10-platform/pull/665#pullrequestreview-365682866", "createdAt": "2020-02-27T13:35:07Z", "commit": {"oid": "8f63fda8b7f82995b1fb4758b8371e087962e15e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "69412ce8204664ddfb91983bbd7014bf119c2747", "author": {"user": {"login": "randomboolean", "name": "Jean-Charles"}}, "url": "https://github.com/senx/warp10-platform/commit/69412ce8204664ddfb91983bbd7014bf119c2747", "committedDate": "2020-02-27T14:20:33Z", "message": "renaming ..DURATION to ..CALENDAR"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NzIzNzA2", "url": "https://github.com/senx/warp10-platform/pull/665#pullrequestreview-365723706", "createdAt": "2020-02-27T14:27:17Z", "commit": {"oid": "69412ce8204664ddfb91983bbd7014bf119c2747"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3432, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}