{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2ODU0MDg2", "number": 692, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTowMjowM1rODprSPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo1MDozMVrODp4Bqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MDI3MzkwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTowMjowM1rOF5ARTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTowMjowM1rOF5ARTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNzU4MA==", "bodyText": "You can't use that because it will add a = before each label value, which won't be overridden in case there is a producer and no owner or no producer and an owner.\nAt the end the labelID will be wrong.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395317580", "createdAt": "2020-03-19T21:02:03Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,83 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+          m.getLabels().putAll(tokenSelectors);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4aa12bbe40e2a81fbce5bb44a7479715de49f662"}, "originalPosition": 74}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTU4NzkyOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozMzoyMFrOF5Mwnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozMzoyMFrOF5Mwnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjIwNw==", "bodyText": "I understand that this is for clarity and safeness but as they are always overridden, this is not needed.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522207", "createdAt": "2020-03-20T09:33:20Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTU4OTY5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozMzo1N1rOF5MxvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozMzo1N1rOF5MxvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjQ5Mg==", "bodyText": "Using a variable containing tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1) would be better IMHO.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522492", "createdAt": "2020-03-20T09:33:57Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL));                        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5"}, "originalPosition": 98}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MTU5MDY1OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozNDoxM1rOF5MySQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozNDoxM1rOF5MySQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjYzMw==", "bodyText": "Same thing with tokenSelectors.get(Constants.OWNER_LABEL).substring(1).", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522633", "createdAt": "2020-03-20T09:34:13Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL));                        \n+          } else if (singleOwner && !tokenSelectors.containsKey(Constants.PRODUCER_LABEL)) {\n+            //\n+            // If the token has a single owner but no producer, use the owner as the producer, again this would\n+            // lead to a narrower scope than what the token can actually access so it is fine too.\n+            //\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+            m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.OWNER_LABEL));            ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjM0OTU5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0NzozOVrOF5UX0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0NzozOVrOF5UX0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NjkzMA==", "bodyText": "Can be defined outside the loop.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395646930", "createdAt": "2020-03-20T13:47:39Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            String producer = tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjM1MDMwOnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0Nzo0OFrOF5UYOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0Nzo0OFrOF5UYOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NzAzNA==", "bodyText": "Ditto.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395647034", "createdAt": "2020-03-20T13:47:48Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            String producer = tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1);\n+            m.getLabels().put(Constants.PRODUCER_LABEL, producer);\n+            m.getLabels().put(Constants.OWNER_LABEL, producer);                        \n+          } else if (singleOwner && !tokenSelectors.containsKey(Constants.PRODUCER_LABEL)) {\n+            //\n+            // If the token has a single owner but no producer, use the owner as the producer, again this would\n+            // lead to a narrower scope than what the token can actually access so it is fine too.\n+            //\n+            String owner = tokenSelectors.get(Constants.OWNER_LABEL).substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1MjM2MTM5OnYy", "diffSide": "RIGHT", "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo1MDozMVrOF5UfSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo1MDozMVrOF5UfSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0ODg0MA==", "bodyText": "Use the variables which will be defined because of the comments below.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395648840", "createdAt": "2020-03-20T13:50:31Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e"}, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1325, "cost": 1, "resetAt": "2021-11-12T12:57:47Z"}}}