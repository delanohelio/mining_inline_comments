{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg2ODU0MDg2", "number": 692, "title": "Modified validation of GTS list.", "bodyText": "When using the 'gts' parameter of the FETCH input map, we now perform some more advanced checks to ensure that the provided READ token would actually select the given GTS. We also replace somme labels (namely owner or producer) if absent by a value extracted from the token and which makes the GTS fall within the set of GTS which could be selected with the given token.", "createdAt": "2020-03-11T18:33:13Z", "url": "https://github.com/senx/warp10-platform/pull/692", "merged": true, "mergeCommit": {"oid": "b57937456ff2a381b42fbd13a74652621ae7e129"}, "closed": true, "closedAt": "2020-03-20T14:24:47Z", "author": {"login": "hbs"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcMrcRHAH2gAyMzg2ODU0MDg2OjRhYTEyYmJlNDBlMmE4MWZiY2U1YmI0NGE3NDc5NzE1ZGU0OWY2NjI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcPhSPMAFqTM3ODUyNDkzMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "4aa12bbe40e2a81fbce5bb44a7479715de49f662", "author": {"user": {"login": "hbs", "name": "Mathias Herberts"}}, "url": "https://github.com/senx/warp10-platform/commit/4aa12bbe40e2a81fbce5bb44a7479715de49f662", "committedDate": "2020-03-11T18:29:58Z", "message": "Modified validation of GTS list."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MDkwODQ4", "url": "https://github.com/senx/warp10-platform/pull/692#pullrequestreview-378090848", "createdAt": "2020-03-19T21:02:03Z", "commit": {"oid": "4aa12bbe40e2a81fbce5bb44a7479715de49f662"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTowMjowM1rOF5ARTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xOVQyMTowMjowM1rOF5ARTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMxNzU4MA==", "bodyText": "You can't use that because it will add a = before each label value, which won't be overridden in case there is a producer and no owner or no producer and an owner.\nAt the end the labelID will be wrong.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395317580", "createdAt": "2020-03-19T21:02:03Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,83 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+          m.getLabels().putAll(tokenSelectors);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4aa12bbe40e2a81fbce5bb44a7479715de49f662"}, "originalPosition": 74}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6e32a9dc19a61642762cd025744461ca7c908eec", "author": {"user": {"login": "hbs", "name": "Mathias Herberts"}}, "url": "https://github.com/senx/warp10-platform/commit/6e32a9dc19a61642762cd025744461ca7c908eec", "committedDate": "2020-03-20T08:52:42Z", "message": "Added missing substringing of producer/owner"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5", "author": {"user": {"login": "hbs", "name": "Mathias Herberts"}}, "url": "https://github.com/senx/warp10-platform/commit/4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5", "committedDate": "2020-03-20T09:01:42Z", "message": "Removed useless code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4MzM0ODY1", "url": "https://github.com/senx/warp10-platform/pull/692#pullrequestreview-378334865", "createdAt": "2020-03-20T09:33:20Z", "commit": {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozMzoyMFrOF5Mwnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQwOTozNDoxM1rOF5MySQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjIwNw==", "bodyText": "I understand that this is for clarity and safeness but as they are always overridden, this is not needed.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522207", "createdAt": "2020-03-20T09:33:20Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjQ5Mg==", "bodyText": "Using a variable containing tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1) would be better IMHO.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522492", "createdAt": "2020-03-20T09:33:57Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL));                        ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTUyMjYzMw==", "bodyText": "Same thing with tokenSelectors.get(Constants.OWNER_LABEL).substring(1).", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395522633", "createdAt": "2020-03-20T09:34:13Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,84 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          m.getLabels().remove(Constants.PRODUCER_LABEL);\n+          m.getLabels().remove(Constants.OWNER_LABEL);\n+          m.getLabels().remove(Constants.APPLICATION_LABEL);\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL));                        \n+          } else if (singleOwner && !tokenSelectors.containsKey(Constants.PRODUCER_LABEL)) {\n+            //\n+            // If the token has a single owner but no producer, use the owner as the producer, again this would\n+            // lead to a narrower scope than what the token can actually access so it is fine too.\n+            //\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+            m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.OWNER_LABEL));            ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e6e248fb1d98d3e3acc6bbe6632cc031241ccb5"}, "originalPosition": 105}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "216a175742399dba49e8e27a74bb618cf8321f3a", "author": {"user": {"login": "hbs", "name": "Mathias Herberts"}}, "url": "https://github.com/senx/warp10-platform/commit/216a175742399dba49e8e27a74bb618cf8321f3a", "committedDate": "2020-03-20T11:02:21Z", "message": "Addressed PR comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e", "author": {"user": {"login": "hbs", "name": "Mathias Herberts"}}, "url": "https://github.com/senx/warp10-platform/commit/a67c285c079f42129521c3ba998fb36a6c95334e", "committedDate": "2020-03-20T11:03:20Z", "message": "Reverted incorrect commit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NDk2NTAx", "url": "https://github.com/senx/warp10-platform/pull/692#pullrequestreview-378496501", "createdAt": "2020-03-20T13:47:39Z", "commit": {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo0NzozOVrOF5UX0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMFQxMzo1MDozMVrOF5UfSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NjkzMA==", "bodyText": "Can be defined outside the loop.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395646930", "createdAt": "2020-03-20T13:47:39Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            String producer = tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0NzAzNA==", "bodyText": "Ditto.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395647034", "createdAt": "2020-03-20T13:47:48Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            \n+          } else if (singleProducer && !tokenSelectors.containsKey(Constants.OWNER_LABEL)) {\n+            //\n+            // If the token has a single producer but no owner, use the producer as the owner, this would\n+            // lead to a narrower scope than what the token would actually select so it is fine.\n+            //\n+            String producer = tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1);\n+            m.getLabels().put(Constants.PRODUCER_LABEL, producer);\n+            m.getLabels().put(Constants.OWNER_LABEL, producer);                        \n+          } else if (singleOwner && !tokenSelectors.containsKey(Constants.PRODUCER_LABEL)) {\n+            //\n+            // If the token has a single owner but no producer, use the owner as the producer, again this would\n+            // lead to a narrower scope than what the token can actually access so it is fine too.\n+            //\n+            String owner = tokenSelectors.get(Constants.OWNER_LABEL).substring(1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e"}, "originalPosition": 105}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTY0ODg0MA==", "bodyText": "Use the variables which will be defined because of the comments below.", "url": "https://github.com/senx/warp10-platform/pull/692#discussion_r395648840", "createdAt": "2020-03-20T13:50:31Z", "author": {"login": "ftence"}, "path": "warp10/src/main/java/io/warp10/script/functions/FETCH.java", "diffHunk": "@@ -235,32 +236,86 @@ public Object apply(WarpScriptStack stack) throws WarpScriptException {\n       iter = metaset.getMetadatas().iterator();\n     } else if (params.containsKey(PARAM_GTS)) {\n       List<Metadata> metas = (List<Metadata>) params.get(PARAM_GTS);\n-            \n+      \n+      Map<String,String> tokenSelectors = Tokens.labelSelectorsFromReadToken(rtoken);\n+      \n+      boolean singleApp = tokenSelectors.containsKey(Constants.APPLICATION_LABEL) && '=' == tokenSelectors.get(Constants.APPLICATION_LABEL).charAt(0);\n+      boolean singleOwner = tokenSelectors.containsKey(Constants.OWNER_LABEL) && '=' == tokenSelectors.get(Constants.OWNER_LABEL).charAt(0);\n+      boolean singleProducer = tokenSelectors.containsKey(Constants.PRODUCER_LABEL) && '=' == tokenSelectors.get(Constants.PRODUCER_LABEL).charAt(0); \n+\n+      Metadata tmeta = new Metadata();\n+      tmeta.setName(\"\");\n+      tmeta.setLabels(tokenSelectors);\n+      \n+      // Build a selector matching all classes\n+      String tselector = \"~.*\" + GTSHelper.buildSelector(tmeta, true);\n+      MetadataSelectorMatcher matcher = new MetadataSelectorMatcher(tselector);\n+      \n+      //\n+      // Build a selector\n       for (Metadata m: metas) {\n         if (null == m.getLabels()) {\n           m.setLabels(new HashMap<String,String>());\n         }\n-        m.getLabels().remove(Constants.PRODUCER_LABEL);\n-        m.getLabels().remove(Constants.OWNER_LABEL);\n-        m.getLabels().remove(Constants.APPLICATION_LABEL);\n-        m.getLabels().putAll(Tokens.labelSelectorsFromReadToken(rtoken));\n-                \n-        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL) && '=' == m.getLabels().get(Constants.PRODUCER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.PRODUCER_LABEL, m.getLabels().get(Constants.PRODUCER_LABEL).substring(1));\n-        } else if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)) {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single producer.\");\n-        }\n         \n-        if (m.getLabels().containsKey(Constants.OWNER_LABEL) && '=' == m.getLabels().get(Constants.OWNER_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.OWNER_LABEL, m.getLabels().get(Constants.OWNER_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single owner.\");\n+        //\n+        // If the Metadata have producer/owner/app labels, check if 'matcher' would select them\n+        //\n+        \n+        boolean matches = false;\n+        \n+        if (m.getLabels().containsKey(Constants.PRODUCER_LABEL)\n+            && m.getLabels().containsKey(Constants.OWNER_LABEL)\n+            && m.getLabels().containsKey(Constants.APPLICATION_LABEL)) {\n+          matches = matcher.matches(m);\n         }\n         \n-        if (m.getLabels().containsKey(Constants.APPLICATION_LABEL) && '=' == m.getLabels().get(Constants.APPLICATION_LABEL).charAt(0)) {\n-          m.getLabels().put(Constants.APPLICATION_LABEL, m.getLabels().get(Constants.APPLICATION_LABEL).substring(1));\n-        } else {\n-          throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+        //\n+        // If the metadata would not get selected by the provided token\n+        // force the producer/owner/app to be that of the token\n+        //\n+        \n+        if (!matches) {\n+          //\n+          // We will now set producer/owner/application\n+          //\n+              \n+          //\n+          // If the token doesn't contain a single app we abort the selection as we cannot\n+          // choose an app which would be within the reach of the token\n+          //\n+          \n+          if (singleApp) {\n+            m.getLabels().put(Constants.APPLICATION_LABEL, tokenSelectors.get(Constants.APPLICATION_LABEL).substring(1));\n+          } else {\n+            throw new WarpScriptException(getName() + \" provided token is incompatible with '\" + PARAM_GTS + \"' parameter, expecting a single application.\");\n+          }\n+\n+          if (singleProducer && singleOwner) {\n+            //\n+            // If the token has a single producer and single owner, use them for the GTS\n+            //\n+            m.getLabels().put(Constants.PRODUCER_LABEL, tokenSelectors.get(Constants.PRODUCER_LABEL).substring(1));\n+            m.getLabels().put(Constants.OWNER_LABEL, tokenSelectors.get(Constants.OWNER_LABEL).substring(1));            ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a67c285c079f42129521c3ba998fb36a6c95334e"}, "originalPosition": 91}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0f2b191fbe98343b105a6dcef1ea4eb4fbdd66ef", "author": {"user": {"login": "hbs", "name": "Mathias Herberts"}}, "url": "https://github.com/senx/warp10-platform/commit/0f2b191fbe98343b105a6dcef1ea4eb4fbdd66ef", "committedDate": "2020-03-20T14:17:08Z", "message": "Addressed more PR comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc4NTI0OTMx", "url": "https://github.com/senx/warp10-platform/pull/692#pullrequestreview-378524931", "createdAt": "2020-03-20T14:21:44Z", "commit": {"oid": "0f2b191fbe98343b105a6dcef1ea4eb4fbdd66ef"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3463, "cost": 1, "resetAt": "2021-11-02T10:47:05Z"}}}