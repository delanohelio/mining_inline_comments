{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg1NTc3NzI0", "number": 1754, "title": "Optmize forced ID resolution", "bodyText": "This PR significantly optimizes forced ID resolution during resource creation, as well as during searches.\nIt reduces 1-4 SQL statements during resource creation, and adds an optional caching layer that can further reduce calls on servers where deletion is disabled.\nIt also reduces resolution calls during searches in some cases.", "createdAt": "2020-03-09T13:07:06Z", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754", "merged": true, "mergeCommit": {"oid": "1dc5d8901328b7646987b596c3b3cdfeace145cd"}, "closed": true, "closedAt": "2020-03-12T21:12:51Z", "author": {"login": "jamesagnew"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcLsGeugH2gAyMzg1NTc3NzI0OjllNzcxM2QwYmUxNTQ4MDc2MjdiZmQ0MDYyMjQwYzM4NmY1MDRhNTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNCXEHAH2gAyMzg1NTc3NzI0OjViNjc1NTQwNTJhMGRlNjgzZmE2N2YxYmFmODRjYzkwOTUxZmMxZmM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "9e7713d0be154807627bfd4062240c386f504a56", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/9e7713d0be154807627bfd4062240c386f504a56", "committedDate": "2020-03-08T16:42:09Z", "message": "Add forced ID caching"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d43dd32feac53f699ef1063e8ce7e7f7b9496d9d", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/d43dd32feac53f699ef1063e8ce7e7f7b9496d9d", "committedDate": "2020-03-09T09:11:25Z", "message": "Work on id optimization"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef61b65f59f52d35fd239b3ac0aa9c4549bc4bad", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/ef61b65f59f52d35fd239b3ac0aa9c4549bc4bad", "committedDate": "2020-03-09T12:07:58Z", "message": "Test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f39e89b66c96be2ae1d845e1963c7527c2b26305", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/f39e89b66c96be2ae1d845e1963c7527c2b26305", "committedDate": "2020-03-09T12:40:52Z", "message": "More optimization work"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43ded0f5fdf4b226697d137657ed91de6ee6b4e9", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/43ded0f5fdf4b226697d137657ed91de6ee6b4e9", "committedDate": "2020-03-09T12:49:38Z", "message": "Add some docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1520e2a958f0b6ec495fa522507e5f6da0586280", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/1520e2a958f0b6ec495fa522507e5f6da0586280", "committedDate": "2020-03-09T13:25:31Z", "message": "Work on docs"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "05e0ace4c5d54e101b3a8e241c92966e49fd3a85", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/05e0ace4c5d54e101b3a8e241c92966e49fd3a85", "committedDate": "2020-03-09T13:48:44Z", "message": "Test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6796473bcf67d4da4d2de5bf2b68b1c664383f82", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/6796473bcf67d4da4d2de5bf2b68b1c664383f82", "committedDate": "2020-03-09T14:51:03Z", "message": "Test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/1f89732250c9fdbe51b478516c241ad62169f620", "committedDate": "2020-03-09T15:29:15Z", "message": "Test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8fa86f80bc37b640a90b2d6600963207ce97b57e", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/8fa86f80bc37b640a90b2d6600963207ce97b57e", "committedDate": "2020-03-09T16:50:55Z", "message": "Merge branch 'master' into ja_20200308_forced_id_caching"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzA3NTg4", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#pullrequestreview-371307588", "createdAt": "2020-03-09T15:55:04Z", "commit": {"oid": "6796473bcf67d4da4d2de5bf2b68b1c664383f82"}, "state": "APPROVED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNTo1NTowNVrOFzulyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzozMTo1MFrOFzyaPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NTAzMw==", "bodyText": "This method actually seems to return a Collection of Object arrays. Is it meant to always return a single element?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389785033", "createdAt": "2020-03-09T15:55:05Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/data/IForcedIdDao.java", "diffHunk": "@@ -35,13 +36,41 @@\n \t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myForcedId IN (:forced_id)\")\n \tList<Long> findByForcedId(@Param(\"forced_id\") Collection<String> theForcedId);\n \n-\t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId IN (:forced_id)\")\n-\tList<Long> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") Collection<String> theForcedId);\n+\t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId = :forced_id\")\n+\tOptional<Long> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") String theForcedId);\n \n \t@Query(\"SELECT f FROM ForcedId f WHERE f.myResourcePid = :resource_pid\")\n \tForcedId findByResourcePid(@Param(\"resource_pid\") Long theResourcePid);\n \n \t@Modifying\n \t@Query(\"DELETE FROM ForcedId t WHERE t.myId = :pid\")\n \tvoid deleteByPid(@Param(\"pid\") Long theId);\n+\n+\t/**\n+\t * This method returns an object array, where the order matters. Be careful if you change this query in any way.\n+\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6796473bcf67d4da4d2de5bf2b68b1c664383f82"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NjA1MQ==", "bodyText": "Question: Is this correctly named? It seems we do not resolve by type here, unless I am mistaken", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389786051", "createdAt": "2020-03-09T15:56:34Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/data/IForcedIdDao.java", "diffHunk": "@@ -35,13 +36,41 @@\n \t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myForcedId IN (:forced_id)\")\n \tList<Long> findByForcedId(@Param(\"forced_id\") Collection<String> theForcedId);\n \n-\t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId IN (:forced_id)\")\n-\tList<Long> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") Collection<String> theForcedId);\n+\t@Query(\"SELECT f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId = :forced_id\")\n+\tOptional<Long> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") String theForcedId);\n \n \t@Query(\"SELECT f FROM ForcedId f WHERE f.myResourcePid = :resource_pid\")\n \tForcedId findByResourcePid(@Param(\"resource_pid\") Long theResourcePid);\n \n \t@Modifying\n \t@Query(\"DELETE FROM ForcedId t WHERE t.myId = :pid\")\n \tvoid deleteByPid(@Param(\"pid\") Long theId);\n+\n+\t/**\n+\t * This method returns an object array, where the order matters. Be careful if you change this query in any way.\n+\t */\n+\t@Query(\"SELECT f.myForcedId, f.myResourcePid FROM ForcedId f WHERE myResourceType = :resource_type AND myForcedId IN ( :forced_id )\")\n+\tCollection<Object[]> findByTypeAndForcedId(@Param(\"resource_type\") String theResourceType, @Param(\"forced_id\") Collection<String> theForcedId);\n+\n+\t/**\n+\t * This method returns an object array, where the order matters. Be careful if you change this query in any way.\n+\t */\n+\t@Query(\"\" +\n+\t\t\"SELECT \" +\n+\t\t\"   f.myResourceType, f.myResourcePid, f.myForcedId, t.myDeleted \" +\n+\t\t\"FROM ForcedId f \" +\n+\t\t\"JOIN ResourceTable t ON t.myId = f.myResourcePid \" +\n+\t\t\"WHERE f.myForcedId IN ( :forced_id )\")\n+\tCollection<Object[]> findAndResolveByTypeAndForcedId(@Param(\"forced_id\") Collection<String> theForcedIds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6796473bcf67d4da4d2de5bf2b68b1c664383f82"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4NzIyMA==", "bodyText": "Suggestion: Add doc strings to the interface methods in IResourceLinkResolver", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389787220", "createdAt": "2020-03-09T15:58:19Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/DaoResourceLinkResolver.java", "diffHunk": "@@ -64,16 +64,15 @@\n \tprivate DaoRegistry myDaoRegistry;\n \n \t@Override\n-\tpublic ResourceTable findTargetResource(RuntimeSearchParam theNextSpDef, String theNextPathsUnsplit, IIdType theNextId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest) {\n-\t\tResourceTable target;\n-\t\tResourcePersistentId valueOf;\n+\tpublic IResourceLookup findTargetResource(RuntimeSearchParam theNextSpDef, String theNextPathsUnsplit, IIdType theNextId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6796473bcf67d4da4d2de5bf2b68b1c664383f82"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4ODQ4NQ==", "bodyText": "Suggestion: Change this variable name, as this is no longer a pid", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389788485", "createdAt": "2020-03-09T16:00:05Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/DaoResourceLinkResolver.java", "diffHunk": "@@ -64,16 +64,15 @@\n \tprivate DaoRegistry myDaoRegistry;\n \n \t@Override\n-\tpublic ResourceTable findTargetResource(RuntimeSearchParam theNextSpDef, String theNextPathsUnsplit, IIdType theNextId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest) {\n-\t\tResourceTable target;\n-\t\tResourcePersistentId valueOf;\n+\tpublic IResourceLookup findTargetResource(RuntimeSearchParam theNextSpDef, String theNextPathsUnsplit, IIdType theNextId, String theTypeString, Class<? extends IBaseResource> theType, IBaseReference theReference, RequestDetails theRequest) {\n+\t\tIResourceLookup valueOf;\n \t\tString idPart = theNextId.getIdPart();\n \t\ttry {\n-\t\t\tvalueOf = myIdHelperService.translateForcedIdToPid(theTypeString, idPart, theRequest);\n+\t\t\tvalueOf = myIdHelperService.resolveResourceIdentity(theTypeString, idPart, theRequest);\n \t\t\tourLog.trace(\"Translated {}/{} to resource PID {}\", theType, idPart, valueOf);\n \t\t} catch (ResourceNotFoundException e) {\n \n-\t\t\tOptional<ResourcePersistentId> pidOpt = createPlaceholderTargetIfConfiguredToDoSo(theType, theReference, idPart);\n+\t\t\tOptional<ResourceTable> pidOpt = createPlaceholderTargetIfConfiguredToDoSo(theType, theReference, idPart);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6796473bcf67d4da4d2de5bf2b68b1c664383f82"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5MDEwNg==", "bodyText": "Unless im mistaken, this log will interpolate the ResourceTable.toString() as the first argument, which probably isn't what you want? Current definition is:\n\t@Override\n\tpublic String toString() {\n\t\tToStringBuilder b = new ToStringBuilder(this, ToStringStyle.SHORT_PREFIX_STYLE);\n\t\tb.append(\"resourceType\", myResourceType);\n\t\tb.append(\"pid\", myId);\n\t\treturn b.build();\n\t}\n\nSo you can probably strip out the second log variable", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389790106", "createdAt": "2020-03-09T16:02:32Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/DaoResourceLinkResolver.java", "diffHunk": "@@ -89,36 +88,29 @@ public ResourceTable findTargetResource(RuntimeSearchParam theNextSpDef, String\n \t\t\tvalueOf = pidOpt.get();\n \t\t}\n \n-\t\ttarget = myEntityManager.find(ResourceTable.class, valueOf.getIdAsLong());\n-\t\tRuntimeResourceDefinition targetResourceDef = myContext.getResourceDefinition(theType);\n-\t\tif (target == null) {\n-\t\t\tString resName = targetResourceDef.getName();\n-\t\t\tthrow new InvalidRequestException(\"Resource \" + resName + \"/\" + idPart + \" not found, specified in path: \" + theNextPathsUnsplit);\n+\t\tourLog.trace(\"Resource PID {} is of type {}\", valueOf, valueOf.getResourceType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6796473bcf67d4da4d2de5bf2b68b1c664383f82"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMTUyOA==", "bodyText": "Will having this warning message inside the loop cause performance issues here?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389831528", "createdAt": "2020-03-09T17:06:55Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -22,132 +22,222 @@\n \n import ca.uhn.fhir.context.FhirContext;\n import ca.uhn.fhir.interceptor.api.HookParams;\n+import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.dao.DaoConfig;\n-import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.dao.data.IForcedIdDao;\n+import ca.uhn.fhir.jpa.dao.data.IResourceTableDao;\n+import ca.uhn.fhir.jpa.model.cross.IResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.model.entity.ForcedId;\n-import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n-import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.model.search.StorageProcessingMessage;\n import ca.uhn.fhir.jpa.util.JpaInterceptorBroadcaster;\n import ca.uhn.fhir.model.primitive.IdDt;\n import ca.uhn.fhir.rest.api.server.RequestDetails;\n import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n import com.google.common.collect.ListMultimap;\n import com.google.common.collect.MultimapBuilder;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.hl7.fhir.instance.model.api.IIdType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n import javax.annotation.Nonnull;\n-import java.util.*;\n+import javax.annotation.PostConstruct;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n \n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n+/**\n+ * This class is used to convert between PIDs (the internal primary key for a particular resource as\n+ * stored in the {@link ca.uhn.fhir.jpa.model.entity.ResourceTable HFJ_RESOURCE} table), and the\n+ * public ID that a resource has.\n+ * <p>\n+ * These IDs are sometimes one and the same (by default, a resource that the server assigns the ID of\n+ * <code>Patient/1</code> will simply use a PID of 1 and and ID of 1. However, they may also be different\n+ * in cases where a forced ID is used (an arbitrary client-assigned ID).\n+ * </p>\n+ * <p>\n+ * This service is highly optimized in order to minimize the number of DB calls as much as possible,\n+ * since ID resolution is fundamental to many basic operations. This service returns either\n+ * {@link IResourceLookup} or {@link ResourcePersistentId} depending on the method being called.\n+ * The former involves an extra database join that the latter does not require, so selecting the\n+ * right method here is important.\n+ * </p>\n+ */\n @Service\n public class IdHelperService {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(IdHelperService.class);\n+\n \t@Autowired\n \tprotected IForcedIdDao myForcedIdDao;\n+\t@Autowired\n+\tprotected IResourceTableDao myResourceTableDao;\n \t@Autowired(required = true)\n \tprivate DaoConfig myDaoConfig;\n \t@Autowired\n \tprivate IInterceptorBroadcaster myInterceptorBroadcaster;\n \n-\tpublic void delete(ForcedId forcedId) {\n-\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n+\tprivate Cache<String, Long> myPersistentIdCache;\n+\tprivate Cache<String, IResourceLookup> myResourceLookupCache;\n+\n+\t@PostConstruct\n+\tpublic void start() {\n+\t\tmyPersistentIdCache = newCache();\n+\t\tmyResourceLookupCache = newCache();\n \t}\n \n-\t/**\n-\t * @throws ResourceNotFoundException If the ID can not be found\n-\t */\n-\t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(IIdType theId, RequestDetails theRequestDetails) {\n-\t\treturn translateForcedIdToPid(theId.getResourceType(), theId.getIdPart(), theRequestDetails);\n+\n+\tpublic void delete(ForcedId forcedId) {\n+\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n \t}\n \n \t/**\n+\t * Given a resource type and ID, looks up the resource and returns a {@link IResourceLookup}. This\n+\t * object contains the internal PID for the resource and the resource deletion status, making it sufficient\n+\t * for persisting resource links between resources without adding any further database calls after the\n+\t * single one performed by this call.\n+\t *\n \t * @throws ResourceNotFoundException If the ID can not be found\n \t */\n \t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n+\tpublic IResourceLookup resolveResourceIdentity(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n \t\t// We only pass 1 input in so only 0..1 will come back\n \t\tIdDt id = new IdDt(theResourceName, theResourceId);\n-\t\tList<ResourcePersistentId> matches = translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, Collections.singletonList(id));\n+\t\tCollection<IResourceLookup> matches = translateForcedIdToPids(theRequestDetails, Collections.singletonList(id));\n \t\tassert matches.size() <= 1;\n \t\tif (matches.isEmpty()) {\n \t\t\tthrow new ResourceNotFoundException(id);\n \t\t}\n-\t\treturn matches.get(0);\n+\t\treturn matches.iterator().next();\n \t}\n \n-\tpublic List<ResourcePersistentId> translateForcedIdToPids(Collection<IIdType> theId, RequestDetails theRequestDetails) {\n-\t\treturn IdHelperService.translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, theId);\n+\t/**\n+\t * Given a resource type and ID, determines the internal persistent ID for the resource.\n+\t *\n+\t * @throws ResourceNotFoundException If the ID can not be found\n+\t */\n+\t@Nonnull\n+\tpublic ResourcePersistentId resolveResourcePersistentIds(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(theId)) {\n+\t\t\tif (myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tretVal = resolveResourceIdentity(theResourceType, theId);\n+\t\t\t} else {\n+\t\t\t\tString key = theResourceType + \"/\" + theId;\n+\t\t\t\tretVal = myPersistentIdCache.get(key, t -> resolveResourceIdentity(theResourceType, theId));\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tretVal = Long.parseLong(theId);\n+\t\t}\n+\n+\t\treturn new ResourcePersistentId(retVal);\n \t}\n \n-\tprivate static List<ResourcePersistentId> translateForcedIdToPids(DaoConfig theDaoConfig, IInterceptorBroadcaster theInterceptorBroadcaster, RequestDetails theRequest, IForcedIdDao theForcedIdDao, Collection<IIdType> theId) {\n-\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\t/**\n+\t * Given a collection of resource IDs (resource type + id), resolves the internal persistent IDs\n+\t */\n+\t@Nonnull\n+\tpublic List<ResourcePersistentId> resolveResourcePersistentIds(List<IIdType> theIds, RequestDetails theRequest) {\n+\t\ttheIds.forEach(id -> Validate.isTrue(id.hasIdPart()));\n \n-\t\tif (theId.isEmpty()) {\n+\t\tif (theIds.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \n \t\tList<ResourcePersistentId> retVal = new ArrayList<>();\n \n-\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n-\t\tfor (IIdType nextId : theId) {\n-\t\t\tif (theDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY && isValidPid(nextId)) {\n-\t\t\t\tretVal.add(new ResourcePersistentId(nextId.getIdPartAsLong()));\n-\t\t\t} else {\n-\t\t\t\tif (nextId.hasResourceType()) {\n-\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n-\t\t\t\t} else {\n-\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\ttheIds\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.map(t -> new ResourcePersistentId(t))\n+\t\t\t\t.forEach(t -> retVal.add(t));\n \t\t}\n \n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theIds);\n+\n \t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n \t\t\tString nextResourceType = nextEntry.getKey();\n \t\t\tCollection<String> nextIds = nextEntry.getValue();\n \t\t\tif (isBlank(nextResourceType)) {\n \n \t\t\t\tStorageProcessingMessage msg = new StorageProcessingMessage()\n \t\t\t\t\t.setMessage(\"This search uses unqualified resource IDs (an ID without a resource type). This is less efficient than using a qualified type.\");\n+\t\t\t\tourLog.debug(msg.getMessage());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMjMwMA==", "bodyText": "Same with here. Is it maybe worthwhile to pull this out and just broadcast once if the list contained a type-less resource PID? Or is this message valuable for every instance of a pid that was processed?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389832300", "createdAt": "2020-03-09T17:08:07Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -22,132 +22,222 @@\n \n import ca.uhn.fhir.context.FhirContext;\n import ca.uhn.fhir.interceptor.api.HookParams;\n+import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.dao.DaoConfig;\n-import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.dao.data.IForcedIdDao;\n+import ca.uhn.fhir.jpa.dao.data.IResourceTableDao;\n+import ca.uhn.fhir.jpa.model.cross.IResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.model.entity.ForcedId;\n-import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n-import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.model.search.StorageProcessingMessage;\n import ca.uhn.fhir.jpa.util.JpaInterceptorBroadcaster;\n import ca.uhn.fhir.model.primitive.IdDt;\n import ca.uhn.fhir.rest.api.server.RequestDetails;\n import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n import com.google.common.collect.ListMultimap;\n import com.google.common.collect.MultimapBuilder;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.hl7.fhir.instance.model.api.IIdType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n import javax.annotation.Nonnull;\n-import java.util.*;\n+import javax.annotation.PostConstruct;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n \n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n+/**\n+ * This class is used to convert between PIDs (the internal primary key for a particular resource as\n+ * stored in the {@link ca.uhn.fhir.jpa.model.entity.ResourceTable HFJ_RESOURCE} table), and the\n+ * public ID that a resource has.\n+ * <p>\n+ * These IDs are sometimes one and the same (by default, a resource that the server assigns the ID of\n+ * <code>Patient/1</code> will simply use a PID of 1 and and ID of 1. However, they may also be different\n+ * in cases where a forced ID is used (an arbitrary client-assigned ID).\n+ * </p>\n+ * <p>\n+ * This service is highly optimized in order to minimize the number of DB calls as much as possible,\n+ * since ID resolution is fundamental to many basic operations. This service returns either\n+ * {@link IResourceLookup} or {@link ResourcePersistentId} depending on the method being called.\n+ * The former involves an extra database join that the latter does not require, so selecting the\n+ * right method here is important.\n+ * </p>\n+ */\n @Service\n public class IdHelperService {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(IdHelperService.class);\n+\n \t@Autowired\n \tprotected IForcedIdDao myForcedIdDao;\n+\t@Autowired\n+\tprotected IResourceTableDao myResourceTableDao;\n \t@Autowired(required = true)\n \tprivate DaoConfig myDaoConfig;\n \t@Autowired\n \tprivate IInterceptorBroadcaster myInterceptorBroadcaster;\n \n-\tpublic void delete(ForcedId forcedId) {\n-\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n+\tprivate Cache<String, Long> myPersistentIdCache;\n+\tprivate Cache<String, IResourceLookup> myResourceLookupCache;\n+\n+\t@PostConstruct\n+\tpublic void start() {\n+\t\tmyPersistentIdCache = newCache();\n+\t\tmyResourceLookupCache = newCache();\n \t}\n \n-\t/**\n-\t * @throws ResourceNotFoundException If the ID can not be found\n-\t */\n-\t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(IIdType theId, RequestDetails theRequestDetails) {\n-\t\treturn translateForcedIdToPid(theId.getResourceType(), theId.getIdPart(), theRequestDetails);\n+\n+\tpublic void delete(ForcedId forcedId) {\n+\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n \t}\n \n \t/**\n+\t * Given a resource type and ID, looks up the resource and returns a {@link IResourceLookup}. This\n+\t * object contains the internal PID for the resource and the resource deletion status, making it sufficient\n+\t * for persisting resource links between resources without adding any further database calls after the\n+\t * single one performed by this call.\n+\t *\n \t * @throws ResourceNotFoundException If the ID can not be found\n \t */\n \t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n+\tpublic IResourceLookup resolveResourceIdentity(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n \t\t// We only pass 1 input in so only 0..1 will come back\n \t\tIdDt id = new IdDt(theResourceName, theResourceId);\n-\t\tList<ResourcePersistentId> matches = translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, Collections.singletonList(id));\n+\t\tCollection<IResourceLookup> matches = translateForcedIdToPids(theRequestDetails, Collections.singletonList(id));\n \t\tassert matches.size() <= 1;\n \t\tif (matches.isEmpty()) {\n \t\t\tthrow new ResourceNotFoundException(id);\n \t\t}\n-\t\treturn matches.get(0);\n+\t\treturn matches.iterator().next();\n \t}\n \n-\tpublic List<ResourcePersistentId> translateForcedIdToPids(Collection<IIdType> theId, RequestDetails theRequestDetails) {\n-\t\treturn IdHelperService.translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, theId);\n+\t/**\n+\t * Given a resource type and ID, determines the internal persistent ID for the resource.\n+\t *\n+\t * @throws ResourceNotFoundException If the ID can not be found\n+\t */\n+\t@Nonnull\n+\tpublic ResourcePersistentId resolveResourcePersistentIds(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(theId)) {\n+\t\t\tif (myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tretVal = resolveResourceIdentity(theResourceType, theId);\n+\t\t\t} else {\n+\t\t\t\tString key = theResourceType + \"/\" + theId;\n+\t\t\t\tretVal = myPersistentIdCache.get(key, t -> resolveResourceIdentity(theResourceType, theId));\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tretVal = Long.parseLong(theId);\n+\t\t}\n+\n+\t\treturn new ResourcePersistentId(retVal);\n \t}\n \n-\tprivate static List<ResourcePersistentId> translateForcedIdToPids(DaoConfig theDaoConfig, IInterceptorBroadcaster theInterceptorBroadcaster, RequestDetails theRequest, IForcedIdDao theForcedIdDao, Collection<IIdType> theId) {\n-\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\t/**\n+\t * Given a collection of resource IDs (resource type + id), resolves the internal persistent IDs\n+\t */\n+\t@Nonnull\n+\tpublic List<ResourcePersistentId> resolveResourcePersistentIds(List<IIdType> theIds, RequestDetails theRequest) {\n+\t\ttheIds.forEach(id -> Validate.isTrue(id.hasIdPart()));\n \n-\t\tif (theId.isEmpty()) {\n+\t\tif (theIds.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \n \t\tList<ResourcePersistentId> retVal = new ArrayList<>();\n \n-\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n-\t\tfor (IIdType nextId : theId) {\n-\t\t\tif (theDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY && isValidPid(nextId)) {\n-\t\t\t\tretVal.add(new ResourcePersistentId(nextId.getIdPartAsLong()));\n-\t\t\t} else {\n-\t\t\t\tif (nextId.hasResourceType()) {\n-\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n-\t\t\t\t} else {\n-\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\ttheIds\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.map(t -> new ResourcePersistentId(t))\n+\t\t\t\t.forEach(t -> retVal.add(t));\n \t\t}\n \n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theIds);\n+\n \t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n \t\t\tString nextResourceType = nextEntry.getKey();\n \t\t\tCollection<String> nextIds = nextEntry.getValue();\n \t\t\tif (isBlank(nextResourceType)) {\n \n \t\t\t\tStorageProcessingMessage msg = new StorageProcessingMessage()\n \t\t\t\t\t.setMessage(\"This search uses unqualified resource IDs (an ID without a resource type). This is less efficient than using a qualified type.\");\n+\t\t\t\tourLog.debug(msg.getMessage());\n \t\t\t\tHookParams params = new HookParams()\n \t\t\t\t\t.add(RequestDetails.class, theRequest)\n \t\t\t\t\t.addIfMatchesType(ServletRequestDetails.class, theRequest)\n \t\t\t\t\t.add(StorageProcessingMessage.class, msg);\n-\t\t\t\tJpaInterceptorBroadcaster.doCallHooks(theInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_WARNING, params);\n+\t\t\t\tJpaInterceptorBroadcaster.doCallHooks(myInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_WARNING, params);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 201}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzNDc2Ng==", "bodyText": "This is essentially an undocumented data structure, and its a bit tough to read unless you know the full context. Is it worthwhile maybe creating a small data class that can consume one of these known object arrays and making it more readable? If this is super one-off, maybe just comment this block of code", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389834766", "createdAt": "2020-03-09T17:12:03Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -22,132 +22,222 @@\n \n import ca.uhn.fhir.context.FhirContext;\n import ca.uhn.fhir.interceptor.api.HookParams;\n+import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.dao.DaoConfig;\n-import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.dao.data.IForcedIdDao;\n+import ca.uhn.fhir.jpa.dao.data.IResourceTableDao;\n+import ca.uhn.fhir.jpa.model.cross.IResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourceLookup;\n+import ca.uhn.fhir.jpa.model.cross.ResourcePersistentId;\n import ca.uhn.fhir.jpa.model.entity.ForcedId;\n-import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n-import ca.uhn.fhir.interceptor.api.Pointcut;\n import ca.uhn.fhir.jpa.model.search.StorageProcessingMessage;\n import ca.uhn.fhir.jpa.util.JpaInterceptorBroadcaster;\n import ca.uhn.fhir.model.primitive.IdDt;\n import ca.uhn.fhir.rest.api.server.RequestDetails;\n import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import com.github.benmanes.caffeine.cache.Cache;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n import com.google.common.collect.ListMultimap;\n import com.google.common.collect.MultimapBuilder;\n+import org.apache.commons.lang3.StringUtils;\n import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n import org.hl7.fhir.instance.model.api.IIdType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n \n import javax.annotation.Nonnull;\n-import java.util.*;\n+import javax.annotation.PostConstruct;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n \n import static org.apache.commons.lang3.StringUtils.isBlank;\n \n+/**\n+ * This class is used to convert between PIDs (the internal primary key for a particular resource as\n+ * stored in the {@link ca.uhn.fhir.jpa.model.entity.ResourceTable HFJ_RESOURCE} table), and the\n+ * public ID that a resource has.\n+ * <p>\n+ * These IDs are sometimes one and the same (by default, a resource that the server assigns the ID of\n+ * <code>Patient/1</code> will simply use a PID of 1 and and ID of 1. However, they may also be different\n+ * in cases where a forced ID is used (an arbitrary client-assigned ID).\n+ * </p>\n+ * <p>\n+ * This service is highly optimized in order to minimize the number of DB calls as much as possible,\n+ * since ID resolution is fundamental to many basic operations. This service returns either\n+ * {@link IResourceLookup} or {@link ResourcePersistentId} depending on the method being called.\n+ * The former involves an extra database join that the latter does not require, so selecting the\n+ * right method here is important.\n+ * </p>\n+ */\n @Service\n public class IdHelperService {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(IdHelperService.class);\n+\n \t@Autowired\n \tprotected IForcedIdDao myForcedIdDao;\n+\t@Autowired\n+\tprotected IResourceTableDao myResourceTableDao;\n \t@Autowired(required = true)\n \tprivate DaoConfig myDaoConfig;\n \t@Autowired\n \tprivate IInterceptorBroadcaster myInterceptorBroadcaster;\n \n-\tpublic void delete(ForcedId forcedId) {\n-\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n+\tprivate Cache<String, Long> myPersistentIdCache;\n+\tprivate Cache<String, IResourceLookup> myResourceLookupCache;\n+\n+\t@PostConstruct\n+\tpublic void start() {\n+\t\tmyPersistentIdCache = newCache();\n+\t\tmyResourceLookupCache = newCache();\n \t}\n \n-\t/**\n-\t * @throws ResourceNotFoundException If the ID can not be found\n-\t */\n-\t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(IIdType theId, RequestDetails theRequestDetails) {\n-\t\treturn translateForcedIdToPid(theId.getResourceType(), theId.getIdPart(), theRequestDetails);\n+\n+\tpublic void delete(ForcedId forcedId) {\n+\t\tmyForcedIdDao.deleteByPid(forcedId.getId());\n \t}\n \n \t/**\n+\t * Given a resource type and ID, looks up the resource and returns a {@link IResourceLookup}. This\n+\t * object contains the internal PID for the resource and the resource deletion status, making it sufficient\n+\t * for persisting resource links between resources without adding any further database calls after the\n+\t * single one performed by this call.\n+\t *\n \t * @throws ResourceNotFoundException If the ID can not be found\n \t */\n \t@Nonnull\n-\tpublic ResourcePersistentId translateForcedIdToPid(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n+\tpublic IResourceLookup resolveResourceIdentity(String theResourceName, String theResourceId, RequestDetails theRequestDetails) throws ResourceNotFoundException {\n \t\t// We only pass 1 input in so only 0..1 will come back\n \t\tIdDt id = new IdDt(theResourceName, theResourceId);\n-\t\tList<ResourcePersistentId> matches = translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, Collections.singletonList(id));\n+\t\tCollection<IResourceLookup> matches = translateForcedIdToPids(theRequestDetails, Collections.singletonList(id));\n \t\tassert matches.size() <= 1;\n \t\tif (matches.isEmpty()) {\n \t\t\tthrow new ResourceNotFoundException(id);\n \t\t}\n-\t\treturn matches.get(0);\n+\t\treturn matches.iterator().next();\n \t}\n \n-\tpublic List<ResourcePersistentId> translateForcedIdToPids(Collection<IIdType> theId, RequestDetails theRequestDetails) {\n-\t\treturn IdHelperService.translateForcedIdToPids(myDaoConfig, myInterceptorBroadcaster, theRequestDetails, myForcedIdDao, theId);\n+\t/**\n+\t * Given a resource type and ID, determines the internal persistent ID for the resource.\n+\t *\n+\t * @throws ResourceNotFoundException If the ID can not be found\n+\t */\n+\t@Nonnull\n+\tpublic ResourcePersistentId resolveResourcePersistentIds(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(theId)) {\n+\t\t\tif (myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tretVal = resolveResourceIdentity(theResourceType, theId);\n+\t\t\t} else {\n+\t\t\t\tString key = theResourceType + \"/\" + theId;\n+\t\t\t\tretVal = myPersistentIdCache.get(key, t -> resolveResourceIdentity(theResourceType, theId));\n+\t\t\t}\n+\n+\t\t} else {\n+\t\t\tretVal = Long.parseLong(theId);\n+\t\t}\n+\n+\t\treturn new ResourcePersistentId(retVal);\n \t}\n \n-\tprivate static List<ResourcePersistentId> translateForcedIdToPids(DaoConfig theDaoConfig, IInterceptorBroadcaster theInterceptorBroadcaster, RequestDetails theRequest, IForcedIdDao theForcedIdDao, Collection<IIdType> theId) {\n-\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\t/**\n+\t * Given a collection of resource IDs (resource type + id), resolves the internal persistent IDs\n+\t */\n+\t@Nonnull\n+\tpublic List<ResourcePersistentId> resolveResourcePersistentIds(List<IIdType> theIds, RequestDetails theRequest) {\n+\t\ttheIds.forEach(id -> Validate.isTrue(id.hasIdPart()));\n \n-\t\tif (theId.isEmpty()) {\n+\t\tif (theIds.isEmpty()) {\n \t\t\treturn Collections.emptyList();\n \t\t}\n \n \t\tList<ResourcePersistentId> retVal = new ArrayList<>();\n \n-\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n-\t\tfor (IIdType nextId : theId) {\n-\t\t\tif (theDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY && isValidPid(nextId)) {\n-\t\t\t\tretVal.add(new ResourcePersistentId(nextId.getIdPartAsLong()));\n-\t\t\t} else {\n-\t\t\t\tif (nextId.hasResourceType()) {\n-\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n-\t\t\t\t} else {\n-\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\ttheIds\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.map(t -> new ResourcePersistentId(t))\n+\t\t\t\t.forEach(t -> retVal.add(t));\n \t\t}\n \n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theIds);\n+\n \t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n \t\t\tString nextResourceType = nextEntry.getKey();\n \t\t\tCollection<String> nextIds = nextEntry.getValue();\n \t\t\tif (isBlank(nextResourceType)) {\n \n \t\t\t\tStorageProcessingMessage msg = new StorageProcessingMessage()\n \t\t\t\t\t.setMessage(\"This search uses unqualified resource IDs (an ID without a resource type). This is less efficient than using a qualified type.\");\n+\t\t\t\tourLog.debug(msg.getMessage());\n \t\t\t\tHookParams params = new HookParams()\n \t\t\t\t\t.add(RequestDetails.class, theRequest)\n \t\t\t\t\t.addIfMatchesType(ServletRequestDetails.class, theRequest)\n \t\t\t\t\t.add(StorageProcessingMessage.class, msg);\n-\t\t\t\tJpaInterceptorBroadcaster.doCallHooks(theInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_WARNING, params);\n+\t\t\t\tJpaInterceptorBroadcaster.doCallHooks(myInterceptorBroadcaster, theRequest, Pointcut.JPA_PERFTRACE_WARNING, params);\n \n-\t\t\t\ttheForcedIdDao\n-\t\t\t\t\t.findByForcedId(nextIds)\n-\t\t\t\t\t.stream()\n-\t\t\t\t\t.map(t->new ResourcePersistentId(t))\n-\t\t\t\t\t.forEach(t->retVal.add(t));\n+\t\t\t\tList<Long> views = myForcedIdDao.findByForcedId(nextIds);\n+\t\t\t\tviews.forEach(t -> retVal.add(new ResourcePersistentId(t)));\n \n \t\t\t} else {\n \n-\t\t\t\ttheForcedIdDao\n-\t\t\t\t\t.findByTypeAndForcedId(nextResourceType, nextIds)\n-\t\t\t\t\t.stream()\n-\t\t\t\t\t.map(t->new ResourcePersistentId(t))\n-\t\t\t\t\t.forEach(t->retVal.add(t));\n+\t\t\t\tif (!myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\t\tfor (Iterator<String> idIterator = nextIds.iterator(); idIterator.hasNext(); ) {\n+\t\t\t\t\t\tString nextId = idIterator.next();\n+\t\t\t\t\t\tString key = nextResourceType + \"/\" + nextId;\n+\t\t\t\t\t\tLong nextCachedPid = myPersistentIdCache.getIfPresent(key);\n+\t\t\t\t\t\tif (nextCachedPid != null) {\n+\t\t\t\t\t\t\tidIterator.remove();\n+\t\t\t\t\t\t\tretVal.add(new ResourcePersistentId(nextCachedPid));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\tif (nextIds.size() > 0) {\n+\t\t\t\t\tCollection<Object[]> views = myForcedIdDao.findByTypeAndForcedId(nextResourceType, nextIds);\n+\t\t\t\t\tfor (Object[] nextView : views) {\n+\t\t\t\t\t\tString forcedId = (String) nextView[0];\n+\t\t\t\t\t\tLong pid = (Long) nextView[1];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzNzY4OA==", "bodyText": "Question: Why is this check necessary? Seems as though this function should organize IDs by type regardless of the ResourceClientIdStrategy, or if the pid is valid or not. If that isnt what this function is supposed to do, (e.g. it should only work on non-valid pids), then this function should be renamed.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389837688", "createdAt": "2020-03-09T17:16:36Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -156,17 +246,136 @@ public String translatePidIdToForcedId(String theResourceType, ResourcePersisten\n \t\t}\n \t}\n \n+\tprivate ListMultimap<String, String> organizeIdsByResourceType(Collection<IIdType> theIds) {\n+\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n+\t\tfor (IIdType nextId : theIds) {\n+\t\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(nextId)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 274}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzOTE5Ng==", "bodyText": "Suggestion: theIds", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389839196", "createdAt": "2020-03-09T17:18:57Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -156,17 +246,136 @@ public String translatePidIdToForcedId(String theResourceType, ResourcePersisten\n \t\t}\n \t}\n \n+\tprivate ListMultimap<String, String> organizeIdsByResourceType(Collection<IIdType> theIds) {\n+\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n+\t\tfor (IIdType nextId : theIds) {\n+\t\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(nextId)) {\n+\t\t\t\tif (nextId.hasResourceType()) {\n+\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n+\t\t\t\t} else {\n+\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn typeToIds;\n+\t}\n+\n+\tprivate Long resolveResourceIdentity(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tretVal = myForcedIdDao\n+\t\t\t.findByTypeAndForcedId(theResourceType, theId)\n+\t\t\t.orElseThrow(() -> new ResourceNotFoundException(new IdDt(theResourceType, theId)));\n+\t\treturn retVal;\n+\t}\n+\n+\tprivate Collection<IResourceLookup> translateForcedIdToPids(RequestDetails theRequest, Collection<IIdType> theId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MDMzMQ==", "bodyText": "So this only works in case where Delete is disabled? Is that because it would be too much of a pain to maintain the cache in a scenario where resource deletion is possible?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389840331", "createdAt": "2020-03-09T17:20:46Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -156,17 +246,136 @@ public String translatePidIdToForcedId(String theResourceType, ResourcePersisten\n \t\t}\n \t}\n \n+\tprivate ListMultimap<String, String> organizeIdsByResourceType(Collection<IIdType> theIds) {\n+\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n+\t\tfor (IIdType nextId : theIds) {\n+\t\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(nextId)) {\n+\t\t\t\tif (nextId.hasResourceType()) {\n+\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n+\t\t\t\t} else {\n+\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn typeToIds;\n+\t}\n+\n+\tprivate Long resolveResourceIdentity(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tretVal = myForcedIdDao\n+\t\t\t.findByTypeAndForcedId(theResourceType, theId)\n+\t\t\t.orElseThrow(() -> new ResourceNotFoundException(new IdDt(theResourceType, theId)));\n+\t\treturn retVal;\n+\t}\n+\n+\tprivate Collection<IResourceLookup> translateForcedIdToPids(RequestDetails theRequest, Collection<IIdType> theId) {\n+\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\n+\t\tif (theId.isEmpty()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\tList<IResourceLookup> retVal = new ArrayList<>();\n+\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\tList<Long> pids = theId\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\tif (!pids.isEmpty()) {\n+\n+\t\t\t\tCollection<Object[]> lookups = myResourceTableDao.findLookupFieldsByResourcePid(pids);\n+\t\t\t\tfor (Object[] next : lookups) {\n+\t\t\t\t\tString resourceType = (String) next[0];\n+\t\t\t\t\tLong resourcePid = (Long) next[1];\n+\t\t\t\t\tDate deletedAt = (Date) next[2];\n+\t\t\t\t\tretVal.add(new ResourceLookup(resourceType, resourcePid, deletedAt));\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theId);\n+\t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n+\t\t\tString nextResourceType = nextEntry.getKey();\n+\t\t\tCollection<String> nextIds = nextEntry.getValue();\n+\n+\t\t\tif (!myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tfor (Iterator<String> forcedIdIterator = nextIds.iterator(); forcedIdIterator.hasNext(); ) {\n+\t\t\t\t\tString nextForcedId = forcedIdIterator.next();\n+\t\t\t\t\tString nextKey = nextResourceType + \"/\" + nextForcedId;\n+\t\t\t\t\tIResourceLookup cachedLookup = myResourceLookupCache.getIfPresent(nextKey);\n+\t\t\t\t\tif (cachedLookup != null) {\n+\t\t\t\t\t\tforcedIdIterator.remove();\n+\t\t\t\t\t\tretVal.add(cachedLookup);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 336}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0MjM4MQ==", "bodyText": "This is the 2nd or 3rd time I've seen this chunk of code. Maybe a constant for this string, or rip the whole Interceptor Broadcast out into a helper function", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389842381", "createdAt": "2020-03-09T17:23:59Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -156,17 +246,136 @@ public String translatePidIdToForcedId(String theResourceType, ResourcePersisten\n \t\t}\n \t}\n \n+\tprivate ListMultimap<String, String> organizeIdsByResourceType(Collection<IIdType> theIds) {\n+\t\tListMultimap<String, String> typeToIds = MultimapBuilder.hashKeys().arrayListValues().build();\n+\t\tfor (IIdType nextId : theIds) {\n+\t\t\tif (myDaoConfig.getResourceClientIdStrategy() == DaoConfig.ClientIdStrategyEnum.ANY || !isValidPid(nextId)) {\n+\t\t\t\tif (nextId.hasResourceType()) {\n+\t\t\t\t\ttypeToIds.put(nextId.getResourceType(), nextId.getIdPart());\n+\t\t\t\t} else {\n+\t\t\t\t\ttypeToIds.put(\"\", nextId.getIdPart());\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn typeToIds;\n+\t}\n+\n+\tprivate Long resolveResourceIdentity(String theResourceType, String theId) {\n+\t\tLong retVal;\n+\t\tretVal = myForcedIdDao\n+\t\t\t.findByTypeAndForcedId(theResourceType, theId)\n+\t\t\t.orElseThrow(() -> new ResourceNotFoundException(new IdDt(theResourceType, theId)));\n+\t\treturn retVal;\n+\t}\n+\n+\tprivate Collection<IResourceLookup> translateForcedIdToPids(RequestDetails theRequest, Collection<IIdType> theId) {\n+\t\ttheId.forEach(id -> Validate.isTrue(id.hasIdPart()));\n+\n+\t\tif (theId.isEmpty()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\n+\t\tList<IResourceLookup> retVal = new ArrayList<>();\n+\n+\t\tif (myDaoConfig.getResourceClientIdStrategy() != DaoConfig.ClientIdStrategyEnum.ANY) {\n+\t\t\tList<Long> pids = theId\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> isValidPid(t))\n+\t\t\t\t.map(t -> t.getIdPartAsLong())\n+\t\t\t\t.collect(Collectors.toList());\n+\t\t\tif (!pids.isEmpty()) {\n+\n+\t\t\t\tCollection<Object[]> lookups = myResourceTableDao.findLookupFieldsByResourcePid(pids);\n+\t\t\t\tfor (Object[] next : lookups) {\n+\t\t\t\t\tString resourceType = (String) next[0];\n+\t\t\t\t\tLong resourcePid = (Long) next[1];\n+\t\t\t\t\tDate deletedAt = (Date) next[2];\n+\t\t\t\t\tretVal.add(new ResourceLookup(resourceType, resourcePid, deletedAt));\n+\t\t\t\t}\n+\n+\t\t\t}\n+\t\t}\n+\n+\t\tListMultimap<String, String> typeToIds = organizeIdsByResourceType(theId);\n+\t\tfor (Map.Entry<String, Collection<String>> nextEntry : typeToIds.asMap().entrySet()) {\n+\t\t\tString nextResourceType = nextEntry.getKey();\n+\t\t\tCollection<String> nextIds = nextEntry.getValue();\n+\n+\t\t\tif (!myDaoConfig.isDeleteEnabled()) {\n+\t\t\t\tfor (Iterator<String> forcedIdIterator = nextIds.iterator(); forcedIdIterator.hasNext(); ) {\n+\t\t\t\t\tString nextForcedId = forcedIdIterator.next();\n+\t\t\t\t\tString nextKey = nextResourceType + \"/\" + nextForcedId;\n+\t\t\t\t\tIResourceLookup cachedLookup = myResourceLookupCache.getIfPresent(nextKey);\n+\t\t\t\t\tif (cachedLookup != null) {\n+\t\t\t\t\t\tforcedIdIterator.remove();\n+\t\t\t\t\t\tretVal.add(cachedLookup);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (nextIds.size() > 0) {\n+\t\t\t\tCollection<Object[]> views;\n+\t\t\t\tif (isBlank(nextResourceType)) {\n+\n+\t\t\t\t\tStorageProcessingMessage msg = new StorageProcessingMessage()\n+\t\t\t\t\t\t.setMessage(\"This search uses unqualified resource IDs (an ID without a resource type). This is less efficient than using a qualified type.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0NzM2Mg==", "bodyText": "Out of curiosity, why create two here?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389847362", "createdAt": "2020-03-09T17:31:24Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -164,6 +156,177 @@ public void testCreateWithClientAssignedId() {\n \t}\n \n \n+\t@Test\n+\tpublic void testReferenceToForcedId() {\n+\t\tmyDaoConfig.setIndexMissingFields(DaoConfig.IndexEnabledEnum.DISABLED);\n+\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"P\");\n+\t\tpatient.setActive(true);\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tmyPatientDao.update(patient);\n+\n+\t\t/*\n+\t\t * Add a resource with a forced ID target link\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tObservation observation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\tmyCaptureQueriesListener.logAllQueriesForCurrentThread();\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\n+\t\t/*\n+\t\t * Add another\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tobservation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTg0NzYxMg==", "bodyText": "ah I now see why", "url": "https://github.com/hapifhir/hapi-fhir/pull/1754#discussion_r389847612", "createdAt": "2020-03-09T17:31:50Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -164,6 +156,177 @@ public void testCreateWithClientAssignedId() {\n \t}\n \n \n+\t@Test\n+\tpublic void testReferenceToForcedId() {\n+\t\tmyDaoConfig.setIndexMissingFields(DaoConfig.IndexEnabledEnum.DISABLED);\n+\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"P\");\n+\t\tpatient.setActive(true);\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tmyPatientDao.update(patient);\n+\n+\t\t/*\n+\t\t * Add a resource with a forced ID target link\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tObservation observation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\tmyCaptureQueriesListener.logAllQueriesForCurrentThread();\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\n+\t\t/*\n+\t\t * Add another\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tobservation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testReferenceToForcedId_DeletesDisabled() {\n+\t\tmyDaoConfig.setIndexMissingFields(DaoConfig.IndexEnabledEnum.DISABLED);\n+\t\tmyDaoConfig.setDeleteEnabled(false);\n+\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"P\");\n+\t\tpatient.setActive(true);\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tmyPatientDao.update(patient);\n+\n+\t\t/*\n+\t\t * Add a resource with a forced ID target link\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tObservation observation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\tmyCaptureQueriesListener.logAllQueriesForCurrentThread();\n+\t\t// select: lookup forced ID\n+\t\tassertEquals(1, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countDeleteQueriesForCurrentThread());\n+\t\t// insert to: HFJ_RESOURCE, HFJ_RES_VER, HFJ_RES_LINK\n+\t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n+\t\tassertEquals(0, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\n+\t\t/*\n+\t\t * Add another\n+\t\t */\n+\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tobservation = new Observation();\n+\t\tobservation.getSubject().setReference(\"Patient/P\");\n+\t\tmyObservationDao.create(observation);\n+\t\t// select: no lookups needed because of cache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1f89732250c9fdbe51b478516c241ad62169f620"}, "originalPosition": 142}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1fad7076931e4fb8df93343b351a7900c38c239", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/e1fad7076931e4fb8df93343b351a7900c38c239", "committedDate": "2020-03-10T12:45:34Z", "message": "Address review comments"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5b67554052a0de683fa67f1baf84cc90951fc1fc", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/5b67554052a0de683fa67f1baf84cc90951fc1fc", "committedDate": "2020-03-12T21:12:06Z", "message": "Compile fix"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4023, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}