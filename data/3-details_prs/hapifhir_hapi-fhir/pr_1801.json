{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDQ2Mjg4", "number": 1801, "title": "Correct two JPA processing bugs", "bodyText": "", "createdAt": "2020-04-14T22:32:23Z", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801", "merged": true, "mergeCommit": {"oid": "f95f619bdc687cc065707048833297330374ab21"}, "closed": true, "closedAt": "2020-04-15T18:22:48Z", "author": {"login": "jamesagnew"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcXgKxUAH2gAyNDAzNDQ2Mjg4OjkyNWVkMjZjZDhhZmRlNTYyMGE0NTBkMjEyYmE1MWRjNGZiMGE3Yzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcX7crmAH2gAyNDAzNDQ2Mjg4OjUwOTBjMjkwMmYwOWI3MmNhNDNmNzJjOGVkZjU4NmJjNTk5YTYzZTc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "925ed26cd8afde5620a450d212ba51dc4fb0a7c8", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/925ed26cd8afde5620a450d212ba51dc4fb0a7c8", "committedDate": "2020-04-14T09:35:04Z", "message": "Work on search params on contained"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "cb3cd693dfb901c79484d5c5fff5c4bfe1fe12b3", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/cb3cd693dfb901c79484d5c5fff5c4bfe1fe12b3", "committedDate": "2020-04-14T22:28:51Z", "message": "Add workaround for stored decimals with leading decimal point"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/2bf30a98003d7d08d933823b673fbe0382cf44e1", "committedDate": "2020-04-14T22:36:12Z", "message": "Add changelog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzQ4NTQz", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#pullrequestreview-393348543", "createdAt": "2020-04-14T22:50:47Z", "commit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "state": "APPROVED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1MDo0OFrOGFjt8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzowNTo0N1rOGFkCSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTI2NQ==", "bodyText": "What happens if the string is literal . ? that substring will fail, but is that a possible state this resource could be in?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408481265", "createdAt": "2020-04-14T22:50:48Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/parser/ParserState.java", "diffHunk": "@@ -1269,41 +1272,50 @@ public boolean isPreResource() {\n \n \tprivate class PrimitiveState extends BaseState {\n \t\tprivate final String myChildName;\n+\t\tprivate final String myTypeName;\n \t\tprivate IPrimitiveType<?> myInstance;\n \n-\t\tPrimitiveState(PreResourceState thePreResourceState, IPrimitiveType<?> theInstance, String theChildName) {\n+\t\tPrimitiveState(PreResourceState thePreResourceState, IPrimitiveType<?> theInstance, String theChildName, String theTypeName) {\n \t\t\tsuper(thePreResourceState);\n \t\t\tmyInstance = theInstance;\n \t\t\tmyChildName = theChildName;\n+\t\t\tmyTypeName = theTypeName;\n \t\t}\n \n \t\t@Override\n \t\tpublic void attributeValue(String theName, String theValue) throws DataFormatException {\n+\t\t\tString value = theValue;\n \t\t\tif (\"value\".equals(theName)) {\n-\t\t\t\tif (\"\".equals(theValue)) {\n+\t\t\t\tif (\"\".equals(value)) {\n \t\t\t\t\tParseLocation location = ParseLocation.fromElementName(myChildName);\n-\t\t\t\t\tmyErrorHandler.invalidValue(location, theValue, \"Attribute value must not be empty (\\\"\\\")\");\n+\t\t\t\t\tmyErrorHandler.invalidValue(location, value, \"Attribute value must not be empty (\\\"\\\")\");\n \t\t\t\t} else {\n+\t\t\t\t\tif (\"decimal\".equals(myTypeName)) {\n+\t\t\t\t\t\tif (value != null && value.startsWith(\".\") && NumberUtils.isDigits(value.substring(1))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjQ0Mg==", "bodyText": "could we not just private the constructor and provide a factory method", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482442", "createdAt": "2020-04-14T22:54:11Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mjc4NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482784", "createdAt": "2020-04-14T22:55:05Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {\n+\t\tsuper(theContext, theParserErrorHandler);\n+\t}\n+\n+\t@Override\n+\tpublic <T extends IBaseResource> T parseResource(Class<T> theResourceType, String theMessageString) {\n+\t\ttry {\n+\t\t\treturn super.parseResource(theResourceType, theMessageString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tif (defaultString(e.getMessage()).contains(\"Unexpected character ('.' (code 46))\")) {\n+\n+\t\t\t\t/*\n+\t\t\t\t * The following is a hacky and gross workaround until the following PR is hopefully merged:\n+\t\t\t\t * https://github.com/FasterXML/jackson-core/pull/611\n+\t\t\t\t *\n+\t\t\t\t * The issue this solves is that under Gson it was possible to store JSON containing\n+\t\t\t\t * decimal numbers with no leading integer, e.g. .123\n+\t\t\t\t *\n+\t\t\t\t * These don't parse in Jackson, meaning we can be stuck with data in the database\n+\t\t\t\t * that can't be loaded back out.\n+\t\t\t\t *\n+\t\t\t\t * Note that if we fix this in the future to rely on Jackson natively handing this\n+\t\t\t\t * nicely we may or may not be able to remove some code from\n+\t\t\t\t * ParserState.Primitive state too.\n+\t\t\t\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjkxOQ==", "bodyText": "heh nice fix", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482919", "createdAt": "2020-04-14T22:55:23Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {\n+\t\tsuper(theContext, theParserErrorHandler);\n+\t}\n+\n+\t@Override\n+\tpublic <T extends IBaseResource> T parseResource(Class<T> theResourceType, String theMessageString) {\n+\t\ttry {\n+\t\t\treturn super.parseResource(theResourceType, theMessageString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tif (defaultString(e.getMessage()).contains(\"Unexpected character ('.' (code 46))\")) {\n+\n+\t\t\t\t/*\n+\t\t\t\t * The following is a hacky and gross workaround until the following PR is hopefully merged:\n+\t\t\t\t * https://github.com/FasterXML/jackson-core/pull/611\n+\t\t\t\t *\n+\t\t\t\t * The issue this solves is that under Gson it was possible to store JSON containing\n+\t\t\t\t * decimal numbers with no leading integer, e.g. .123\n+\t\t\t\t *\n+\t\t\t\t * These don't parse in Jackson, meaning we can be stuck with data in the database\n+\t\t\t\t * that can't be loaded back out.\n+\t\t\t\t *\n+\t\t\t\t * Note that if we fix this in the future to rely on Jackson natively handing this\n+\t\t\t\t * nicely we may or may not be able to remove some code from\n+\t\t\t\t * ParserState.Primitive state too.\n+\t\t\t\t */\n+\n+\t\t\t\tGson gson = new Gson();\n+\n+\t\t\t\tJsonObject object = gson.fromJson(theMessageString, JsonObject.class);\n+\t\t\t\tString corrected = gson.toJson(object);\n+\n+\t\t\t\treturn super.parseResource(theResourceType, corrected);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MzU3MA==", "bodyText": "JSONing a SearchParameter feels pretty brittle in a test. Is there a reason why we don't just instantiate it and pass it to the DAO?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408483570", "createdAt": "2020-04-14T22:57:18Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoDstu3SearchCustomSearchParamTest.java", "diffHunk": "@@ -1054,6 +1057,55 @@ public void testSearchWithCustomParamDraft() {\n \n \t}\n \n+\t@Test\n+\tpublic void testProgramaticallyContainedByReferenceAreStillResolvable() {\n+\t\tString sp = \"{\" +\n+\t\t\t\"\\\"resourceType\\\": \\\"SearchParameter\\\",\\n\" +\n+\t\t\t\"  \\\"id\\\": \\\"medicationadministration-ingredient-medication\\\",\\n\" +\n+\t\t\t\"  \\\"url\\\": \\\"http://hapifhir.io/fhir/StructureDefinition/sp-unique\\\",\\n\" +\n+\t\t\t\"  \\\"name\\\": \\\"MEDICATIONADMINISTRATION-INGREDIENT-MEDICATION\\\",\\n\" +\n+\t\t\t\"  \\\"status\\\": \\\"active\\\",\\n\" +\n+\t\t\t\"  \\\"code\\\": \\\"medicationadministration-ingredient-medication\\\",\\n\" +\n+\t\t\t\"  \\\"base\\\": [\\n\" +\n+\t\t\t\"    \\\"MedicationAdministration\\\"\\n\" +\n+\t\t\t\"  ],\\n\" +\n+\t\t\t\"  \\\"type\\\": \\\"token\\\",\\n\" +\n+\t\t\t\"  \\\"description\\\": \\\"This search parameter is used to find a MedicationAdministration by contained medication\\\",\\n\" +\n+\t\t\t\"  \\\"expression\\\": \\\"MedicationAdministration.medication.resolve().ingredient.item.as(Reference).resolve().code\\\",\\n\" +\n+\t\t\t\"  \\\"xpathUsage\\\": \\\"normal\\\"\\n\" +\n+\t\t\t\"}\\n\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mzc1Mw==", "bodyText": "I imagine this is a typo?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408483753", "createdAt": "2020-04-14T22:57:50Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirSystemDaoR4Test.java", "diffHunk": "@@ -645,7 +645,7 @@ public void testReindexingSingleStringHashIdentityValueIsDeleted() {\n \n \t\trunInTransaction(()->{\n \t\t\tLong i = myEntityManager\n-\t\t\t\t.createQuery(\"SELECT count(s) FROM ResourceIndexedSearchParamString s WHERE s.myHashIdentity IS null\", Long.class)\n+\t\t\t\t.createQuery(\"SELECT count(s) FROM ResourceIndexedSearchParamString s WHERE s.myHashIdentity IS nullhir\", Long.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NjQ3Mg==", "bodyText": "I am relatively lost as to whats going on in this function, but i understand this is a hack that will probably eventually be removed, so I'm good with it. May be worthwhile to document somewhere that this needs reworking", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408486472", "createdAt": "2020-04-14T23:05:47Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-searchparam/src/main/java/ca/uhn/fhir/jpa/searchparam/extractor/SearchParamExtractorService.java", "diffHunk": "@@ -90,8 +115,155 @@ public void extractFromResource(RequestDetails theRequestDetails, ResourceIndexe\n \t\tpopulateResourceTable(theParams.myUriParams, theEntity);\n \t\tpopulateResourceTable(theParams.myCoordsParams, theEntity);\n \t\tpopulateResourceTable(theParams.myTokenParams, theEntity);\n+\n+\t\ttheParams.setUpdatedTime(theUpdateTime);\n+\t}\n+\n+\t/**\n+\t * This is a bit hacky, but if someone has manually populated a resource (ie. my working directly with the model\n+\t * as opposed to by parsing a serialized instance) it's possible that they have put in contained resources\n+\t * using {@link IBaseReference#setResource(IBaseResource)}, and those contained resources have not yet\n+\t * ended up in the Resource.contained array, meaning that FHIRPath expressions won't be able to find them.\n+\t *\n+\t * As a result, we to a serialize-and-parse to normalize the object. This really only affects people who\n+\t * are calling the JPA DAOs directly, but there are a few of those...\n+\t */\n+\tprivate IBaseResource normalizeResource(IBaseResource theResource) {\n+\t\tIParser parser = myContext.newJsonParser().setPrettyPrint(false);\n+\t\ttheResource = parser.parseResource(parser.encodeResourceToString(theResource));\n+\t\treturn theResource;\n+\t}\n+\n+\tprivate void extractResourceLinks(ResourceIndexedSearchParams theParams, ResourceTable theEntity, IBaseResource theResource, Date theUpdateTime, IResourceLinkResolver theResourceLinkResolver, boolean theFailOnInvalidReference, RequestDetails theRequest) {\n+\t\tString resourceName = myContext.getResourceDefinition(theResource).getName();\n+\n+\t\tISearchParamExtractor.SearchParamSet<PathAndRef> refs = mySearchParamExtractor.extractResourceLinks(theResource);\n+\t\tSearchParamExtractorService.handleWarnings(theRequest, myInterceptorBroadcaster, refs);\n+\n+\t\tMap<String, IResourceLookup> resourceIdToResolvedTarget = new HashMap<>();\n+\t\tfor (PathAndRef nextPathAndRef : refs) {\n+\t\t\tRuntimeSearchParam searchParam = mySearchParamRegistry.getActiveSearchParam(resourceName, nextPathAndRef.getSearchParamName());\n+\t\t\textractResourceLinks(theParams, theEntity, theUpdateTime, theResourceLinkResolver, searchParam, nextPathAndRef, theFailOnInvalidReference, theRequest, resourceIdToResolvedTarget);\n+\t\t}\n+\n+\t\ttheEntity.setHasLinks(theParams.myLinks.size() > 0);\n+\t}\n+\n+\tprivate void extractResourceLinks(ResourceIndexedSearchParams theParams, ResourceTable theEntity, Date theUpdateTime, IResourceLinkResolver theResourceLinkResolver, RuntimeSearchParam theRuntimeSearchParam, PathAndRef thePathAndRef, boolean theFailOnInvalidReference, RequestDetails theRequest, Map<String, IResourceLookup> theResourceIdToResolvedTarget) {\n+\t\tIBaseReference nextReference = thePathAndRef.getRef();\n+\t\tIIdType nextId = nextReference.getReferenceElement();\n+\t\tString path = thePathAndRef.getPath();\n+\n+\t\t/*\n+\t\t * This can only really happen if the DAO is being called\n+\t\t * programmatically with a Bundle (not through the FHIR REST API)\n+\t\t * but Smile does this\n+\t\t */\n+\t\tif (nextId.isEmpty() && nextReference.getResource() != null) {\n+\t\t\tnextId = nextReference.getResource().getIdElement();\n+\t\t}\n+\n+\t\ttheParams.myPopulatedResourceLinkParameters.add(thePathAndRef.getSearchParamName());\n+\n+\t\tboolean canonical = thePathAndRef.isCanonical();\n+\t\tif (LogicalReferenceHelper.isLogicalReference(myModelConfig, nextId) || canonical) {\n+\t\t\tString value = nextId.getValue();\n+\t\t\tResourceLink resourceLink = ResourceLink.forLogicalReference(thePathAndRef.getPath(), theEntity, value, theUpdateTime);\n+\t\t\tif (theParams.myLinks.add(resourceLink)) {\n+\t\t\t\tourLog.debug(\"Indexing remote resource reference URL: {}\", nextId);\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tString baseUrl = nextId.getBaseUrl();\n+\t\tString typeString = nextId.getResourceType();\n+\t\tif (isBlank(typeString)) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Does not contain resource type - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tRuntimeResourceDefinition resourceDefinition;\n+\t\ttry {\n+\t\t\tresourceDefinition = myContext.getResourceDefinition(typeString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Resource type is unknown or not supported on this server - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (theRuntimeSearchParam.hasTargets()) {\n+\t\t\tif (!theRuntimeSearchParam.getTargets().contains(typeString)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (isNotBlank(baseUrl)) {\n+\t\t\tif (!myModelConfig.getTreatBaseUrlsAsLocal().contains(baseUrl) && !myModelConfig.isAllowExternalReferences()) {\n+\t\t\t\tString msg = myContext.getLocalizer().getMessage(BaseSearchParamExtractor.class, \"externalReferenceNotAllowed\", nextId.getValue());\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tResourceLink resourceLink = ResourceLink.forAbsoluteReference(thePathAndRef.getPath(), theEntity, nextId, theUpdateTime);\n+\t\t\t\tif (theParams.myLinks.add(resourceLink)) {\n+\t\t\t\t\tourLog.debug(\"Indexing remote resource reference URL: {}\", nextId);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tClass<? extends IBaseResource> type = resourceDefinition.getImplementingClass();\n+\t\tString id = nextId.getIdPart();\n+\t\tif (StringUtils.isBlank(id)) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Does not contain resource ID - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\ttheResourceLinkResolver.validateTypeOrThrowException(type);\n+\t\tResourceLink resourceLink = createResourceLink(theEntity, theUpdateTime, theResourceLinkResolver, theRuntimeSearchParam, path, thePathAndRef, nextId, typeString, type, nextReference, theRequest, theResourceIdToResolvedTarget);\n+\t\tif (resourceLink == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttheParams.myLinks.add(resourceLink);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 222}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "36311a86d5019cb451fa90262b671c61bc60cb9b", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/36311a86d5019cb451fa90262b671c61bc60cb9b", "committedDate": "2020-04-15T00:14:16Z", "message": "Cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "797c7ffb0bc3b9d65cbed5cf6f748e643507316e", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/797c7ffb0bc3b9d65cbed5cf6f748e643507316e", "committedDate": "2020-04-15T12:30:30Z", "message": "Test fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e26884a84980fabdf9d4b58d712b4d9b9373f1cc", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/e26884a84980fabdf9d4b58d712b4d9b9373f1cc", "committedDate": "2020-04-15T16:37:53Z", "message": "Test fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5090c2902f09b72ca43f72c8edf586bc599a63e7", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/5090c2902f09b72ca43f72c8edf586bc599a63e7", "committedDate": "2020-04-15T17:22:04Z", "message": "One more test fix"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4041, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}