{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQ1NDU3NDQ1", "number": 2262, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTozOToxOFrOFK8KbA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTo0ODowMVrOFK8YJA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDE1Nzg4OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTozOToxOFrOIN2Stw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMDowMDowOVrOIOFcPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM5MTkyNw==", "bodyText": "It's probably better to avoid the version specific dialects..\nI think you can get away with just checking whether the dialect is instanceof MySQLDialect (which covers all versions of MySQL as well as MariaDB) or SQLServerDialect (which covers all versions of SQL Server).", "url": "https://github.com/hapifhir/hapi-fhir/pull/2262#discussion_r551391927", "createdAt": "2021-01-04T15:39:18Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java", "diffHunk": "@@ -115,6 +119,16 @@ private SearchQueryBuilder(FhirContext theFhirContext, ModelConfig theModelConfi\n \t\tmySqlBuilderFactory = theSqlBuilderFactory;\n \t\tmyCountQuery = theCountQuery;\n \t\tmyDialect = theDialect;\n+\t\tif (myDialect instanceof org.hibernate.dialect.MySQL57Dialect){", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2dfe86fd66df04d79186275f1ef0884d52f21b"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0MDEyNQ==", "bodyText": "Good point. Implemented suggested changes.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2262#discussion_r551640125", "createdAt": "2021-01-05T00:00:09Z", "author": {"login": "IanMMarshall"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java", "diffHunk": "@@ -115,6 +119,16 @@ private SearchQueryBuilder(FhirContext theFhirContext, ModelConfig theModelConfi\n \t\tmySqlBuilderFactory = theSqlBuilderFactory;\n \t\tmyCountQuery = theCountQuery;\n \t\tmyDialect = theDialect;\n+\t\tif (myDialect instanceof org.hibernate.dialect.MySQL57Dialect){", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM5MTkyNw=="}, "originalCommit": {"oid": "8a2dfe86fd66df04d79186275f1ef0884d52f21b"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ3MDE5MzAwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQxNTo0ODowMVrOIN2nwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQwMDowNTo1OFrOIOFijw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM5NzMxMw==", "bodyText": "I'm worried about the performance implications of adding this coalesce here when operating over large datasets... I think my recommendation would be to just add the sort without any null ordering on DBs that don't support it.\nFYI it looks like hibernate has an interesting alternate approach for accomplishing the same thing: https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/dialect/MySQLDialect.java#L467 -- But I suspect the most performance sensitive thing is to just not use null ordering.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2262#discussion_r551397313", "createdAt": "2021-01-04T15:48:01Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java", "diffHunk": "@@ -550,12 +564,87 @@ public boolean haveAtLeastOnePredicate() {\n \t\treturn myHaveAtLeastOnePredicate;\n \t}\n \n-\tpublic void addSort(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\tpublic void addSortString(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n+\t\taddSortString(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortNumeric(DbColumn theColumnValueNormalized, boolean theAscending) {\n \t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n-\t\taddSort(theColumnValueNormalized, theAscending, nullOrder);\n+\t\taddSortNumeric(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortDate(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n+\t\taddSortDate(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortString(DbColumn theTheColumnValueNormalized, boolean theTheAscending, OrderObject.NullOrder theNullOrder) {\n+\t\tif ((dialectIsMariaDb || dialectIsMySql || dialectIsMsSql)) {\n+\t\t\t// MariaDB, MySQL and MSSQL do not support \"NULLS FIRST\" and \"NULLS LAST\" syntax.\n+\t\t\t// Null values are always treated as less than non-null values.\n+\t\t\t// As such special handling is required here.\n+\t\t\tString direction = theTheAscending ? \" ASC\" : \" DESC\";\n+\t\t\tString sortColumnName = theTheColumnValueNormalized.getTable().getAlias() + \".\" + theTheColumnValueNormalized.getName();\n+\t\t\tif ((theTheAscending && theNullOrder == OrderObject.NullOrder.LAST)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a2dfe86fd66df04d79186275f1ef0884d52f21b"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY0MTc0Mw==", "bodyText": "Once again, good point. I took a look at the link you provided above and coded and tested a similar approach (i.e. embedding a case statement into the order by clause) and confirmed that this could also work. However per your concerns about performance, I have opted to comment out the special order by clause for now (keeping the tested code in place in case for future reference if needed).\nThe modified code will sort without any null ordering for MariaDB, MSSQL and MySQL.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2262#discussion_r551641743", "createdAt": "2021-01-05T00:05:58Z", "author": {"login": "IanMMarshall"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/sql/SearchQueryBuilder.java", "diffHunk": "@@ -550,12 +564,87 @@ public boolean haveAtLeastOnePredicate() {\n \t\treturn myHaveAtLeastOnePredicate;\n \t}\n \n-\tpublic void addSort(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\tpublic void addSortString(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n+\t\taddSortString(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortNumeric(DbColumn theColumnValueNormalized, boolean theAscending) {\n \t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n-\t\taddSort(theColumnValueNormalized, theAscending, nullOrder);\n+\t\taddSortNumeric(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortDate(DbColumn theColumnValueNormalized, boolean theAscending) {\n+\t\tOrderObject.NullOrder nullOrder = OrderObject.NullOrder.LAST;\n+\t\taddSortDate(theColumnValueNormalized, theAscending, nullOrder);\n+\t}\n+\n+\tpublic void addSortString(DbColumn theTheColumnValueNormalized, boolean theTheAscending, OrderObject.NullOrder theNullOrder) {\n+\t\tif ((dialectIsMariaDb || dialectIsMySql || dialectIsMsSql)) {\n+\t\t\t// MariaDB, MySQL and MSSQL do not support \"NULLS FIRST\" and \"NULLS LAST\" syntax.\n+\t\t\t// Null values are always treated as less than non-null values.\n+\t\t\t// As such special handling is required here.\n+\t\t\tString direction = theTheAscending ? \" ASC\" : \" DESC\";\n+\t\t\tString sortColumnName = theTheColumnValueNormalized.getTable().getAlias() + \".\" + theTheColumnValueNormalized.getName();\n+\t\t\tif ((theTheAscending && theNullOrder == OrderObject.NullOrder.LAST)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTM5NzMxMw=="}, "originalCommit": {"oid": "8a2dfe86fd66df04d79186275f1ef0884d52f21b"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1758, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}