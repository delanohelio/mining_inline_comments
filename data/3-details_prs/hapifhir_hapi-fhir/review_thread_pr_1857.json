{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIxMDY1ODQy", "number": 1857, "reviewThreads": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMzo1MjozNVrOD-bfSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTowNzowMlrOD-tyLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2Nzg4NjgzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/context/FhirContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMFQyMzo1MjozNVrOGYhtfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOToyNzoxNVrOGY_2Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3MTMyNw==", "bodyText": "This is a breaking API change. I think it's ok, but it should have an entry in changes.yaml (see the equivalent file in the 5_0_0 changelog directory) and a JavaDoc saying @since 5.1.0", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428371327", "createdAt": "2020-05-20T23:52:35Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/context/FhirContext.java", "diffHunk": "@@ -502,7 +547,7 @@ public RuntimeResourceDefinition getResourceDefinitionById(final String theId) {\n \t * Returns an unmodifiable set containing all resource names known to this\n \t * context\n \t */\n-\tpublic Set<String> getResourceNames() {\n+\tpublic Set<String> getResourceTypes() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 92}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2NTA0Nw==", "bodyText": "Resolved in 82b3756", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428865047", "createdAt": "2020-05-21T19:27:15Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/context/FhirContext.java", "diffHunk": "@@ -502,7 +547,7 @@ public RuntimeResourceDefinition getResourceDefinitionById(final String theId) {\n \t * Returns an unmodifiable set containing all resource names known to this\n \t * context\n \t */\n-\tpublic Set<String> getResourceNames() {\n+\tpublic Set<String> getResourceTypes() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM3MTMyNw=="}, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODAxOTYxOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/org/hl7/fhir/instance/model/api/IAnyResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxMTowMFrOGYi_Kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxMTowMFrOGYi_Kg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5MjIzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * An IBaseResource that has a FHIR version of DSTU3 or higher\n          \n          \n            \n             * An IBaseResource that is using an <code>org.hl7.fhir.*</code> structure, as opposed to the <code>ca.uhn.fhir.model.*</code> structures that are used for DSTU2 and below in HAPI FHIR.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428392234", "createdAt": "2020-05-21T01:11:00Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/org/hl7/fhir/instance/model/api/IAnyResource.java", "diffHunk": "@@ -23,6 +23,9 @@\n  * #L%\n  */\n \n+/**\n+ * An IBaseResource that has a FHIR version of DSTU3 or higher", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODAyMTg2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-client/src/main/java/ca/uhn/fhir/rest/client/impl/GenericClient.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxMjo0NFrOGYjAng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxMjo0NFrOGYjAng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5MjYwNg==", "bodyText": "Heh, this is a lot of these to review, but what a great change!", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428392606", "createdAt": "2020-05-21T01:12:44Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-client/src/main/java/ca/uhn/fhir/rest/client/impl/GenericClient.java", "diffHunk": "@@ -361,7 +361,7 @@ public IUntypedQuery search() {\n \t}\n \n \tprivate String toResourceName(Class<? extends IBaseResource> theType) {\n-\t\treturn myContext.getResourceDefinition(theType).getName();\n+\t\treturn myContext.getResourceType(theType);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODAyMzIwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/changelog/5_1_0/1853-make-interceptor-annotation-inheritable.yaml", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxMzozM1rOGYjBZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxMzozM1rOGYjBZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5MjgwNw==", "bodyText": "Lol, thanks!", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428392807", "createdAt": "2020-05-21T01:13:33Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/changelog/5_1_0/1853-make-interceptor-annotation-inheritable.yaml", "diffHunk": "@@ -1,5 +1,5 @@\n ---\n type: fix\n issue: 1853\n-issue: \"The `@Interceptor` annotation was not marked as inheritable, meaning that the order attribute was lost when\n+title: \"The `@Interceptor` annotation was not marked as inheritable, meaning that the order attribute was lost when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODAyNDY3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa_empi/empi.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxNDo0M1rOGYjCdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxNDo0M1rOGYjCdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5MzA3OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            HAPI FHIR 5.0.0 introduced preliminary support for **EMPI**.\n          \n          \n            \n            HAPI FHIR 5.1.0 introduced preliminary support for **EMPI**.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428393079", "createdAt": "2020-05-21T01:14:43Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa_empi/empi.md", "diffHunk": "@@ -0,0 +1,159 @@\n+# Enterprise Master Person Index (EMPI)\n+\n+HAPI FHIR 5.0.0 introduced preliminary support for **EMPI**.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 3}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODAyNzEyOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa_empi/empi.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxNjowNVrOGYjD2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxNjowNVrOGYjD2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5MzQzNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The [hapi-fhir-jpaserver-starter](https://github.com/hapifhir/hapi-fhir-jpaserver-starter) project contains a complete working example of the HAPI EMPI feature and documentation about how to enable and configure it. You may wish to browse its source to see how this works.\n          \n          \n            \n            The [JPA Server Starter](/hapi-fhir/docs/server_jpa/get_started.html) project contains a complete working example of the HAPI EMPI feature and documentation about how to enable and configure it. You may wish to browse its source to see how this works.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428393434", "createdAt": "2020-05-21T01:16:05Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa_empi/empi.md", "diffHunk": "@@ -0,0 +1,159 @@\n+# Enterprise Master Person Index (EMPI)\n+\n+HAPI FHIR 5.0.0 introduced preliminary support for **EMPI**.\n+\n+An EMPI allows for links to be created and maintained between different Patient and/or Practitioner resources. These links are used to indicate the fact that different Patient/Practitioner resources are known or believed to refer to the same actual (real world) person.\n+\n+These links may be created and updated using different combinations of automatic linking as well as manual linking.\n+\n+Note: The following sections describe linking between Patient and Person resources. The same information applies for linking between Practitioner and Person, but for readability it is not repeated.\n+\n+## Working Example\n+\n+The [hapi-fhir-jpaserver-starter](https://github.com/hapifhir/hapi-fhir-jpaserver-starter) project contains a complete working example of the HAPI EMPI feature and documentation about how to enable and configure it. You may wish to browse its source to see how this works.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODAzMTgyOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa_empi/empi_settings.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxOTowMlrOGYjGvQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToxOTowMlrOGYjGvQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NDE3Mw==", "bodyText": "Meta-comment:\nThis is fantastic documentation. Nice work!", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428394173", "createdAt": "2020-05-21T01:19:02Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa_empi/empi_settings.md", "diffHunk": "@@ -0,0 +1,11 @@\n+# Enabling EMPI in HAPI FHIR\n+\n+Follow these steps to enable EMPI on the server:\n+\n+The [EmpiSettings](/hapi-fhir/apidocs/hapi-fhir-server-empi/ca/uhn/fhir/empi/rules/config/EmpiSettings.html) bean contains configuration settings related to EMPI within the server. To enable Empi, the [setEnabled(boolean)](/hapi-fhir/apidocs/hapi-fhir-server-empi/ca/uhn/fhir/empi/rules/config/EmpiSettings.html#setEnabled(boolean)) property should be enabled.\n+\n+The following settings are enabled by default:\n+\n+* **Prevent EID Updates** ([JavaDoc](/hapi-fhir/apidocs/hapi-fhir-server-empi/ca/uhn/fhir/empi/rules/config/EmpiSettings.html#setPreventEidUpdates(boolean))): If this is enabled, then once an EID is set on a resource, it cannot be changed. If disabled, patients may have their EID updated.\n+\n+* **Prevent multiple EIDs**: ([JavaDoc](/hapi-fhir/apidocs/hapi-fhir-server-empi/ca/uhn/fhir/empi/rules/config/EmpiSettings.html#setPreventMultipleEids(boolean))): If this is enabled, then a resource cannot have more than one EID, and incoming resources that break this rule will be rejected.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODAzNTcwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/BaseConfig.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToyMTozNVrOGYjJHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo0NzowNFrOGZCS4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NDc4Mg==", "bodyText": "Are there really enough beans that we need this? Can we just explicitly declare them? Maybe in a dedicated context file in the EMPI project that gets imported here?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428394782", "createdAt": "2020-05-21T01:21:35Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/BaseConfig.java", "diffHunk": "@@ -102,7 +102,8 @@\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*\\\\.test\\\\..*\"),\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*Test.*\"),\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.subscription.*\"),\n-\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.searchparam.*\")\n+\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.searchparam.*\"),\n+\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.empi.*\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3MDY4Ng==", "bodyText": "This is an exclude.  Empi does not @ComponentScan.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428870686", "createdAt": "2020-05-21T19:38:36Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/BaseConfig.java", "diffHunk": "@@ -102,7 +102,8 @@\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*\\\\.test\\\\..*\"),\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*Test.*\"),\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.subscription.*\"),\n-\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.searchparam.*\")\n+\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.searchparam.*\"),\n+\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.empi.*\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NDc4Mg=="}, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNTE4Ng==", "bodyText": "Sorry, missed that fact. Resolving this.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428905186", "createdAt": "2020-05-21T20:47:04Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/BaseConfig.java", "diffHunk": "@@ -102,7 +102,8 @@\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*\\\\.test\\\\..*\"),\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \".*Test.*\"),\n \t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.subscription.*\"),\n-\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.searchparam.*\")\n+\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.searchparam.*\"),\n+\t@ComponentScan.Filter(type = FilterType.REGEX, pattern = \"ca.uhn.fhir.jpa.empi.*\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NDc4Mg=="}, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODA0NDIyOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/EmpiLinkDaoSvc.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMToyNzoxM1rOGYjOtw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMToyNjoxNFrOGZDcQw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NjIxNQ==", "bodyText": "I have never seen this query-by-Example thing before. Strangely named, but kinda neat.\nIt does kind of give me pause if I'm honest though:\n\nThis is a different query pattern to how we do everything else, and\nIt really obscures which columns are used for SELECTs which makes it hard to tell if the indexes added to the tables are appropriate, when compared to just putting standard @Query methods on the repository interface\n\nI'm not necessarily saying to do anything about this comment, but I don't know that this is a query pattern we want to propagate without considering the consequences..", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428396215", "createdAt": "2020-05-21T01:27:13Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package ca.uhn.fhir.jpa.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchResult);\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchResult);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink empiLink = new EmpiLink();\n+\t\t\tempiLink.setPersonPid(thePersonPid);\n+\t\t\tempiLink.setTargetPid(theResourcePid);\n+\t\t\treturn empiLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3MTY4OQ==", "bodyText": "It becomes particularly useful in the $empi-query-links operation where there are 4 parameters that are all nullable and you want to be able to query by all 4 of them.  Beats 16 @Query methods.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428871689", "createdAt": "2020-05-21T19:40:27Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package ca.uhn.fhir.jpa.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchResult);\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchResult);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink empiLink = new EmpiLink();\n+\t\t\tempiLink.setPersonPid(thePersonPid);\n+\t\t\tempiLink.setTargetPid(theResourcePid);\n+\t\t\treturn empiLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NjIxNQ=="}, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwNTU5OA==", "bodyText": "Fair enough. I guess I'll restate this comment to just be:\nMake sure you have appropriate indexes for any columns being searched on :)", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428905598", "createdAt": "2020-05-21T20:47:53Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package ca.uhn.fhir.jpa.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchResult);\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchResult);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink empiLink = new EmpiLink();\n+\t\t\tempiLink.setPersonPid(thePersonPid);\n+\t\t\tempiLink.setTargetPid(theResourcePid);\n+\t\t\treturn empiLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NjIxNQ=="}, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkxNTgwNA==", "bodyText": "Following the rule of thumb \"If you are reading more than 5% of the records from a table, then a full table scan will be faster than an indexed lookup.\" We'll index the two id columns but leave the two enum columns unindexed.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428915804", "createdAt": "2020-05-21T21:09:00Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package ca.uhn.fhir.jpa.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchResult);\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchResult);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink empiLink = new EmpiLink();\n+\t\t\tempiLink.setPersonPid(thePersonPid);\n+\t\t\tempiLink.setTargetPid(theResourcePid);\n+\t\t\treturn empiLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NjIxNQ=="}, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkyMzk3MQ==", "bodyText": "Resolved in 6a6111a", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428923971", "createdAt": "2020-05-21T21:26:14Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/EmpiLinkDaoSvc.java", "diffHunk": "@@ -0,0 +1,195 @@\n+package ca.uhn.fhir.jpa.dao;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.EmpiTransactionContext;\n+import ca.uhn.fhir.jpa.dao.data.IEmpiLinkDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.data.domain.Example;\n+import org.springframework.stereotype.Service;\n+import org.springframework.transaction.annotation.Propagation;\n+import org.springframework.transaction.annotation.Transactional;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.Optional;\n+\n+@Service\n+public class EmpiLinkDaoSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiLinkDao myEmpiLinkDao;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\tpublic EmpiLink createOrUpdateLinkEntity(IBaseResource thePerson, IBaseResource theTarget, EmpiMatchResultEnum theMatchResult, EmpiLinkSourceEnum theLinkSource, @Nullable EmpiTransactionContext theEmpiTransactionContext) {\n+\t\tLong personPid = myIdHelperService.getPidOrNull(thePerson);\n+\t\tLong resourcePid = myIdHelperService.getPidOrNull(theTarget);\n+\n+\t\tEmpiLink empiLink = getOrCreateEmpiLinkByPersonPidAndTargetPid(personPid, resourcePid);\n+\t\tempiLink.setLinkSource(theLinkSource);\n+\t\tempiLink.setMatchResult(theMatchResult);\n+\n+\t\tString message = String.format(\"Creating EmpiLink from %s to %s -> %s\", thePerson.getIdElement().toUnqualifiedVersionless(), theTarget.getIdElement().toUnqualifiedVersionless(), theMatchResult);\n+\t\ttheEmpiTransactionContext.addTransactionLogMessage(message);\n+\t\tourLog.debug(message);\n+\t\tsave(empiLink);\n+\t\treturn empiLink;\n+\t}\n+\n+\n+\t@Nonnull\n+\tpublic EmpiLink getOrCreateEmpiLinkByPersonPidAndTargetPid(Long thePersonPid, Long theResourcePid) {\n+\t\tOptional<EmpiLink> oExisting = getLinkByPersonPidAndTargetPid(thePersonPid, theResourcePid);\n+\t\tif (oExisting.isPresent()) {\n+\t\t\treturn oExisting.get();\n+\t\t} else {\n+\t\t\tEmpiLink empiLink = new EmpiLink();\n+\t\t\tempiLink.setPersonPid(thePersonPid);\n+\t\t\tempiLink.setTargetPid(theResourcePid);\n+\t\t\treturn empiLink;\n+\t\t}\n+\t}\n+\n+\tpublic Optional<EmpiLink> getLinkByPersonPidAndTargetPid(Long thePersonPid, Long theTargetPid) {\n+\n+\t\tif (theTargetPid == null || thePersonPid == null) {\n+\t\t\treturn Optional.empty();\n+\t\t}\n+\t\tEmpiLink link = new EmpiLink();\n+\t\tlink.setTargetPid(theTargetPid);\n+\t\tlink.setPersonPid(thePersonPid);\n+\t\tExample<EmpiLink> example = Example.of(link);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NjIxNQ=="}, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY2ODA1MzgwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/util/StringNormalizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQwMTozMzo1OVrOGYjU7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDozMDo1MVrOGZBzrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NzgwNA==", "bodyText": "If we're promoting this class to the core library, I think I'd recommend renaming the normalizeString method to normalizeStringforSearchIndexing or something along those lines, since it's a pretty arbitrary definition of normalizing (but also one that is specifically mandated by the spec)", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428397804", "createdAt": "2020-05-21T01:33:59Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/util/StringNormalizer.java", "diffHunk": "@@ -1,8 +1,8 @@\n-package ca.uhn.fhir.jpa.model.util;\n+package ca.uhn.fhir.util;\n \n /*-\n  * #%L\n- * HAPI FHIR Model\n+ * HAPI FHIR - Core Library", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5NzE5Nw==", "bodyText": "Resolved in ec2b169", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428897197", "createdAt": "2020-05-21T20:30:51Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/util/StringNormalizer.java", "diffHunk": "@@ -1,8 +1,8 @@\n-package ca.uhn.fhir.jpa.model.util;\n+package ca.uhn.fhir.util;\n \n /*-\n  * #%L\n- * HAPI FHIR Model\n+ * HAPI FHIR - Core Library", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM5NzgwNA=="}, "originalCommit": {"oid": "ec16add802fbf306dfed85616fe59b6d225ff92c"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDcyODk0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODoxODo1MVrOGY9rlA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo0MjoyOVrOGZCJlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyOTU4OA==", "bodyText": "I'm curious about these optimisticlock annotations.. I don't see any @Version column so I don't think they do anything. Is this deliberate?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428829588", "createdAt": "2020-05-21T18:18:51Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package ca.uhn.fhir.jpa.entity;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTable;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.apache.commons.lang3.builder.ToStringStyle;\n+import org.hibernate.annotations.OptimisticLock;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.ForeignKey;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.UniqueConstraint;\n+import java.util.Date;\n+\n+@Entity\n+@Table(name = \"MPI_LINK\", uniqueConstraints = {\n+\t@UniqueConstraint(name = \"IDX_EMPI_PERSON_TGT\", columnNames = {\"PERSON_PID\", \"TARGET_PID\"}),\n+})\n+public class EmpiLink {\n+\tprivate static final int MATCH_RESULT_LENGTH = 16;\n+\tprivate static final int LINK_SOURCE_LENGTH = 16;\n+\n+\t@SequenceGenerator(name = \"SEQ_EMPI_LINK_ID\", sequenceName = \"SEQ_EMPI_LINK_ID\")\n+\t@GeneratedValue(strategy = GenerationType.AUTO, generator = \"SEQ_EMPI_LINK_ID\")\n+\t@Id\n+\t@Column(name = \"PID\")\n+\tprivate Long myId;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"PERSON_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_PERSON\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myPerson;\n+\n+\t@Column(name = \"PERSON_PID\", nullable=false)\n+\tprivate Long myPersonPid;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"TARGET_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_TARGET\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myTarget;\n+\n+\t@Column(name = \"TARGET_PID\", updatable=false, nullable=false)\n+\tprivate Long myTargetPid;\n+\n+\t@Column(name = \"MATCH_RESULT\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiMatchResultEnum myMatchResult;\n+\n+\t@Column(name = \"LINK_SOURCE\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiLinkSourceEnum myLinkSource;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"CREATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)\n+\tprivate Date myCreated;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"UPDATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3MjQ1Nw==", "bodyText": "I just copy/pasted those from elsewhere.  Gary asked me what it did and I had no idea.  Gary wondered if there was a way to automatically maintain these columns.  If that's what @Version does then we should do this properly", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428872457", "createdAt": "2020-05-21T19:41:54Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package ca.uhn.fhir.jpa.entity;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTable;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.apache.commons.lang3.builder.ToStringStyle;\n+import org.hibernate.annotations.OptimisticLock;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.ForeignKey;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.UniqueConstraint;\n+import java.util.Date;\n+\n+@Entity\n+@Table(name = \"MPI_LINK\", uniqueConstraints = {\n+\t@UniqueConstraint(name = \"IDX_EMPI_PERSON_TGT\", columnNames = {\"PERSON_PID\", \"TARGET_PID\"}),\n+})\n+public class EmpiLink {\n+\tprivate static final int MATCH_RESULT_LENGTH = 16;\n+\tprivate static final int LINK_SOURCE_LENGTH = 16;\n+\n+\t@SequenceGenerator(name = \"SEQ_EMPI_LINK_ID\", sequenceName = \"SEQ_EMPI_LINK_ID\")\n+\t@GeneratedValue(strategy = GenerationType.AUTO, generator = \"SEQ_EMPI_LINK_ID\")\n+\t@Id\n+\t@Column(name = \"PID\")\n+\tprivate Long myId;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"PERSON_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_PERSON\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myPerson;\n+\n+\t@Column(name = \"PERSON_PID\", nullable=false)\n+\tprivate Long myPersonPid;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"TARGET_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_TARGET\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myTarget;\n+\n+\t@Column(name = \"TARGET_PID\", updatable=false, nullable=false)\n+\tprivate Long myTargetPid;\n+\n+\t@Column(name = \"MATCH_RESULT\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiMatchResultEnum myMatchResult;\n+\n+\t@Column(name = \"LINK_SOURCE\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiLinkSourceEnum myLinkSource;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"CREATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)\n+\tprivate Date myCreated;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"UPDATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyOTU4OA=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwMDM0Nw==", "bodyText": "We took another look and decided to just delete these annotations", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428900347", "createdAt": "2020-05-21T20:37:25Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package ca.uhn.fhir.jpa.entity;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTable;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.apache.commons.lang3.builder.ToStringStyle;\n+import org.hibernate.annotations.OptimisticLock;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.ForeignKey;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.UniqueConstraint;\n+import java.util.Date;\n+\n+@Entity\n+@Table(name = \"MPI_LINK\", uniqueConstraints = {\n+\t@UniqueConstraint(name = \"IDX_EMPI_PERSON_TGT\", columnNames = {\"PERSON_PID\", \"TARGET_PID\"}),\n+})\n+public class EmpiLink {\n+\tprivate static final int MATCH_RESULT_LENGTH = 16;\n+\tprivate static final int LINK_SOURCE_LENGTH = 16;\n+\n+\t@SequenceGenerator(name = \"SEQ_EMPI_LINK_ID\", sequenceName = \"SEQ_EMPI_LINK_ID\")\n+\t@GeneratedValue(strategy = GenerationType.AUTO, generator = \"SEQ_EMPI_LINK_ID\")\n+\t@Id\n+\t@Column(name = \"PID\")\n+\tprivate Long myId;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"PERSON_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_PERSON\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myPerson;\n+\n+\t@Column(name = \"PERSON_PID\", nullable=false)\n+\tprivate Long myPersonPid;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"TARGET_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_TARGET\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myTarget;\n+\n+\t@Column(name = \"TARGET_PID\", updatable=false, nullable=false)\n+\tprivate Long myTargetPid;\n+\n+\t@Column(name = \"MATCH_RESULT\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiMatchResultEnum myMatchResult;\n+\n+\t@Column(name = \"LINK_SOURCE\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiLinkSourceEnum myLinkSource;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"CREATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)\n+\tprivate Date myCreated;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"UPDATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyOTU4OA=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwMDM3Ng==", "bodyText": "Removed in 8ce96f7", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428900376", "createdAt": "2020-05-21T20:37:28Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package ca.uhn.fhir.jpa.entity;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTable;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.apache.commons.lang3.builder.ToStringStyle;\n+import org.hibernate.annotations.OptimisticLock;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.ForeignKey;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.UniqueConstraint;\n+import java.util.Date;\n+\n+@Entity\n+@Table(name = \"MPI_LINK\", uniqueConstraints = {\n+\t@UniqueConstraint(name = \"IDX_EMPI_PERSON_TGT\", columnNames = {\"PERSON_PID\", \"TARGET_PID\"}),\n+})\n+public class EmpiLink {\n+\tprivate static final int MATCH_RESULT_LENGTH = 16;\n+\tprivate static final int LINK_SOURCE_LENGTH = 16;\n+\n+\t@SequenceGenerator(name = \"SEQ_EMPI_LINK_ID\", sequenceName = \"SEQ_EMPI_LINK_ID\")\n+\t@GeneratedValue(strategy = GenerationType.AUTO, generator = \"SEQ_EMPI_LINK_ID\")\n+\t@Id\n+\t@Column(name = \"PID\")\n+\tprivate Long myId;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"PERSON_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_PERSON\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myPerson;\n+\n+\t@Column(name = \"PERSON_PID\", nullable=false)\n+\tprivate Long myPersonPid;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"TARGET_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_TARGET\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myTarget;\n+\n+\t@Column(name = \"TARGET_PID\", updatable=false, nullable=false)\n+\tprivate Long myTargetPid;\n+\n+\t@Column(name = \"MATCH_RESULT\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiMatchResultEnum myMatchResult;\n+\n+\t@Column(name = \"LINK_SOURCE\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiLinkSourceEnum myLinkSource;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"CREATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)\n+\tprivate Date myCreated;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"UPDATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyOTU4OA=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwMjgwNw==", "bodyText": "@Version creates an optimistic lock column, which is useful if you think that both:\n\nthere is a chance for two threads to update a row with different values at the same time\nthis happening would be a bad thing\n\n...or....\n\nyou want to make sure that two threads are never touching the same row at the same time\n\nFor system processing like this I'd say it's less common for that to be the case. Not unheard of at all though. We have an @Version on BulkExportJobEntity for the second reason for example", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428902807", "createdAt": "2020-05-21T20:42:29Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/entity/EmpiLink.java", "diffHunk": "@@ -0,0 +1,209 @@\n+package ca.uhn.fhir.jpa.entity;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.EmpiLinkSourceEnum;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTable;\n+import org.apache.commons.lang3.builder.ToStringBuilder;\n+import org.apache.commons.lang3.builder.ToStringStyle;\n+import org.hibernate.annotations.OptimisticLock;\n+\n+import javax.persistence.Column;\n+import javax.persistence.Entity;\n+import javax.persistence.EnumType;\n+import javax.persistence.Enumerated;\n+import javax.persistence.FetchType;\n+import javax.persistence.ForeignKey;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.JoinColumn;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+import javax.persistence.Table;\n+import javax.persistence.Temporal;\n+import javax.persistence.TemporalType;\n+import javax.persistence.UniqueConstraint;\n+import java.util.Date;\n+\n+@Entity\n+@Table(name = \"MPI_LINK\", uniqueConstraints = {\n+\t@UniqueConstraint(name = \"IDX_EMPI_PERSON_TGT\", columnNames = {\"PERSON_PID\", \"TARGET_PID\"}),\n+})\n+public class EmpiLink {\n+\tprivate static final int MATCH_RESULT_LENGTH = 16;\n+\tprivate static final int LINK_SOURCE_LENGTH = 16;\n+\n+\t@SequenceGenerator(name = \"SEQ_EMPI_LINK_ID\", sequenceName = \"SEQ_EMPI_LINK_ID\")\n+\t@GeneratedValue(strategy = GenerationType.AUTO, generator = \"SEQ_EMPI_LINK_ID\")\n+\t@Id\n+\t@Column(name = \"PID\")\n+\tprivate Long myId;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"PERSON_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_PERSON\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myPerson;\n+\n+\t@Column(name = \"PERSON_PID\", nullable=false)\n+\tprivate Long myPersonPid;\n+\n+\t@ManyToOne(optional = false, fetch = FetchType.LAZY, cascade = {})\n+\t@JoinColumn(name = \"TARGET_PID\", referencedColumnName = \"RES_ID\", foreignKey = @ForeignKey(name = \"FK_EMPI_LINK_TARGET\"), insertable=false, updatable=false, nullable=false)\n+\tprivate ResourceTable myTarget;\n+\n+\t@Column(name = \"TARGET_PID\", updatable=false, nullable=false)\n+\tprivate Long myTargetPid;\n+\n+\t@Column(name = \"MATCH_RESULT\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiMatchResultEnum myMatchResult;\n+\n+\t@Column(name = \"LINK_SOURCE\", nullable = false)\n+\t@Enumerated(EnumType.ORDINAL)\n+\t@OptimisticLock(excluded = true)\n+\tprivate EmpiLinkSourceEnum myLinkSource;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"CREATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)\n+\tprivate Date myCreated;\n+\n+\t@Temporal(TemporalType.TIMESTAMP)\n+\t@Column(name = \"UPDATED\", nullable = false)\n+\t@OptimisticLock(excluded = true)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODgyOTU4OA=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDg1NTQ1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiCandidateSearchSvc.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxODo1Nzo0OVrOGY-8MQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDo0MzoyN1rOGZCLgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MDIyNQ==", "bodyText": "Instead of String.join here you should use ParameterUtil.escapeAndJoinOrList - That method also escapes reserved characters in the strings such as | and ,\n..unless you are manually creating strings for token SPs such as system|value in which case that method will hurt you since you don't want the | escaped. If that's the case, at least make sure you're using ParameterUtil.escape on the left and right sides of that statement.. otherwise someone will eventually try to match on a value with a comma and have a horribly hard to diagnose bug", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428850225", "createdAt": "2020-05-21T18:57:49Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiCandidateSearchSvc.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.IEmpiSettings;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.rules.json.EmpiFilterSearchParamJson;\n+import ca.uhn.fhir.empi.rules.json.EmpiResourceSearchParamJson;\n+import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n+import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import ca.uhn.fhir.rest.api.server.IBundleProvider;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.empi.api.EmpiConstants.ALL_RESOURCE_SEARCH_PARAM_TYPE;\n+\n+@Service\n+public class EmpiCandidateSearchSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiSettings myEmpiConfig;\n+\t@Autowired\n+\tprivate EmpiSearchParamSvc myEmpiSearchParamSvc;\n+\t@Autowired\n+\tprivate DaoRegistry myDaoRegistry;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\t/**\n+\t * Given a target resource, search for all resources that are considered an EMPI match based on defined EMPI rules.\n+\t *\n+\t *\n+\t * @param theResourceType\n+\t * @param theResource the target {@link IBaseResource} we are attempting to match.\n+\t *\n+\t * @return the list of candidate {@link IBaseResource} which could be matches to theResource\n+\t */\n+\tpublic Collection<IAnyResource> findCandidates(String theResourceType, IAnyResource theResource) {\n+\t\tMap<Long, IAnyResource> matchedPidsToResources = new HashMap<>();\n+\n+\t\tList<EmpiFilterSearchParamJson> filterSearchParams = myEmpiConfig.getEmpiRules().getFilterSearchParams();\n+\n+\t\tList<String> filterCriteria = buildFilterQuery(filterSearchParams, theResourceType);\n+\n+\t\tfor (EmpiResourceSearchParamJson resourceSearchParam : myEmpiConfig.getEmpiRules().getResourceSearchParams()) {\n+\n+\t\t\tif (!isSearchParamForResource(theResourceType, resourceSearchParam)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t//to compare it to all known PERSON objects, using the overlapping search parameters that they have.\n+\t\t\tList<String> valuesFromResourceForSearchParam = myEmpiSearchParamSvc.getValueFromResourceForSearchParam(theResource, resourceSearchParam);\n+\t\t\tif (valuesFromResourceForSearchParam.isEmpty()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tsearchForIdsAndAddToMap(theResourceType, matchedPidsToResources, filterCriteria, resourceSearchParam, valuesFromResourceForSearchParam);\n+\t\t}\n+\t\t//Obviously we don't want to consider the freshly added resource as a potential candidate.\n+\t\t//Sometimes, we are running this function on a resource that has not yet been persisted,\n+\t\t//so it may not have an ID yet, precluding the need to remove it.\n+\t\tif (theResource.getIdElement().getIdPart() != null) {\n+\t\t\tmatchedPidsToResources.remove(myIdHelperService.getPidOrNull(theResource));\n+\t\t}\n+\t\treturn matchedPidsToResources.values();\n+\t}\n+\n+\tprivate boolean isSearchParamForResource(String theResourceType, EmpiResourceSearchParamJson resourceSearchParam) {\n+\t\tString resourceType = resourceSearchParam.getResourceType();\n+\t\treturn resourceType.equals(theResourceType) || resourceType.equalsIgnoreCase(ALL_RESOURCE_SEARCH_PARAM_TYPE);\n+\t}\n+\n+\t/*\n+\t * Helper method which performs too much work currently.\n+\t * 1. Build a full query string for the given filter and resource criteria.\n+\t * 2. Convert that URL to a SearchParameterMap.\n+\t * 3. Execute a Synchronous search on the DAO using that parameter map.\n+\t * 4. Store all results in `theMatchedPidsToResources`\n+\t */\n+\t@SuppressWarnings(\"rawtypes\")\n+\tprivate void searchForIdsAndAddToMap(String theResourceType, Map<Long, IAnyResource> theMatchedPidsToResources, List<String> theFilterCriteria, EmpiResourceSearchParamJson resourceSearchParam, List<String> theValuesFromResourceForSearchParam) {\n+\t\t//1.\n+\t\tString resourceCriteria = buildResourceQueryString(theResourceType, theFilterCriteria, resourceSearchParam, theValuesFromResourceForSearchParam);\n+\t\tourLog.debug(\"Searching for {} candidates with {}\", theResourceType, resourceCriteria);\n+\n+\t\t//2.\n+\t\tSearchParameterMap searchParameterMap = myEmpiSearchParamSvc.mapFromCriteria(theResourceType, resourceCriteria);\n+\n+\t\tsearchParameterMap.setLoadSynchronous(true);\n+\n+\t\t//TODO EMPI this will blow up under large scale i think.\n+\t\t//3.\n+\t\tIFhirResourceDao<?> resourceDao = myDaoRegistry.getResourceDao(theResourceType);\n+\t\tIBundleProvider search = resourceDao.search(searchParameterMap);\n+\t\tList<IBaseResource> resources = search.getResources(0, search.size());\n+\n+\t\tint initialSize = theMatchedPidsToResources.size();\n+\n+\t\t//4.\n+\t\tresources.forEach(resource -> theMatchedPidsToResources.put(myIdHelperService.getPidOrNull(resource), (IAnyResource) resource));\n+\n+\t\tint newSize = theMatchedPidsToResources.size();\n+\n+\t\tif (ourLog.isDebugEnabled()) {\n+\t\t\tourLog.debug(\"Candidate search added {} {}s\", newSize - initialSize, theResourceType);\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Given a list of criteria upon which to block, a resource search parameter, and a list of values for that given search parameter,\n+\t * build a query url. e.g.\n+\t *\n+\t * Patient?active=true&name.given=Gary,Grant\n+\t */\n+\t@Nonnull\n+\tprivate String buildResourceQueryString(String theResourceType, List<String> theFilterCriteria, EmpiResourceSearchParamJson resourceSearchParam, List<String> theValuesFromResourceForSearchParam) {\n+\t\tList<String> criteria = new ArrayList<>(theFilterCriteria);\n+\t\tcriteria.add(buildResourceMatchQuery(resourceSearchParam.getSearchParam(), theValuesFromResourceForSearchParam));\n+\n+\t\treturn theResourceType + \"?\" +  String.join(\"&\", criteria);\n+\t}\n+\n+\tprivate String buildResourceMatchQuery(String theSearchParamName, List<String> theResourceValues) {\n+\t\treturn theSearchParamName + \"=\" + String.join(\",\", theResourceValues);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkwMzI5OQ==", "bodyText": "Good catch!  Fixed", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428903299", "createdAt": "2020-05-21T20:43:27Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiCandidateSearchSvc.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.empi.api.IEmpiSettings;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.rules.json.EmpiFilterSearchParamJson;\n+import ca.uhn.fhir.empi.rules.json.EmpiResourceSearchParamJson;\n+import ca.uhn.fhir.jpa.api.dao.DaoRegistry;\n+import ca.uhn.fhir.jpa.api.dao.IFhirResourceDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import ca.uhn.fhir.rest.api.server.IBundleProvider;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import static ca.uhn.fhir.empi.api.EmpiConstants.ALL_RESOURCE_SEARCH_PARAM_TYPE;\n+\n+@Service\n+public class EmpiCandidateSearchSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate IEmpiSettings myEmpiConfig;\n+\t@Autowired\n+\tprivate EmpiSearchParamSvc myEmpiSearchParamSvc;\n+\t@Autowired\n+\tprivate DaoRegistry myDaoRegistry;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\n+\t/**\n+\t * Given a target resource, search for all resources that are considered an EMPI match based on defined EMPI rules.\n+\t *\n+\t *\n+\t * @param theResourceType\n+\t * @param theResource the target {@link IBaseResource} we are attempting to match.\n+\t *\n+\t * @return the list of candidate {@link IBaseResource} which could be matches to theResource\n+\t */\n+\tpublic Collection<IAnyResource> findCandidates(String theResourceType, IAnyResource theResource) {\n+\t\tMap<Long, IAnyResource> matchedPidsToResources = new HashMap<>();\n+\n+\t\tList<EmpiFilterSearchParamJson> filterSearchParams = myEmpiConfig.getEmpiRules().getFilterSearchParams();\n+\n+\t\tList<String> filterCriteria = buildFilterQuery(filterSearchParams, theResourceType);\n+\n+\t\tfor (EmpiResourceSearchParamJson resourceSearchParam : myEmpiConfig.getEmpiRules().getResourceSearchParams()) {\n+\n+\t\t\tif (!isSearchParamForResource(theResourceType, resourceSearchParam)) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\t//to compare it to all known PERSON objects, using the overlapping search parameters that they have.\n+\t\t\tList<String> valuesFromResourceForSearchParam = myEmpiSearchParamSvc.getValueFromResourceForSearchParam(theResource, resourceSearchParam);\n+\t\t\tif (valuesFromResourceForSearchParam.isEmpty()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tsearchForIdsAndAddToMap(theResourceType, matchedPidsToResources, filterCriteria, resourceSearchParam, valuesFromResourceForSearchParam);\n+\t\t}\n+\t\t//Obviously we don't want to consider the freshly added resource as a potential candidate.\n+\t\t//Sometimes, we are running this function on a resource that has not yet been persisted,\n+\t\t//so it may not have an ID yet, precluding the need to remove it.\n+\t\tif (theResource.getIdElement().getIdPart() != null) {\n+\t\t\tmatchedPidsToResources.remove(myIdHelperService.getPidOrNull(theResource));\n+\t\t}\n+\t\treturn matchedPidsToResources.values();\n+\t}\n+\n+\tprivate boolean isSearchParamForResource(String theResourceType, EmpiResourceSearchParamJson resourceSearchParam) {\n+\t\tString resourceType = resourceSearchParam.getResourceType();\n+\t\treturn resourceType.equals(theResourceType) || resourceType.equalsIgnoreCase(ALL_RESOURCE_SEARCH_PARAM_TYPE);\n+\t}\n+\n+\t/*\n+\t * Helper method which performs too much work currently.\n+\t * 1. Build a full query string for the given filter and resource criteria.\n+\t * 2. Convert that URL to a SearchParameterMap.\n+\t * 3. Execute a Synchronous search on the DAO using that parameter map.\n+\t * 4. Store all results in `theMatchedPidsToResources`\n+\t */\n+\t@SuppressWarnings(\"rawtypes\")\n+\tprivate void searchForIdsAndAddToMap(String theResourceType, Map<Long, IAnyResource> theMatchedPidsToResources, List<String> theFilterCriteria, EmpiResourceSearchParamJson resourceSearchParam, List<String> theValuesFromResourceForSearchParam) {\n+\t\t//1.\n+\t\tString resourceCriteria = buildResourceQueryString(theResourceType, theFilterCriteria, resourceSearchParam, theValuesFromResourceForSearchParam);\n+\t\tourLog.debug(\"Searching for {} candidates with {}\", theResourceType, resourceCriteria);\n+\n+\t\t//2.\n+\t\tSearchParameterMap searchParameterMap = myEmpiSearchParamSvc.mapFromCriteria(theResourceType, resourceCriteria);\n+\n+\t\tsearchParameterMap.setLoadSynchronous(true);\n+\n+\t\t//TODO EMPI this will blow up under large scale i think.\n+\t\t//3.\n+\t\tIFhirResourceDao<?> resourceDao = myDaoRegistry.getResourceDao(theResourceType);\n+\t\tIBundleProvider search = resourceDao.search(searchParameterMap);\n+\t\tList<IBaseResource> resources = search.getResources(0, search.size());\n+\n+\t\tint initialSize = theMatchedPidsToResources.size();\n+\n+\t\t//4.\n+\t\tresources.forEach(resource -> theMatchedPidsToResources.put(myIdHelperService.getPidOrNull(resource), (IAnyResource) resource));\n+\n+\t\tint newSize = theMatchedPidsToResources.size();\n+\n+\t\tif (ourLog.isDebugEnabled()) {\n+\t\t\tourLog.debug(\"Candidate search added {} {}s\", newSize - initialSize, theResourceType);\n+\t\t}\n+\t}\n+\n+\t/*\n+\t * Given a list of criteria upon which to block, a resource search parameter, and a list of values for that given search parameter,\n+\t * build a query url. e.g.\n+\t *\n+\t * Patient?active=true&name.given=Gary,Grant\n+\t */\n+\t@Nonnull\n+\tprivate String buildResourceQueryString(String theResourceType, List<String> theFilterCriteria, EmpiResourceSearchParamJson resourceSearchParam, List<String> theValuesFromResourceForSearchParam) {\n+\t\tList<String> criteria = new ArrayList<>(theFilterCriteria);\n+\t\tcriteria.add(buildResourceMatchQuery(resourceSearchParam.getSearchParam(), theValuesFromResourceForSearchParam));\n+\n+\t\treturn theResourceType + \"?\" +  String.join(\"&\", criteria);\n+\t}\n+\n+\tprivate String buildResourceMatchQuery(String theSearchParamName, List<String> theResourceValues) {\n+\t\treturn theSearchParamName + \"=\" + String.join(\",\", theResourceValues);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MDIyNQ=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 157}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDg2NzU3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiPersonFindingSvc.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTowMToyN1rOGY_D1w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQyMDozNDoyNFrOGZB6Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjE4Mw==", "bodyText": "Ooh two spaces after the period. So uhhhhhhhhhhhhhhhhhhhhhhhhhhh the AP style guide doesn't recommend two spaces after a period so clearly like we can't have that geez", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428852183", "createdAt": "2020-05-21T19:01:27Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiPersonFindingSvc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n+import ca.uhn.fhir.empi.api.MatchedTarget;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.CanonicalEID;\n+import ca.uhn.fhir.empi.util.EIDHelper;\n+import ca.uhn.fhir.jpa.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class EmpiPersonFindingSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\t@Autowired\n+\tIdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\t@Autowired\n+\tprivate IEmpiMatchFinderSvc myEmpiMatchFinderSvc;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\t/**\n+\t * Given an incoming IBaseResource, limited to Patient/Practitioner, return a list of {@link MatchedPersonCandidate}\n+\t * indicating possible candidates for a matching Person. Uses several separate methods for finding candidates:\n+\t * <p>\n+\t * 0. First, check the incoming Resource for an EID. If it is present, and we can find a Person with this EID, it automatically matches.\n+\t * 1. First, check link table for any entries where this baseresource is the target of a person. If found, return.\n+\t * 2. If none are found, attempt to find Person Resources which link to this theResource.\n+\t * 3. If none are found, attempt to find Persons similar to our incoming resource based on the EMPI rules and similarity metrics.\n+\t * 4. If none are found, attempt to find Persons that are linked to Patients/Practitioners that are similar to our incoming resource based on the EMPI rules and\n+\t * similarity metrics.\n+\t *\n+\t * @param theResource the {@link IBaseResource} we are attempting to find matching candidate Persons for.\n+\t * @return A list of {@link MatchedPersonCandidate} indicating all potential Person matches.\n+\t */\n+\tpublic List<MatchedPersonCandidate> findPersonCandidates(IAnyResource theResource) {\n+\t\tList<MatchedPersonCandidate> matchedPersonCandidates = attemptToFindPersonCandidateFromIncomingEID(theResource);\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromEmpiLinkTable(theResource);\n+\t\t}\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\t//OK, so we have not found any links in the EmpiLink table with us as a target. Next, let's find possible Patient/Practitioner\n+\t\t\t//matches by following EMPI rules.\n+\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromSimilarTargetResource(theResource);\n+\t\t}\n+\t\treturn matchedPersonCandidates;\n+\t}\n+\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromIncomingEID(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theBaseResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tfor (CanonicalEID eid : eidFromResource) {\n+\t\t\t\tIBaseResource foundPerson = myEmpiResourceDaoSvc.searchPersonByEid(eid.getValue());\n+\t\t\t\tif (foundPerson != null) {\n+\t\t\t\t\tLong pidOrNull = myIdHelperService.getPidOrNull(foundPerson);\n+\t\t\t\t\tMatchedPersonCandidate mpc = new MatchedPersonCandidate(new ResourcePersistentId(pidOrNull), EmpiMatchResultEnum.MATCH);\n+\t\t\t\t\tourLog.debug(\"Matched {} by EID {}\", foundPerson.getIdElement(), eid);\n+\t\t\t\t\tretval.add(mpc);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * Attempt to find a currently matching Person, based on the presence of an {@link EmpiLink} entity.\n+\t *\n+\t * @param theBaseResource the {@link IAnyResource} that we want to find candidate Persons for.\n+\t * @return an Optional list of {@link MatchedPersonCandidate} indicating matches.\n+\t */\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromEmpiLinkTable(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tLong targetPid = myIdHelperService.getPidOrNull(theBaseResource);\n+\t\tif (targetPid != null) {\n+\t\t\tOptional<EmpiLink> oLink = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(targetPid);\n+\t\t\tif (oLink.isPresent()) {\n+\t\t\t\tResourcePersistentId personPid = new ResourcePersistentId(oLink.get().getPersonPid());\n+\t\t\t\tourLog.debug(\"Resource previously linked.  Using existing link.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg2OTYwMw==", "bodyText": "I learned to type in 1979 on a manual typewriter and had two spaces DRILLED into my soul.  I have tried.  I cannot change this.  It is too deeply engrained.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428869603", "createdAt": "2020-05-21T19:36:13Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiPersonFindingSvc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n+import ca.uhn.fhir.empi.api.MatchedTarget;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.CanonicalEID;\n+import ca.uhn.fhir.empi.util.EIDHelper;\n+import ca.uhn.fhir.jpa.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class EmpiPersonFindingSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\t@Autowired\n+\tIdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\t@Autowired\n+\tprivate IEmpiMatchFinderSvc myEmpiMatchFinderSvc;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\t/**\n+\t * Given an incoming IBaseResource, limited to Patient/Practitioner, return a list of {@link MatchedPersonCandidate}\n+\t * indicating possible candidates for a matching Person. Uses several separate methods for finding candidates:\n+\t * <p>\n+\t * 0. First, check the incoming Resource for an EID. If it is present, and we can find a Person with this EID, it automatically matches.\n+\t * 1. First, check link table for any entries where this baseresource is the target of a person. If found, return.\n+\t * 2. If none are found, attempt to find Person Resources which link to this theResource.\n+\t * 3. If none are found, attempt to find Persons similar to our incoming resource based on the EMPI rules and similarity metrics.\n+\t * 4. If none are found, attempt to find Persons that are linked to Patients/Practitioners that are similar to our incoming resource based on the EMPI rules and\n+\t * similarity metrics.\n+\t *\n+\t * @param theResource the {@link IBaseResource} we are attempting to find matching candidate Persons for.\n+\t * @return A list of {@link MatchedPersonCandidate} indicating all potential Person matches.\n+\t */\n+\tpublic List<MatchedPersonCandidate> findPersonCandidates(IAnyResource theResource) {\n+\t\tList<MatchedPersonCandidate> matchedPersonCandidates = attemptToFindPersonCandidateFromIncomingEID(theResource);\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromEmpiLinkTable(theResource);\n+\t\t}\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\t//OK, so we have not found any links in the EmpiLink table with us as a target. Next, let's find possible Patient/Practitioner\n+\t\t\t//matches by following EMPI rules.\n+\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromSimilarTargetResource(theResource);\n+\t\t}\n+\t\treturn matchedPersonCandidates;\n+\t}\n+\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromIncomingEID(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theBaseResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tfor (CanonicalEID eid : eidFromResource) {\n+\t\t\t\tIBaseResource foundPerson = myEmpiResourceDaoSvc.searchPersonByEid(eid.getValue());\n+\t\t\t\tif (foundPerson != null) {\n+\t\t\t\t\tLong pidOrNull = myIdHelperService.getPidOrNull(foundPerson);\n+\t\t\t\t\tMatchedPersonCandidate mpc = new MatchedPersonCandidate(new ResourcePersistentId(pidOrNull), EmpiMatchResultEnum.MATCH);\n+\t\t\t\t\tourLog.debug(\"Matched {} by EID {}\", foundPerson.getIdElement(), eid);\n+\t\t\t\t\tretval.add(mpc);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * Attempt to find a currently matching Person, based on the presence of an {@link EmpiLink} entity.\n+\t *\n+\t * @param theBaseResource the {@link IAnyResource} that we want to find candidate Persons for.\n+\t * @return an Optional list of {@link MatchedPersonCandidate} indicating matches.\n+\t */\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromEmpiLinkTable(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tLong targetPid = myIdHelperService.getPidOrNull(theBaseResource);\n+\t\tif (targetPid != null) {\n+\t\t\tOptional<EmpiLink> oLink = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(targetPid);\n+\t\t\tif (oLink.isPresent()) {\n+\t\t\t\tResourcePersistentId personPid = new ResourcePersistentId(oLink.get().getPersonPid());\n+\t\t\t\tourLog.debug(\"Resource previously linked.  Using existing link.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjE4Mw=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3OTA4Mw==", "bodyText": "", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428879083", "createdAt": "2020-05-21T19:54:52Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiPersonFindingSvc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n+import ca.uhn.fhir.empi.api.MatchedTarget;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.CanonicalEID;\n+import ca.uhn.fhir.empi.util.EIDHelper;\n+import ca.uhn.fhir.jpa.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class EmpiPersonFindingSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\t@Autowired\n+\tIdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\t@Autowired\n+\tprivate IEmpiMatchFinderSvc myEmpiMatchFinderSvc;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\t/**\n+\t * Given an incoming IBaseResource, limited to Patient/Practitioner, return a list of {@link MatchedPersonCandidate}\n+\t * indicating possible candidates for a matching Person. Uses several separate methods for finding candidates:\n+\t * <p>\n+\t * 0. First, check the incoming Resource for an EID. If it is present, and we can find a Person with this EID, it automatically matches.\n+\t * 1. First, check link table for any entries where this baseresource is the target of a person. If found, return.\n+\t * 2. If none are found, attempt to find Person Resources which link to this theResource.\n+\t * 3. If none are found, attempt to find Persons similar to our incoming resource based on the EMPI rules and similarity metrics.\n+\t * 4. If none are found, attempt to find Persons that are linked to Patients/Practitioners that are similar to our incoming resource based on the EMPI rules and\n+\t * similarity metrics.\n+\t *\n+\t * @param theResource the {@link IBaseResource} we are attempting to find matching candidate Persons for.\n+\t * @return A list of {@link MatchedPersonCandidate} indicating all potential Person matches.\n+\t */\n+\tpublic List<MatchedPersonCandidate> findPersonCandidates(IAnyResource theResource) {\n+\t\tList<MatchedPersonCandidate> matchedPersonCandidates = attemptToFindPersonCandidateFromIncomingEID(theResource);\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromEmpiLinkTable(theResource);\n+\t\t}\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\t//OK, so we have not found any links in the EmpiLink table with us as a target. Next, let's find possible Patient/Practitioner\n+\t\t\t//matches by following EMPI rules.\n+\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromSimilarTargetResource(theResource);\n+\t\t}\n+\t\treturn matchedPersonCandidates;\n+\t}\n+\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromIncomingEID(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theBaseResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tfor (CanonicalEID eid : eidFromResource) {\n+\t\t\t\tIBaseResource foundPerson = myEmpiResourceDaoSvc.searchPersonByEid(eid.getValue());\n+\t\t\t\tif (foundPerson != null) {\n+\t\t\t\t\tLong pidOrNull = myIdHelperService.getPidOrNull(foundPerson);\n+\t\t\t\t\tMatchedPersonCandidate mpc = new MatchedPersonCandidate(new ResourcePersistentId(pidOrNull), EmpiMatchResultEnum.MATCH);\n+\t\t\t\t\tourLog.debug(\"Matched {} by EID {}\", foundPerson.getIdElement(), eid);\n+\t\t\t\t\tretval.add(mpc);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * Attempt to find a currently matching Person, based on the presence of an {@link EmpiLink} entity.\n+\t *\n+\t * @param theBaseResource the {@link IAnyResource} that we want to find candidate Persons for.\n+\t * @return an Optional list of {@link MatchedPersonCandidate} indicating matches.\n+\t */\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromEmpiLinkTable(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tLong targetPid = myIdHelperService.getPidOrNull(theBaseResource);\n+\t\tif (targetPid != null) {\n+\t\t\tOptional<EmpiLink> oLink = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(targetPid);\n+\t\t\tif (oLink.isPresent()) {\n+\t\t\t\tResourcePersistentId personPid = new ResourcePersistentId(oLink.get().getPersonPid());\n+\t\t\t\tourLog.debug(\"Resource previously linked.  Using existing link.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjE4Mw=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg3OTM2OA==", "bodyText": "resolved in 78babeb", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428879368", "createdAt": "2020-05-21T19:55:24Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiPersonFindingSvc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n+import ca.uhn.fhir.empi.api.MatchedTarget;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.CanonicalEID;\n+import ca.uhn.fhir.empi.util.EIDHelper;\n+import ca.uhn.fhir.jpa.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class EmpiPersonFindingSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\t@Autowired\n+\tIdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\t@Autowired\n+\tprivate IEmpiMatchFinderSvc myEmpiMatchFinderSvc;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\t/**\n+\t * Given an incoming IBaseResource, limited to Patient/Practitioner, return a list of {@link MatchedPersonCandidate}\n+\t * indicating possible candidates for a matching Person. Uses several separate methods for finding candidates:\n+\t * <p>\n+\t * 0. First, check the incoming Resource for an EID. If it is present, and we can find a Person with this EID, it automatically matches.\n+\t * 1. First, check link table for any entries where this baseresource is the target of a person. If found, return.\n+\t * 2. If none are found, attempt to find Person Resources which link to this theResource.\n+\t * 3. If none are found, attempt to find Persons similar to our incoming resource based on the EMPI rules and similarity metrics.\n+\t * 4. If none are found, attempt to find Persons that are linked to Patients/Practitioners that are similar to our incoming resource based on the EMPI rules and\n+\t * similarity metrics.\n+\t *\n+\t * @param theResource the {@link IBaseResource} we are attempting to find matching candidate Persons for.\n+\t * @return A list of {@link MatchedPersonCandidate} indicating all potential Person matches.\n+\t */\n+\tpublic List<MatchedPersonCandidate> findPersonCandidates(IAnyResource theResource) {\n+\t\tList<MatchedPersonCandidate> matchedPersonCandidates = attemptToFindPersonCandidateFromIncomingEID(theResource);\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromEmpiLinkTable(theResource);\n+\t\t}\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\t//OK, so we have not found any links in the EmpiLink table with us as a target. Next, let's find possible Patient/Practitioner\n+\t\t\t//matches by following EMPI rules.\n+\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromSimilarTargetResource(theResource);\n+\t\t}\n+\t\treturn matchedPersonCandidates;\n+\t}\n+\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromIncomingEID(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theBaseResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tfor (CanonicalEID eid : eidFromResource) {\n+\t\t\t\tIBaseResource foundPerson = myEmpiResourceDaoSvc.searchPersonByEid(eid.getValue());\n+\t\t\t\tif (foundPerson != null) {\n+\t\t\t\t\tLong pidOrNull = myIdHelperService.getPidOrNull(foundPerson);\n+\t\t\t\t\tMatchedPersonCandidate mpc = new MatchedPersonCandidate(new ResourcePersistentId(pidOrNull), EmpiMatchResultEnum.MATCH);\n+\t\t\t\t\tourLog.debug(\"Matched {} by EID {}\", foundPerson.getIdElement(), eid);\n+\t\t\t\t\tretval.add(mpc);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * Attempt to find a currently matching Person, based on the presence of an {@link EmpiLink} entity.\n+\t *\n+\t * @param theBaseResource the {@link IAnyResource} that we want to find candidate Persons for.\n+\t * @return an Optional list of {@link MatchedPersonCandidate} indicating matches.\n+\t */\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromEmpiLinkTable(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tLong targetPid = myIdHelperService.getPidOrNull(theBaseResource);\n+\t\tif (targetPid != null) {\n+\t\t\tOptional<EmpiLink> oLink = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(targetPid);\n+\t\t\tif (oLink.isPresent()) {\n+\t\t\t\tResourcePersistentId personPid = new ResourcePersistentId(oLink.get().getPersonPid());\n+\t\t\t\tourLog.debug(\"Resource previously linked.  Using existing link.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjE4Mw=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg5ODg2Ng==", "bodyText": "hahahaha", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428898866", "createdAt": "2020-05-21T20:34:24Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-empi/src/main/java/ca/uhn/fhir/jpa/empi/svc/EmpiPersonFindingSvc.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package ca.uhn.fhir.jpa.empi.svc;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Enterprise Master Patient Index\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.empi.api.IEmpiMatchFinderSvc;\n+import ca.uhn.fhir.empi.api.MatchedTarget;\n+import ca.uhn.fhir.empi.log.Logs;\n+import ca.uhn.fhir.empi.model.CanonicalEID;\n+import ca.uhn.fhir.empi.util.EIDHelper;\n+import ca.uhn.fhir.jpa.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Service;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class EmpiPersonFindingSvc {\n+\tprivate static final Logger ourLog = Logs.getEmpiTroubleshootingLog();\n+\n+\t@Autowired\n+\tprivate FhirContext myFhirContext;\n+\t@Autowired\n+\tIdHelperService myIdHelperService;\n+\t@Autowired\n+\tprivate EmpiLinkDaoSvc myEmpiLinkDaoSvc;\n+\t@Autowired\n+\tprivate EmpiResourceDaoSvc myEmpiResourceDaoSvc;\n+\t@Autowired\n+\tprivate IEmpiMatchFinderSvc myEmpiMatchFinderSvc;\n+\t@Autowired\n+\tprivate EIDHelper myEIDHelper;\n+\n+\t/**\n+\t * Given an incoming IBaseResource, limited to Patient/Practitioner, return a list of {@link MatchedPersonCandidate}\n+\t * indicating possible candidates for a matching Person. Uses several separate methods for finding candidates:\n+\t * <p>\n+\t * 0. First, check the incoming Resource for an EID. If it is present, and we can find a Person with this EID, it automatically matches.\n+\t * 1. First, check link table for any entries where this baseresource is the target of a person. If found, return.\n+\t * 2. If none are found, attempt to find Person Resources which link to this theResource.\n+\t * 3. If none are found, attempt to find Persons similar to our incoming resource based on the EMPI rules and similarity metrics.\n+\t * 4. If none are found, attempt to find Persons that are linked to Patients/Practitioners that are similar to our incoming resource based on the EMPI rules and\n+\t * similarity metrics.\n+\t *\n+\t * @param theResource the {@link IBaseResource} we are attempting to find matching candidate Persons for.\n+\t * @return A list of {@link MatchedPersonCandidate} indicating all potential Person matches.\n+\t */\n+\tpublic List<MatchedPersonCandidate> findPersonCandidates(IAnyResource theResource) {\n+\t\tList<MatchedPersonCandidate> matchedPersonCandidates = attemptToFindPersonCandidateFromIncomingEID(theResource);\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromEmpiLinkTable(theResource);\n+\t\t}\n+\t\tif (matchedPersonCandidates.isEmpty()) {\n+\t\t\t//OK, so we have not found any links in the EmpiLink table with us as a target. Next, let's find possible Patient/Practitioner\n+\t\t\t//matches by following EMPI rules.\n+\n+\t\t\tmatchedPersonCandidates = attemptToFindPersonCandidateFromSimilarTargetResource(theResource);\n+\t\t}\n+\t\treturn matchedPersonCandidates;\n+\t}\n+\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromIncomingEID(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tList<CanonicalEID> eidFromResource = myEIDHelper.getExternalEid(theBaseResource);\n+\t\tif (!eidFromResource.isEmpty()) {\n+\t\t\tfor (CanonicalEID eid : eidFromResource) {\n+\t\t\t\tIBaseResource foundPerson = myEmpiResourceDaoSvc.searchPersonByEid(eid.getValue());\n+\t\t\t\tif (foundPerson != null) {\n+\t\t\t\t\tLong pidOrNull = myIdHelperService.getPidOrNull(foundPerson);\n+\t\t\t\t\tMatchedPersonCandidate mpc = new MatchedPersonCandidate(new ResourcePersistentId(pidOrNull), EmpiMatchResultEnum.MATCH);\n+\t\t\t\t\tourLog.debug(\"Matched {} by EID {}\", foundPerson.getIdElement(), eid);\n+\t\t\t\t\tretval.add(mpc);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn retval;\n+\t}\n+\n+\t/**\n+\t * Attempt to find a currently matching Person, based on the presence of an {@link EmpiLink} entity.\n+\t *\n+\t * @param theBaseResource the {@link IAnyResource} that we want to find candidate Persons for.\n+\t * @return an Optional list of {@link MatchedPersonCandidate} indicating matches.\n+\t */\n+\tprivate List<MatchedPersonCandidate> attemptToFindPersonCandidateFromEmpiLinkTable(IAnyResource theBaseResource) {\n+\t\tList<MatchedPersonCandidate> retval = new ArrayList<>();\n+\n+\t\tLong targetPid = myIdHelperService.getPidOrNull(theBaseResource);\n+\t\tif (targetPid != null) {\n+\t\t\tOptional<EmpiLink> oLink = myEmpiLinkDaoSvc.getMatchedLinkForTargetPid(targetPid);\n+\t\t\tif (oLink.isPresent()) {\n+\t\t\t\tResourcePersistentId personPid = new ResourcePersistentId(oLink.get().getPersonPid());\n+\t\t\t\tourLog.debug(\"Resource previously linked.  Using existing link.\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1MjE4Mw=="}, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 122}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY3MDg4NDMwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/BasePersonMatcher.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTowNzowMlrOGY_PBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yMVQxOTowNzowMlrOGY_PBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODg1NTA0NA==", "bodyText": "These typesafematchers are really cool!", "url": "https://github.com/hapifhir/hapi-fhir/pull/1857#discussion_r428855044", "createdAt": "2020-05-21T19:07:02Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-empi/src/test/java/ca/uhn/fhir/jpa/empi/matcher/BasePersonMatcher.java", "diffHunk": "@@ -0,0 +1,79 @@\n+package ca.uhn.fhir.jpa.empi.matcher;\n+\n+import ca.uhn.fhir.empi.api.EmpiMatchResultEnum;\n+import ca.uhn.fhir.jpa.dao.EmpiLinkDaoSvc;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.EmpiLink;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nullable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public abstract class BasePersonMatcher extends TypeSafeMatcher<IAnyResource> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ca80c73e3b39000324ff3cba701cd9108cdd280c"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1983, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}