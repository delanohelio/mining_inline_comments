{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDg4MDUyMzU3", "number": 2086, "reviewThreads": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozODo0MVrOEv4Utw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDowOTo0M1rOE8ohoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjQxMzM1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-api/src/main/java/ca/uhn/fhir/jpa/api/config/DaoConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjozODo0MVrOHlHRsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzoyNzoyN1rOHn1BGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3ODU3Nw==", "bodyText": "Find a way to ensure you set this to true when you cut the November release!  (Do you have a release checklist somewhere?)", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508678577", "createdAt": "2020-10-20T16:38:41Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-api/src/main/java/ca/uhn/fhir/jpa/api/config/DaoConfig.java", "diffHunk": "@@ -195,6 +193,32 @@\n \t * @since 5.0.0\n \t */\n \tprivate boolean myDeleteEnabled = true;\n+\t/**\n+\t * @since 5.1.0\n+\t */\n+\tprivate boolean myLastNEnabled = false;\n+\t/**\n+\t * @since 5.2.0\n+\t */\n+\tprivate boolean myUseLegacySearchBuilder = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNTE0Ng==", "bodyText": "I'll figure something out...", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r511525146", "createdAt": "2020-10-24T23:27:27Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-api/src/main/java/ca/uhn/fhir/jpa/api/config/DaoConfig.java", "diffHunk": "@@ -195,6 +193,32 @@\n \t * @since 5.0.0\n \t */\n \tprivate boolean myDeleteEnabled = true;\n+\t/**\n+\t * @since 5.1.0\n+\t */\n+\tprivate boolean myLastNEnabled = false;\n+\t/**\n+\t * @since 5.2.0\n+\t */\n+\tprivate boolean myUseLegacySearchBuilder = false;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY3ODU3Nw=="}, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 30}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjQzNzgzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/HibernateDialectProvider.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjo0NDo0NlrOHlHg-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjo0NDo0NlrOHlHg-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4MjQ5MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tValidate.notNull(dialect, \"Unable to create class: %s\", dialectClass);\n          \n          \n            \n            \t\t\tValidate.notNull(dialect, \"Unable to create instance of class: %s\", dialectClass);", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508682490", "createdAt": "2020-10-20T16:44:46Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/HibernateDialectProvider.java", "diffHunk": "@@ -0,0 +1,46 @@\n+package ca.uhn.fhir.jpa.config;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.util.ReflectionUtil;\n+import org.apache.commons.lang3.Validate;\n+import org.hibernate.dialect.Dialect;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n+\n+public class HibernateDialectProvider {\n+\n+\t@Autowired\n+\tprivate LocalContainerEntityManagerFactoryBean myEntityManagerFactory;\n+\tprivate Dialect myDialect;\n+\n+\tpublic Dialect getDialect() {\n+\t\tDialect dialect = myDialect;\n+\t\tif (dialect == null) {\n+\t\t\tString dialectClass = (String) myEntityManagerFactory.getJpaPropertyMap().get(\"hibernate.dialect\");\n+\t\t\tdialect = ReflectionUtil.newInstanceOrReturnNull(dialectClass, Dialect.class);\n+\t\t\tValidate.notNull(dialect, \"Unable to create class: %s\", dialectClass);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjQ0NzYzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderReference.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjo0Njo1MlrOHlHm0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzoyOTowOVrOHn1BhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4Mzk4Nw==", "bodyText": "I gather this means you're confident duplicates were filtered out elsewhere...?", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508683987", "createdAt": "2020-10-20T16:46:52Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderReference.java", "diffHunk": "@@ -682,7 +683,7 @@ void searchForIdsWithAndOr(String theResourceName, String theParamName, List<Lis\n \t\t\t\t\t\t}\n \n \t\t\t\t\t} else {\n-\t\t\t\t\t\tString validNames = new TreeSet<>(mySearchParamRegistry.getActiveSearchParams(theResourceName).keySet()).toString();\n+\t\t\t\t\t\tCollection<String> validNames = mySearchParamRegistry.getValidSearchParameterNamesIncludingMeta(theResourceName);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNTI1Mw==", "bodyText": "Yeah, in that method. The treeset there wasn't actually needed for guaranteeing uniqueness (the values are already coming from keys in a map), it was just a lazy way to get a sorted collection. The new method accomplishes the same thing", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r511525253", "createdAt": "2020-10-24T23:29:09Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderReference.java", "diffHunk": "@@ -682,7 +683,7 @@ void searchForIdsWithAndOr(String theResourceName, String theParamName, List<Lis\n \t\t\t\t\t\t}\n \n \t\t\t\t\t} else {\n-\t\t\t\t\t\tString validNames = new TreeSet<>(mySearchParamRegistry.getActiveSearchParams(theResourceName).keySet()).toString();\n+\t\t\t\t\t\tCollection<String> validNames = mySearchParamRegistry.getValidSearchParameterNamesIncludingMeta(theResourceName);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY4Mzk4Nw=="}, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 31}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjQ5NDM5OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/predicate/BasePredicateBuilder.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjo1ODoyOFrOHlIEJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxNjo1ODoyOFrOHlIEJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODY5MTQ5NA==", "bodyText": "At first I got excited when I saw:\n> find dao/predicate -name '*.java' | xargs wc -l\n    5024 total\n> find search/builder/predicate -name '*.java' | xargs wc -l\n    2860 total\n\nBut then I saw it looks like you moved a bunch of methods back into QueryStack...", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508691494", "createdAt": "2020-10-20T16:58:28Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/predicate/BasePredicateBuilder.java", "diffHunk": "@@ -0,0 +1,93 @@\n+package ca.uhn.fhir.jpa.search.builder.predicate;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NjkzNDM2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/predicate/BaseSearchParamPredicateBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo0NzozOFrOHlMWLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzo0MDo1MVrOHn1E-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTY0Ng==", "bodyText": "One downside to using sqlbuilder are all these string constants, but I don't think adding constants would help much really...", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508761646", "createdAt": "2020-10-20T18:47:38Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/predicate/BaseSearchParamPredicateBuilder.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package ca.uhn.fhir.jpa.search.builder.predicate;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.model.entity.BaseResourceIndexedSearchParam;\n+import ca.uhn.fhir.jpa.search.builder.sql.SearchQueryBuilder;\n+import com.healthmarketscience.sqlbuilder.BinaryCondition;\n+import com.healthmarketscience.sqlbuilder.ComboCondition;\n+import com.healthmarketscience.sqlbuilder.Condition;\n+import com.healthmarketscience.sqlbuilder.dbspec.basic.DbColumn;\n+import com.healthmarketscience.sqlbuilder.dbspec.basic.DbTable;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static ca.uhn.fhir.jpa.search.builder.QueryStack.toAndPredicate;\n+\n+public abstract class BaseSearchParamPredicateBuilder extends BaseJoiningPredicateBuilder {\n+\n+\tprivate final DbColumn myColumnMissing;\n+\tprivate final DbColumn myColumnResType;\n+\tprivate final DbColumn myColumnParamName;\n+\tprivate final DbColumn myColumnResId;\n+\tprivate final DbColumn myColumnHashIdentity;\n+\n+\tpublic BaseSearchParamPredicateBuilder(SearchQueryBuilder theSearchSqlBuilder, DbTable theTable) {\n+\t\tsuper(theSearchSqlBuilder, theTable);\n+\n+\t\tmyColumnResId = getTable().addColumn(\"RES_ID\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNjEzNg==", "bodyText": "Yeah, I had the same thought...", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r511526136", "createdAt": "2020-10-24T23:40:51Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/predicate/BaseSearchParamPredicateBuilder.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package ca.uhn.fhir.jpa.search.builder.predicate;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.model.entity.BaseResourceIndexedSearchParam;\n+import ca.uhn.fhir.jpa.search.builder.sql.SearchQueryBuilder;\n+import com.healthmarketscience.sqlbuilder.BinaryCondition;\n+import com.healthmarketscience.sqlbuilder.ComboCondition;\n+import com.healthmarketscience.sqlbuilder.Condition;\n+import com.healthmarketscience.sqlbuilder.dbspec.basic.DbColumn;\n+import com.healthmarketscience.sqlbuilder.dbspec.basic.DbTable;\n+\n+import javax.annotation.Nonnull;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static ca.uhn.fhir.jpa.search.builder.QueryStack.toAndPredicate;\n+\n+public abstract class BaseSearchParamPredicateBuilder extends BaseJoiningPredicateBuilder {\n+\n+\tprivate final DbColumn myColumnMissing;\n+\tprivate final DbColumn myColumnResType;\n+\tprivate final DbColumn myColumnParamName;\n+\tprivate final DbColumn myColumnResId;\n+\tprivate final DbColumn myColumnHashIdentity;\n+\n+\tpublic BaseSearchParamPredicateBuilder(SearchQueryBuilder theSearchSqlBuilder, DbTable theTable) {\n+\t\tsuper(theSearchSqlBuilder, theTable);\n+\n+\t\tmyColumnResId = getTable().addColumn(\"RES_ID\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2MTY0Ng=="}, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njk2NTg4OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/QueryStack.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1NjowOVrOHlMpIA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxODo1NjowOVrOHlMpIA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc2NjQ5Ng==", "bodyText": "Nitpick: Is there some way we can avoid having all these different concerns in a single 1000+ line class?", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508766496", "createdAt": "2020-10-20T18:56:09Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/QueryStack.java", "diffHunk": "@@ -0,0 +1,1197 @@\n+package ca.uhn.fhir.jpa.search.builder;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.context.RuntimeSearchParam;\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.api.config.DaoConfig;\n+import ca.uhn.fhir.jpa.dao.BaseHapiFhirResourceDao;\n+import ca.uhn.fhir.jpa.dao.LegacySearchBuilder;\n+import ca.uhn.fhir.jpa.dao.predicate.PredicateBuilderToken;\n+import ca.uhn.fhir.jpa.dao.predicate.SearchFilterParser;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.jpa.model.entity.ModelConfig;\n+import ca.uhn.fhir.jpa.model.entity.TagTypeEnum;\n+import ca.uhn.fhir.jpa.search.builder.predicate.BaseJoiningPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.CompositeUniqueSearchParameterPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.CoordsPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.DatePredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.ForcedIdPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.NumberPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.QuantityPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.ResourceIdPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.ResourceLinkPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.ResourceTablePredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.SearchParamPresentPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.sql.SearchQueryBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.SourcePredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.StringPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.TagPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.TokenPredicateBuilder;\n+import ca.uhn.fhir.jpa.search.builder.predicate.UriPredicateBuilder;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import ca.uhn.fhir.jpa.searchparam.extractor.BaseSearchParamExtractor;\n+import ca.uhn.fhir.jpa.searchparam.registry.ISearchParamRegistry;\n+import ca.uhn.fhir.jpa.searchparam.util.SourceParam;\n+import ca.uhn.fhir.model.api.IQueryParameterAnd;\n+import ca.uhn.fhir.model.api.IQueryParameterOr;\n+import ca.uhn.fhir.model.api.IQueryParameterType;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.rest.api.Constants;\n+import ca.uhn.fhir.rest.api.QualifiedParamList;\n+import ca.uhn.fhir.rest.api.RestSearchParameterTypeEnum;\n+import ca.uhn.fhir.rest.api.server.RequestDetails;\n+import ca.uhn.fhir.rest.param.CompositeParam;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.HasParam;\n+import ca.uhn.fhir.rest.param.NumberParam;\n+import ca.uhn.fhir.rest.param.ParamPrefixEnum;\n+import ca.uhn.fhir.rest.param.ParameterUtil;\n+import ca.uhn.fhir.rest.param.QuantityParam;\n+import ca.uhn.fhir.rest.param.ReferenceParam;\n+import ca.uhn.fhir.rest.param.StringParam;\n+import ca.uhn.fhir.rest.param.TokenParam;\n+import ca.uhn.fhir.rest.param.TokenParamModifier;\n+import ca.uhn.fhir.rest.param.UriParam;\n+import ca.uhn.fhir.rest.server.exceptions.InternalErrorException;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import ca.uhn.fhir.rest.server.exceptions.MethodNotAllowedException;\n+import ca.uhn.fhir.rest.server.exceptions.PreconditionFailedException;\n+import com.google.common.collect.Lists;\n+import com.healthmarketscience.sqlbuilder.BinaryCondition;\n+import com.healthmarketscience.sqlbuilder.ComboCondition;\n+import com.healthmarketscience.sqlbuilder.Condition;\n+import com.healthmarketscience.sqlbuilder.Expression;\n+import com.healthmarketscience.sqlbuilder.InCondition;\n+import com.healthmarketscience.sqlbuilder.OrderObject;\n+import com.healthmarketscience.sqlbuilder.SelectQuery;\n+import com.healthmarketscience.sqlbuilder.Subquery;\n+import com.healthmarketscience.sqlbuilder.dbspec.basic.DbColumn;\n+import org.apache.commons.lang3.builder.EqualsBuilder;\n+import org.apache.commons.lang3.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.math.BigDecimal;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.EnumSet;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+\n+public class QueryStack {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(QueryStack.class);\n+\tprivate final ModelConfig myModelConfig;\n+\tprivate final FhirContext myFhirContext;\n+\tprivate final SearchQueryBuilder mySqlBuilder;\n+\tprivate final SearchParameterMap mySearchParameters;\n+\tprivate final ISearchParamRegistry mySearchParamRegistry;\n+\tprivate final PartitionSettings myPartitionSettings;\n+\tprivate final DaoConfig myDaoConfig;\n+\tprivate final EnumSet<PredicateBuilderTypeEnum> myReusePredicateBuilderTypes;\n+\tprivate Map<PredicateBuilderCacheKey, BaseJoiningPredicateBuilder> myJoinMap;\n+\n+\t/**\n+\t * Constructor\n+\t */\n+\tpublic QueryStack(SearchParameterMap theSearchParameters, DaoConfig theDaoConfig, ModelConfig theModelConfig, FhirContext theFhirContext, SearchQueryBuilder theSqlBuilder, ISearchParamRegistry theSearchParamRegistry, PartitionSettings thePartitionSettings) {\n+\t\tthis(theSearchParameters, theDaoConfig, theModelConfig, theFhirContext, theSqlBuilder, theSearchParamRegistry, thePartitionSettings, EnumSet.of(PredicateBuilderTypeEnum.DATE));\n+\t}\n+\n+\t/**\n+\t * Constructor\n+\t */\n+\tprivate QueryStack(SearchParameterMap theSearchParameters, DaoConfig theDaoConfig, ModelConfig theModelConfig, FhirContext theFhirContext, SearchQueryBuilder theSqlBuilder, ISearchParamRegistry theSearchParamRegistry, PartitionSettings thePartitionSettings, EnumSet<PredicateBuilderTypeEnum> theReusePredicateBuilderTypes) {\n+\t\tmyPartitionSettings = thePartitionSettings;\n+\t\tassert theSearchParameters != null;\n+\t\tassert theDaoConfig != null;\n+\t\tassert theModelConfig != null;\n+\t\tassert theFhirContext != null;\n+\t\tassert theSqlBuilder != null;\n+\n+\t\tmySearchParameters = theSearchParameters;\n+\t\tmyDaoConfig = theDaoConfig;\n+\t\tmyModelConfig = theModelConfig;\n+\t\tmyFhirContext = theFhirContext;\n+\t\tmySqlBuilder = theSqlBuilder;\n+\t\tmySearchParamRegistry = theSearchParamRegistry;\n+\t\tmyReusePredicateBuilderTypes = theReusePredicateBuilderTypes;\n+\t}\n+\n+\tpublic void addSortOnDate(String theResourceName, String theParamName, boolean theAscending) {\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tDatePredicateBuilder sortPredicateBuilder = mySqlBuilder.addDatePredicateBuilder(firstPredicateBuilder.getResourceIdColumn());\n+\n+\t\tCondition hashIdentityPredicate = sortPredicateBuilder.createHashIdentityPredicate(theResourceName, theParamName);\n+\t\tmySqlBuilder.addPredicate(hashIdentityPredicate);\n+\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnValueLow(), theAscending);\n+\t}\n+\n+\tpublic void addSortOnLastUpdated(boolean theAscending) {\n+\t\tResourceTablePredicateBuilder resourceTablePredicateBuilder;\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tif (firstPredicateBuilder instanceof ResourceTablePredicateBuilder) {\n+\t\t\tresourceTablePredicateBuilder = (ResourceTablePredicateBuilder) firstPredicateBuilder;\n+\t\t} else {\n+\t\t\tresourceTablePredicateBuilder = mySqlBuilder.addResourceTablePredicateBuilder(firstPredicateBuilder.getResourceIdColumn());\n+\t\t}\n+\t\tmySqlBuilder.addSort(resourceTablePredicateBuilder.getColumnLastUpdated(), theAscending);\n+\t}\n+\n+\n+\tpublic void addSortOnNumber(String theResourceName, String theParamName, boolean theAscending) {\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tNumberPredicateBuilder sortPredicateBuilder = mySqlBuilder.addNumberPredicateBuilder(firstPredicateBuilder.getResourceIdColumn());\n+\n+\t\tCondition hashIdentityPredicate = sortPredicateBuilder.createHashIdentityPredicate(theResourceName, theParamName);\n+\t\tmySqlBuilder.addPredicate(hashIdentityPredicate);\n+\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnValue(), theAscending);\n+\t}\n+\n+\tpublic void addSortOnQuantity(String theResourceName, String theParamName, boolean theAscending) {\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tQuantityPredicateBuilder sortPredicateBuilder = mySqlBuilder.addQuantityPredicateBuilder(firstPredicateBuilder.getResourceIdColumn());\n+\n+\t\tCondition hashIdentityPredicate = sortPredicateBuilder.createHashIdentityPredicate(theResourceName, theParamName);\n+\t\tmySqlBuilder.addPredicate(hashIdentityPredicate);\n+\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnValue(), theAscending);\n+\t}\n+\n+\tpublic void addSortOnResourceId(boolean theAscending) {\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tForcedIdPredicateBuilder sortPredicateBuilder = mySqlBuilder.addForcedIdPredicateBuilder(firstPredicateBuilder.getResourceIdColumn());\n+\t\tif (!theAscending) {\n+\t\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnForcedId(), false, OrderObject.NullOrder.FIRST);\n+\t\t} else {\n+\t\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnForcedId(), true);\n+\t\t}\n+\t\tmySqlBuilder.addSort(firstPredicateBuilder.getResourceIdColumn(), theAscending);\n+\n+\t}\n+\n+\tpublic void addSortOnResourceLink(String theResourceName, String theParamName, boolean theAscending) {\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tResourceLinkPredicateBuilder sortPredicateBuilder = mySqlBuilder.addReferencePredicateBuilder(this, firstPredicateBuilder.getResourceIdColumn());\n+\n+\t\tCondition pathPredicate = sortPredicateBuilder.createPredicateSourcePaths(theResourceName, theParamName);\n+\t\tmySqlBuilder.addPredicate(pathPredicate);\n+\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnTargetResourceId(), theAscending);\n+\t}\n+\n+\n+\tpublic void addSortOnString(String theResourceName, String theParamName, boolean theAscending) {\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tStringPredicateBuilder sortPredicateBuilder = mySqlBuilder.addStringPredicateBuilder(firstPredicateBuilder.getResourceIdColumn());\n+\n+\t\tCondition hashIdentityPredicate = sortPredicateBuilder.createHashIdentityPredicate(theResourceName, theParamName);\n+\t\tmySqlBuilder.addPredicate(hashIdentityPredicate);\n+\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnValueNormalized(), theAscending);\n+\t}\n+\n+\tpublic void addSortOnToken(String theResourceName, String theParamName, boolean theAscending) {\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tTokenPredicateBuilder sortPredicateBuilder = mySqlBuilder.addTokenPredicateBuilder(firstPredicateBuilder.getResourceIdColumn());\n+\n+\t\tCondition hashIdentityPredicate = sortPredicateBuilder.createHashIdentityPredicate(theResourceName, theParamName);\n+\t\tmySqlBuilder.addPredicate(hashIdentityPredicate);\n+\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnSystem(), theAscending);\n+\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnValue(), theAscending);\n+\t}\n+\n+\tpublic void addSortOnUri(String theResourceName, String theParamName, boolean theAscending) {\n+\t\tBaseJoiningPredicateBuilder firstPredicateBuilder = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\tUriPredicateBuilder sortPredicateBuilder = mySqlBuilder.addUriPredicateBuilder(firstPredicateBuilder.getResourceIdColumn());\n+\n+\t\tCondition hashIdentityPredicate = sortPredicateBuilder.createHashIdentityPredicate(theResourceName, theParamName);\n+\t\tmySqlBuilder.addPredicate(hashIdentityPredicate);\n+\t\tmySqlBuilder.addSort(sortPredicateBuilder.getColumnValue(), theAscending);\n+\t}\n+\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate <T extends BaseJoiningPredicateBuilder> PredicateBuilderCacheLookupResult<T> createOrReusePredicateBuilder(PredicateBuilderTypeEnum theType, DbColumn theSourceJoinColumn, String theParamName, Supplier<T> theFactoryMethod) {\n+\t\tboolean cacheHit = false;\n+\t\tBaseJoiningPredicateBuilder retVal;\n+\t\tif (myReusePredicateBuilderTypes.contains(theType)) {\n+\t\t\tPredicateBuilderCacheKey key = new PredicateBuilderCacheKey(theSourceJoinColumn, theType, theParamName);\n+\t\t\tif (myJoinMap == null) {\n+\t\t\t\tmyJoinMap = new HashMap<>();\n+\t\t\t}\n+\t\t\tretVal = myJoinMap.get(key);\n+\t\t\tif (retVal != null) {\n+\t\t\t\tcacheHit = true;\n+\t\t\t} else {\n+\t\t\t\tretVal = theFactoryMethod.get();\n+\t\t\t\tmyJoinMap.put(key, retVal);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tretVal = theFactoryMethod.get();\n+\t\t}\n+\t\treturn new PredicateBuilderCacheLookupResult<>(cacheHit, (T) retVal);\n+\t}\n+\n+\tprivate Condition createPredicateComposite(@Nullable DbColumn theSourceJoinColumn, String theResourceName, RuntimeSearchParam theParamDef, List<? extends IQueryParameterType> theNextAnd, RequestPartitionId theRequestPartitionId) {\n+\t\t// TODO: fail if missing is set for a composite query\n+\n+\t\tIQueryParameterType or = theNextAnd.get(0);\n+\t\tif (!(or instanceof CompositeParam<?, ?>)) {\n+\t\t\tthrow new InvalidRequestException(\"Invalid type for composite param (must be \" + CompositeParam.class.getSimpleName() + \": \" + or.getClass());\n+\t\t}\n+\t\tCompositeParam<?, ?> cp = (CompositeParam<?, ?>) or;\n+\n+\t\tRuntimeSearchParam left = theParamDef.getCompositeOf().get(0);\n+\t\tIQueryParameterType leftValue = cp.getLeftValue();\n+\t\tCondition leftPredicate = createPredicateCompositePart(theSourceJoinColumn, theResourceName, left, leftValue, theRequestPartitionId);\n+\n+\t\tRuntimeSearchParam right = theParamDef.getCompositeOf().get(1);\n+\t\tIQueryParameterType rightValue = cp.getRightValue();\n+\t\tCondition rightPredicate = createPredicateCompositePart(theSourceJoinColumn, theResourceName, right, rightValue, theRequestPartitionId);\n+\n+\t\treturn toAndPredicate(leftPredicate, rightPredicate);\n+\t}\n+\n+\tprivate Condition createPredicateCompositePart(@Nullable DbColumn theSourceJoinColumn, String theResourceName, RuntimeSearchParam theParam, IQueryParameterType theParamValue, RequestPartitionId theRequestPartitionId) {\n+\n+\t\tswitch (theParam.getParamType()) {\n+\t\t\tcase STRING: {\n+\t\t\t\treturn createPredicateString(theSourceJoinColumn, theResourceName, theParam, Collections.singletonList(theParamValue), null, theRequestPartitionId);\n+\t\t\t}\n+\t\t\tcase TOKEN: {\n+\t\t\t\treturn createPredicateToken(theSourceJoinColumn, theResourceName, theParam, Collections.singletonList(theParamValue), null, theRequestPartitionId);\n+\t\t\t}\n+\t\t\tcase DATE: {\n+\t\t\t\treturn createPredicateDate(theSourceJoinColumn, theResourceName, theParam, Collections.singletonList(theParamValue), null, theRequestPartitionId);\n+\t\t\t}\n+\t\t\tcase QUANTITY: {\n+\t\t\t\treturn createPredicateQuantity(theSourceJoinColumn, theResourceName, theParam, Collections.singletonList(theParamValue), null, theRequestPartitionId);\n+\t\t\t}\n+\t\t}\n+\n+\t\tthrow new InvalidRequestException(\"Don't know how to handle composite parameter with type of \" + theParam.getParamType());\n+\t}\n+\n+\n+\tpublic Condition createPredicateCoords(@Nullable DbColumn theSourceJoinColumn,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tString theResourceName,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tRuntimeSearchParam theSearchParam,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tList<? extends IQueryParameterType> theList,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tRequestPartitionId theRequestPartitionId) {\n+\n+\t\tCoordsPredicateBuilder predicateBuilder = createOrReusePredicateBuilder(PredicateBuilderTypeEnum.COORDS, theSourceJoinColumn, theSearchParam.getName(), () -> mySqlBuilder.addCoordsPredicateBuilder(theSourceJoinColumn)).getResult();\n+\n+\t\tif (theList.get(0).getMissing() != null) {\n+\t\t\treturn predicateBuilder.createPredicateParamMissingForNonReference(theResourceName, theSearchParam.getName(), theList.get(0).getMissing(), theRequestPartitionId);\n+\t\t}\n+\n+\t\tList<Condition> codePredicates = new ArrayList<>();\n+\t\tfor (IQueryParameterType nextOr : theList) {\n+\t\t\tCondition singleCode = predicateBuilder.createPredicateCoords(mySearchParameters, nextOr, theResourceName, theSearchParam, predicateBuilder, theRequestPartitionId);\n+\t\t\tcodePredicates.add(singleCode);\n+\t\t}\n+\n+\t\treturn predicateBuilder.combineWithRequestPartitionIdPredicate(theRequestPartitionId, ComboCondition.or(codePredicates.toArray(new Condition[0])));\n+\t}\n+\n+\tpublic Condition createPredicateDate(@Nullable DbColumn theSourceJoinColumn,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t String theResourceName,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t RuntimeSearchParam theSearchParam,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t List<? extends IQueryParameterType> theList,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t SearchFilterParser.CompareOperation theOperation,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t RequestPartitionId theRequestPartitionId) {\n+\n+\t\tString paramName = theSearchParam.getName();\n+\n+\t\tPredicateBuilderCacheLookupResult<DatePredicateBuilder> predicateBuilderLookupResult = createOrReusePredicateBuilder(PredicateBuilderTypeEnum.DATE, theSourceJoinColumn, paramName, () -> mySqlBuilder.addDatePredicateBuilder(theSourceJoinColumn));\n+\t\tDatePredicateBuilder predicateBuilder = predicateBuilderLookupResult.getResult();\n+\t\tboolean cacheHit = predicateBuilderLookupResult.isCacheHit();\n+\n+\t\tif (theList.get(0).getMissing() != null) {\n+\t\t\tBoolean missing = theList.get(0).getMissing();\n+\t\t\treturn predicateBuilder.createPredicateParamMissingForNonReference(theResourceName, paramName, missing, theRequestPartitionId);\n+\t\t}\n+\n+\t\tList<Condition> codePredicates = new ArrayList<>();\n+\n+\t\tfor (IQueryParameterType nextOr : theList) {\n+\t\t\tCondition p = predicateBuilder.createPredicateDateWithoutIdentityPredicate(nextOr, theResourceName, paramName, predicateBuilder, theOperation, theRequestPartitionId);\n+\t\t\tcodePredicates.add(p);\n+\t\t}\n+\n+\t\tCondition predicate = toOrPredicate(codePredicates);\n+\n+\t\tif (!cacheHit) {\n+\t\t\tpredicate = predicateBuilder.combineWithHashIdentityPredicate(theResourceName, paramName, predicate);\n+\t\t\tpredicate = predicateBuilder.combineWithRequestPartitionIdPredicate(theRequestPartitionId, predicate);\n+\t\t}\n+\n+\t\treturn predicate;\n+\n+\t}\n+\n+\tprivate Condition createPredicateFilter(QueryStack theQueryStack3, SearchFilterParser.Filter theFilter, String theResourceName, RequestDetails theRequest, RequestPartitionId theRequestPartitionId) {\n+\n+\t\tif (theFilter instanceof SearchFilterParser.FilterParameter) {\n+\t\t\treturn createPredicateFilter(theQueryStack3, (SearchFilterParser.FilterParameter) theFilter, theResourceName, theRequest, theRequestPartitionId);\n+\t\t} else if (theFilter instanceof SearchFilterParser.FilterLogical) {\n+\t\t\t// Left side\n+\t\t\tCondition xPredicate = createPredicateFilter(theQueryStack3, ((SearchFilterParser.FilterLogical) theFilter).getFilter1(), theResourceName, theRequest, theRequestPartitionId);\n+\n+\t\t\t// Right side\n+\t\t\tCondition yPredicate = createPredicateFilter(theQueryStack3, ((SearchFilterParser.FilterLogical) theFilter).getFilter2(), theResourceName, theRequest, theRequestPartitionId);\n+\n+\t\t\tif (((SearchFilterParser.FilterLogical) theFilter).getOperation() == SearchFilterParser.FilterLogicalOperation.and) {\n+\t\t\t\treturn ComboCondition.and(xPredicate, yPredicate);\n+\t\t\t} else if (((SearchFilterParser.FilterLogical) theFilter).getOperation() == SearchFilterParser.FilterLogicalOperation.or) {\n+\t\t\t\treturn ComboCondition.or(xPredicate, yPredicate);\n+\t\t\t} else {\n+\t\t\t\t// Shouldn't happen\n+\t\t\t\tthrow new InvalidRequestException(\"Don't know how to handle operation \" + ((SearchFilterParser.FilterLogical) theFilter).getOperation());\n+\t\t\t}\n+\t\t} else {\n+\t\t\treturn createPredicateFilter(theQueryStack3, ((SearchFilterParser.FilterParameterGroup) theFilter).getContained(), theResourceName, theRequest, theRequestPartitionId);\n+\t\t}\n+\t}\n+\n+\tprivate Condition createPredicateFilter(QueryStack theQueryStack3, SearchFilterParser.FilterParameter theFilter, String theResourceName, RequestDetails theRequest, RequestPartitionId theRequestPartitionId) {\n+\n+\t\tString paramName = theFilter.getParamPath().getName();\n+\n+\t\tif (paramName.equals(IAnyResource.SP_RES_ID)) {\n+\t\t\tTokenParam param = new TokenParam();\n+\t\t\tparam.setValueAsQueryToken(null, null, null, theFilter.getValue());\n+\t\t\treturn theQueryStack3.createPredicateResourceId(null, Collections.singletonList(Collections.singletonList(param)), theResourceName, theFilter.getOperation(), theRequestPartitionId);\n+\t\t} else if (paramName.equals(IAnyResource.SP_RES_LANGUAGE)) {\n+\t\t\t\treturn theQueryStack3.createPredicateLanguage(Collections.singletonList(Collections.singletonList(new StringParam(theFilter.getValue()))), theFilter.getOperation());\n+\t\t} else if (paramName.equals(Constants.PARAM_SOURCE)) {\n+\t\t\t\tTokenParam param = new TokenParam();\n+\t\t\t\tparam.setValueAsQueryToken(null, null, null, theFilter.getValue());\n+\t\t\t\treturn createPredicateSource(null, Collections.singletonList(param));\n+\t\t} else {\n+\t\t\tRuntimeSearchParam searchParam = mySearchParamRegistry.getActiveSearchParam(theResourceName, paramName);\n+\t\t\tif (searchParam == null) {\n+\t\t\t\tCollection<String> validNames = mySearchParamRegistry.getValidSearchParameterNamesIncludingMeta(theResourceName);\n+\t\t\t\tString msg = myFhirContext.getLocalizer().getMessageSanitized(BaseHapiFhirResourceDao.class, \"invalidSearchParameter\", paramName, theResourceName, validNames);\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t}\n+\t\t\tRestSearchParameterTypeEnum typeEnum = searchParam.getParamType();\n+\t\t\tif (typeEnum == RestSearchParameterTypeEnum.URI) {\n+\t\t\t\treturn theQueryStack3.createPredicateUri(null, theResourceName, searchParam, Collections.singletonList(new UriParam(theFilter.getValue())), theFilter.getOperation(), theRequest, theRequestPartitionId);\n+\t\t\t} else if (typeEnum == RestSearchParameterTypeEnum.STRING) {\n+\t\t\t\treturn theQueryStack3.createPredicateString(null, theResourceName, searchParam, Collections.singletonList(new StringParam(theFilter.getValue())), theFilter.getOperation(), theRequestPartitionId);\n+\t\t\t} else if (typeEnum == RestSearchParameterTypeEnum.DATE) {\n+\t\t\t\treturn theQueryStack3.createPredicateDate(null, theResourceName, searchParam, Collections.singletonList(new DateParam(theFilter.getValue())), theFilter.getOperation(), theRequestPartitionId);\n+\t\t\t} else if (typeEnum == RestSearchParameterTypeEnum.NUMBER) {\n+\t\t\t\treturn theQueryStack3.createPredicateNumber(null, theResourceName, searchParam, Collections.singletonList(new NumberParam(theFilter.getValue())), theFilter.getOperation(), theRequestPartitionId);\n+\t\t\t} else if (typeEnum == RestSearchParameterTypeEnum.REFERENCE) {\n+\t\t\t\tSearchFilterParser.CompareOperation operation = theFilter.getOperation();\n+\t\t\t\tString resourceType = null; // The value can either have (Patient/123) or not have (123) a resource type, either way it's not needed here\n+\t\t\t\tString chain = (theFilter.getParamPath().getNext() != null) ? theFilter.getParamPath().getNext().toString() : null;\n+\t\t\t\tString value = theFilter.getValue();\n+\t\t\t\tReferenceParam referenceParam = new ReferenceParam(resourceType, chain, value);\n+\t\t\t\treturn theQueryStack3.createPredicateReference(null, theResourceName, paramName, Collections.singletonList(referenceParam), operation, theRequest, theRequestPartitionId);\n+\t\t\t} else if (typeEnum == RestSearchParameterTypeEnum.QUANTITY) {\n+\t\t\t\treturn theQueryStack3.createPredicateQuantity(null, theResourceName, searchParam, Collections.singletonList(new QuantityParam(theFilter.getValue())), theFilter.getOperation(), theRequestPartitionId);\n+\t\t\t} else if (typeEnum == RestSearchParameterTypeEnum.COMPOSITE) {\n+\t\t\t\tthrow new InvalidRequestException(\"Composite search parameters not currently supported with _filter clauses\");\n+\t\t\t} else if (typeEnum == RestSearchParameterTypeEnum.TOKEN) {\n+\t\t\t\tTokenParam param = new TokenParam();\n+\t\t\t\tparam.setValueAsQueryToken(null,\n+\t\t\t\t\tnull,\n+\t\t\t\t\tnull,\n+\t\t\t\t\ttheFilter.getValue());\n+\t\t\t\treturn theQueryStack3.createPredicateToken(null, theResourceName, searchParam, Collections.singletonList(param), theFilter.getOperation(), theRequestPartitionId);\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate Condition createPredicateHas(@Nullable DbColumn theSourceJoinColumn, String theResourceType, List<List<IQueryParameterType>> theHasParameters, RequestDetails theRequest, RequestPartitionId theRequestPartitionId) {\n+\n+\t\tList<Condition> andPredicates = new ArrayList<>();\n+\t\tfor (List<? extends IQueryParameterType> nextOrList : theHasParameters) {\n+\n+\t\t\tString targetResourceType = null;\n+\t\t\tString paramReference = null;\n+\t\t\tString parameterName = null;\n+\n+\t\t\tString paramName = null;\n+\t\t\tList<QualifiedParamList> parameters = new ArrayList<>();\n+\t\t\tfor (IQueryParameterType nextParam : nextOrList) {\n+\t\t\t\tHasParam next = (HasParam) nextParam;\n+\t\t\t\ttargetResourceType = next.getTargetResourceType();\n+\t\t\t\tparamReference = next.getReferenceFieldName();\n+\t\t\t\tparameterName = next.getParameterName();\n+\t\t\t\tparamName = parameterName.replaceAll(\"\\\\..*\", \"\");\n+\t\t\t\tparameters.add(QualifiedParamList.singleton(null, next.getValueAsQueryToken(myFhirContext)));\n+\t\t\t}\n+\n+\t\t\tif (paramName == null) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tRuntimeResourceDefinition targetResourceDefinition;\n+\t\t\ttry {\n+\t\t\t\ttargetResourceDefinition = myFhirContext.getResourceDefinition(targetResourceType);\n+\t\t\t} catch (DataFormatException e) {\n+\t\t\t\tthrow new InvalidRequestException(\"Invalid resource type: \" + targetResourceType);\n+\t\t\t}\n+\n+\t\t\tArrayList<IQueryParameterType> orValues = Lists.newArrayList();\n+\n+\t\t\tif (paramName.startsWith(\"_has:\")) {\n+\n+\t\t\t\tourLog.trace(\"Handing double _has query: {}\", paramName);\n+\n+\t\t\t\tString qualifier = paramName.substring(4);\n+\t\t\t\tfor (IQueryParameterType next : nextOrList) {\n+\t\t\t\t\tHasParam nextHasParam = new HasParam();\n+\t\t\t\t\tnextHasParam.setValueAsQueryToken(myFhirContext, Constants.PARAM_HAS, qualifier, next.getValueAsQueryToken(myFhirContext));\n+\t\t\t\t\torValues.add(nextHasParam);\n+\t\t\t\t}\n+\n+\t\t\t} else {\n+\n+\t\t\t\t//Ensure that the name of the search param\n+\t\t\t\t// (e.g. the `code` in Patient?_has:Observation:subject:code=sys|val)\n+\t\t\t\t// exists on the target resource type.\n+\t\t\t\tRuntimeSearchParam owningParameterDef = mySearchParamRegistry.getSearchParamByName(targetResourceDefinition, paramName);\n+\t\t\t\tif (owningParameterDef == null) {\n+\t\t\t\t\tthrow new InvalidRequestException(\"Unknown parameter name: \" + targetResourceType + ':' + parameterName);\n+\t\t\t\t}\n+\n+\t\t\t\t//Ensure that the name of the back-referenced search param on the target (e.g. the `subject` in Patient?_has:Observation:subject:code=sys|val)\n+\t\t\t\t//exists on the target resource.\n+\t\t\t\towningParameterDef = mySearchParamRegistry.getSearchParamByName(targetResourceDefinition, paramReference);\n+\t\t\t\tif (owningParameterDef == null) {\n+\t\t\t\t\tthrow new InvalidRequestException(\"Unknown parameter name: \" + targetResourceType + ':' + paramReference);\n+\t\t\t\t}\n+\n+\t\t\t\tRuntimeSearchParam paramDef = mySearchParamRegistry.getSearchParamByName(targetResourceDefinition, paramName);\n+\t\t\t\tIQueryParameterAnd<?> parsedParam = ParameterUtil.parseQueryParams(myFhirContext, paramDef, paramName, parameters);\n+\n+\t\t\t\tfor (IQueryParameterOr<?> next : parsedParam.getValuesAsQueryTokens()) {\n+\t\t\t\t\torValues.addAll(next.getValuesAsQueryTokens());\n+\t\t\t\t}\n+\n+\t\t\t}\n+\n+\t\t\t//Handle internal chain inside the has.\n+\t\t\tif (parameterName.contains(\".\")) {\n+\t\t\t\tString chainedPartOfParameter = getChainedPart(parameterName);\n+\t\t\t\torValues.stream()\n+\t\t\t\t\t.filter(qp -> qp instanceof ReferenceParam)\n+\t\t\t\t\t.map(qp -> (ReferenceParam) qp)\n+\t\t\t\t\t.forEach(rp -> rp.setChain(getChainedPart(chainedPartOfParameter)));\n+\n+\t\t\t\tparameterName = parameterName.substring(0, parameterName.indexOf('.'));\n+\t\t\t}\n+\n+\t\t\tint colonIndex = parameterName.indexOf(':');\n+\t\t\tif (colonIndex != -1) {\n+\t\t\t\tparameterName = parameterName.substring(0, colonIndex);\n+\t\t\t}\n+\n+\t\t\tResourceLinkPredicateBuilder join = mySqlBuilder.addReferencePredicateBuilderReversed(this, theSourceJoinColumn);\n+\t\t\tCondition partitionPredicate = join.createPartitionIdPredicate(theRequestPartitionId);\n+\n+\t\t\tList<String> paths = join.createResourceLinkPaths(targetResourceType, paramReference);\n+\t\t\tCondition typePredicate = BinaryCondition.equalTo(join.getColumnTargetResourceType(), mySqlBuilder.generatePlaceholder(theResourceType));\n+\t\t\tCondition pathPredicate = toEqualToOrInPredicate(join.getColumnSourcePath(), mySqlBuilder.generatePlaceholders(paths));\n+\t\t\tCondition linkedPredicate = searchForIdsWithAndOr(join.getColumnSrcResourceId(), targetResourceType, parameterName, Collections.singletonList(orValues), theRequest, theRequestPartitionId);\n+\t\t\tandPredicates.add(toAndPredicate(partitionPredicate, pathPredicate, typePredicate, linkedPredicate));\n+\t\t}\n+\n+\t\treturn toAndPredicate(andPredicates);\n+\t}\n+\n+\tpublic Condition createPredicateLanguage(List<List<IQueryParameterType>> theList, Object theOperation) {\n+\n+\t\tResourceTablePredicateBuilder rootTable = mySqlBuilder.getOrCreateResourceTablePredicateBuilder();\n+\n+\t\tList<Condition> predicates = new ArrayList<>();\n+\t\tfor (List<? extends IQueryParameterType> nextList : theList) {\n+\n+\t\t\tSet<String> values = new HashSet<>();\n+\t\t\tfor (IQueryParameterType next : nextList) {\n+\t\t\t\tif (next instanceof StringParam) {\n+\t\t\t\t\tString nextValue = ((StringParam) next).getValue();\n+\t\t\t\t\tif (isBlank(nextValue)) {\n+\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t}\n+\t\t\t\t\tvalues.add(nextValue);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow new InternalErrorException(\"Language parameter must be of type \" + StringParam.class.getCanonicalName() + \" - Got \" + next.getClass().getCanonicalName());\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (values.isEmpty()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tif ((theOperation == null) ||\n+\t\t\t\t(theOperation == SearchFilterParser.CompareOperation.eq)) {\n+\t\t\t\tpredicates.add(rootTable.createLanguagePredicate(values, false));\n+\t\t\t} else if (theOperation == SearchFilterParser.CompareOperation.ne) {\n+\t\t\t\tpredicates.add(rootTable.createLanguagePredicate(values, true));\n+\t\t\t} else {\n+\t\t\t\tthrow new InvalidRequestException(\"Unsupported operator specified in language query, only \\\"eq\\\" and \\\"ne\\\" are supported\");\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn toAndPredicate(predicates);\n+\t}\n+\n+\tpublic Condition createPredicateNumber(@Nullable DbColumn theSourceJoinColumn,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tString theResourceName,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tRuntimeSearchParam theSearchParam,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tList<? extends IQueryParameterType> theList,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tSearchFilterParser.CompareOperation theOperation,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tRequestPartitionId theRequestPartitionId) {\n+\n+\t\tNumberPredicateBuilder join = createOrReusePredicateBuilder(PredicateBuilderTypeEnum.NUMBER, theSourceJoinColumn, theSearchParam.getName(), () -> mySqlBuilder.addNumberPredicateBuilder(theSourceJoinColumn)).getResult();\n+\n+\t\tif (theList.get(0).getMissing() != null) {\n+\t\t\treturn join.createPredicateParamMissingForNonReference(theResourceName, theSearchParam.getName(), theList.get(0).getMissing(), theRequestPartitionId);\n+\t\t}\n+\n+\t\tList<Condition> codePredicates = new ArrayList<>();\n+\t\tfor (IQueryParameterType nextOr : theList) {\n+\n+\t\t\tif (nextOr instanceof NumberParam) {\n+\t\t\t\tNumberParam param = (NumberParam) nextOr;\n+\n+\t\t\t\tBigDecimal value = param.getValue();\n+\t\t\t\tif (value == null) {\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\n+\t\t\t\tSearchFilterParser.CompareOperation operation = theOperation;\n+\t\t\t\tif (operation == null) {\n+\t\t\t\t\toperation = toOperation(param.getPrefix());\n+\t\t\t\t}\n+\n+\t\t\t\tCondition predicate = join.createPredicateNumeric(theResourceName, theSearchParam.getName(), operation, value, theRequestPartitionId, nextOr);\n+\t\t\t\tcodePredicates.add(predicate);\n+\n+\t\t\t} else {\n+\t\t\t\tthrow new IllegalArgumentException(\"Invalid token type: \" + nextOr.getClass());\n+\t\t\t}\n+\n+\t\t}\n+\n+\t\treturn join.combineWithRequestPartitionIdPredicate(theRequestPartitionId, ComboCondition.or(codePredicates.toArray(new Condition[0])));\n+\t}\n+\n+\tpublic Condition createPredicateQuantity(@Nullable DbColumn theSourceJoinColumn,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  String theResourceName,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  RuntimeSearchParam theSearchParam,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  List<? extends IQueryParameterType> theList,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  SearchFilterParser.CompareOperation theOperation,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t  RequestPartitionId theRequestPartitionId) {\n+\n+\t\tQuantityPredicateBuilder join = createOrReusePredicateBuilder(PredicateBuilderTypeEnum.QUANTITY, theSourceJoinColumn, theSearchParam.getName(), () -> mySqlBuilder.addQuantityPredicateBuilder(theSourceJoinColumn)).getResult();\n+\n+\t\tif (theList.get(0).getMissing() != null) {\n+\t\t\treturn join.createPredicateParamMissingForNonReference(theResourceName, theSearchParam.getName(), theList.get(0).getMissing(), theRequestPartitionId);\n+\t\t}\n+\n+\t\tList<Condition> codePredicates = new ArrayList<>();\n+\t\tfor (IQueryParameterType nextOr : theList) {\n+\t\t\tCondition singleCode = join.createPredicateQuantity(nextOr, theResourceName, theSearchParam.getName(), null, join, theOperation, theRequestPartitionId);\n+\t\t\tcodePredicates.add(singleCode);\n+\t\t}\n+\n+\t\treturn join.combineWithRequestPartitionIdPredicate(theRequestPartitionId, ComboCondition.or(codePredicates.toArray(new Condition[0])));\n+\t}\n+\n+\tpublic Condition createPredicateReference(@Nullable DbColumn theSourceJoinColumn,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tString theResourceName,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tString theParamName,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tList<? extends IQueryParameterType> theList,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tSearchFilterParser.CompareOperation theOperation,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRequestDetails theRequest,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tRequestPartitionId theRequestPartitionId) {\n+\n+\t\t// This just to ensure the chain has been split correctly\n+\t\tassert theParamName.contains(\".\") == false;\n+\n+\t\tif ((theOperation != null) &&\n+\t\t\t(theOperation != SearchFilterParser.CompareOperation.eq) &&\n+\t\t\t(theOperation != SearchFilterParser.CompareOperation.ne)) {\n+\t\t\tthrow new InvalidRequestException(\"Invalid operator specified for reference predicate.  Supported operators for reference predicate are \\\"eq\\\" and \\\"ne\\\".\");\n+\t\t}\n+\n+\t\tif (theList.get(0).getMissing() != null) {\n+\t\t\tSearchParamPresentPredicateBuilder join = mySqlBuilder.addSearchParamPresentPredicateBuilder(theSourceJoinColumn);\n+\t\t\treturn join.createPredicateParamMissingForReference(theResourceName, theParamName, theList.get(0).getMissing(), theRequestPartitionId);\n+\n+\t\t}\n+\n+\t\tResourceLinkPredicateBuilder predicateBuilder = createOrReusePredicateBuilder(PredicateBuilderTypeEnum.REFERENCE, theSourceJoinColumn, theParamName, () -> mySqlBuilder.addReferencePredicateBuilder(this, theSourceJoinColumn)).getResult();\n+\t\treturn predicateBuilder.createPredicate(theRequest, theResourceName, theParamName, theList, theOperation, theRequestPartitionId);\n+\t}\n+\n+\t@Nullable\n+\tpublic Condition createPredicateResourceId(@Nullable DbColumn theSourceJoinColumn, List<List<IQueryParameterType>> theValues, String theResourceName, SearchFilterParser.CompareOperation theOperation, RequestPartitionId theRequestPartitionId) {\n+\t\tResourceIdPredicateBuilder builder = mySqlBuilder.newResourceIdBuilder();\n+\t\treturn builder.createPredicateResourceId(theSourceJoinColumn, theResourceName, theValues, theOperation, theRequestPartitionId);\n+\t}\n+\n+\tprivate Condition createPredicateSourceForAndList(@Nullable DbColumn theSourceJoinColumn, List<List<IQueryParameterType>> theAndOrParams) {\n+\t\tList<Condition> andPredicates = new ArrayList<>(theAndOrParams.size());\n+\t\tfor (List<? extends IQueryParameterType> nextAnd : theAndOrParams) {\n+\t\t\tandPredicates.add(createPredicateSource(theSourceJoinColumn, nextAnd));\n+\t\t}\n+\t\treturn toAndPredicate(andPredicates);\n+\t}\n+\n+\tprivate Condition createPredicateSource(@Nullable DbColumn theSourceJoinColumn, List<? extends IQueryParameterType> theList) {\n+\t\tif (myDaoConfig.getStoreMetaSourceInformation() == DaoConfig.StoreMetaSourceInformationEnum.NONE) {\n+\t\t\tString msg = myFhirContext.getLocalizer().getMessage(LegacySearchBuilder.class, \"sourceParamDisabled\");\n+\t\t\tthrow new InvalidRequestException(msg);\n+\t\t}\n+\n+\t\tSourcePredicateBuilder join = createOrReusePredicateBuilder(PredicateBuilderTypeEnum.SOURCE, theSourceJoinColumn, Constants.PARAM_SOURCE, () -> mySqlBuilder.addSourcePredicateBuilder(theSourceJoinColumn)).getResult();\n+\n+\t\tList<Condition> orPredicates = new ArrayList<>();\n+\t\tfor (IQueryParameterType nextParameter : theList) {\n+\t\t\tSourceParam sourceParameter = new SourceParam(nextParameter.getValueAsQueryToken(myFhirContext));\n+\t\t\tString sourceUri = sourceParameter.getSourceUri();\n+\t\t\tString requestId = sourceParameter.getRequestId();\n+\t\t\tif (isNotBlank(sourceUri) && isNotBlank(requestId)) {\n+\t\t\t\torPredicates.add(toAndPredicate(\n+\t\t\t\t\tjoin.createPredicateSourceUri(sourceUri),\n+\t\t\t\t\tjoin.createPredicateRequestId(requestId)\n+\t\t\t\t));\n+\t\t\t} else if (isNotBlank(sourceUri)) {\n+\t\t\t\torPredicates.add(join.createPredicateSourceUri(sourceUri));\n+\t\t\t} else if (isNotBlank(requestId)) {\n+\t\t\t\torPredicates.add(join.createPredicateRequestId(requestId));\n+\t\t\t}\n+\t\t}\n+\n+\t\treturn toOrPredicate(orPredicates);\n+\t}\n+\n+\tpublic Condition createPredicateString(@Nullable DbColumn theSourceJoinColumn,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tString theResourceName,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tRuntimeSearchParam theSearchParam,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tList<? extends IQueryParameterType> theList,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tSearchFilterParser.CompareOperation theOperation,\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\tRequestPartitionId theRequestPartitionId) {\n+\n+\t\tStringPredicateBuilder join = createOrReusePredicateBuilder(PredicateBuilderTypeEnum.STRING, theSourceJoinColumn, theSearchParam.getName(), () -> mySqlBuilder.addStringPredicateBuilder(theSourceJoinColumn)).getResult();\n+\n+\t\tif (theList.get(0).getMissing() != null) {\n+\t\t\treturn join.createPredicateParamMissingForNonReference(theResourceName, theSearchParam.getName(), theList.get(0).getMissing(), theRequestPartitionId);\n+\t\t}\n+\n+\t\tList<Condition> codePredicates = new ArrayList<>();\n+\t\tfor (IQueryParameterType nextOr : theList) {\n+\t\t\tCondition singleCode = join.createPredicateString(nextOr, theResourceName, theSearchParam, join, theOperation);\n+\t\t\tcodePredicates.add(singleCode);\n+\t\t}\n+\n+\t\treturn join.combineWithRequestPartitionIdPredicate(theRequestPartitionId, ComboCondition.or(codePredicates.toArray(new Condition[0])));\n+\t}\n+\n+\tpublic Condition createPredicateTag(@Nullable DbColumn theSourceJoinColumn, List<List<IQueryParameterType>> theList, String theParamName, RequestPartitionId theRequestPartitionId) {\n+\t\tTagTypeEnum tagType;\n+\t\tif (Constants.PARAM_TAG.equals(theParamName)) {\n+\t\t\ttagType = TagTypeEnum.TAG;\n+\t\t} else if (Constants.PARAM_PROFILE.equals(theParamName)) {\n+\t\t\ttagType = TagTypeEnum.PROFILE;\n+\t\t} else if (Constants.PARAM_SECURITY.equals(theParamName)) {\n+\t\t\ttagType = TagTypeEnum.SECURITY_LABEL;\n+\t\t} else {\n+\t\t\tthrow new IllegalArgumentException(\"Param name: \" + theParamName); // shouldn't happen\n+\t\t}\n+\n+\t\tList<Condition> andPredicates = new ArrayList<>();\n+\t\tfor (List<? extends IQueryParameterType> nextAndParams : theList) {\n+\t\t\tboolean haveTags = false;\n+\t\t\tfor (IQueryParameterType nextParamUncasted : nextAndParams) {\n+\t\t\t\tif (nextParamUncasted instanceof TokenParam) {\n+\t\t\t\t\tTokenParam nextParam = (TokenParam) nextParamUncasted;\n+\t\t\t\t\tif (isNotBlank(nextParam.getValue())) {\n+\t\t\t\t\t\thaveTags = true;\n+\t\t\t\t\t} else if (isNotBlank(nextParam.getSystem())) {\n+\t\t\t\t\t\tthrow new InvalidRequestException(\"Invalid \" + theParamName + \" parameter (must supply a value/code and not just a system): \" + nextParam.getValueAsQueryToken(myFhirContext));\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tUriParam nextParam = (UriParam) nextParamUncasted;\n+\t\t\t\t\tif (isNotBlank(nextParam.getValue())) {\n+\t\t\t\t\t\thaveTags = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (!haveTags) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tboolean paramInverted = false;\n+\t\t\tList<Pair<String, String>> tokens = Lists.newArrayList();\n+\t\t\tfor (IQueryParameterType nextOrParams : nextAndParams) {\n+\t\t\t\tString code;\n+\t\t\t\tString system;\n+\t\t\t\tif (nextOrParams instanceof TokenParam) {\n+\t\t\t\t\tTokenParam nextParam = (TokenParam) nextOrParams;\n+\t\t\t\t\tcode = nextParam.getValue();\n+\t\t\t\t\tsystem = nextParam.getSystem();\n+\t\t\t\t\tif (nextParam.getModifier() == TokenParamModifier.NOT) {\n+\t\t\t\t\t\tparamInverted = true;\n+\t\t\t\t\t}\n+\t\t\t\t} else {\n+\t\t\t\t\tUriParam nextParam = (UriParam) nextOrParams;\n+\t\t\t\t\tcode = nextParam.getValue();\n+\t\t\t\t\tsystem = null;\n+\t\t\t\t}\n+\n+\t\t\t\tif (isNotBlank(code)) {\n+\t\t\t\t\ttokens.add(Pair.of(system, code));\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif (tokens.isEmpty()) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tCondition tagPredicate;\n+\t\t\tBaseJoiningPredicateBuilder join;\n+\t\t\tif (paramInverted) {\n+\n+\t\t\t\tSearchQueryBuilder sqlBuilder = mySqlBuilder.newChildSqlBuilder();\n+\t\t\t\tTagPredicateBuilder tagSelector = sqlBuilder.addTagPredicateBuilder(null);\n+\t\t\t\tsqlBuilder.addPredicate(tagSelector.createPredicateTag(tagType, tokens, theParamName, theRequestPartitionId));\n+\t\t\t\tSelectQuery sql = sqlBuilder.getSelect();\n+\n+\t\t\t\tjoin = mySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\t\t\t\tExpression subSelect = new Subquery(sql);\n+\t\t\t\ttagPredicate = new InCondition(join.getResourceIdColumn(), subSelect).setNegate(true);\n+\n+\t\t\t} else {\n+\t\t\t\t// Tag table can't be a query root because it will include deleted resources, and can't select by resource type\n+\t\t\t\tmySqlBuilder.getOrCreateFirstPredicateBuilder();\n+\n+\t\t\t\tTagPredicateBuilder tagJoin = createOrReusePredicateBuilder(PredicateBuilderTypeEnum.TAG, theSourceJoinColumn, theParamName, () -> mySqlBuilder.addTagPredicateBuilder(theSourceJoinColumn)).getResult();\n+\t\t\t\ttagPredicate = tagJoin.createPredicateTag(tagType, tokens, theParamName, theRequestPartitionId);\n+\t\t\t\tjoin = tagJoin;\n+\t\t\t}\n+\n+\t\t\tandPredicates.add(join.combineWithRequestPartitionIdPredicate(theRequestPartitionId, tagPredicate));\n+\t\t}\n+\n+\t\treturn toAndPredicate(andPredicates);\n+\t}\n+\n+\tpublic Condition createPredicateToken(@Nullable DbColumn theSourceJoinColumn,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 823}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4Njk4OTk3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/SearchCoordinatorSvcImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQxOTowMjozMFrOHlM30g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzozMDoxOVrOHn1CAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MDI1OA==", "bodyText": "Will this change the order of the includes & revincludes?  This may affect some users who are expecting the old order.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508770258", "createdAt": "2020-10-20T19:02:30Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/SearchCoordinatorSvcImpl.java", "diffHunk": "@@ -535,8 +536,11 @@ private IBundleProvider executeQuery(String theResourceType, SearchParameterMap\n \t\t\t * individually for pages as we return them to clients\n \t\t\t */\n \t\t\tfinal Set<ResourcePersistentId> includedPids = new HashSet<>();\n+\t\t\tif (theParams.getEverythingMode() == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNTM3OQ==", "bodyText": "As far as I can tell, it doesn't affect the output at all", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r511525379", "createdAt": "2020-10-24T23:30:19Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/SearchCoordinatorSvcImpl.java", "diffHunk": "@@ -535,8 +536,11 @@ private IBundleProvider executeQuery(String theResourceType, SearchParameterMap\n \t\t\t * individually for pages as we return them to clients\n \t\t\t */\n \t\t\tfinal Set<ResourcePersistentId> includedPids = new HashSet<>();\n+\t\t\tif (theParams.getEverythingMode() == null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODc3MDI1OA=="}, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQxMjg1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/CircularQueueCaptureQueriesListener.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowMDo1NFrOHlQ6Rw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzozMTo1N1rOHn1CcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNjQyMw==", "bodyText": "nitpick: I like the :: syntax better", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508836423", "createdAt": "2020-10-20T21:00:54Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/CircularQueueCaptureQueriesListener.java", "diffHunk": "@@ -197,7 +197,7 @@ public String logUpdateQueriesForCurrentThread() {\n \tpublic String logSelectQueriesForCurrentThread(int... theIndexes) {\n \t\tList<String> queries = getSelectQueriesForCurrentThread()\n \t\t\t.stream()\n-\t\t\t.map(CircularQueueCaptureQueriesListener::formatQueryAsSql)\n+\t\t\t.map(t -> CircularQueueCaptureQueriesListener.formatQueryAsSql(t))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNTQ4OQ==", "bodyText": "I'm not actually sure why I changed this. Changing back.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r511525489", "createdAt": "2020-10-24T23:31:57Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/CircularQueueCaptureQueriesListener.java", "diffHunk": "@@ -197,7 +197,7 @@ public String logUpdateQueriesForCurrentThread() {\n \tpublic String logSelectQueriesForCurrentThread(int... theIndexes) {\n \t\tList<String> queries = getSelectQueriesForCurrentThread()\n \t\t\t.stream()\n-\t\t\t.map(CircularQueueCaptureQueriesListener::formatQueryAsSql)\n+\t\t\t.map(t -> CircularQueueCaptureQueriesListener.formatQueryAsSql(t))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzNjQyMw=="}, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQyNTg2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowNDo0OVrOHlRCpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowNDo0OVrOHlRCpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODgzODU2Nw==", "bodyText": "I like this convention of recording a test assert value changed.  I will start using it.  Particularly helpful when you hit a failure.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508838567", "createdAt": "2020-10-20T21:04:49Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -1087,7 +1088,7 @@ public void testTransactionWithMultiplePreExistingReferences_IfNoneExist() {\n \t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n \t\tassertEquals(6, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n \t\tassertEquals(3, myCaptureQueriesListener.countInsertQueriesForCurrentThread());\n-\t\tassertEquals(2, myCaptureQueriesListener.countUpdateQueriesForCurrentThread());\n+\t\tassertEquals(1, myCaptureQueriesListener.countUpdateQueriesForCurrentThread()); // was 2", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQzOTU5OnYy", "diffSide": "LEFT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMTowODozOFrOHlRK5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzozNDo0NVrOHn1DLQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MDY3OQ==", "bodyText": "Why can we delete this test?", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508840679", "createdAt": "2020-10-20T21:08:38Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -3148,24 +3228,6 @@ public void testSearchResourceReferenceOnlyCorrectPath() {\n \n \t}\n \n-\t@Test\n-\tpublic void testSearchStringParamWithLike() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 308}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNTY3Nw==", "bodyText": "It isn't actually a test, I assume it is cruft from debugging something.. It has no asserts and isn't testing anything that isn't well covered elsewhere.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r511525677", "createdAt": "2020-10-24T23:34:45Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -3148,24 +3228,6 @@ public void testSearchResourceReferenceOnlyCorrectPath() {\n \n \t}\n \n-\t@Test\n-\tpublic void testSearchStringParamWithLike() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MDY3OQ=="}, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 308}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzQ0Njc5OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchOptimizedTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxMDozOFrOHlRPHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToxMDozOFrOHlRPHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg0MTc1OA==", "bodyText": "nice test", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508841758", "createdAt": "2020-10-20T21:10:38Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchOptimizedTest.java", "diffHunk": "@@ -744,13 +771,28 @@ public void testReferenceOrLinksUseInList() {\n \n \t\tString resultingQueryNotFormatted = queries.get(0);\n \t\tassertEquals(1, StringUtils.countMatches(resultingQueryNotFormatted, \"Patient.managingOrganization\"), resultingQueryNotFormatted);\n-\t\tassertThat(resultingQueryNotFormatted, containsString(\"TARGET_RESOURCE_ID in ('\" + ids.get(0) + \"' , '\" + ids.get(1) + \"' , '\" + ids.get(2) + \"' , '\" + ids.get(3) + \"' , '\" + ids.get(4) + \"')\"));\n+\t\tassertThat(resultingQueryNotFormatted, containsString(\"TARGET_RESOURCE_ID IN ('\" + ids.get(0) + \"','\" + ids.get(1) + \"','\" + ids.get(2) + \"','\" + ids.get(3) + \"','\" + ids.get(4) + \"')\"));\n \n \t\t// Ensure that the search actually worked\n \t\tassertEquals(5, search.size().intValue());\n \n \t}\n \n+\t@Test\n+\tpublic void testChainedSearchUsesJoinNotSubselect() {\n+\t\tmyCaptureQueriesListener.clear();\n+\n+\t\tRuntimeResourceDefinition resourceDef = myFhirCtx.getResourceDefinition(\"Observation\");\n+\t\tSearchParameterMap params = myMatchUrlService.translateMatchUrl(\"/Observation?subject:patient.identifier=urn:oid:ZOOP.MRN.OID|1234\", resourceDef, null);\n+\t\tparams.setLoadSynchronous(true);\n+\t\tmyObservationDao.search(params);\n+\t\tmyCaptureQueriesListener.logSelectQueries();\n+\n+\t\tString selectQuery = myCaptureQueriesListener.getSelectQueries().get(0).getSql(true, true);\n+\t\tourLog.info(selectQuery);\n+\t\tassertEquals(2, StringUtils.countMatches(selectQuery, \"JOIN\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE4NzUwMDk3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/rest/param/TokenParam.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yMFQyMToyNjo1M1rOHlRvlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNFQyMzo0MTowNVrOHn1FCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MDA3MA==", "bodyText": "Sticking this review in a random spot.  Just realized you might want to add a changelog entry for this MR.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r508850070", "createdAt": "2020-10-20T21:26:53Z", "author": {"login": "fil512"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/rest/param/TokenParam.java", "diffHunk": "@@ -208,7 +208,7 @@ public String getValueNotNull() {\n \t}\n ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTUyNjE1NQ==", "bodyText": "Changelog addded.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r511526155", "createdAt": "2020-10-24T23:41:05Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/rest/param/TokenParam.java", "diffHunk": "@@ -208,7 +208,7 @@ public String getValueNotNull() {\n \t}\n ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODg1MDA3MA=="}, "originalCommit": {"oid": "1466633c17b0a9469131ba2ad51944b44c684369"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMDEzOTg0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/SearchBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDowOTo0M1rOH43wzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxMDowOTo0M1rOH43wzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTM5NTkxOA==", "bodyText": "Why is HapiFhirLocalContainerEntityManagerFactoryBean injected here because only myEntityManagerFactory.getDataSource() is used? We prefer to use Spring Boot generated LocalContainerEntityManagerFactoryBean instead of HapiFhirLocalContainerEntityManagerFactoryBean so this autowiring breaks our code. Could you change this to\n@Autowired\nprivate DataSource dataSource;\n\nand use\nJdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource);\n\nin row 352?", "url": "https://github.com/hapifhir/hapi-fhir/pull/2086#discussion_r529395918", "createdAt": "2020-11-24T10:09:43Z", "author": {"login": "ruoat"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/search/builder/SearchBuilder.java", "diffHunk": "@@ -0,0 +1,1298 @@\n+package ca.uhn.fhir.jpa.search.builder;\n+\n+/*\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.context.FhirVersionEnum;\n+import ca.uhn.fhir.context.RuntimeResourceDefinition;\n+import ca.uhn.fhir.context.RuntimeSearchParam;\n+import ca.uhn.fhir.interceptor.api.HookParams;\n+import ca.uhn.fhir.interceptor.api.IInterceptorBroadcaster;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.interceptor.model.RequestPartitionId;\n+import ca.uhn.fhir.jpa.api.config.DaoConfig;\n+import ca.uhn.fhir.jpa.api.dao.IDao;\n+import ca.uhn.fhir.jpa.config.HapiFhirLocalContainerEntityManagerFactoryBean;\n+import ca.uhn.fhir.jpa.config.HibernateDialectProvider;\n+import ca.uhn.fhir.jpa.dao.BaseHapiFhirResourceDao;\n+import ca.uhn.fhir.jpa.dao.IFulltextSearchSvc;\n+import ca.uhn.fhir.jpa.dao.IResultIterator;\n+import ca.uhn.fhir.jpa.dao.ISearchBuilder;\n+import ca.uhn.fhir.jpa.dao.data.IResourceSearchViewDao;\n+import ca.uhn.fhir.jpa.dao.data.IResourceTagDao;\n+import ca.uhn.fhir.jpa.dao.index.IdHelperService;\n+import ca.uhn.fhir.jpa.entity.ResourceSearchView;\n+import ca.uhn.fhir.jpa.interceptor.JpaPreResourceAccessDetails;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTable;\n+import ca.uhn.fhir.jpa.model.entity.ResourceTag;\n+import ca.uhn.fhir.jpa.model.search.SearchRuntimeDetails;\n+import ca.uhn.fhir.jpa.model.search.StorageProcessingMessage;\n+import ca.uhn.fhir.jpa.search.builder.sql.GeneratedSql;\n+import ca.uhn.fhir.jpa.search.builder.sql.SearchQueryBuilder;\n+import ca.uhn.fhir.jpa.search.builder.sql.SearchQueryExecutor;\n+import ca.uhn.fhir.jpa.search.builder.sql.SqlObjectFactory;\n+import ca.uhn.fhir.jpa.search.lastn.IElasticsearchSvc;\n+import ca.uhn.fhir.jpa.searchparam.JpaRuntimeSearchParam;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import ca.uhn.fhir.jpa.searchparam.registry.ISearchParamRegistry;\n+import ca.uhn.fhir.jpa.searchparam.util.Dstu3DistanceHelper;\n+import ca.uhn.fhir.jpa.searchparam.util.LastNParameterHelper;\n+import ca.uhn.fhir.jpa.util.BaseIterator;\n+import ca.uhn.fhir.jpa.util.CurrentThreadCaptureQueriesListener;\n+import ca.uhn.fhir.jpa.util.JpaInterceptorBroadcaster;\n+import ca.uhn.fhir.jpa.util.QueryChunker;\n+import ca.uhn.fhir.jpa.util.SqlQueryList;\n+import ca.uhn.fhir.model.api.IQueryParameterType;\n+import ca.uhn.fhir.model.api.IResource;\n+import ca.uhn.fhir.model.api.Include;\n+import ca.uhn.fhir.model.api.ResourceMetadataKeyEnum;\n+import ca.uhn.fhir.model.primitive.InstantDt;\n+import ca.uhn.fhir.model.valueset.BundleEntrySearchModeEnum;\n+import ca.uhn.fhir.rest.api.Constants;\n+import ca.uhn.fhir.rest.api.RestSearchParameterTypeEnum;\n+import ca.uhn.fhir.rest.api.SortOrderEnum;\n+import ca.uhn.fhir.rest.api.SortSpec;\n+import ca.uhn.fhir.rest.api.server.IPreResourceAccessDetails;\n+import ca.uhn.fhir.rest.api.server.RequestDetails;\n+import ca.uhn.fhir.rest.api.server.storage.ResourcePersistentId;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.rest.param.ReferenceParam;\n+import ca.uhn.fhir.rest.param.StringParam;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import ca.uhn.fhir.util.StopWatch;\n+import ca.uhn.fhir.util.UrlUtil;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Lists;\n+import com.healthmarketscience.sqlbuilder.Condition;\n+import org.apache.commons.lang3.Validate;\n+import org.hl7.fhir.instance.model.api.IAnyResource;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.SingleColumnRowMapper;\n+import org.springframework.transaction.support.TransactionSynchronizationManager;\n+\n+import javax.annotation.Nonnull;\n+import javax.persistence.EntityManager;\n+import javax.persistence.PersistenceContext;\n+import javax.persistence.PersistenceContextType;\n+import javax.persistence.TypedQuery;\n+import javax.persistence.criteria.CriteriaBuilder;\n+import javax.persistence.criteria.CriteriaQuery;\n+import javax.persistence.criteria.From;\n+import javax.persistence.criteria.Predicate;\n+import javax.persistence.criteria.Root;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+\n+/**\n+ * The SearchBuilder is responsible for actually forming the SQL query that handles\n+ * searches for resources\n+ */\n+public class SearchBuilder implements ISearchBuilder {\n+\n+\t/**\n+\t * See loadResourcesByPid\n+\t * for an explanation of why we use the constant 800\n+\t */\n+\t// NB: keep public\n+\tpublic static final int MAXIMUM_PAGE_SIZE = 800;\n+\tpublic static final int MAXIMUM_PAGE_SIZE_FOR_TESTING = 50;\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchBuilder.class);\n+\tprivate static final ResourcePersistentId NO_MORE = new ResourcePersistentId(-1L);\n+\tpublic static boolean myUseMaxPageSize50ForTest = false;\n+\tprivate final String myResourceName;\n+\tprivate final Class<? extends IBaseResource> myResourceType;\n+\tprivate final IDao myCallingDao;\n+\t@Autowired\n+\tprotected IInterceptorBroadcaster myInterceptorBroadcaster;\n+\t@Autowired\n+\tprotected IResourceTagDao myResourceTagDao;\n+\t@PersistenceContext(type = PersistenceContextType.TRANSACTION)\n+\tprotected EntityManager myEntityManager;\n+\t@Autowired\n+\tprivate DaoConfig myDaoConfig;\n+\t@Autowired\n+\tprivate IResourceSearchViewDao myResourceSearchViewDao;\n+\t@Autowired\n+\tprivate FhirContext myContext;\n+\t@Autowired\n+\tprivate IdHelperService myIdHelperService;\n+\t@Autowired(required = false)\n+\tprivate IFulltextSearchSvc myFulltextSearchSvc;\n+\t@Autowired(required = false)\n+\tprivate IElasticsearchSvc myIElasticsearchSvc;\n+\t@Autowired\n+\tprivate ISearchParamRegistry mySearchParamRegistry;\n+\tprivate List<ResourcePersistentId> myAlsoIncludePids;\n+\tprivate CriteriaBuilder myCriteriaBuilder;\n+\tprivate SearchParameterMap myParams;\n+\tprivate String mySearchUuid;\n+\tprivate int myFetchSize;\n+\tprivate Integer myMaxResultsToFetch;\n+\tprivate Set<ResourcePersistentId> myPidSet;\n+\tprivate RequestPartitionId myRequestPartitionId;\n+\t@Autowired\n+\tprivate PartitionSettings myPartitionSettings;\n+\t@Autowired\n+\tprivate HapiFhirLocalContainerEntityManagerFactoryBean myEntityManagerFactory;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b30efdeca631d4a6fec3fa19ae9a1db95487de6e"}, "originalPosition": 172}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1794, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}