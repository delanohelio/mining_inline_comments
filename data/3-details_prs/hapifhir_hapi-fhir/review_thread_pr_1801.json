{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzNDQ2Mjg4", "number": 1801, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1MDo0OFrODx2cAw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzowNTo0N1rODx2pdw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk4NzIzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/parser/ParserState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1MDo0OFrOGFjt8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1NDo1MFrOGFk_Fg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTI2NQ==", "bodyText": "What happens if the string is literal . ? that substring will fail, but is that a possible state this resource could be in?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408481265", "createdAt": "2020-04-14T22:50:48Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/parser/ParserState.java", "diffHunk": "@@ -1269,41 +1272,50 @@ public boolean isPreResource() {\n \n \tprivate class PrimitiveState extends BaseState {\n \t\tprivate final String myChildName;\n+\t\tprivate final String myTypeName;\n \t\tprivate IPrimitiveType<?> myInstance;\n \n-\t\tPrimitiveState(PreResourceState thePreResourceState, IPrimitiveType<?> theInstance, String theChildName) {\n+\t\tPrimitiveState(PreResourceState thePreResourceState, IPrimitiveType<?> theInstance, String theChildName, String theTypeName) {\n \t\t\tsuper(thePreResourceState);\n \t\t\tmyInstance = theInstance;\n \t\t\tmyChildName = theChildName;\n+\t\t\tmyTypeName = theTypeName;\n \t\t}\n \n \t\t@Override\n \t\tpublic void attributeValue(String theName, String theValue) throws DataFormatException {\n+\t\t\tString value = theValue;\n \t\t\tif (\"value\".equals(theName)) {\n-\t\t\t\tif (\"\".equals(theValue)) {\n+\t\t\t\tif (\"\".equals(value)) {\n \t\t\t\t\tParseLocation location = ParseLocation.fromElementName(myChildName);\n-\t\t\t\t\tmyErrorHandler.invalidValue(location, theValue, \"Attribute value must not be empty (\\\"\\\")\");\n+\t\t\t\t\tmyErrorHandler.invalidValue(location, value, \"Attribute value must not be empty (\\\"\\\")\");\n \t\t\t\t} else {\n+\t\t\t\t\tif (\"decimal\".equals(myTypeName)) {\n+\t\t\t\t\t\tif (value != null && value.startsWith(\".\") && NumberUtils.isDigits(value.substring(1))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMjAzOA==", "bodyText": "Good question, adding a test!", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408502038", "createdAt": "2020-04-14T23:54:50Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/parser/ParserState.java", "diffHunk": "@@ -1269,41 +1272,50 @@ public boolean isPreResource() {\n \n \tprivate class PrimitiveState extends BaseState {\n \t\tprivate final String myChildName;\n+\t\tprivate final String myTypeName;\n \t\tprivate IPrimitiveType<?> myInstance;\n \n-\t\tPrimitiveState(PreResourceState thePreResourceState, IPrimitiveType<?> theInstance, String theChildName) {\n+\t\tPrimitiveState(PreResourceState thePreResourceState, IPrimitiveType<?> theInstance, String theChildName, String theTypeName) {\n \t\t\tsuper(thePreResourceState);\n \t\t\tmyInstance = theInstance;\n \t\t\tmyChildName = theChildName;\n+\t\t\tmyTypeName = theTypeName;\n \t\t}\n \n \t\t@Override\n \t\tpublic void attributeValue(String theName, String theValue) throws DataFormatException {\n+\t\t\tString value = theValue;\n \t\t\tif (\"value\".equals(theName)) {\n-\t\t\t\tif (\"\".equals(theValue)) {\n+\t\t\t\tif (\"\".equals(value)) {\n \t\t\t\t\tParseLocation location = ParseLocation.fromElementName(myChildName);\n-\t\t\t\t\tmyErrorHandler.invalidValue(location, theValue, \"Attribute value must not be empty (\\\"\\\")\");\n+\t\t\t\t\tmyErrorHandler.invalidValue(location, value, \"Attribute value must not be empty (\\\"\\\")\");\n \t\t\t\t} else {\n+\t\t\t\t\tif (\"decimal\".equals(myTypeName)) {\n+\t\t\t\t\t\tif (value != null && value.startsWith(\".\") && NumberUtils.isDigits(value.substring(1))) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MTI2NQ=="}, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk5NTA2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NDoxMVrOGFjyig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1ODo1MVrOGFlD_w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjQ0Mg==", "bodyText": "could we not just private the constructor and provide a factory method", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482442", "createdAt": "2020-04-14T22:54:11Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMzI5NQ==", "bodyText": "oops, that comment is actually just copy-paste from the regular JsonParser.. but this whole class should really be package-protected. Doing that,", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408503295", "createdAt": "2020-04-14T23:58:51Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjQ0Mg=="}, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk5NzIxOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NTowNVrOGFjz4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NTowNVrOGFjz4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mjc4NA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482784", "createdAt": "2020-04-14T22:55:05Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {\n+\t\tsuper(theContext, theParserErrorHandler);\n+\t}\n+\n+\t@Override\n+\tpublic <T extends IBaseResource> T parseResource(Class<T> theResourceType, String theMessageString) {\n+\t\ttry {\n+\t\t\treturn super.parseResource(theResourceType, theMessageString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tif (defaultString(e.getMessage()).contains(\"Unexpected character ('.' (code 46))\")) {\n+\n+\t\t\t\t/*\n+\t\t\t\t * The following is a hacky and gross workaround until the following PR is hopefully merged:\n+\t\t\t\t * https://github.com/FasterXML/jackson-core/pull/611\n+\t\t\t\t *\n+\t\t\t\t * The issue this solves is that under Gson it was possible to store JSON containing\n+\t\t\t\t * decimal numbers with no leading integer, e.g. .123\n+\t\t\t\t *\n+\t\t\t\t * These don't parse in Jackson, meaning we can be stuck with data in the database\n+\t\t\t\t * that can't be loaded back out.\n+\t\t\t\t *\n+\t\t\t\t * Note that if we fix this in the future to rely on Jackson natively handing this\n+\t\t\t\t * nicely we may or may not be able to remove some code from\n+\t\t\t\t * ParserState.Primitive state too.\n+\t\t\t\t */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNTk5ODE0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NToyM1rOGFj0Zw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzo1OToyN1rOGFlE0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjkxOQ==", "bodyText": "heh nice fix", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408482919", "createdAt": "2020-04-14T22:55:23Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {\n+\t\tsuper(theContext, theParserErrorHandler);\n+\t}\n+\n+\t@Override\n+\tpublic <T extends IBaseResource> T parseResource(Class<T> theResourceType, String theMessageString) {\n+\t\ttry {\n+\t\t\treturn super.parseResource(theResourceType, theMessageString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tif (defaultString(e.getMessage()).contains(\"Unexpected character ('.' (code 46))\")) {\n+\n+\t\t\t\t/*\n+\t\t\t\t * The following is a hacky and gross workaround until the following PR is hopefully merged:\n+\t\t\t\t * https://github.com/FasterXML/jackson-core/pull/611\n+\t\t\t\t *\n+\t\t\t\t * The issue this solves is that under Gson it was possible to store JSON containing\n+\t\t\t\t * decimal numbers with no leading integer, e.g. .123\n+\t\t\t\t *\n+\t\t\t\t * These don't parse in Jackson, meaning we can be stuck with data in the database\n+\t\t\t\t * that can't be loaded back out.\n+\t\t\t\t *\n+\t\t\t\t * Note that if we fix this in the future to rely on Jackson natively handing this\n+\t\t\t\t * nicely we may or may not be able to remove some code from\n+\t\t\t\t * ParserState.Primitive state too.\n+\t\t\t\t */\n+\n+\t\t\t\tGson gson = new Gson();\n+\n+\t\t\t\tJsonObject object = gson.fromJson(theMessageString, JsonObject.class);\n+\t\t\t\tString corrected = gson.toJson(object);\n+\n+\t\t\t\treturn super.parseResource(theResourceType, corrected);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwMzUwNw==", "bodyText": "\"nice\"\n... gross more like :p", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408503507", "createdAt": "2020-04-14T23:59:27Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/util/TolerantJsonParser.java", "diffHunk": "@@ -0,0 +1,61 @@\n+package ca.uhn.fhir.jpa.util;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.parser.DataFormatException;\n+import ca.uhn.fhir.parser.IParserErrorHandler;\n+import ca.uhn.fhir.parser.JsonParser;\n+import com.google.gson.Gson;\n+import com.google.gson.JsonObject;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.apache.commons.lang3.StringUtils.defaultString;\n+\n+public class TolerantJsonParser extends JsonParser {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(TolerantJsonParser.class);\n+\n+\t/**\n+\t * Do not use this constructor, the recommended way to obtain a new instance of the JSON parser is to invoke\n+\t * {@link FhirContext#newJsonParser()}.\n+\t */\n+\tpublic TolerantJsonParser(FhirContext theContext, IParserErrorHandler theParserErrorHandler) {\n+\t\tsuper(theContext, theParserErrorHandler);\n+\t}\n+\n+\t@Override\n+\tpublic <T extends IBaseResource> T parseResource(Class<T> theResourceType, String theMessageString) {\n+\t\ttry {\n+\t\t\treturn super.parseResource(theResourceType, theMessageString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tif (defaultString(e.getMessage()).contains(\"Unexpected character ('.' (code 46))\")) {\n+\n+\t\t\t\t/*\n+\t\t\t\t * The following is a hacky and gross workaround until the following PR is hopefully merged:\n+\t\t\t\t * https://github.com/FasterXML/jackson-core/pull/611\n+\t\t\t\t *\n+\t\t\t\t * The issue this solves is that under Gson it was possible to store JSON containing\n+\t\t\t\t * decimal numbers with no leading integer, e.g. .123\n+\t\t\t\t *\n+\t\t\t\t * These don't parse in Jackson, meaning we can be stuck with data in the database\n+\t\t\t\t * that can't be loaded back out.\n+\t\t\t\t *\n+\t\t\t\t * Note that if we fix this in the future to rely on Jackson natively handing this\n+\t\t\t\t * nicely we may or may not be able to remove some code from\n+\t\t\t\t * ParserState.Primitive state too.\n+\t\t\t\t */\n+\n+\t\t\t\tGson gson = new Gson();\n+\n+\t\t\t\tJsonObject object = gson.fromJson(theMessageString, JsonObject.class);\n+\t\t\t\tString corrected = gson.toJson(object);\n+\n+\t\t\t\treturn super.parseResource(theResourceType, corrected);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MjkxOQ=="}, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 55}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjAwMjE1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoDstu3SearchCustomSearchParamTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1NzoxOFrOGFj28g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDowMToyNlrOGFlHRw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MzU3MA==", "bodyText": "JSONing a SearchParameter feels pretty brittle in a test. Is there a reason why we don't just instantiate it and pass it to the DAO?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408483570", "createdAt": "2020-04-14T22:57:18Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoDstu3SearchCustomSearchParamTest.java", "diffHunk": "@@ -1054,6 +1057,55 @@ public void testSearchWithCustomParamDraft() {\n \n \t}\n \n+\t@Test\n+\tpublic void testProgramaticallyContainedByReferenceAreStillResolvable() {\n+\t\tString sp = \"{\" +\n+\t\t\t\"\\\"resourceType\\\": \\\"SearchParameter\\\",\\n\" +\n+\t\t\t\"  \\\"id\\\": \\\"medicationadministration-ingredient-medication\\\",\\n\" +\n+\t\t\t\"  \\\"url\\\": \\\"http://hapifhir.io/fhir/StructureDefinition/sp-unique\\\",\\n\" +\n+\t\t\t\"  \\\"name\\\": \\\"MEDICATIONADMINISTRATION-INGREDIENT-MEDICATION\\\",\\n\" +\n+\t\t\t\"  \\\"status\\\": \\\"active\\\",\\n\" +\n+\t\t\t\"  \\\"code\\\": \\\"medicationadministration-ingredient-medication\\\",\\n\" +\n+\t\t\t\"  \\\"base\\\": [\\n\" +\n+\t\t\t\"    \\\"MedicationAdministration\\\"\\n\" +\n+\t\t\t\"  ],\\n\" +\n+\t\t\t\"  \\\"type\\\": \\\"token\\\",\\n\" +\n+\t\t\t\"  \\\"description\\\": \\\"This search parameter is used to find a MedicationAdministration by contained medication\\\",\\n\" +\n+\t\t\t\"  \\\"expression\\\": \\\"MedicationAdministration.medication.resolve().ingredient.item.as(Reference).resolve().code\\\",\\n\" +\n+\t\t\t\"  \\\"xpathUsage\\\": \\\"normal\\\"\\n\" +\n+\t\t\t\"}\\n\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNDEzNQ==", "bodyText": "Just laziness... fixing it now :)", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408504135", "createdAt": "2020-04-15T00:01:26Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoDstu3SearchCustomSearchParamTest.java", "diffHunk": "@@ -1054,6 +1057,55 @@ public void testSearchWithCustomParamDraft() {\n \n \t}\n \n+\t@Test\n+\tpublic void testProgramaticallyContainedByReferenceAreStillResolvable() {\n+\t\tString sp = \"{\" +\n+\t\t\t\"\\\"resourceType\\\": \\\"SearchParameter\\\",\\n\" +\n+\t\t\t\"  \\\"id\\\": \\\"medicationadministration-ingredient-medication\\\",\\n\" +\n+\t\t\t\"  \\\"url\\\": \\\"http://hapifhir.io/fhir/StructureDefinition/sp-unique\\\",\\n\" +\n+\t\t\t\"  \\\"name\\\": \\\"MEDICATIONADMINISTRATION-INGREDIENT-MEDICATION\\\",\\n\" +\n+\t\t\t\"  \\\"status\\\": \\\"active\\\",\\n\" +\n+\t\t\t\"  \\\"code\\\": \\\"medicationadministration-ingredient-medication\\\",\\n\" +\n+\t\t\t\"  \\\"base\\\": [\\n\" +\n+\t\t\t\"    \\\"MedicationAdministration\\\"\\n\" +\n+\t\t\t\"  ],\\n\" +\n+\t\t\t\"  \\\"type\\\": \\\"token\\\",\\n\" +\n+\t\t\t\"  \\\"description\\\": \\\"This search parameter is used to find a MedicationAdministration by contained medication\\\",\\n\" +\n+\t\t\t\"  \\\"expression\\\": \\\"MedicationAdministration.medication.resolve().ingredient.item.as(Reference).resolve().code\\\",\\n\" +\n+\t\t\t\"  \\\"xpathUsage\\\": \\\"normal\\\"\\n\" +\n+\t\t\t\"}\\n\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4MzU3MA=="}, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjAwMzM3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirSystemDaoR4Test.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMjo1Nzo1MFrOGFj3qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDowMjowMlrOGFlH8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mzc1Mw==", "bodyText": "I imagine this is a typo?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408483753", "createdAt": "2020-04-14T22:57:50Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirSystemDaoR4Test.java", "diffHunk": "@@ -645,7 +645,7 @@ public void testReindexingSingleStringHashIdentityValueIsDeleted() {\n \n \t\trunInTransaction(()->{\n \t\t\tLong i = myEntityManager\n-\t\t\t\t.createQuery(\"SELECT count(s) FROM ResourceIndexedSearchParamString s WHERE s.myHashIdentity IS null\", Long.class)\n+\t\t\t\t.createQuery(\"SELECT count(s) FROM ResourceIndexedSearchParamString s WHERE s.myHashIdentity IS nullhir\", Long.class)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNDMwNg==", "bodyText": "yyyyup", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408504306", "createdAt": "2020-04-15T00:02:02Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirSystemDaoR4Test.java", "diffHunk": "@@ -645,7 +645,7 @@ public void testReindexingSingleStringHashIdentityValueIsDeleted() {\n \n \t\trunInTransaction(()->{\n \t\t\tLong i = myEntityManager\n-\t\t\t\t.createQuery(\"SELECT count(s) FROM ResourceIndexedSearchParamString s WHERE s.myHashIdentity IS null\", Long.class)\n+\t\t\t\t.createQuery(\"SELECT count(s) FROM ResourceIndexedSearchParamString s WHERE s.myHashIdentity IS nullhir\", Long.class)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4Mzc1Mw=="}, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUzNjAyMTY3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-searchparam/src/main/java/ca/uhn/fhir/jpa/searchparam/extractor/SearchParamExtractorService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNFQyMzowNTo0N1rOGFkCSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwMDowNjoyNlrOGFlNOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NjQ3Mg==", "bodyText": "I am relatively lost as to whats going on in this function, but i understand this is a hack that will probably eventually be removed, so I'm good with it. May be worthwhile to document somewhere that this needs reworking", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408486472", "createdAt": "2020-04-14T23:05:47Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-searchparam/src/main/java/ca/uhn/fhir/jpa/searchparam/extractor/SearchParamExtractorService.java", "diffHunk": "@@ -90,8 +115,155 @@ public void extractFromResource(RequestDetails theRequestDetails, ResourceIndexe\n \t\tpopulateResourceTable(theParams.myUriParams, theEntity);\n \t\tpopulateResourceTable(theParams.myCoordsParams, theEntity);\n \t\tpopulateResourceTable(theParams.myTokenParams, theEntity);\n+\n+\t\ttheParams.setUpdatedTime(theUpdateTime);\n+\t}\n+\n+\t/**\n+\t * This is a bit hacky, but if someone has manually populated a resource (ie. my working directly with the model\n+\t * as opposed to by parsing a serialized instance) it's possible that they have put in contained resources\n+\t * using {@link IBaseReference#setResource(IBaseResource)}, and those contained resources have not yet\n+\t * ended up in the Resource.contained array, meaning that FHIRPath expressions won't be able to find them.\n+\t *\n+\t * As a result, we to a serialize-and-parse to normalize the object. This really only affects people who\n+\t * are calling the JPA DAOs directly, but there are a few of those...\n+\t */\n+\tprivate IBaseResource normalizeResource(IBaseResource theResource) {\n+\t\tIParser parser = myContext.newJsonParser().setPrettyPrint(false);\n+\t\ttheResource = parser.parseResource(parser.encodeResourceToString(theResource));\n+\t\treturn theResource;\n+\t}\n+\n+\tprivate void extractResourceLinks(ResourceIndexedSearchParams theParams, ResourceTable theEntity, IBaseResource theResource, Date theUpdateTime, IResourceLinkResolver theResourceLinkResolver, boolean theFailOnInvalidReference, RequestDetails theRequest) {\n+\t\tString resourceName = myContext.getResourceDefinition(theResource).getName();\n+\n+\t\tISearchParamExtractor.SearchParamSet<PathAndRef> refs = mySearchParamExtractor.extractResourceLinks(theResource);\n+\t\tSearchParamExtractorService.handleWarnings(theRequest, myInterceptorBroadcaster, refs);\n+\n+\t\tMap<String, IResourceLookup> resourceIdToResolvedTarget = new HashMap<>();\n+\t\tfor (PathAndRef nextPathAndRef : refs) {\n+\t\t\tRuntimeSearchParam searchParam = mySearchParamRegistry.getActiveSearchParam(resourceName, nextPathAndRef.getSearchParamName());\n+\t\t\textractResourceLinks(theParams, theEntity, theUpdateTime, theResourceLinkResolver, searchParam, nextPathAndRef, theFailOnInvalidReference, theRequest, resourceIdToResolvedTarget);\n+\t\t}\n+\n+\t\ttheEntity.setHasLinks(theParams.myLinks.size() > 0);\n+\t}\n+\n+\tprivate void extractResourceLinks(ResourceIndexedSearchParams theParams, ResourceTable theEntity, Date theUpdateTime, IResourceLinkResolver theResourceLinkResolver, RuntimeSearchParam theRuntimeSearchParam, PathAndRef thePathAndRef, boolean theFailOnInvalidReference, RequestDetails theRequest, Map<String, IResourceLookup> theResourceIdToResolvedTarget) {\n+\t\tIBaseReference nextReference = thePathAndRef.getRef();\n+\t\tIIdType nextId = nextReference.getReferenceElement();\n+\t\tString path = thePathAndRef.getPath();\n+\n+\t\t/*\n+\t\t * This can only really happen if the DAO is being called\n+\t\t * programmatically with a Bundle (not through the FHIR REST API)\n+\t\t * but Smile does this\n+\t\t */\n+\t\tif (nextId.isEmpty() && nextReference.getResource() != null) {\n+\t\t\tnextId = nextReference.getResource().getIdElement();\n+\t\t}\n+\n+\t\ttheParams.myPopulatedResourceLinkParameters.add(thePathAndRef.getSearchParamName());\n+\n+\t\tboolean canonical = thePathAndRef.isCanonical();\n+\t\tif (LogicalReferenceHelper.isLogicalReference(myModelConfig, nextId) || canonical) {\n+\t\t\tString value = nextId.getValue();\n+\t\t\tResourceLink resourceLink = ResourceLink.forLogicalReference(thePathAndRef.getPath(), theEntity, value, theUpdateTime);\n+\t\t\tif (theParams.myLinks.add(resourceLink)) {\n+\t\t\t\tourLog.debug(\"Indexing remote resource reference URL: {}\", nextId);\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tString baseUrl = nextId.getBaseUrl();\n+\t\tString typeString = nextId.getResourceType();\n+\t\tif (isBlank(typeString)) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Does not contain resource type - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tRuntimeResourceDefinition resourceDefinition;\n+\t\ttry {\n+\t\t\tresourceDefinition = myContext.getResourceDefinition(typeString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Resource type is unknown or not supported on this server - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (theRuntimeSearchParam.hasTargets()) {\n+\t\t\tif (!theRuntimeSearchParam.getTargets().contains(typeString)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (isNotBlank(baseUrl)) {\n+\t\t\tif (!myModelConfig.getTreatBaseUrlsAsLocal().contains(baseUrl) && !myModelConfig.isAllowExternalReferences()) {\n+\t\t\t\tString msg = myContext.getLocalizer().getMessage(BaseSearchParamExtractor.class, \"externalReferenceNotAllowed\", nextId.getValue());\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tResourceLink resourceLink = ResourceLink.forAbsoluteReference(thePathAndRef.getPath(), theEntity, nextId, theUpdateTime);\n+\t\t\t\tif (theParams.myLinks.add(resourceLink)) {\n+\t\t\t\t\tourLog.debug(\"Indexing remote resource reference URL: {}\", nextId);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tClass<? extends IBaseResource> type = resourceDefinition.getImplementingClass();\n+\t\tString id = nextId.getIdPart();\n+\t\tif (StringUtils.isBlank(id)) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Does not contain resource ID - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\ttheResourceLinkResolver.validateTypeOrThrowException(type);\n+\t\tResourceLink resourceLink = createResourceLink(theEntity, theUpdateTime, theResourceLinkResolver, theRuntimeSearchParam, path, thePathAndRef, nextId, typeString, type, nextReference, theRequest, theResourceIdToResolvedTarget);\n+\t\tif (resourceLink == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttheParams.myLinks.add(resourceLink);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 222}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODUwNTY1OA==", "bodyText": "This class is actually not going away.. I did some cleanup to turn two redundant services into one so that I wouldn't have to fix this bug in 2 places.\nI'm gonna reorganize a bit to make it more readable.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1801#discussion_r408505658", "createdAt": "2020-04-15T00:06:26Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-searchparam/src/main/java/ca/uhn/fhir/jpa/searchparam/extractor/SearchParamExtractorService.java", "diffHunk": "@@ -90,8 +115,155 @@ public void extractFromResource(RequestDetails theRequestDetails, ResourceIndexe\n \t\tpopulateResourceTable(theParams.myUriParams, theEntity);\n \t\tpopulateResourceTable(theParams.myCoordsParams, theEntity);\n \t\tpopulateResourceTable(theParams.myTokenParams, theEntity);\n+\n+\t\ttheParams.setUpdatedTime(theUpdateTime);\n+\t}\n+\n+\t/**\n+\t * This is a bit hacky, but if someone has manually populated a resource (ie. my working directly with the model\n+\t * as opposed to by parsing a serialized instance) it's possible that they have put in contained resources\n+\t * using {@link IBaseReference#setResource(IBaseResource)}, and those contained resources have not yet\n+\t * ended up in the Resource.contained array, meaning that FHIRPath expressions won't be able to find them.\n+\t *\n+\t * As a result, we to a serialize-and-parse to normalize the object. This really only affects people who\n+\t * are calling the JPA DAOs directly, but there are a few of those...\n+\t */\n+\tprivate IBaseResource normalizeResource(IBaseResource theResource) {\n+\t\tIParser parser = myContext.newJsonParser().setPrettyPrint(false);\n+\t\ttheResource = parser.parseResource(parser.encodeResourceToString(theResource));\n+\t\treturn theResource;\n+\t}\n+\n+\tprivate void extractResourceLinks(ResourceIndexedSearchParams theParams, ResourceTable theEntity, IBaseResource theResource, Date theUpdateTime, IResourceLinkResolver theResourceLinkResolver, boolean theFailOnInvalidReference, RequestDetails theRequest) {\n+\t\tString resourceName = myContext.getResourceDefinition(theResource).getName();\n+\n+\t\tISearchParamExtractor.SearchParamSet<PathAndRef> refs = mySearchParamExtractor.extractResourceLinks(theResource);\n+\t\tSearchParamExtractorService.handleWarnings(theRequest, myInterceptorBroadcaster, refs);\n+\n+\t\tMap<String, IResourceLookup> resourceIdToResolvedTarget = new HashMap<>();\n+\t\tfor (PathAndRef nextPathAndRef : refs) {\n+\t\t\tRuntimeSearchParam searchParam = mySearchParamRegistry.getActiveSearchParam(resourceName, nextPathAndRef.getSearchParamName());\n+\t\t\textractResourceLinks(theParams, theEntity, theUpdateTime, theResourceLinkResolver, searchParam, nextPathAndRef, theFailOnInvalidReference, theRequest, resourceIdToResolvedTarget);\n+\t\t}\n+\n+\t\ttheEntity.setHasLinks(theParams.myLinks.size() > 0);\n+\t}\n+\n+\tprivate void extractResourceLinks(ResourceIndexedSearchParams theParams, ResourceTable theEntity, Date theUpdateTime, IResourceLinkResolver theResourceLinkResolver, RuntimeSearchParam theRuntimeSearchParam, PathAndRef thePathAndRef, boolean theFailOnInvalidReference, RequestDetails theRequest, Map<String, IResourceLookup> theResourceIdToResolvedTarget) {\n+\t\tIBaseReference nextReference = thePathAndRef.getRef();\n+\t\tIIdType nextId = nextReference.getReferenceElement();\n+\t\tString path = thePathAndRef.getPath();\n+\n+\t\t/*\n+\t\t * This can only really happen if the DAO is being called\n+\t\t * programmatically with a Bundle (not through the FHIR REST API)\n+\t\t * but Smile does this\n+\t\t */\n+\t\tif (nextId.isEmpty() && nextReference.getResource() != null) {\n+\t\t\tnextId = nextReference.getResource().getIdElement();\n+\t\t}\n+\n+\t\ttheParams.myPopulatedResourceLinkParameters.add(thePathAndRef.getSearchParamName());\n+\n+\t\tboolean canonical = thePathAndRef.isCanonical();\n+\t\tif (LogicalReferenceHelper.isLogicalReference(myModelConfig, nextId) || canonical) {\n+\t\t\tString value = nextId.getValue();\n+\t\t\tResourceLink resourceLink = ResourceLink.forLogicalReference(thePathAndRef.getPath(), theEntity, value, theUpdateTime);\n+\t\t\tif (theParams.myLinks.add(resourceLink)) {\n+\t\t\t\tourLog.debug(\"Indexing remote resource reference URL: {}\", nextId);\n+\t\t\t}\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tString baseUrl = nextId.getBaseUrl();\n+\t\tString typeString = nextId.getResourceType();\n+\t\tif (isBlank(typeString)) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Does not contain resource type - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\t\tRuntimeResourceDefinition resourceDefinition;\n+\t\ttry {\n+\t\t\tresourceDefinition = myContext.getResourceDefinition(typeString);\n+\t\t} catch (DataFormatException e) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Resource type is unknown or not supported on this server - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (theRuntimeSearchParam.hasTargets()) {\n+\t\t\tif (!theRuntimeSearchParam.getTargets().contains(typeString)) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (isNotBlank(baseUrl)) {\n+\t\t\tif (!myModelConfig.getTreatBaseUrlsAsLocal().contains(baseUrl) && !myModelConfig.isAllowExternalReferences()) {\n+\t\t\t\tString msg = myContext.getLocalizer().getMessage(BaseSearchParamExtractor.class, \"externalReferenceNotAllowed\", nextId.getValue());\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tResourceLink resourceLink = ResourceLink.forAbsoluteReference(thePathAndRef.getPath(), theEntity, nextId, theUpdateTime);\n+\t\t\t\tif (theParams.myLinks.add(resourceLink)) {\n+\t\t\t\t\tourLog.debug(\"Indexing remote resource reference URL: {}\", nextId);\n+\t\t\t\t}\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\tClass<? extends IBaseResource> type = resourceDefinition.getImplementingClass();\n+\t\tString id = nextId.getIdPart();\n+\t\tif (StringUtils.isBlank(id)) {\n+\t\t\tString msg = \"Invalid resource reference found at path[\" + path + \"] - Does not contain resource ID - \" + nextId.getValue();\n+\t\t\tif (theFailOnInvalidReference) {\n+\t\t\t\tthrow new InvalidRequestException(msg);\n+\t\t\t} else {\n+\t\t\t\tourLog.debug(msg);\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t}\n+\n+\t\ttheResourceLinkResolver.validateTypeOrThrowException(type);\n+\t\tResourceLink resourceLink = createResourceLink(theEntity, theUpdateTime, theResourceLinkResolver, theRuntimeSearchParam, path, thePathAndRef, nextId, typeString, type, nextReference, theRequest, theResourceIdToResolvedTarget);\n+\t\tif (resourceLink == null) {\n+\t\t\treturn;\n+\t\t}\n+\t\ttheParams.myLinks.add(resourceLink);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODQ4NjQ3Mg=="}, "originalCommit": {"oid": "2bf30a98003d7d08d933823b673fbe0382cf44e1"}, "originalPosition": 222}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1937, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}