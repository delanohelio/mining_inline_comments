{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMDE4ODI0", "number": 2149, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoxNjoxOFrOEy1WHg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoyMjozNFrOEy1h3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzM4MjcwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoxNjoxOFrOHpsQvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjoxMToxM1rOHpyDEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODg0Nw==", "bodyText": "@fil512 What do you think about this implementation of converting match status -> MatchGrade? Since we are being forced to use these matchgrades here in the $match operation, how should these map to our internal assurance levels?", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513478847", "createdAt": "2020-10-28T14:16:18Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -74,25 +79,50 @@ public EmpiProviderR4(FhirContext theFhirContext, IEmpiControllerSvc theEmpiCont\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {\n+\t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n+\t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n+\t\tsearchComponent.setScore(next.getMatchResult().getNormalizedScore());\n+\n+\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n+\t\tif (next.isMatch()) {\n+\t\t\tmatchGrade = MatchGrade.CERTAIN;\n+\t\t} else if (next.isPossibleMatch()) {\n+\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n+\t\t}\n+\t\tsearchComponent.addExtension(\"http://hl7.org/fhir/StructureDefinition/match-grade\",\n+\t\t\tnew CodeType(matchGrade.toCode()));\n+\t\treturn searchComponent;\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3MzY1MQ==", "bodyText": "It looks like he implemented the mapping I requested", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513573651", "createdAt": "2020-10-28T16:11:13Z", "author": {"login": "fil512"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -74,25 +79,50 @@ public EmpiProviderR4(FhirContext theFhirContext, IEmpiControllerSvc theEmpiCont\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {\n+\t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n+\t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n+\t\tsearchComponent.setScore(next.getMatchResult().getNormalizedScore());\n+\n+\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n+\t\tif (next.isMatch()) {\n+\t\t\tmatchGrade = MatchGrade.CERTAIN;\n+\t\t} else if (next.isPossibleMatch()) {\n+\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n+\t\t}\n+\t\tsearchComponent.addExtension(\"http://hl7.org/fhir/StructureDefinition/match-grade\",\n+\t\t\tnew CodeType(matchGrade.toCode()));\n+\t\treturn searchComponent;\n+\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODg0Nw=="}, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzM5ODI1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoxOTo0MFrOHpsa1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOToxMjowMlrOHp5lgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MTQyOA==", "bodyText": "Are we certain these are ordered in terms of descending score? It looks to me as though these are just in returned order. The spec says: The response from an MPI $match operation is a set of patient records, ordered from most likely to least likely. . Can we add a test to prove this is the case? And if it isn't the case, add a sort to the list before returning? This can easily be done via a stream comparator before return", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513481428", "createdAt": "2020-10-28T14:19:40Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -77,20 +81,45 @@ public Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE,\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5NzE1Mw==", "bodyText": "Great catch, thank you, added sorting to the matched items", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513697153", "createdAt": "2020-10-28T19:12:02Z", "author": {"login": "nvg-smile"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -77,20 +81,45 @@ public Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE,\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MTQyOA=="}, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 56}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzQwNjY3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoyMToyMFrOHpsgJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOToxMjoxNFrOHp5l4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mjc4OQ==", "bodyText": "next is generally innapropriate unless it is directly involved in a loop. Since this is a helper function, i think a name like theMatchedTarget is better. Also, note the convention for naming of the hapi-fhir repository. Method params are prefixed with the, member variables are my, and static variables are our", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513482789", "createdAt": "2020-10-28T14:21:20Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -77,20 +81,45 @@ public Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE,\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5NzI1MA==", "bodyText": "Fixed, thank you for pointing out", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513697250", "createdAt": "2020-10-28T19:12:14Z", "author": {"login": "nvg-smile"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -77,20 +81,45 @@ public Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE,\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mjc4OQ=="}, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzQwOTE5OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoyMTo1MFrOHpshzg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxOToxMjoyM1rOHp5mLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MzIxNA==", "bodyText": "This String should be ripped into a server constant and reused across both implementations", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513483214", "createdAt": "2020-10-28T14:21:50Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -74,25 +79,50 @@ public EmpiProviderR4(FhirContext theFhirContext, IEmpiControllerSvc theEmpiCont\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {\n+\t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n+\t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n+\t\tsearchComponent.setScore(next.getMatchResult().getNormalizedScore());\n+\n+\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n+\t\tif (next.isMatch()) {\n+\t\t\tmatchGrade = MatchGrade.CERTAIN;\n+\t\t} else if (next.isPossibleMatch()) {\n+\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n+\t\t}\n+\t\tsearchComponent.addExtension(\"http://hl7.org/fhir/StructureDefinition/match-grade\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzY5NzMyNw==", "bodyText": "Done, thank you", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513697327", "createdAt": "2020-10-28T19:12:23Z", "author": {"login": "nvg-smile"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -74,25 +79,50 @@ public EmpiProviderR4(FhirContext theFhirContext, IEmpiControllerSvc theEmpiCont\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {\n+\t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n+\t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n+\t\tsearchComponent.setScore(next.getMatchResult().getNormalizedScore());\n+\n+\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n+\t\tif (next.isMatch()) {\n+\t\t\tmatchGrade = MatchGrade.CERTAIN;\n+\t\t} else if (next.isPossibleMatch()) {\n+\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n+\t\t}\n+\t\tsearchComponent.addExtension(\"http://hl7.org/fhir/StructureDefinition/match-grade\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MzIxNA=="}, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzQxMjc3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiMatchOutcome.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoyMjozNFrOHpskDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNjoxMTo0NlrOHpyEug==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mzc5MQ==", "bodyText": "@fil512 Would appreciate your input on this as well. I think this is correct for normalization, but this needs your eyes on it.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513483791", "createdAt": "2020-10-28T14:22:34Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiMatchOutcome.java", "diffHunk": "@@ -105,6 +105,21 @@ public EmpiMatchOutcome setEidMatch(boolean theEidMatch) {\n \t\treturn this;\n \t}\n \n+\t/**\n+\t * Gets normalized score that is in the range from zero to one\n+\t *\n+\t * @return\n+\t * \tReturns the normalized score\n+\t */\n+\tpublic Double getNormalizedScore() {\n+\t\tif (vector == 0) {\n+\t\t\treturn 0.0;\n+\t\t} else if (score > vector) {\n+\t\t\treturn 1.0;\n+\t\t}\n+\t\treturn score / vector;\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU3NDA3NA==", "bodyText": "Nick also checked with me on this ahead of time and it looks like the best option to me", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513574074", "createdAt": "2020-10-28T16:11:46Z", "author": {"login": "fil512"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiMatchOutcome.java", "diffHunk": "@@ -105,6 +105,21 @@ public EmpiMatchOutcome setEidMatch(boolean theEidMatch) {\n \t\treturn this;\n \t}\n \n+\t/**\n+\t * Gets normalized score that is in the range from zero to one\n+\t *\n+\t * @return\n+\t * \tReturns the normalized score\n+\t */\n+\tpublic Double getNormalizedScore() {\n+\t\tif (vector == 0) {\n+\t\t\treturn 0.0;\n+\t\t} else if (score > vector) {\n+\t\t\treturn 1.0;\n+\t\t}\n+\t\treturn score / vector;\n+\t}\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mzc5MQ=="}, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 18}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1823, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}