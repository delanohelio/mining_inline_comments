{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTExMDE4ODI0", "number": 2149, "title": "#2148 Initial implementation", "bodyText": "Updated EmpiProviderR4 match to include additional fields. Addresses #2148", "createdAt": "2020-10-27T19:55:02Z", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149", "merged": true, "mergeCommit": {"oid": "590d3c468bccd2ea4b34561b4f71c8a49a9525be"}, "closed": true, "closedAt": "2020-10-28T21:43:21Z", "author": {"login": "nvg-smile"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdWuco4gH2gAyNTExMDE4ODI0OjE3MGNmMjQ1Y2NjZGRiZjhjYWIzNTdiZDVlNzg5ZDgzZDRiMmM0ODM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdXCimpAFqTUxOTAwNDA1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483", "author": {"user": {"login": "nvg-smile", "name": "Nick Goupinets"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/170cf245cccddbf8cab357bd5e789d83d4b2c483", "committedDate": "2020-10-27T19:50:29Z", "message": "#2184 Initial implementation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE4NzEwMDQz", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#pullrequestreview-518710043", "createdAt": "2020-10-28T14:16:18Z", "commit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoxNjoxOFrOHpsQvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoyMjozNFrOHpskDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3ODg0Nw==", "bodyText": "@fil512 What do you think about this implementation of converting match status -> MatchGrade? Since we are being forced to use these matchgrades here in the $match operation, how should these map to our internal assurance levels?", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513478847", "createdAt": "2020-10-28T14:16:18Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -74,25 +79,50 @@ public EmpiProviderR4(FhirContext theFhirContext, IEmpiControllerSvc theEmpiCont\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {\n+\t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n+\t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n+\t\tsearchComponent.setScore(next.getMatchResult().getNormalizedScore());\n+\n+\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n+\t\tif (next.isMatch()) {\n+\t\t\tmatchGrade = MatchGrade.CERTAIN;\n+\t\t} else if (next.isPossibleMatch()) {\n+\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n+\t\t}\n+\t\tsearchComponent.addExtension(\"http://hl7.org/fhir/StructureDefinition/match-grade\",\n+\t\t\tnew CodeType(matchGrade.toCode()));\n+\t\treturn searchComponent;\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MTQyOA==", "bodyText": "Are we certain these are ordered in terms of descending score? It looks to me as though these are just in returned order. The spec says: The response from an MPI $match operation is a set of patient records, ordered from most likely to least likely. . Can we add a test to prove this is the case? And if it isn't the case, add a sort to the list before returning? This can easily be done via a stream comparator before return", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513481428", "createdAt": "2020-10-28T14:19:40Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -77,20 +81,45 @@ public Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE,\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mjc4OQ==", "bodyText": "next is generally innapropriate unless it is directly involved in a loop. Since this is a helper function, i think a name like theMatchedTarget is better. Also, note the convention for naming of the hapi-fhir repository. Method params are prefixed with the, member variables are my, and static variables are our", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513482789", "createdAt": "2020-10-28T14:21:20Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderDstu3.java", "diffHunk": "@@ -77,20 +81,45 @@ public Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE,\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MzIxNA==", "bodyText": "This String should be ripped into a server constant and reused across both implementations", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513483214", "createdAt": "2020-10-28T14:21:50Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/provider/EmpiProviderR4.java", "diffHunk": "@@ -74,25 +79,50 @@ public EmpiProviderR4(FhirContext theFhirContext, IEmpiControllerSvc theEmpiCont\n \t}\n \n \t@Operation(name = ProviderConstants.EMPI_MATCH, type = Patient.class)\n-\tpublic Bundle match(@OperationParam(name=ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n+\tpublic Bundle match(@OperationParam(name = ProviderConstants.EMPI_MATCH_RESOURCE, min = 1, max = 1) Patient thePatient) {\n \t\tif (thePatient == null) {\n \t\t\tthrow new InvalidRequestException(\"resource may not be null\");\n \t\t}\n \n-\t\tCollection<IAnyResource> matches = myEmpiMatchFinderSvc.findMatches(\"Patient\", thePatient);\n+\t\tList<MatchedTarget> matches = myEmpiMatchFinderSvc.getMatchedTargets(\"Patient\", thePatient);\n \n \t\tBundle retVal = new Bundle();\n \t\tretVal.setType(Bundle.BundleType.SEARCHSET);\n \t\tretVal.setId(UUID.randomUUID().toString());\n \t\tretVal.getMeta().setLastUpdatedElement(InstantType.now());\n \n-\t\tfor (IAnyResource next : matches) {\n-\t\t\tretVal.addEntry().setResource((Resource) next);\n+\t\tfor (MatchedTarget next : matches) {\n+\t\t\tboolean shouldKeepThisEntry = next.isMatch() || next.isPossibleMatch();\n+\t\t\tif (!shouldKeepThisEntry) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\n+\t\t\tBundle.BundleEntryComponent entry = new Bundle.BundleEntryComponent();\n+\t\t\tentry.setResource((Resource) next.getTarget());\n+\t\t\tentry.setSearch(toBundleEntrySearchComponent(next));\n+\n+\t\t\tretVal.addEntry(entry);\n \t\t}\n \n \t\treturn retVal;\n \t}\n \n+\tprivate Bundle.BundleEntrySearchComponent toBundleEntrySearchComponent(MatchedTarget next) {\n+\t\tBundle.BundleEntrySearchComponent searchComponent = new Bundle.BundleEntrySearchComponent();\n+\t\tsearchComponent.setMode(Bundle.SearchEntryMode.MATCH);\n+\t\tsearchComponent.setScore(next.getMatchResult().getNormalizedScore());\n+\n+\t\tMatchGrade matchGrade = MatchGrade.PROBABLE;\n+\t\tif (next.isMatch()) {\n+\t\t\tmatchGrade = MatchGrade.CERTAIN;\n+\t\t} else if (next.isPossibleMatch()) {\n+\t\t\tmatchGrade = MatchGrade.POSSIBLE;\n+\t\t}\n+\t\tsearchComponent.addExtension(\"http://hl7.org/fhir/StructureDefinition/match-grade\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mzc5MQ==", "bodyText": "@fil512 Would appreciate your input on this as well. I think this is correct for normalization, but this needs your eyes on it.", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#discussion_r513483791", "createdAt": "2020-10-28T14:22:34Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-server-empi/src/main/java/ca/uhn/fhir/empi/api/EmpiMatchOutcome.java", "diffHunk": "@@ -105,6 +105,21 @@ public EmpiMatchOutcome setEidMatch(boolean theEidMatch) {\n \t\treturn this;\n \t}\n \n+\t/**\n+\t * Gets normalized score that is in the range from zero to one\n+\t *\n+\t * @return\n+\t * \tReturns the normalized score\n+\t */\n+\tpublic Double getNormalizedScore() {\n+\t\tif (vector == 0) {\n+\t\t\treturn 0.0;\n+\t\t} else if (score > vector) {\n+\t\t\treturn 1.0;\n+\t\t}\n+\t\treturn score / vector;\n+\t}\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "170cf245cccddbf8cab357bd5e789d83d4b2c483"}, "originalPosition": 18}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "954fbf054ff36efc99b11fa107555a2e2da788e7", "author": {"user": {"login": "nvg-smile", "name": "Nick Goupinets"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/954fbf054ff36efc99b11fa107555a2e2da788e7", "committedDate": "2020-10-28T19:09:15Z", "message": "Fixed implementation based on the feedback."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTE5MDA0MDU4", "url": "https://github.com/hapifhir/hapi-fhir/pull/2149#pullrequestreview-519004058", "createdAt": "2020-10-28T19:15:06Z", "commit": {"oid": "954fbf054ff36efc99b11fa107555a2e2da788e7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3897, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}