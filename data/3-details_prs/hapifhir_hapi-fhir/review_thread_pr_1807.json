{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2MTE5NjM0", "number": 1807, "reviewThreads": {"totalCount": 53, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTozNTo1NFrODz7xUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTo1NzoyNFrOD0dKaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzgzMjQ5OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTozNTo1NFrOGIoskg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoxNzo0NVrOGJdzrw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwODU2Mg==", "bodyText": "I'm curious do you have a tool that checks when you can bump versions?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r411708562", "createdAt": "2020-04-20T21:35:54Z", "author": {"login": "fil512"}, "path": "pom.xml", "diffHunk": "@@ -641,7 +641,7 @@\n \t\t<!--<derby_version>10.15.1.3</derby_version>-->\n \t\t<error_prone_annotations_version>2.3.4</error_prone_annotations_version>\n \t\t<error_prone_core_version>2.3.3</error_prone_core_version>\n-\t\t<guava_version>28.0-jre</guava_version>\n+\t\t<guava_version>28.2-jre</guava_version>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MDc0Mw==", "bodyText": "Yup:\nmvn versions:display-dependency-updates -P ROOT", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412570743", "createdAt": "2020-04-21T23:55:05Z", "author": {"login": "jamesagnew"}, "path": "pom.xml", "diffHunk": "@@ -641,7 +641,7 @@\n \t\t<!--<derby_version>10.15.1.3</derby_version>-->\n \t\t<error_prone_annotations_version>2.3.4</error_prone_annotations_version>\n \t\t<error_prone_core_version>2.3.3</error_prone_core_version>\n-\t\t<guava_version>28.0-jre</guava_version>\n+\t\t<guava_version>28.2-jre</guava_version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwODU2Mg=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3ODczNQ==", "bodyText": "cool!  I added it to the wiki", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412578735", "createdAt": "2020-04-22T00:17:45Z", "author": {"login": "fil512"}, "path": "pom.xml", "diffHunk": "@@ -641,7 +641,7 @@\n \t\t<!--<derby_version>10.15.1.3</derby_version>-->\n \t\t<error_prone_annotations_version>2.3.4</error_prone_annotations_version>\n \t\t<error_prone_core_version>2.3.3</error_prone_core_version>\n-\t\t<guava_version>28.0-jre</guava_version>\n+\t\t<guava_version>28.2-jre</guava_version>", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwODU2Mg=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1NzgzODE0OnYy", "diffSide": "RIGHT", "path": "pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTozNzoyMFrOGIovwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMzo1NTozMVrOGJdU_A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwOTM3Nw==", "bodyText": "Cool!  Does this mean we can use Java 11 in our hapi tests now?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r411709377", "createdAt": "2020-04-20T21:37:20Z", "author": {"login": "fil512"}, "path": "pom.xml", "diffHunk": "@@ -1965,16 +1975,37 @@\n \t\t\t\t\t\t\t\t\t<version>3.3.9</version>\n \t\t\t\t\t\t\t\t</requireMavenVersion>\n \t\t\t\t\t\t\t\t<requireJavaVersion>\n-\t\t\t\t\t\t\t\t\t<version>1.8</version>\n+\t\t\t\t\t\t\t\t\t<version>11</version>\n \t\t\t\t\t\t\t\t\t<message>\n-\t\t\t\t\t\t\t\t\t\tThe hapi-fhir Maven build requires JDK version 1.8.x.\n+\t\t\t\t\t\t\t\t\t\tHAPI FHIR is still targeting JDK 8 for published binaries, but we require JDK 11", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MDg3Ng==", "bodyText": "Not yet, but this is a step in that direction. Need to figure out what I did in CDR too get IJ to recognize it..", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412570876", "createdAt": "2020-04-21T23:55:31Z", "author": {"login": "jamesagnew"}, "path": "pom.xml", "diffHunk": "@@ -1965,16 +1975,37 @@\n \t\t\t\t\t\t\t\t\t<version>3.3.9</version>\n \t\t\t\t\t\t\t\t</requireMavenVersion>\n \t\t\t\t\t\t\t\t<requireJavaVersion>\n-\t\t\t\t\t\t\t\t\t<version>1.8</version>\n+\t\t\t\t\t\t\t\t\t<version>11</version>\n \t\t\t\t\t\t\t\t\t<message>\n-\t\t\t\t\t\t\t\t\t\tThe hapi-fhir Maven build requires JDK version 1.8.x.\n+\t\t\t\t\t\t\t\t\t\tHAPI FHIR is still targeting JDK 8 for published binaries, but we require JDK 11", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcwOTM3Nw=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzg0NjA0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/api/IInterceptorService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTozOTozMVrOGIo0XQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDowMTowNlrOGJddBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDU1Nw==", "bodyText": "Consider using Predicate<Object> instead of Function<Object, Boolean>", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r411710557", "createdAt": "2020-04-20T21:39:31Z", "author": {"login": "fil512"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/api/IInterceptorService.java", "diffHunk": "@@ -90,4 +91,8 @@\n \n \tvoid registerInterceptors(@Nullable Collection<?> theInterceptors);\n \n+\t/**\n+\t * Unregisters all interceptors that are indicated by the given callback function returning <code>true</code>\n+\t */\n+\tvoid unregisterInterceptorsIf(Function<Object, Boolean> theShouldUnregisterFunction);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MjkzMw==", "bodyText": "good call, will do", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412572933", "createdAt": "2020-04-22T00:01:06Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/api/IInterceptorService.java", "diffHunk": "@@ -90,4 +91,8 @@\n \n \tvoid registerInterceptors(@Nullable Collection<?> theInterceptors);\n \n+\t/**\n+\t * Unregisters all interceptors that are indicated by the given callback function returning <code>true</code>\n+\t */\n+\tvoid unregisterInterceptorsIf(Function<Object, Boolean> theShouldUnregisterFunction);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMDU1Nw=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 15}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzg1NzgzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/api/Pointcut.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo0Mjo0OVrOGIo7Dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDowMjowNlrOGJdedQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMjI3MA==", "bodyText": "Fix javadoc.  No resource is being created here.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r411712270", "createdAt": "2020-04-20T21:42:49Z", "author": {"login": "fil512"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/api/Pointcut.java", "diffHunk": "@@ -1364,6 +1374,80 @@\n \t\t\"ca.uhn.fhir.rest.server.servlet.ServletRequestDetails\"\n \t),\n \n+\t/**\n+\t * <b>Storage Hook:</b>\n+\t * Invoked before FHIR <b>create</b> operation to request the identification of the partition ID to be associated\n+\t * with the resource being created. This hook will only be called if partitioning is enabled in the JPA\n+\t * server.\n+\t * <p>\n+\t * Hooks may accept the following parameters:\n+\t * </p>\n+\t * <ul>\n+\t * <li>\n+\t * org.hl7.fhir.instance.model.api.IBaseResource - The resource that will be created and needs a tenant ID assigned.\n+\t * </li>\n+\t * <li>\n+\t * ca.uhn.fhir.rest.api.server.RequestDetails - A bean containing details about the request that is about to be processed, including details such as the\n+\t * resource type and logical ID (if any) and other FHIR-specific aspects of the request which have been\n+\t * pulled out of the servlet request. Note that the bean\n+\t * properties are not all guaranteed to be populated, depending on how early during processing the\n+\t * exception occurred.\n+\t * </li>\n+\t * <li>\n+\t * ca.uhn.fhir.rest.server.servlet.ServletRequestDetails - A bean containing details about the request that is about to be processed, including details such as the\n+\t * resource type and logical ID (if any) and other FHIR-specific aspects of the request which have been\n+\t * pulled out of the servlet request. This parameter is identical to the RequestDetails parameter above but will\n+\t * only be populated when operating in a RestfulServer implementation. It is provided as a convenience.\n+\t * </li>\n+\t * </ul>\n+\t * <p>\n+\t * Hooks should return an instance of <code>ca.uhn.fhir.jpa.api.model.PartitionId</code> or <code>null</code>.\n+\t * </p>\n+\t */\n+\tSTORAGE_PARTITION_IDENTIFY_CREATE(\n+\t\t// Return type\n+\t\t\"ca.uhn.fhir.interceptor.model.PartitionId\",\n+\t\t// Params\n+\t\t\"org.hl7.fhir.instance.model.api.IBaseResource\",\n+\t\t\"ca.uhn.fhir.rest.api.server.RequestDetails\",\n+\t\t\"ca.uhn.fhir.rest.server.servlet.ServletRequestDetails\"\n+\t),\n+\n+\t/**\n+\t * <b>Storage Hook:</b>\n+\t * Invoked before FHIR read/access operation (e.g. <b>read/vread</b>, <b>search</b>, <b>history</b>, etc.) operation to request the\n+\t * identification of the partition ID to be associated with the resource being created. This hook will only be called if", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3MzMwMQ==", "bodyText": "will do", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412573301", "createdAt": "2020-04-22T00:02:06Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/api/Pointcut.java", "diffHunk": "@@ -1364,6 +1374,80 @@\n \t\t\"ca.uhn.fhir.rest.server.servlet.ServletRequestDetails\"\n \t),\n \n+\t/**\n+\t * <b>Storage Hook:</b>\n+\t * Invoked before FHIR <b>create</b> operation to request the identification of the partition ID to be associated\n+\t * with the resource being created. This hook will only be called if partitioning is enabled in the JPA\n+\t * server.\n+\t * <p>\n+\t * Hooks may accept the following parameters:\n+\t * </p>\n+\t * <ul>\n+\t * <li>\n+\t * org.hl7.fhir.instance.model.api.IBaseResource - The resource that will be created and needs a tenant ID assigned.\n+\t * </li>\n+\t * <li>\n+\t * ca.uhn.fhir.rest.api.server.RequestDetails - A bean containing details about the request that is about to be processed, including details such as the\n+\t * resource type and logical ID (if any) and other FHIR-specific aspects of the request which have been\n+\t * pulled out of the servlet request. Note that the bean\n+\t * properties are not all guaranteed to be populated, depending on how early during processing the\n+\t * exception occurred.\n+\t * </li>\n+\t * <li>\n+\t * ca.uhn.fhir.rest.server.servlet.ServletRequestDetails - A bean containing details about the request that is about to be processed, including details such as the\n+\t * resource type and logical ID (if any) and other FHIR-specific aspects of the request which have been\n+\t * pulled out of the servlet request. This parameter is identical to the RequestDetails parameter above but will\n+\t * only be populated when operating in a RestfulServer implementation. It is provided as a convenience.\n+\t * </li>\n+\t * </ul>\n+\t * <p>\n+\t * Hooks should return an instance of <code>ca.uhn.fhir.jpa.api.model.PartitionId</code> or <code>null</code>.\n+\t * </p>\n+\t */\n+\tSTORAGE_PARTITION_IDENTIFY_CREATE(\n+\t\t// Return type\n+\t\t\"ca.uhn.fhir.interceptor.model.PartitionId\",\n+\t\t// Params\n+\t\t\"org.hl7.fhir.instance.model.api.IBaseResource\",\n+\t\t\"ca.uhn.fhir.rest.api.server.RequestDetails\",\n+\t\t\"ca.uhn.fhir.rest.server.servlet.ServletRequestDetails\"\n+\t),\n+\n+\t/**\n+\t * <b>Storage Hook:</b>\n+\t * Invoked before FHIR read/access operation (e.g. <b>read/vread</b>, <b>search</b>, <b>history</b>, etc.) operation to request the\n+\t * identification of the partition ID to be associated with the resource being created. This hook will only be called if", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxMjI3MA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 88}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzg3MjM2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/executor/InterceptorService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo0NzowM1rOGIpDig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDowNDowOVrOGJdhHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNDQ0Mg==", "bodyText": "Less code this way:\ntheGlobalInvokers.entries().removeIf(entry -> theShouldUnregisterFunction(entry.getValue().getInterceptor()));", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r411714442", "createdAt": "2020-04-20T21:47:03Z", "author": {"login": "fil512"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/executor/InterceptorService.java", "diffHunk": "@@ -145,6 +146,22 @@ public void registerInterceptors(@Nullable Collection<?> theInterceptors) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void unregisterInterceptorsIf(Function<Object, Boolean> theShouldUnregisterFunction) {\n+\t\tunregisterInterceptorsIf(theShouldUnregisterFunction, myGlobalInvokers);\n+\t\tunregisterInterceptorsIf(theShouldUnregisterFunction, myAnonymousInvokers);\n+\t}\n+\n+\tprivate void unregisterInterceptorsIf(Function<Object, Boolean> theShouldUnregisterFunction, ListMultimap<Pointcut, BaseInvoker> theGlobalInvokers) {\n+\t\tfor (Iterator<Map.Entry<Pointcut, BaseInvoker>> iter = theGlobalInvokers.entries().iterator(); iter.hasNext(); ) {\n+\t\t\tMap.Entry<Pointcut, BaseInvoker> next = iter.next();\n+\t\t\tObject nextInterceptor = next.getValue().getInterceptor();\n+\t\t\tif (theShouldUnregisterFunction.apply(nextInterceptor)) {\n+\t\t\t\titer.remove();\n+\t\t\t}\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3Mzk4MA==", "bodyText": "thanks, done", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412573980", "createdAt": "2020-04-22T00:04:09Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/executor/InterceptorService.java", "diffHunk": "@@ -145,6 +146,22 @@ public void registerInterceptors(@Nullable Collection<?> theInterceptors) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic void unregisterInterceptorsIf(Function<Object, Boolean> theShouldUnregisterFunction) {\n+\t\tunregisterInterceptorsIf(theShouldUnregisterFunction, myGlobalInvokers);\n+\t\tunregisterInterceptorsIf(theShouldUnregisterFunction, myAnonymousInvokers);\n+\t}\n+\n+\tprivate void unregisterInterceptorsIf(Function<Object, Boolean> theShouldUnregisterFunction, ListMultimap<Pointcut, BaseInvoker> theGlobalInvokers) {\n+\t\tfor (Iterator<Map.Entry<Pointcut, BaseInvoker>> iter = theGlobalInvokers.entries().iterator(); iter.hasNext(); ) {\n+\t\t\tMap.Entry<Pointcut, BaseInvoker> next = iter.next();\n+\t\t\tObject nextInterceptor = next.getValue().getInterceptor();\n+\t\t\tif (theShouldUnregisterFunction.apply(nextInterceptor)) {\n+\t\t\t\titer.remove();\n+\t\t\t}\n+\t\t}\n+\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNDQ0Mg=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU1Nzg4MDU2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/model/PartitionId.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMFQyMTo0OToxN1rOGIpIEQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoxNTo0OVrOGJdxCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNTYwMQ==", "bodyText": "Consider renaming to PartitionIdRequest or PartitionIdParam", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r411715601", "createdAt": "2020-04-20T21:49:17Z", "author": {"login": "fil512"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/model/PartitionId.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package ca.uhn.fhir.interceptor.model;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Core Library\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.LocalDate;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+public class PartitionId {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3ODA1Ng==", "bodyText": "Changed to RequestPartitionId", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412578056", "createdAt": "2020-04-22T00:15:49Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-base/src/main/java/ca/uhn/fhir/interceptor/model/PartitionId.java", "diffHunk": "@@ -0,0 +1,106 @@\n+package ca.uhn.fhir.interceptor.model;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Core Library\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import javax.annotation.Nonnull;\n+import javax.annotation.Nullable;\n+import java.time.LocalDate;\n+\n+import static org.apache.commons.lang3.ObjectUtils.defaultIfNull;\n+\n+public class PartitionId {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTcxNTYwMQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDg4NjQ0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/java/ca/uhn/hapi/fhir/docs/PartitionExamples.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMjo0NzoxNlrOGJD2DA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyMjoxNVrOGJd59g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MzM1Ng==", "bodyText": "Is this the first time we're requesting a non-boolean from a callback?  I wonder if we need to consider any other concerns--e.g. any consequences for other languages we need to consider?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412153356", "createdAt": "2020-04-21T12:47:16Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/java/ca/uhn/hapi/fhir/docs/PartitionExamples.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package ca.uhn.hapi.fhir.docs;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Docs\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Interceptor;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.interceptor.model.PartitionId;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.rest.server.RestfulServer;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import ca.uhn.fhir.rest.server.tenant.UrlBaseTenantIdentificationStrategy;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.r4.model.Observation;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+@SuppressWarnings(\"InnerClassMayBeStatic\")\n+public class PartitionExamples {\n+\n+\tpublic void multitenantServer() {\n+\n+\t}\n+\n+\n+\t// START SNIPPET: partitionInterceptorRequestPartition\n+\t@Interceptor\n+\tpublic class RequestTenantPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_READ)\n+\t\tpublic PartitionId PartitionIdentifyRead(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\tprivate PartitionId extractPartitionIdFromRequest(ServletRequestDetails theRequestDetails) {\n+\t\t\t// We will use the tenant ID that came from the request as the partition name\n+\t\t\tString tenantId = theRequestDetails.getTenantId();\n+\t\t\treturn PartitionId.fromPartitionName(tenantId);\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorRequestPartition\n+\n+\n+\t// START SNIPPET: partitionInterceptorHeaders\n+\t@Interceptor\n+\tpublic class CustomHeaderBasedPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3ODQyOA==", "bodyText": "No, we've done this before.. E.g. for delete conflicts", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412578428", "createdAt": "2020-04-22T00:16:47Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/java/ca/uhn/hapi/fhir/docs/PartitionExamples.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package ca.uhn.hapi.fhir.docs;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Docs\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Interceptor;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.interceptor.model.PartitionId;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.rest.server.RestfulServer;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import ca.uhn.fhir.rest.server.tenant.UrlBaseTenantIdentificationStrategy;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.r4.model.Observation;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+@SuppressWarnings(\"InnerClassMayBeStatic\")\n+public class PartitionExamples {\n+\n+\tpublic void multitenantServer() {\n+\n+\t}\n+\n+\n+\t// START SNIPPET: partitionInterceptorRequestPartition\n+\t@Interceptor\n+\tpublic class RequestTenantPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_READ)\n+\t\tpublic PartitionId PartitionIdentifyRead(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\tprivate PartitionId extractPartitionIdFromRequest(ServletRequestDetails theRequestDetails) {\n+\t\t\t// We will use the tenant ID that came from the request as the partition name\n+\t\t\tString tenantId = theRequestDetails.getTenantId();\n+\t\t\treturn PartitionId.fromPartitionName(tenantId);\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorRequestPartition\n+\n+\n+\t// START SNIPPET: partitionInterceptorHeaders\n+\t@Interceptor\n+\tpublic class CustomHeaderBasedPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MzM1Ng=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDM0Mg==", "bodyText": "right!", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412580342", "createdAt": "2020-04-22T00:22:15Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/java/ca/uhn/hapi/fhir/docs/PartitionExamples.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package ca.uhn.hapi.fhir.docs;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Docs\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Interceptor;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.interceptor.model.PartitionId;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.rest.server.RestfulServer;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import ca.uhn.fhir.rest.server.tenant.UrlBaseTenantIdentificationStrategy;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.r4.model.Observation;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+@SuppressWarnings(\"InnerClassMayBeStatic\")\n+public class PartitionExamples {\n+\n+\tpublic void multitenantServer() {\n+\n+\t}\n+\n+\n+\t// START SNIPPET: partitionInterceptorRequestPartition\n+\t@Interceptor\n+\tpublic class RequestTenantPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_READ)\n+\t\tpublic PartitionId PartitionIdentifyRead(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\tprivate PartitionId extractPartitionIdFromRequest(ServletRequestDetails theRequestDetails) {\n+\t\t\t// We will use the tenant ID that came from the request as the partition name\n+\t\t\tString tenantId = theRequestDetails.getTenantId();\n+\t\t\treturn PartitionId.fromPartitionName(tenantId);\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorRequestPartition\n+\n+\n+\t// START SNIPPET: partitionInterceptorHeaders\n+\t@Interceptor\n+\tpublic class CustomHeaderBasedPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1MzM1Ng=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MDkyNzQ3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/java/ca/uhn/hapi/fhir/docs/PartitionExamples.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMjo1NTo1OFrOGJEOng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoxNzowNVrOGJdy7g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1OTY0Ng==", "bodyText": "Nice clear examples!", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412159646", "createdAt": "2020-04-21T12:55:58Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/java/ca/uhn/hapi/fhir/docs/PartitionExamples.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package ca.uhn.hapi.fhir.docs;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Docs\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Interceptor;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.interceptor.model.PartitionId;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.rest.server.RestfulServer;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import ca.uhn.fhir.rest.server.tenant.UrlBaseTenantIdentificationStrategy;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.r4.model.Observation;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+@SuppressWarnings(\"InnerClassMayBeStatic\")\n+public class PartitionExamples {\n+\n+\tpublic void multitenantServer() {\n+\n+\t}\n+\n+\n+\t// START SNIPPET: partitionInterceptorRequestPartition\n+\t@Interceptor\n+\tpublic class RequestTenantPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_READ)\n+\t\tpublic PartitionId PartitionIdentifyRead(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\tprivate PartitionId extractPartitionIdFromRequest(ServletRequestDetails theRequestDetails) {\n+\t\t\t// We will use the tenant ID that came from the request as the partition name\n+\t\t\tString tenantId = theRequestDetails.getTenantId();\n+\t\t\treturn PartitionId.fromPartitionName(tenantId);\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorRequestPartition\n+\n+\n+\t// START SNIPPET: partitionInterceptorHeaders\n+\t@Interceptor\n+\tpublic class CustomHeaderBasedPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {\n+\t\t\tString partitionName = theRequestDetails.getHeader(\"X-Partition-Name\");\n+\t\t\treturn PartitionId.fromPartitionName(partitionName);\n+\t\t}\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_READ)\n+\t\tpublic PartitionId PartitionIdentifyRead(ServletRequestDetails theRequestDetails) {\n+\t\t\tString partitionName = theRequestDetails.getHeader(\"X-Partition-Name\");\n+\t\t\treturn PartitionId.fromPartitionName(partitionName);\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorHeaders\n+\n+\n+\t// START SNIPPET: partitionInterceptorResourceContents\n+\t@Interceptor\n+\tpublic class ResourceTypePartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(IBaseResource theResource) {\n+\t\t\tif (theResource instanceof Patient) {\n+\t\t\t\treturn PartitionId.fromPartitionName(\"PATIENT\");\n+\t\t\t} else if (theResource instanceof Observation) {\n+\t\t\t\t\treturn PartitionId.fromPartitionName(\"OBSERVATION\");\n+\t\t\t} else {\n+\t\t\t\treturn PartitionId.fromPartitionName(\"OTHER\");\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorResourceContents\n+\n+\n+\t// START SNIPPET: multitenantServer\n+\tpublic class MultitenantServer extends RestfulServer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 108}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3ODU0Mg==", "bodyText": ":)", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412578542", "createdAt": "2020-04-22T00:17:05Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/java/ca/uhn/hapi/fhir/docs/PartitionExamples.java", "diffHunk": "@@ -0,0 +1,133 @@\n+package ca.uhn.hapi.fhir.docs;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR - Docs\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Interceptor;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.interceptor.model.PartitionId;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.rest.server.RestfulServer;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import ca.uhn.fhir.rest.server.tenant.UrlBaseTenantIdentificationStrategy;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.r4.model.Observation;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+@SuppressWarnings(\"InnerClassMayBeStatic\")\n+public class PartitionExamples {\n+\n+\tpublic void multitenantServer() {\n+\n+\t}\n+\n+\n+\t// START SNIPPET: partitionInterceptorRequestPartition\n+\t@Interceptor\n+\tpublic class RequestTenantPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_READ)\n+\t\tpublic PartitionId PartitionIdentifyRead(ServletRequestDetails theRequestDetails) {\n+\t\t\treturn extractPartitionIdFromRequest(theRequestDetails);\n+\t\t}\n+\n+\t\tprivate PartitionId extractPartitionIdFromRequest(ServletRequestDetails theRequestDetails) {\n+\t\t\t// We will use the tenant ID that came from the request as the partition name\n+\t\t\tString tenantId = theRequestDetails.getTenantId();\n+\t\t\treturn PartitionId.fromPartitionName(tenantId);\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorRequestPartition\n+\n+\n+\t// START SNIPPET: partitionInterceptorHeaders\n+\t@Interceptor\n+\tpublic class CustomHeaderBasedPartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(ServletRequestDetails theRequestDetails) {\n+\t\t\tString partitionName = theRequestDetails.getHeader(\"X-Partition-Name\");\n+\t\t\treturn PartitionId.fromPartitionName(partitionName);\n+\t\t}\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_READ)\n+\t\tpublic PartitionId PartitionIdentifyRead(ServletRequestDetails theRequestDetails) {\n+\t\t\tString partitionName = theRequestDetails.getHeader(\"X-Partition-Name\");\n+\t\t\treturn PartitionId.fromPartitionName(partitionName);\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorHeaders\n+\n+\n+\t// START SNIPPET: partitionInterceptorResourceContents\n+\t@Interceptor\n+\tpublic class ResourceTypePartitionInterceptor {\n+\n+\t\t@Hook(Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE)\n+\t\tpublic PartitionId PartitionIdentifyCreate(IBaseResource theResource) {\n+\t\t\tif (theResource instanceof Patient) {\n+\t\t\t\treturn PartitionId.fromPartitionName(\"PATIENT\");\n+\t\t\t} else if (theResource instanceof Observation) {\n+\t\t\t\t\treturn PartitionId.fromPartitionName(\"OBSERVATION\");\n+\t\t\t} else {\n+\t\t\t\treturn PartitionId.fromPartitionName(\"OTHER\");\n+\t\t\t}\n+\t\t}\n+\n+\t}\n+\t// END SNIPPET: partitionInterceptorResourceContents\n+\n+\n+\t// START SNIPPET: multitenantServer\n+\tpublic class MultitenantServer extends RestfulServer {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE1OTY0Ng=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 108}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTA2Nzg2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoyNDo0NVrOGJFjEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoyNDo0NVrOGJFjEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4MTI2Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n          \n          \n            \n            * Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to another tenant.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412181266", "createdAt": "2020-04-21T13:24:45Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTA3NDI3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoyNjowMVrOGJFm6Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoyNjowMVrOGJFm6Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4MjI0OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n          \n          \n            \n            * Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to support security groups, retention policies, etc.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412182249", "createdAt": "2020-04-21T13:26:01Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 11}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTA4NTk0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoyODoxM1rOGJFtpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzoyODoxM1rOGJFtpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4Mzk3NA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n          \n          \n            \n            When partitioning is used, these two columns will be populated with the same value for a given resource on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412183974", "createdAt": "2020-04-21T13:28:13Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTA5Nzg4OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozMDozM1rOGJF1IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozMDozM1rOGJF1IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4NTg4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n          \n          \n            \n            When a new resource is **created**, an [interceptor hook](#partition-interceptors) is invoked to request the partition ID and date to be assigned to the resource.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412185889", "createdAt": "2020-04-21T13:30:33Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTA5OTY3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozMTowMVrOGJF2dg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozMTowMVrOGJF2dg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4NjIzMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n          \n          \n            \n            When a resource is **updated**, the partition ID and date from the previous version will be used.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412186230", "createdAt": "2020-04-21T13:31:01Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTEyMDQ2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozNTowNlrOGJGDHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozNTowNlrOGJGDHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4OTQ2OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n          \n          \n            \n            * The system can be configured to operate as a **multitenant** solution by configuring the partition interceptor to scope all read operations to read data only from the partition that request has access to.```", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412189469", "createdAt": "2020-04-21T13:35:06Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTE0MDAxOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozODo1MFrOGJGO1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzozODo1MFrOGJGO1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5MjQ3MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n          \n          \n            \n            * The system can be configured to operate with logical segments by configuring the partition interceptor to scope read operations to access all partitions.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412192470", "createdAt": "2020-04-21T13:38:50Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTE0NTQ3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0MDowMFrOGJGSMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0MDowMFrOGJGSMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5MzMyOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Enabling partitioning on the server involves a set of steps.\n          \n          \n            \n            Follow these steps to enable partitioning on the server:", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412193328", "createdAt": "2020-04-21T13:40:00Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTE1MjQzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0MToxOVrOGJGWag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0MToxOVrOGJGWag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NDQxMA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n          \n          \n            \n            The [PartitionSettings](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionSettings.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionSettings.html#setPartitioningEnabled(boolean)) property should be enabled.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412194410", "createdAt": "2020-04-21T13:41:19Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTE2NDIzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0MzozNVrOGJGdlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzo0MTozMlrOGJ3FXA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NjI0NQ==", "bodyText": "The security comment doesn't make sense to me.  These hash values are not visible to the REST interface--they're only visible at the dao layer; and if someone already has access to the dao then they can see everything...?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412196245", "createdAt": "2020-04-21T13:43:35Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MDUyMg==", "bodyText": "It's not a cryptographic hash, and it's not salted, so if you know the tenant ID you could easily create artificial collisions on your own machine. Maybe in the future we will change this, but for now we definitely can't trust that someone couldn't reverse engineer a hash value because it would be relatively trivial to do.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412580522", "createdAt": "2020-04-22T00:22:49Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NjI0NQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk4MjM5MA==", "bodyText": "I still don't understand the concern.  The hash isn't exposed outside the dao layer, and if they have access to the dao layer, they have access to everything anyway.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412982390", "createdAt": "2020-04-22T13:28:39Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NjI0NQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5Mjg2MA==", "bodyText": "Let's say I know you have deployed a server in your own infrastructure and you've given me access to tenant 1, and Alice has access to tenant 2.\nI create a patient in my tenant with an identifier \"555\", and I get a row with a hash of \"1 + 'identifier' + 555\".\nAlice creates a patient in her tenant with an identifier \"123\", and she gets a row with a hash of \"2 + 'identifier' + 123\".\nNow let's say that for some reason I know that Alice has tenant ID 2 and that she has a Patient with identifier '123'. And I want to see her data even though I don't have access to it.\nAll I need to do in order to see the row is figure out some data to create that will have the same hash as 2 + 'identifier' + 123. I can recreate these exact conditions on my own test system so I know what the hash will be. Now it's just a matter of brute forcing combinations of search parameter names and identifiers until I find a hash collision.\nThere are lots of good defenses against this of course.. We just haven't implemented any yet.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412992860", "createdAt": "2020-04-22T13:41:32Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NjI0NQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 57}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTE2NjU0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0NDowMVrOGJGe7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0NDowMVrOGJGe7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NjU5MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            * **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n          \n          \n            \n            * **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition are allowed to create references to resources in other partitions.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412196591", "createdAt": "2020-04-21T13:44:01Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTE3MzI4OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0NToxNVrOGJGi4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyNTowMlrOGJd9uw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NzYwMQ==", "bodyText": "This is the setting that feels like it needs a \"carve out\" for 'lookup' resources like Patient & Organization.  Maybe we make an exception for references to resources in the default partition to support this?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412197601", "createdAt": "2020-04-21T13:45:15Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MTMwNw==", "bodyText": "I'm not against this necessarily but don't want to hold this PR up and I'm not actually sure that this is a good idea... need to thiink on it moore", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412581307", "createdAt": "2020-04-22T00:25:02Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5NzYwMQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTE4Mjg2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo0NzowMlrOGJGotg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyNTo1M1rOGJd-yQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5OTA5NA==", "bodyText": "I think the concept of multiple interceptor registries will continue to confuse people.  We will need to find a way to help make this easier for people--maybe a little validator that knows which cutpoints are used by which modules to verify they're registered in a module where they'll be called?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412199094", "createdAt": "2020-04-21T13:47:02Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MTU3Nw==", "bodyText": "Not a bad idea...", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412581577", "createdAt": "2020-04-22T00:25:53Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE5OTA5NA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 64}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTIwMzA0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo1MDo0N1rOGJG0vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo1MDo0N1rOGJG0vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIwMjE3NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n          \n          \n            \n            A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is created in order to determine the partition the resource is assigned to.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412202175", "createdAt": "2020-04-21T13:50:47Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).\n+\n+This interceptor can implement the hooks shown below.\n+\n+## Identify Partition for Create (Required)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 70}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTIwNzQ0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxMzo1MTozMlrOGJG3RA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyNzoxN1rOGJeAwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIwMjgyMA==", "bodyText": "What's a 'actpartitionInterceptorHeadersual'?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412202820", "createdAt": "2020-04-21T13:51:32Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).\n+\n+This interceptor can implement the hooks shown below.\n+\n+## Identify Partition for Create (Required)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+The criteria for determining the partition will depend on your use case. For example:\n+ \n+* If you are implementing multi-tenancy the partition might be determined by using the [Request Tenant ID](/docs/server_plain/multitenancy.html). It could also be determined by looking at request headers, or the authorized user/session context, etc.\n+\n+* If you are implementing segmented data partitioning, the partition might be determined by examining the actpartitionInterceptorHeadersual resource being created, by the identity of the sending system, etc.    ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MjA4MQ==", "bodyText": "heh... \"actual\" + some random copy-paste", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412582081", "createdAt": "2020-04-22T00:27:17Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).\n+\n+This interceptor can implement the hooks shown below.\n+\n+## Identify Partition for Create (Required)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+The criteria for determining the partition will depend on your use case. For example:\n+ \n+* If you are implementing multi-tenancy the partition might be determined by using the [Request Tenant ID](/docs/server_plain/multitenancy.html). It could also be determined by looking at request headers, or the authorized user/session context, etc.\n+\n+* If you are implementing segmented data partitioning, the partition might be determined by examining the actpartitionInterceptorHeadersual resource being created, by the identity of the sending system, etc.    ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIwMjgyMA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTQwMjcwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNDoyNjozNVrOGJItEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNDoyNjozNVrOGJItEA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjIzMjk3Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n          \n          \n            \n            A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is created in order to determine the partition to assign the resource to.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412232976", "createdAt": "2020-04-21T14:26:35Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).\n+\n+This interceptor can implement the hooks shown below.\n+\n+## Identify Partition for Create (Required)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+The criteria for determining the partition will depend on your use case. For example:\n+ \n+* If you are implementing multi-tenancy the partition might be determined by using the [Request Tenant ID](/docs/server_plain/multitenancy.html). It could also be determined by looking at request headers, or the authorized user/session context, etc.\n+\n+* If you are implementing segmented data partitioning, the partition might be determined by examining the actpartitionInterceptorHeadersual resource being created, by the identity of the sending system, etc.    \n+\n+## Identify Partition for Read (Optional)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 80}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTYxNTAwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTowMzo0NFrOGJKsvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTowMzo0NFrOGJKsvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTY2Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Partitioning is a relatively new feature in HAPI FHIR (added in HAPI FHIR 5.0.0) and has a number of known limitations. If you are intending to use partitioning for achieving a multi-tenant architecture it is important to carefully consider these limitations. \n          \n          \n            \n            Partitioning is a relatively new feature in HAPI FHIR (added in HAPI FHIR 5.0.0) and has a number of known limitations. If you are intending to use partitioning for achieving a multi-tenant architecture it is important to consider these limitations.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412265663", "createdAt": "2020-04-21T15:03:44Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).\n+\n+This interceptor can implement the hooks shown below.\n+\n+## Identify Partition for Create (Required)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+The criteria for determining the partition will depend on your use case. For example:\n+ \n+* If you are implementing multi-tenancy the partition might be determined by using the [Request Tenant ID](/docs/server_plain/multitenancy.html). It could also be determined by looking at request headers, or the authorized user/session context, etc.\n+\n+* If you are implementing segmented data partitioning, the partition might be determined by examining the actpartitionInterceptorHeadersual resource being created, by the identity of the sending system, etc.    \n+\n+## Identify Partition for Read (Optional)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+## Example: Partitioning based on Tenant ID\n+\n+The [RequestTenantPartitionInterceptor](/docs/interceptors/built_in_server_interceptors.html#request-tenant-partition-interceptor) uses the request tenant ID to determine the partition name. A simplified version of its source is shown below:\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorRequestPartition}}\n+```\n+\n+## Example: Partitioning based on headers\n+\n+If requests are coming from a trusted system, that system might be relied on to determine the partition for reads and writes.\n+\n+The following example shows a simple partition interceptor that determines the partition name by looking at a custom HTTP header:\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorHeaders}}\n+```\n+\n+## Example: Using Resource Contents\n+\n+When creating resources, the contents of the resource can also be factored into the decision on which tenant to use. The following example shows a very simple algorithm, placing resources into one of three partitions based on the resource type. Other contents in the resource could also be used instead.\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorResourceContents}}\n+```\n+\n+\n+# Complete Example: Using Request Tenants\n+\n+In order to achieve a multitenant configuration, the following configuration steps must be taken:\n+\n+* Partitioning must be enabled.\n+* A [Tenant Identification Strategy](/docs/server_plain/multitenancy.html) must be enabled on the RestfulServer.\n+* A [RequestTenantPartitionInterceptor](/docs/interceptors/built_in_server_interceptors.html#request-tenant-partition-interceptor) instance must be registered as an interceptor.\n+\n+Additionally, indexes will likely need to be tuned in order to support the partition-aware queries.\n+\n+The following snippet shows a server with this configuration.\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|multitenantServer}}\n+```\n+\n+<a name=\"partition-mapping-operations\"/>\n+\n+# Partition Mapping Operations\n+\n+Several operations exist that can be used to manage the existence of partitions. These operations are supplied by a [plain provider](/docs/server_plain/resource_providers.html#plain-providers) called [PartitionManagementProvider](/hapi-fhir/apidocs/hapi-fhir-jpaserver-base-javadoc/ca/uhn/fhir/jpa/partition/PartitionManagementProvider.html).\n+\n+Before a partition can be used, it must be registered using these methods.\n+\n+## Creating a Partition\n+\n+The `$partition-management-add-partition` operation can be used to create a new partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition. This value can be any integer, positive or negative or zero. It must not be a value that has already been used. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>name</td>\n+            <td>Code</td>\n+            <td>1..1</td>\n+            <td>\n+                A code (string) to assign to the partition. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>description</td>\n+            <td>String</td>\n+            <td>0..1</td>\n+            <td>\n+                An optional description for the partition. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-add-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  }, {\n+    \"name\": \"name\",\n+    \"valueCode\": \"PARTITION-123\"\n+  }, {\n+    \"name\": \"description\",\n+    \"valueString\": \"a description\"\n+  } ]\n+}\n+```\n+\n+## Updating a Partition\n+\n+The `$partition-management-update-partition` operation can be used to update an existing partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition to update. This ID must already exist. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>name</td>\n+            <td>Code</td>\n+            <td>1..1</td>\n+            <td>\n+                A code (string) to assign to the partition. Note that it is acceptable to change the name of a partition, but this should be done with caution since partition names may be referenced by URLs, caches, etc.\n+            </td>\n+        </tr>\n+        <tr>\n+            <td>description</td>\n+            <td>String</td>\n+            <td>0..1</td>\n+            <td>\n+                An optional description for the partition. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-add-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  }, {\n+    \"name\": \"name\",\n+    \"valueCode\": \"PARTITION-123\"\n+  }, {\n+    \"name\": \"description\",\n+    \"valueString\": \"a description\"\n+  } ]\n+}\n+```\n+\n+## Deleting a Partition\n+\n+The `$partition-management-delete-partition` operation can be used to delete an existing partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition to update. This ID must already exist. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-delete-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  } ]\n+}\n+```\n+\n+\n+# Limitations\n+\n+Partitioning is a relatively new feature in HAPI FHIR (added in HAPI FHIR 5.0.0) and has a number of known limitations. If you are intending to use partitioning for achieving a multi-tenant architecture it is important to carefully consider these limitations. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 315}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTYxNzA1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTowNDowN1rOGJKt9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTowNDowN1rOGJKt9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NTk3Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            None of the limitations listed here are considered permanent. Over time the HAPI FHIR team are hoping to make all of these features partition aware.\n          \n          \n            \n            None of the limitations listed here are considered permanent. Over time the HAPI FHIR team is hoping to make all of these features partition aware.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412265973", "createdAt": "2020-04-21T15:04:07Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).\n+\n+This interceptor can implement the hooks shown below.\n+\n+## Identify Partition for Create (Required)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+The criteria for determining the partition will depend on your use case. For example:\n+ \n+* If you are implementing multi-tenancy the partition might be determined by using the [Request Tenant ID](/docs/server_plain/multitenancy.html). It could also be determined by looking at request headers, or the authorized user/session context, etc.\n+\n+* If you are implementing segmented data partitioning, the partition might be determined by examining the actpartitionInterceptorHeadersual resource being created, by the identity of the sending system, etc.    \n+\n+## Identify Partition for Read (Optional)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+## Example: Partitioning based on Tenant ID\n+\n+The [RequestTenantPartitionInterceptor](/docs/interceptors/built_in_server_interceptors.html#request-tenant-partition-interceptor) uses the request tenant ID to determine the partition name. A simplified version of its source is shown below:\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorRequestPartition}}\n+```\n+\n+## Example: Partitioning based on headers\n+\n+If requests are coming from a trusted system, that system might be relied on to determine the partition for reads and writes.\n+\n+The following example shows a simple partition interceptor that determines the partition name by looking at a custom HTTP header:\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorHeaders}}\n+```\n+\n+## Example: Using Resource Contents\n+\n+When creating resources, the contents of the resource can also be factored into the decision on which tenant to use. The following example shows a very simple algorithm, placing resources into one of three partitions based on the resource type. Other contents in the resource could also be used instead.\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorResourceContents}}\n+```\n+\n+\n+# Complete Example: Using Request Tenants\n+\n+In order to achieve a multitenant configuration, the following configuration steps must be taken:\n+\n+* Partitioning must be enabled.\n+* A [Tenant Identification Strategy](/docs/server_plain/multitenancy.html) must be enabled on the RestfulServer.\n+* A [RequestTenantPartitionInterceptor](/docs/interceptors/built_in_server_interceptors.html#request-tenant-partition-interceptor) instance must be registered as an interceptor.\n+\n+Additionally, indexes will likely need to be tuned in order to support the partition-aware queries.\n+\n+The following snippet shows a server with this configuration.\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|multitenantServer}}\n+```\n+\n+<a name=\"partition-mapping-operations\"/>\n+\n+# Partition Mapping Operations\n+\n+Several operations exist that can be used to manage the existence of partitions. These operations are supplied by a [plain provider](/docs/server_plain/resource_providers.html#plain-providers) called [PartitionManagementProvider](/hapi-fhir/apidocs/hapi-fhir-jpaserver-base-javadoc/ca/uhn/fhir/jpa/partition/PartitionManagementProvider.html).\n+\n+Before a partition can be used, it must be registered using these methods.\n+\n+## Creating a Partition\n+\n+The `$partition-management-add-partition` operation can be used to create a new partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition. This value can be any integer, positive or negative or zero. It must not be a value that has already been used. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>name</td>\n+            <td>Code</td>\n+            <td>1..1</td>\n+            <td>\n+                A code (string) to assign to the partition. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>description</td>\n+            <td>String</td>\n+            <td>0..1</td>\n+            <td>\n+                An optional description for the partition. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-add-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  }, {\n+    \"name\": \"name\",\n+    \"valueCode\": \"PARTITION-123\"\n+  }, {\n+    \"name\": \"description\",\n+    \"valueString\": \"a description\"\n+  } ]\n+}\n+```\n+\n+## Updating a Partition\n+\n+The `$partition-management-update-partition` operation can be used to update an existing partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition to update. This ID must already exist. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>name</td>\n+            <td>Code</td>\n+            <td>1..1</td>\n+            <td>\n+                A code (string) to assign to the partition. Note that it is acceptable to change the name of a partition, but this should be done with caution since partition names may be referenced by URLs, caches, etc.\n+            </td>\n+        </tr>\n+        <tr>\n+            <td>description</td>\n+            <td>String</td>\n+            <td>0..1</td>\n+            <td>\n+                An optional description for the partition. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-add-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  }, {\n+    \"name\": \"name\",\n+    \"valueCode\": \"PARTITION-123\"\n+  }, {\n+    \"name\": \"description\",\n+    \"valueString\": \"a description\"\n+  } ]\n+}\n+```\n+\n+## Deleting a Partition\n+\n+The `$partition-management-delete-partition` operation can be used to delete an existing partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition to update. This ID must already exist. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-delete-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  } ]\n+}\n+```\n+\n+\n+# Limitations\n+\n+Partitioning is a relatively new feature in HAPI FHIR (added in HAPI FHIR 5.0.0) and has a number of known limitations. If you are intending to use partitioning for achieving a multi-tenant architecture it is important to carefully consider these limitations. \n+\n+None of the limitations listed here are considered permanent. Over time the HAPI FHIR team are hoping to make all of these features partition aware.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 317}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTYyODI2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTowNjowOFrOGJK0ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozMToyMFrOGJeGKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NzY3OA==", "bodyText": "Nice job with this list!  We'll likely need to add empi to this list once it's released.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412267678", "createdAt": "2020-04-21T15:06:08Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).\n+\n+This interceptor can implement the hooks shown below.\n+\n+## Identify Partition for Create (Required)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+The criteria for determining the partition will depend on your use case. For example:\n+ \n+* If you are implementing multi-tenancy the partition might be determined by using the [Request Tenant ID](/docs/server_plain/multitenancy.html). It could also be determined by looking at request headers, or the authorized user/session context, etc.\n+\n+* If you are implementing segmented data partitioning, the partition might be determined by examining the actpartitionInterceptorHeadersual resource being created, by the identity of the sending system, etc.    \n+\n+## Identify Partition for Read (Optional)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+## Example: Partitioning based on Tenant ID\n+\n+The [RequestTenantPartitionInterceptor](/docs/interceptors/built_in_server_interceptors.html#request-tenant-partition-interceptor) uses the request tenant ID to determine the partition name. A simplified version of its source is shown below:\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorRequestPartition}}\n+```\n+\n+## Example: Partitioning based on headers\n+\n+If requests are coming from a trusted system, that system might be relied on to determine the partition for reads and writes.\n+\n+The following example shows a simple partition interceptor that determines the partition name by looking at a custom HTTP header:\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorHeaders}}\n+```\n+\n+## Example: Using Resource Contents\n+\n+When creating resources, the contents of the resource can also be factored into the decision on which tenant to use. The following example shows a very simple algorithm, placing resources into one of three partitions based on the resource type. Other contents in the resource could also be used instead.\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorResourceContents}}\n+```\n+\n+\n+# Complete Example: Using Request Tenants\n+\n+In order to achieve a multitenant configuration, the following configuration steps must be taken:\n+\n+* Partitioning must be enabled.\n+* A [Tenant Identification Strategy](/docs/server_plain/multitenancy.html) must be enabled on the RestfulServer.\n+* A [RequestTenantPartitionInterceptor](/docs/interceptors/built_in_server_interceptors.html#request-tenant-partition-interceptor) instance must be registered as an interceptor.\n+\n+Additionally, indexes will likely need to be tuned in order to support the partition-aware queries.\n+\n+The following snippet shows a server with this configuration.\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|multitenantServer}}\n+```\n+\n+<a name=\"partition-mapping-operations\"/>\n+\n+# Partition Mapping Operations\n+\n+Several operations exist that can be used to manage the existence of partitions. These operations are supplied by a [plain provider](/docs/server_plain/resource_providers.html#plain-providers) called [PartitionManagementProvider](/hapi-fhir/apidocs/hapi-fhir-jpaserver-base-javadoc/ca/uhn/fhir/jpa/partition/PartitionManagementProvider.html).\n+\n+Before a partition can be used, it must be registered using these methods.\n+\n+## Creating a Partition\n+\n+The `$partition-management-add-partition` operation can be used to create a new partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition. This value can be any integer, positive or negative or zero. It must not be a value that has already been used. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>name</td>\n+            <td>Code</td>\n+            <td>1..1</td>\n+            <td>\n+                A code (string) to assign to the partition. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>description</td>\n+            <td>String</td>\n+            <td>0..1</td>\n+            <td>\n+                An optional description for the partition. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-add-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  }, {\n+    \"name\": \"name\",\n+    \"valueCode\": \"PARTITION-123\"\n+  }, {\n+    \"name\": \"description\",\n+    \"valueString\": \"a description\"\n+  } ]\n+}\n+```\n+\n+## Updating a Partition\n+\n+The `$partition-management-update-partition` operation can be used to update an existing partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition to update. This ID must already exist. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>name</td>\n+            <td>Code</td>\n+            <td>1..1</td>\n+            <td>\n+                A code (string) to assign to the partition. Note that it is acceptable to change the name of a partition, but this should be done with caution since partition names may be referenced by URLs, caches, etc.\n+            </td>\n+        </tr>\n+        <tr>\n+            <td>description</td>\n+            <td>String</td>\n+            <td>0..1</td>\n+            <td>\n+                An optional description for the partition. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-add-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  }, {\n+    \"name\": \"name\",\n+    \"valueCode\": \"PARTITION-123\"\n+  }, {\n+    \"name\": \"description\",\n+    \"valueString\": \"a description\"\n+  } ]\n+}\n+```\n+\n+## Deleting a Partition\n+\n+The `$partition-management-delete-partition` operation can be used to delete an existing partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition to update. This ID must already exist. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-delete-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  } ]\n+}\n+```\n+\n+\n+# Limitations\n+\n+Partitioning is a relatively new feature in HAPI FHIR (added in HAPI FHIR 5.0.0) and has a number of known limitations. If you are intending to use partitioning for achieving a multi-tenant architecture it is important to carefully consider these limitations. \n+\n+None of the limitations listed here are considered permanent. Over time the HAPI FHIR team are hoping to make all of these features partition aware.\n+\n+* **Server Capability Statement is not partition aware**: The server creates and exposes a single server capability statement, covering all partitions. This can be misleading when partitioning us used as a multitenancy strategy. \n+\n+* **Subscriptions may not be partitioned**: All subscriptions must be placed in the default partition, and subscribers will receive deliveries for any matching resources from all partitions.\n+\n+* **Conformance resources may not be partitioned**: The following resources must be placed in the default partition, and will be shared for any validation activities across all partitions:\n+   * StructureDefinition\n+   * Questionnaire\n+   * ValueSet\n+   * CodeSystem\n+   * ConceptMap\n+\n+* **Search Parameters are not partitioned**: There is only one set of SearchParameter resources for the entire system, and any search parameters will apply to resources in all partitions. All SearchParameter resources must be stored in the default partition.\n+   \n+* **Bulk Operations are not partition aware**: Bulk export operations will export data across all partitions.\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MzQ2Nw==", "bodyText": "ah true", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412583467", "createdAt": "2020-04-22T00:31:20Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/partitioning.md", "diffHunk": "@@ -0,0 +1,333 @@\n+# Partitioning and Multitenancy\n+\n+HAPI FHIR 5.0.0 introduced a new feature to HAPI FHIR JPA server called **Partitioning**.\n+\n+Partitioning allows each resource on the server to be placed in a partition, which is essentially just an arbitrary identifier grouping a set of resources together.\n+\n+Partitioning is designed to be very flexible, and can be used to achieve different outcomes. For example:\n+\n+* Partitioning could be used to achieve **multitenancy**, where there are multiple logically separate pools of resources on the server. Traditionally this kind of setup is desired when each of these pools belongs to a distinct user group / organization / customer / etc. (a \"tenant\"), and each of these tenants should not be able to access or modify data belonging to anther tenant.\n+\n+* Partitioning could also be used to **logically separate data coming from distinct sources** within an organization. For example, patient records might be placed in one partition, lab data sourced from a lab system might be placed in a second partition and patient surveys from a survey app might be placed in another. In this situation data does not need to be completely segregated (lab Observation records may have references to Patient records in the patient partition) but these partitions might be used to create security groups, retention policies, etc.\n+\n+* Partitioning could be used for **geographic sharding**, keeping data in a partition that is geographically closest to where it is likely to be used.\n+\n+These examples each have different properties in terms of security rules, and how data is organized and searched.\n+\n+# Architecture\n+\n+## Conceptual Architecture\n+\n+Partitioning in HAPI FHIR JPA means that every resource has a partition identity. This identity consists of the following attributes:\n+\n+* **Partition Name**: This is a short textual identifier for the partition that the resource belongs to. This might be a customer ID, a description of the type of data in the partition, or something else. There is no restriction on the text used aside from a maximum length of 200, but generally it makes sense to limit the text to URL-friendly characters.\n+\n+* **Partition ID**: This is an integer ID that corresponds 1:1 with the partition Name. It is used in the database as the partition identifier.   \n+\n+* **Partition Date**: This is an additional partition discriminator that can be used to implement partitioning strategies using a date axis.\n+\n+Mappings between the **Partition Name** and the **Partition ID** are maintained using the [Partition Mapping Operations](#partition-mapping-operations).\n+\n+## Logical Architecture\n+\n+At the database level, partitioning involves the use of two dedicated columns to many tables within the HAPI FHIR JPA [database schema](./schema.html):\n+\n+* **PARTITION_ID** &ndash; This is an integer indicating the specific partition that a given resource is placed in. This column can also be *NULL*, meaning that the given resource is in the **Default Partition**.\n+* **PARTITION_DATE** &ndash; This is a date/time column that can be assigned an arbitrary value depending on your use case. Typically, this would be used for use cases where data should be automatically dropped after a certain time period using native database partition drops. \n+\n+When partitioning is used, these two columns will be populated with the same value on all resource-specific tables (this includes [HFJ_RESOURCE](./schema.html#HFJ_RESOURCE) and all tables that have a foreign key relationship to it including [HFJ_RES_VER](./schema.html#HFJ_RES_VER), [HFJ_RESLINK](./schema.html#HFJ_RES_LINK), [HFJ_SPIDX_*](./schema.html#search-indexes), etc.)\n+\n+At the time that a resource is being **created**, an [interceptor hook](#partition-interceptors) is invoked in order to request the partition ID and date, and these will be written to the resource.\n+\n+At the time that a resource is being **updated**, the partition ID and date from the previous version will be used.\n+\n+When a **read operation** is being performed (e.g. a read, search, history, etc.), a separate [interceptor hook](#partition-interceptors) is invoked in order to determine whether the operation should target a specific partition. The outcome of this hook determines how the partitioning manifests itself to the end user: \n+\n+* If all read operations are scoped by the interceptor to only apply to a single partition, then the partitioning behaves as a **multitenant** solution.\n+* If read operations are scopes to all partitions, then the partitioning is simply partitioning the data into logical segments.\n+\n+# Enabling Partitioning in HAPI FHIR\n+\n+Enabling partitioning on the server involves a set of steps.\n+\n+The [PartitionConfig](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html) bean contains configuration settings related to partitioning within the server. To enable partitioning, the [setPartitioningEnabled(boolean)](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setPartitioningEnabled(boolean)) property should be enabled.\n+\n+The following settings can be enabled:\n+\n+* **Include Partition in Search Hashes** ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setIncludePartitionInSearchHashes(boolean))): If this feature is enabled, partition IDs will be factored into [Search Hashes](./schema.html#search-hashes). When this flag is not set (as is the default), when a search requests a specific partition, an additional SQL WHERE predicate is added to the query to explicitly request the given partition ID. When this flag is set, this additional WHERE predicate is not necessary since the partition is factored into the hash value being searched on. Setting this flag avoids the need to manually adjust indexes against the HFJ_SPIDX tables. Note that this flag should **not be used in environments where partitioning is being used for security purposes**, since it is possible for a user to reverse engineer false hash collisions.\n+\n+* **Cross-Partition Reference Mode**: ([JavaDoc](/apidocs/hapi-fhir-jpaserver-model/ca/uhn/fhir/jpa/model/config/PartitionConfig.html#setAllowReferencesAcrossPartitions(ca.uhn.fhir.jpa.model.config.PartitionSettings.CrossPartitionReferenceMode))): This setting controls whether resources in one partition should be allowed to create references to resources in other partitions.\n+\n+\n+# Partition Interceptors\n+\n+In order to implement partitioning, an interceptor must be registered against the interceptor registry (either the REST Server registry, or the JPA Server registry will work).\n+\n+This interceptor can implement the hooks shown below.\n+\n+## Identify Partition for Create (Required)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+The criteria for determining the partition will depend on your use case. For example:\n+ \n+* If you are implementing multi-tenancy the partition might be determined by using the [Request Tenant ID](/docs/server_plain/multitenancy.html). It could also be determined by looking at request headers, or the authorized user/session context, etc.\n+\n+* If you are implementing segmented data partitioning, the partition might be determined by examining the actpartitionInterceptorHeadersual resource being created, by the identity of the sending system, etc.    \n+\n+## Identify Partition for Read (Optional)\n+\n+A hook against the [`Pointcut.STORAGE_PARTITION_IDENTIFY_CREATE`](/apidocs/hapi-fhir-base/ca/uhn/fhir/interceptor/api/Pointcut.html#STORAGE_PARTITION_IDENTIFY_CREATE) pointcut must be registered, and this hook method will be invoked every time a resource is being created in order to determine the partition to create the resource in.\n+\n+## Example: Partitioning based on Tenant ID\n+\n+The [RequestTenantPartitionInterceptor](/docs/interceptors/built_in_server_interceptors.html#request-tenant-partition-interceptor) uses the request tenant ID to determine the partition name. A simplified version of its source is shown below:\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorRequestPartition}}\n+```\n+\n+## Example: Partitioning based on headers\n+\n+If requests are coming from a trusted system, that system might be relied on to determine the partition for reads and writes.\n+\n+The following example shows a simple partition interceptor that determines the partition name by looking at a custom HTTP header:\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorHeaders}}\n+```\n+\n+## Example: Using Resource Contents\n+\n+When creating resources, the contents of the resource can also be factored into the decision on which tenant to use. The following example shows a very simple algorithm, placing resources into one of three partitions based on the resource type. Other contents in the resource could also be used instead.\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|partitionInterceptorResourceContents}}\n+```\n+\n+\n+# Complete Example: Using Request Tenants\n+\n+In order to achieve a multitenant configuration, the following configuration steps must be taken:\n+\n+* Partitioning must be enabled.\n+* A [Tenant Identification Strategy](/docs/server_plain/multitenancy.html) must be enabled on the RestfulServer.\n+* A [RequestTenantPartitionInterceptor](/docs/interceptors/built_in_server_interceptors.html#request-tenant-partition-interceptor) instance must be registered as an interceptor.\n+\n+Additionally, indexes will likely need to be tuned in order to support the partition-aware queries.\n+\n+The following snippet shows a server with this configuration.\n+\n+```java\n+{{snippet:classpath:/ca/uhn/hapi/fhir/docs/PartitionExamples.java|multitenantServer}}\n+```\n+\n+<a name=\"partition-mapping-operations\"/>\n+\n+# Partition Mapping Operations\n+\n+Several operations exist that can be used to manage the existence of partitions. These operations are supplied by a [plain provider](/docs/server_plain/resource_providers.html#plain-providers) called [PartitionManagementProvider](/hapi-fhir/apidocs/hapi-fhir-jpaserver-base-javadoc/ca/uhn/fhir/jpa/partition/PartitionManagementProvider.html).\n+\n+Before a partition can be used, it must be registered using these methods.\n+\n+## Creating a Partition\n+\n+The `$partition-management-add-partition` operation can be used to create a new partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition. This value can be any integer, positive or negative or zero. It must not be a value that has already been used. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>name</td>\n+            <td>Code</td>\n+            <td>1..1</td>\n+            <td>\n+                A code (string) to assign to the partition. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>description</td>\n+            <td>String</td>\n+            <td>0..1</td>\n+            <td>\n+                An optional description for the partition. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-add-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  }, {\n+    \"name\": \"name\",\n+    \"valueCode\": \"PARTITION-123\"\n+  }, {\n+    \"name\": \"description\",\n+    \"valueString\": \"a description\"\n+  } ]\n+}\n+```\n+\n+## Updating a Partition\n+\n+The `$partition-management-update-partition` operation can be used to update an existing partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition to update. This ID must already exist. \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>name</td>\n+            <td>Code</td>\n+            <td>1..1</td>\n+            <td>\n+                A code (string) to assign to the partition. Note that it is acceptable to change the name of a partition, but this should be done with caution since partition names may be referenced by URLs, caches, etc.\n+            </td>\n+        </tr>\n+        <tr>\n+            <td>description</td>\n+            <td>String</td>\n+            <td>0..1</td>\n+            <td>\n+                An optional description for the partition. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-add-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  }, {\n+    \"name\": \"name\",\n+    \"valueCode\": \"PARTITION-123\"\n+  }, {\n+    \"name\": \"description\",\n+    \"valueString\": \"a description\"\n+  } ]\n+}\n+```\n+\n+## Deleting a Partition\n+\n+The `$partition-management-delete-partition` operation can be used to delete an existing partition. This operation takes the following parameters:\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Type</th>\n+            <th>Cardinality</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>id</td>\n+            <td>Integer</td>\n+            <td>1..1</td>\n+            <td>\n+                The numeric ID for the partition to update. This ID must already exist. \n+            </td>\n+        </tr>\n+    </tbody>\n+</table>\n+\n+### Example\n+\n+The following URL would be used to invoke this operation:\n+\n+```url\n+POST http://example.com/$partition-management-delete-partition \n+```\n+\n+The following request body could be used:\n+\n+```json\n+{\n+  \"resourceType\": \"Parameters\",\n+  \"parameter\": [ {\n+    \"name\": \"id\",\n+    \"valueInteger\": 123\n+  } ]\n+}\n+```\n+\n+\n+# Limitations\n+\n+Partitioning is a relatively new feature in HAPI FHIR (added in HAPI FHIR 5.0.0) and has a number of known limitations. If you are intending to use partitioning for achieving a multi-tenant architecture it is important to carefully consider these limitations. \n+\n+None of the limitations listed here are considered permanent. Over time the HAPI FHIR team are hoping to make all of these features partition aware.\n+\n+* **Server Capability Statement is not partition aware**: The server creates and exposes a single server capability statement, covering all partitions. This can be misleading when partitioning us used as a multitenancy strategy. \n+\n+* **Subscriptions may not be partitioned**: All subscriptions must be placed in the default partition, and subscribers will receive deliveries for any matching resources from all partitions.\n+\n+* **Conformance resources may not be partitioned**: The following resources must be placed in the default partition, and will be shared for any validation activities across all partitions:\n+   * StructureDefinition\n+   * Questionnaire\n+   * ValueSet\n+   * CodeSystem\n+   * ConceptMap\n+\n+* **Search Parameters are not partitioned**: There is only one set of SearchParameter resources for the entire system, and any search parameters will apply to resources in all partitions. All SearchParameter resources must be stored in the default partition.\n+   \n+* **Bulk Operations are not partition aware**: Bulk export operations will export data across all partitions.\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI2NzY3OA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 333}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTY0ODY0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/schema.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTowOTo0MVrOGJLAmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozMjoyMVrOGJeHrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MDc0Nw==", "bodyText": "Maybe mention that they can see the SQL data types in the sql schemas", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412270747", "createdAt": "2020-04-21T15:09:41Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/schema.md", "diffHunk": "@@ -0,0 +1,525 @@\n+# HAPI FHIR JPA Schema\n+\n+**This page is a work in progress. It is not yet comprehensive.**\n+\n+It contains a description of the tables within the HAPI FHIR JPA database. Note that columns are shown using Java datatypes as opposed to SQL datatypes, because the exact SQL datatype used will vary depending on the underlying database platform. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4Mzg1Mg==", "bodyText": "done", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412583852", "createdAt": "2020-04-22T00:32:21Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/schema.md", "diffHunk": "@@ -0,0 +1,525 @@\n+# HAPI FHIR JPA Schema\n+\n+**This page is a work in progress. It is not yet comprehensive.**\n+\n+It contains a description of the tables within the HAPI FHIR JPA database. Note that columns are shown using Java datatypes as opposed to SQL datatypes, because the exact SQL datatype used will vary depending on the underlying database platform. ", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI3MDc0Nw=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTcyNzgzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/schema.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyNDowNVrOGJLv8Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyNDowNVrOGJLv8Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4Mjg2NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            However, when client-assigned IDs are used, these may contain text values in order to allow a client to create an ID such as `Patient/ABC`. When a client-assigned ID is given to a resource, a row is created in the **HFJ_RESOURCE** table. When an **HFJ_FORCED_ID** row exists corresponding to the equivalent **HFJ_RESOURCE** row, the RES_ID value is no longer visible or usable by FHIR clients and it becomes purely an internal ID to the JPA server.\n          \n          \n            \n            However, when client-assigned IDs are used, these may contain text values to allow a client to create an ID such as `Patient/ABC`. When a client-assigned ID is given to a resource, a row is created in the **HFJ_RESOURCE** table. When an **HFJ_FORCED_ID** row exists corresponding to the equivalent **HFJ_RESOURCE** row, the RES_ID value is no longer visible or usable by FHIR clients and it becomes purely an internal ID to the JPA server.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412282865", "createdAt": "2020-04-21T15:24:05Z", "author": {"login": "fil512"}, "path": "hapi-fhir-docs/src/main/resources/ca/uhn/hapi/fhir/docs/server_jpa/schema.md", "diffHunk": "@@ -0,0 +1,525 @@\n+# HAPI FHIR JPA Schema\n+\n+**This page is a work in progress. It is not yet comprehensive.**\n+\n+It contains a description of the tables within the HAPI FHIR JPA database. Note that columns are shown using Java datatypes as opposed to SQL datatypes, because the exact SQL datatype used will vary depending on the underlying database platform. \n+\n+# Background: Persistent IDs (PIDs)\n+\n+The HAPI FHIR JPA schema relies heavily on the concept of internal persistent IDs on tables, using a Java type of Long (8-byte integer, which translates to an *int8* or *number(19)* on various database platforms).\n+\n+Many tables use an internal persistent ID as their primary key, allowing the flexibility for other more complex business identifiers to be changed and minimizing the amount of data consumed by foreign key relationships. These persistent ID columns are generally assigned using a dedicated database sequence on platforms which support sequences.\n+\n+The persistent ID column is generally called `PID` in the database schema, although there are exceptions.\n+\n+<a name=\"HFJ_RESOURCE\"/>\n+\n+# HFJ_RESOURCE: Resource Master Table\n+\n+<img src=\"/hapi-fhir/docs/images/jpa_erd_resources.svg\" alt=\"Resources\" style=\"width: 100%; max-width: 600px;\"/>\n+\n+The HFJ_RESOURCE table indicates a single resource of any type in the database. For example, the resource `Patient/1` will have exactly one row in this table, representing all versions of the resource.\n+\n+## Columns\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Relationships</th>\n+            <th>Datatype</th>\n+            <th>Nullable</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>PARTITION_ID</td>\n+            <td></td>\n+            <td>Integer</td>\n+            <td>Nullable</td>\n+            <td>\n+                This is the optional partition ID, if the resource is in a partition. See <a href=\"./partitioning.html\">Partitioning</a>.  \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>PARTITION_DATE</td>\n+            <td></td>\n+            <td>Timestamp</td>\n+            <td>Nullable</td>\n+            <td>\n+                This is the optional partition date, if the resource is in a partition. See <a href=\"./partitioning.html\">Partitioning</a>.  \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>RES_VER</td>\n+            <td></td>\n+            <td>Long</td>\n+            <td></td>\n+            <td>\n+                This is the current version ID of the resource. Will contain <code>1</code> when the resource is first\n+                created, <code>2</code> the first time it is updated, etc.  \n+                This column is equivalent to the <b>HFJ_RES_VER.RES_VER</b>\n+                column, although it does not have a foreign-key dependency in order to allow selective expunge of versions\n+                when necessary. Not to be confused with <b>RES_VERSION</b> below.   \n+            </td>\n+        </tr>\n+        <tr>\n+            <td>RES_VERSION</td>\n+            <td></td>\n+            <td>String</td>\n+            <td></td>\n+            <td>\n+                This column contains the FHIR version associated with this resource, using a constant drawn\n+                from <a href=\"/hapi-fhir/apidocs/hapi-fhir-base/ca/uhn/fhir/context/FhirVersionEnum.html\">FhirVersionEnum</a>.\n+                Not to be confused with <b>RES_VER</b> above.\n+            </td>\n+        </tr>\n+        <tr>\n+            <td>RES_TYPE</td>\n+            <td></td>\n+            <td>String</td>\n+            <td></td>\n+            <td>\n+                Contains the resource type (e.g. <code>Patient</code>) \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>HASH_SHA256</td>\n+            <td></td>\n+            <td>Long</td>\n+            <td></td>\n+            <td>\n+                This column contains a SHA-256 hash of the current resource contents, exclusive of resource metadata.\n+                This is used in order to detect NO-OP writes to the resource. \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>RES_PUBLISHED</td>\n+            <td></td>\n+            <td>Timestamp</td>\n+            <td></td>\n+            <td>\n+                Contains the date that the first version of the resource was created. \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>RES_UPDATED</td>\n+            <td></td>\n+            <td>Timestamp</td>\n+            <td></td>\n+            <td>\n+                Contains the date that the most recent version of the resource was created. \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>RES_DELETED_AT</td>\n+            <td></td>\n+            <td>Timestamp</td>\n+            <td>Nullable</td>\n+            <td>\n+                If the most recent version of the resource is a delete, this contains the timestamp at which \n+                the resource was deleted. Otherwise, contains <i>NULL</i>. \n+            </td>        \n+        </tr>\n+    </tbody>\n+</table>\n+\n+\n+\n+<a name=\"HFJ_RES_VER\"/>\n+\n+# HFJ_RES_VER: Resource Versions and Contents\n+\n+The HFJ_RES_VER table contains individual versions of a resource. If the resource `Patient/1` has 3 versions, there will be 3 rows in this table.\n+\n+The complete raw contents of the resource is stored in the `RES_TEXT` column, using the encoding specified in the `RES_ENCODING` column.\n+\n+## Columns\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Name</th>\n+            <th>Relationships</th>\n+            <th>Datatype</th>\n+            <th>Nullable</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>PARTITION_ID</td>\n+            <td></td>\n+            <td>Integer</td>\n+            <td>Nullable</td>\n+            <td>\n+                This is the optional partition ID, if the resource is in a partition. See <a href=\"./partitioning.html\">Partitioning</a>.  \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>PARTITION_DATE</td>\n+            <td></td>\n+            <td>Timestamp</td>\n+            <td>Nullable</td>\n+            <td>\n+                This is the optional partition date, if the resource is in a partition. See <a href=\"./partitioning.html\">Partitioning</a>.  \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>PID</td>\n+            <td>PK</td>\n+            <td>Long</td>\n+            <td></td>\n+            <td>\n+                This is the row persistent ID.  \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>RES_ID</td>\n+            <td>FK to <a href=\"#HFJ_RESOURCE\">HFJ_RESOURCE</a></td>\n+            <td>Long</td>\n+            <td></td>\n+            <td>\n+                This is the persistent ID of the resource being versioned.\n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>RES_VER</td>\n+            <td></td>\n+            <td>Long</td>\n+            <td></td>\n+            <td>\n+                Contains the specific version (starting with 1) of the resource that this row corresponds to. \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>RES_ENCODING</td>\n+            <td></td>\n+            <td>String</td>\n+            <td></td>\n+            <td>\n+                Describes the encoding of the resource being used to store this resource in <b>RES_TEXT</b>. See\n+                <i>Encodings</i> below for allowable values. \n+            </td>        \n+        </tr>\n+        <tr>\n+            <td>RES_TEXT</td>\n+            <td></td>\n+            <td>byte[]</td>\n+            <td></td>\n+            <td>\n+                Contains the actual full text of the resource being stored. \n+            </td>        \n+        </tr>\n+    </tbody>\n+</table>\n+\n+## Encodings\n+\n+<table class=\"table table-striped table-condensed\">\n+    <thead>\n+        <tr>\n+            <th>Value</th>\n+            <th>Description</th>\n+        </tr>\n+    </thead>\n+    <tbody>\n+        <tr>\n+            <td>JSONC</td>\n+            <td>\n+                The resource is serialized using FHIR JSON encoding, and then compressed into a byte stream using GZIP compression. \n+            </td>        \n+        </tr>\n+    </tbody>\n+</table>     \n+\n+<a name=\"HFJ_FORCED_ID\"/>\n+\n+# HFJ_FORCED_ID: Client Assigned/Visible Resource IDs\n+\n+By default, the **HFJ_RESOURCE.RES_ID** column is used as the resource ID for all server-assigned IDs. For example, if a Patient resource is created in a completely empty database, it will be assigned the ID `Patient/1` by the server and RES_ID will have a value of 1.\n+\n+However, when client-assigned IDs are used, these may contain text values in order to allow a client to create an ID such as `Patient/ABC`. When a client-assigned ID is given to a resource, a row is created in the **HFJ_RESOURCE** table. When an **HFJ_FORCED_ID** row exists corresponding to the equivalent **HFJ_RESOURCE** row, the RES_ID value is no longer visible or usable by FHIR clients and it becomes purely an internal ID to the JPA server.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 243}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTc1MjczOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/BaseConfig.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNToyODo0MVrOGJL_WA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozMzozMVrOGJeJSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4NjgwOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tpublic PartitionSettings partitionConfig() {\n          \n          \n            \n            \tpublic PartitionSettings partitionSettings() {", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412286808", "createdAt": "2020-04-21T15:28:41Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/BaseConfig.java", "diffHunk": "@@ -230,11 +240,33 @@ public IConsentContextServices consentContextServices() {\n \t\treturn new JpaConsentContextServices();\n \t}\n \n+\t@Bean\n+\tpublic PartitionSettings partitionConfig() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDI2NA==", "bodyText": "done", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412584264", "createdAt": "2020-04-22T00:33:31Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/config/BaseConfig.java", "diffHunk": "@@ -230,11 +240,33 @@ public IConsentContextServices consentContextServices() {\n \t\treturn new JpaConsentContextServices();\n \t}\n \n+\t@Bean\n+\tpublic PartitionSettings partitionConfig() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI4NjgwOA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTgwMDkxOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/data/IResourceIndexedCompositeStringUniqueDao.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTo0OTo1NVrOGJMcYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNDoyMlrOGJeKeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NDI0Mg==", "bodyText": "It looks like this is only needed for tests.  Perhaps \"forUnitTest\"?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412294242", "createdAt": "2020-04-21T15:49:55Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/data/IResourceIndexedCompositeStringUniqueDao.java", "diffHunk": "@@ -25,15 +25,13 @@\n import org.springframework.data.jpa.repository.Query;\n import org.springframework.data.repository.query.Param;\n \n-import java.util.Collection;\n-import java.util.Optional;\n+import java.util.List;\n \n public interface IResourceIndexedCompositeStringUniqueDao extends JpaRepository<ResourceIndexedCompositeStringUnique, Long> {\n \n \t@Query(\"SELECT r FROM ResourceIndexedCompositeStringUnique r WHERE r.myIndexString = :str\")\n \tResourceIndexedCompositeStringUnique findByQueryString(@Param(\"str\") String theQueryString);\n \n-\t@Query(\"SELECT r.myResourceId FROM ResourceIndexedCompositeStringUnique r WHERE r.myIndexString IN :str\")\n-\tCollection<Long> findResourcePidsByQueryStrings(@Param(\"str\") Collection<String> theQueryString);\n-\n+\t@Query(\"SELECT r FROM ResourceIndexedCompositeStringUnique r WHERE r.myResourceId = :resId\")\n+\tList<ResourceIndexedCompositeStringUnique> findAllForResourceId(@Param(\"resId\") Long theResourceId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMyMTU4NA==", "bodyText": "Same goes for the other ones like this", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412321584", "createdAt": "2020-04-21T16:49:50Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/data/IResourceIndexedCompositeStringUniqueDao.java", "diffHunk": "@@ -25,15 +25,13 @@\n import org.springframework.data.jpa.repository.Query;\n import org.springframework.data.repository.query.Param;\n \n-import java.util.Collection;\n-import java.util.Optional;\n+import java.util.List;\n \n public interface IResourceIndexedCompositeStringUniqueDao extends JpaRepository<ResourceIndexedCompositeStringUnique, Long> {\n \n \t@Query(\"SELECT r FROM ResourceIndexedCompositeStringUnique r WHERE r.myIndexString = :str\")\n \tResourceIndexedCompositeStringUnique findByQueryString(@Param(\"str\") String theQueryString);\n \n-\t@Query(\"SELECT r.myResourceId FROM ResourceIndexedCompositeStringUnique r WHERE r.myIndexString IN :str\")\n-\tCollection<Long> findResourcePidsByQueryStrings(@Param(\"str\") Collection<String> theQueryString);\n-\n+\t@Query(\"SELECT r FROM ResourceIndexedCompositeStringUnique r WHERE r.myResourceId = :resId\")\n+\tList<ResourceIndexedCompositeStringUnique> findAllForResourceId(@Param(\"resId\") Long theResourceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NDI0Mg=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDU3MA==", "bodyText": "done", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412584570", "createdAt": "2020-04-22T00:34:22Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/data/IResourceIndexedCompositeStringUniqueDao.java", "diffHunk": "@@ -25,15 +25,13 @@\n import org.springframework.data.jpa.repository.Query;\n import org.springframework.data.repository.query.Param;\n \n-import java.util.Collection;\n-import java.util.Optional;\n+import java.util.List;\n \n public interface IResourceIndexedCompositeStringUniqueDao extends JpaRepository<ResourceIndexedCompositeStringUnique, Long> {\n \n \t@Query(\"SELECT r FROM ResourceIndexedCompositeStringUnique r WHERE r.myIndexString = :str\")\n \tResourceIndexedCompositeStringUnique findByQueryString(@Param(\"str\") String theQueryString);\n \n-\t@Query(\"SELECT r.myResourceId FROM ResourceIndexedCompositeStringUnique r WHERE r.myIndexString IN :str\")\n-\tCollection<Long> findResourcePidsByQueryStrings(@Param(\"str\") Collection<String> theQueryString);\n-\n+\t@Query(\"SELECT r FROM ResourceIndexedCompositeStringUnique r WHERE r.myResourceId = :resId\")\n+\tList<ResourceIndexedCompositeStringUnique> findAllForResourceId(@Param(\"resId\") Long theResourceId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NDI0Mg=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 17}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTgxMjgzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTo1Nzo1NVrOGJMkYg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNzoyMlrOGJeN-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NjI5MA==", "bodyText": "Nitpick: That's a lot of parameters.  Looks like an opportunity to group them together into a new class.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412296290", "createdAt": "2020-04-21T15:57:55Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "diffHunk": "@@ -72,8 +72,9 @@ protected void validateResourceForStorage(SearchParameter theResource, ResourceT\n \t\tString expression = theResource.getExpression();\n \t\tFhirContext context = getContext();\n \t\tEnumerations.SearchParamType type = theResource.getType();\n+\t\tString code = theResource.getCode();\n \n-\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamExtractor, type, status, base, expression, context, getConfig());\n+\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamRegistry, mySearchParamExtractor, code, type, status, base, expression, context, getConfig());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NTQ2NQ==", "bodyText": "It's kinda gross, but this approach helps us have one codebase to validate all versions.. i actually put it this way to fix a bug where the checks were inconsistent across versions", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412585465", "createdAt": "2020-04-22T00:37:22Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "diffHunk": "@@ -72,8 +72,9 @@ protected void validateResourceForStorage(SearchParameter theResource, ResourceT\n \t\tString expression = theResource.getExpression();\n \t\tFhirContext context = getContext();\n \t\tEnumerations.SearchParamType type = theResource.getType();\n+\t\tString code = theResource.getCode();\n \n-\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamExtractor, type, status, base, expression, context, getConfig());\n+\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamRegistry, mySearchParamExtractor, code, type, status, base, expression, context, getConfig());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NjI5MA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTgxMzQ3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNTo1ODoxOVrOGJMk0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNToyOFrOGJeLmw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NjQwMA==", "bodyText": "Nitpick: That's a lot of parameters.  Looks like an opportunity to group them together into a new class.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412296400", "createdAt": "2020-04-21T15:58:19Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "diffHunk": "@@ -72,8 +72,9 @@ protected void validateResourceForStorage(SearchParameter theResource, ResourceT\n \t\tString expression = theResource.getExpression();\n \t\tFhirContext context = getContext();\n \t\tEnumerations.SearchParamType type = theResource.getType();\n+\t\tString code = theResource.getCode();\n \n-\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamExtractor, type, status, base, expression, context, getConfig());\n+\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamRegistry, mySearchParamExtractor, code, type, status, base, expression, context, getConfig());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NDg1OQ==", "bodyText": "It's kinda gross, but this approach helps us have one codebase to validate all versions.. i actually put it this way to fix a bug where the checks were inconsistent across versions", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412584859", "createdAt": "2020-04-22T00:35:28Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "diffHunk": "@@ -72,8 +72,9 @@ protected void validateResourceForStorage(SearchParameter theResource, ResourceT\n \t\tString expression = theResource.getExpression();\n \t\tFhirContext context = getContext();\n \t\tEnumerations.SearchParamType type = theResource.getType();\n+\t\tString code = theResource.getCode();\n \n-\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamExtractor, type, status, base, expression, context, getConfig());\n+\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamRegistry, mySearchParamExtractor, code, type, status, base, expression, context, getConfig());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjI5NjQwMA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MTk3ODE5OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo0OTo1N1rOGJOHnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNzoyOFrOGJeOGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMyMTY5NQ==", "bodyText": "Nitpick: That's a lot of parameters.  Looks like an opportunity to group them together into a new class.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412321695", "createdAt": "2020-04-21T16:49:57Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "diffHunk": "@@ -72,8 +72,9 @@ protected void validateResourceForStorage(SearchParameter theResource, ResourceT\n \t\tString expression = theResource.getExpression();\n \t\tFhirContext context = getContext();\n \t\tEnumerations.SearchParamType type = theResource.getType();\n+\t\tString code = theResource.getCode();\n \n-\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamExtractor, type, status, base, expression, context, getConfig());\n+\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamRegistry, mySearchParamExtractor, code, type, status, base, expression, context, getConfig());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 7}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NTQ5OA==", "bodyText": "It's kinda gross, but this approach helps us have one codebase to validate all versions.. i actually put it this way to fix a bug where the checks were inconsistent across versions", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412585498", "createdAt": "2020-04-22T00:37:28Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/dstu3/FhirResourceDaoSearchParameterDstu3.java", "diffHunk": "@@ -72,8 +72,9 @@ protected void validateResourceForStorage(SearchParameter theResource, ResourceT\n \t\tString expression = theResource.getExpression();\n \t\tFhirContext context = getContext();\n \t\tEnumerations.SearchParamType type = theResource.getType();\n+\t\tString code = theResource.getCode();\n \n-\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamExtractor, type, status, base, expression, context, getConfig());\n+\t\tFhirResourceDaoSearchParameterR4.validateSearchParam(mySearchParamRegistry, mySearchParamExtractor, code, type, status, base, expression, context, getConfig());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMyMTY5NQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjAzMjYzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNjo1OToxMlrOGJOltA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozNzo0MlrOGJeOUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMyOTM5Ng==", "bodyText": "I suspect there may need to be changes to LiveBundle", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412329396", "createdAt": "2020-04-21T16:59:12Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -132,14 +135,14 @@ public IResourceLookup resolveResourceIdentity(String theResourceName, String th\n \t * @throws ResourceNotFoundException If the ID can not be found\n \t */\n \t@Nonnull\n-\tpublic ResourcePersistentId resolveResourcePersistentIds(String theResourceType, String theId) {\n+\tpublic ResourcePersistentId resolveResourcePersistentIds(PartitionId thePartitionId, String theResourceType, String theId) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NTU1NA==", "bodyText": "I'm adjusting it to just not support partitioning for now...", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412585554", "createdAt": "2020-04-22T00:37:42Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -132,14 +135,14 @@ public IResourceLookup resolveResourceIdentity(String theResourceName, String th\n \t * @throws ResourceNotFoundException If the ID can not be found\n \t */\n \t@Nonnull\n-\tpublic ResourcePersistentId resolveResourcePersistentIds(String theResourceType, String theId) {\n+\tpublic ResourcePersistentId resolveResourcePersistentIds(PartitionId thePartitionId, String theResourceType, String theId) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjMyOTM5Ng=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjEyMTk2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxNzo1NlrOGJPaZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxNzo1NlrOGJPaZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0Mjg4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (pid.isPresent() == false) {\n          \n          \n            \n            \t\tif (pid.isEmpty()) {", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412342886", "createdAt": "2020-04-21T17:17:56Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -248,15 +260,35 @@ private String translatePidIdToForcedId(String theResourceType, ResourcePersiste\n \t\treturn typeToIds;\n \t}\n \n-\tprivate Long resolveResourceIdentity(String theResourceType, String theId) {\n-\t\tLong retVal;\n-\t\tretVal = myForcedIdDao\n-\t\t\t.findByTypeAndForcedId(theResourceType, theId)\n-\t\t\t.orElseThrow(() -> new ResourceNotFoundException(new IdDt(theResourceType, theId)));\n-\t\treturn retVal;\n+\tprivate Long resolveResourceIdentity(@Nullable PartitionId thePartitionId, @Nonnull String theResourceType, @Nonnull String theId) {\n+\t\tOptional<Long> pid;\n+\t\tif (thePartitionId != null) {\n+\t\t\tif (thePartitionId.getPartitionId() == null) {\n+\t\t\t\tpid = myForcedIdDao.findByPartitionIdNullAndTypeAndForcedId(theResourceType, theId);\n+\t\t\t} else {\n+\t\t\t\tpid = myForcedIdDao.findByPartitionIdAndTypeAndForcedId(thePartitionId.getPartitionId(), theResourceType, theId);\n+\t\t\t}\n+\t\t} else {\n+\t\t\ttry {\n+\t\t\t\tpid = myForcedIdDao.findByTypeAndForcedId(theResourceType, theId);\n+\t\t\t} catch (IncorrectResultSizeDataAccessException e) {\n+\t\t\t\t/*\n+\t\t\t\t *  This means that:\n+\t\t\t\t *  1. There are two resources with the exact same resource type and forced id\n+\t\t\t\t *  2. The unique constraint on this column-pair has been dropped\n+\t\t\t\t */\n+\t\t\t\tString msg = myFhirCtx.getLocalizer().getMessage(IdHelperService.class, \"nonUniqueForcedId\");\n+\t\t\t\tthrow new PreconditionFailedException(msg);\n+\t\t\t}\n+\t\t}\n+\n+\t\tif (pid.isPresent() == false) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjEyNTk4OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoxODo0M1rOGJPcrw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo1MjoyNVrOGJehYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MzQ3MQ==", "bodyText": "Nitpick: this looks like a method", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412343471", "createdAt": "2020-04-21T17:18:43Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -272,9 +304,19 @@ private Long resolveResourceIdentity(String theResourceType, String theId) {\n \t\t\t\t.map(t -> t.getIdPartAsLong())\n \t\t\t\t.collect(Collectors.toList());\n \t\t\tif (!pids.isEmpty()) {\n-\t\t\t\tmyResourceTableDao.findLookupFieldsByResourcePid(pids)\n+\t\t\t\tCollection<Object[]> lookup;\n+\t\t\t\tif (thePartitionId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU5MDQzNQ==", "bodyText": "refactored", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412590435", "createdAt": "2020-04-22T00:52:25Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/index/IdHelperService.java", "diffHunk": "@@ -272,9 +304,19 @@ private Long resolveResourceIdentity(String theResourceType, String theId) {\n \t\t\t\t.map(t -> t.getIdPartAsLong())\n \t\t\t\t.collect(Collectors.toList());\n \t\t\tif (!pids.isEmpty()) {\n-\t\t\t\tmyResourceTableDao.findLookupFieldsByResourcePid(pids)\n+\t\t\t\tCollection<Object[]> lookup;\n+\t\t\t\tif (thePartitionId != null) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0MzQ3MQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 207}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjEzODMyOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/BasePredicateBuilder.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoyMToyNFrOGJPkNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozODoxOFrOGJePJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0NTM5Nw==", "bodyText": "I wonder what the performance implications of this will be.  Good idea putting it first.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412345397", "createdAt": "2020-04-21T17:21:24Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/BasePredicateBuilder.java", "diffHunk": "@@ -110,41 +115,57 @@ private void postConstruct() {\n \t\treturn (Join<ResourceTable, T>) join;\n \t}\n \n-\tvoid addPredicateParamMissing(String theResourceName, String theParamName, boolean theMissing) {\n-//\t\tif (myDontUseHashesForSearch) {\n-//\t\t\tJoin<ResourceTable, SearchParamPresent> paramPresentJoin = myQueryRoot.join(\"mySearchParamPresents\", JoinType.LEFT);\n-//\t\t\tJoin<Object, Object> paramJoin = paramPresentJoin.join(\"mySearchParam\", JoinType.LEFT);\n-//\n-//\t\t\tmyQueryRoot.addPredicate(myBuilder.equal(paramJoin.get(\"myResourceName\"), theResourceName));\n-//\t\t\tmyQueryRoot.addPredicate(myBuilder.equal(paramJoin.get(\"myParamName\"), theParamName));\n-//\t\t\tmyQueryRoot.addPredicate(myBuilder.equal(paramPresentJoin.get(\"myPresent\"), !theMissing));\n-//\t\t}\n-\n+\tvoid addPredicateParamMissingForReference(String theResourceName, String theParamName, boolean theMissing, PartitionId thePartitionId) {\n \t\tJoin<ResourceTable, SearchParamPresent> paramPresentJoin = myQueryRoot.join(\"mySearchParamPresents\", JoinType.LEFT);\n \n \t\tExpression<Long> hashPresence = paramPresentJoin.get(\"myHashPresence\").as(Long.class);\n-\t\tLong hash = SearchParamPresent.calculateHashPresence(theResourceName, theParamName, !theMissing);\n-\t\tmyQueryRoot.addPredicate(myCriteriaBuilder.equal(hashPresence, hash));\n-\t}\n+\t\tLong hash = SearchParamPresent.calculateHashPresence(myPartitionSettings, thePartitionId, theResourceName, theParamName, !theMissing);\n+\n+\t\tList<Predicate> predicates = new ArrayList<>();\n+\t\tpredicates.add(myCriteriaBuilder.equal(hashPresence, hash));\n \n-\tvoid addPredicateParamMissing(String theResourceName, String theParamName, boolean theMissing, Join<ResourceTable, ? extends BaseResourceIndexedSearchParam> theJoin) {\n+\t\taddPartitionIdPredicate(thePartitionId, paramPresentJoin, predicates);\n \n+\t\tmyQueryRoot.setHasIndexJoins();\n+\t\tmyQueryRoot.addPredicates(predicates);\n+\t}\n+\n+\tvoid addPredicateParamMissingForNonReference(String theResourceName, String theParamName, boolean theMissing, Join<ResourceTable, ? extends BaseResourceIndexedSearchParam> theJoin, PartitionId thePartitionId) {\n+\t\tif (thePartitionId != null) {\n+\t\t\tif (thePartitionId.getPartitionId() != null) {\n+\t\t\t\tmyQueryRoot.addPredicate(myCriteriaBuilder.equal(theJoin.get(\"myPartitionIdValue\"), thePartitionId.getPartitionId()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NTc2Nw==", "bodyText": "This will absolutely require index tuning in order to work in a performant way...", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412585767", "createdAt": "2020-04-22T00:38:18Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/BasePredicateBuilder.java", "diffHunk": "@@ -110,41 +115,57 @@ private void postConstruct() {\n \t\treturn (Join<ResourceTable, T>) join;\n \t}\n \n-\tvoid addPredicateParamMissing(String theResourceName, String theParamName, boolean theMissing) {\n-//\t\tif (myDontUseHashesForSearch) {\n-//\t\t\tJoin<ResourceTable, SearchParamPresent> paramPresentJoin = myQueryRoot.join(\"mySearchParamPresents\", JoinType.LEFT);\n-//\t\t\tJoin<Object, Object> paramJoin = paramPresentJoin.join(\"mySearchParam\", JoinType.LEFT);\n-//\n-//\t\t\tmyQueryRoot.addPredicate(myBuilder.equal(paramJoin.get(\"myResourceName\"), theResourceName));\n-//\t\t\tmyQueryRoot.addPredicate(myBuilder.equal(paramJoin.get(\"myParamName\"), theParamName));\n-//\t\t\tmyQueryRoot.addPredicate(myBuilder.equal(paramPresentJoin.get(\"myPresent\"), !theMissing));\n-//\t\t}\n-\n+\tvoid addPredicateParamMissingForReference(String theResourceName, String theParamName, boolean theMissing, PartitionId thePartitionId) {\n \t\tJoin<ResourceTable, SearchParamPresent> paramPresentJoin = myQueryRoot.join(\"mySearchParamPresents\", JoinType.LEFT);\n \n \t\tExpression<Long> hashPresence = paramPresentJoin.get(\"myHashPresence\").as(Long.class);\n-\t\tLong hash = SearchParamPresent.calculateHashPresence(theResourceName, theParamName, !theMissing);\n-\t\tmyQueryRoot.addPredicate(myCriteriaBuilder.equal(hashPresence, hash));\n-\t}\n+\t\tLong hash = SearchParamPresent.calculateHashPresence(myPartitionSettings, thePartitionId, theResourceName, theParamName, !theMissing);\n+\n+\t\tList<Predicate> predicates = new ArrayList<>();\n+\t\tpredicates.add(myCriteriaBuilder.equal(hashPresence, hash));\n \n-\tvoid addPredicateParamMissing(String theResourceName, String theParamName, boolean theMissing, Join<ResourceTable, ? extends BaseResourceIndexedSearchParam> theJoin) {\n+\t\taddPartitionIdPredicate(thePartitionId, paramPresentJoin, predicates);\n \n+\t\tmyQueryRoot.setHasIndexJoins();\n+\t\tmyQueryRoot.addPredicates(predicates);\n+\t}\n+\n+\tvoid addPredicateParamMissingForNonReference(String theResourceName, String theParamName, boolean theMissing, Join<ResourceTable, ? extends BaseResourceIndexedSearchParam> theJoin, PartitionId thePartitionId) {\n+\t\tif (thePartitionId != null) {\n+\t\t\tif (thePartitionId.getPartitionId() != null) {\n+\t\t\t\tmyQueryRoot.addPredicate(myCriteriaBuilder.equal(theJoin.get(\"myPartitionIdValue\"), thePartitionId.getPartitionId()));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM0NTM5Nw=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjE3MTIyOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirResourceDao.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxNzoyODozMlrOGJP35g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDozODo1MlrOGJeQHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM1MDQzOA==", "bodyText": "This surprises me.  I guess this is a fairly urgent TODO to add support for history back in when partitioning is enabled?  This means that FMC will lose the history operation?  I don't think this came across in the docs that we are switching off functionality like this when partitions are switched on.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412350438", "createdAt": "2020-04-21T17:28:32Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirResourceDao.java", "diffHunk": "@@ -635,6 +685,11 @@ public void setResourceType(Class<? extends IBaseResource> theTableType) {\n \n \t@Override\n \tpublic IBundleProvider history(Date theSince, Date theUntil, RequestDetails theRequestDetails) {\n+\t\tif (myPartitionSettings.isPartitioningEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NjAxNA==", "bodyText": "Yeah, I'll make that the next ticket", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412586014", "createdAt": "2020-04-22T00:38:52Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirResourceDao.java", "diffHunk": "@@ -635,6 +685,11 @@ public void setResourceType(Class<? extends IBaseResource> theTableType) {\n \n \t@Override\n \tpublic IBundleProvider history(Date theSince, Date theUntil, RequestDetails theRequestDetails) {\n+\t\tif (myPartitionSettings.isPartitioningEnabled()) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjM1MDQzOA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 161}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjYyMjQwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirResourceDao.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTowNzo1NlrOGJUDTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTowNzo1NlrOGJUDTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQxODg5NA==", "bodyText": "This is an interesting tradeoff of read/write performance.  I think you chose the better option.  I guess another option would be to index partition id with pid and do the find directly on that.  But I guess that doesn't work with partition id = null as an option.  (Maybe a reason to consider default partition = 0?).", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412418894", "createdAt": "2020-04-21T19:07:56Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/BaseHapiFhirResourceDao.java", "diffHunk": "@@ -943,17 +998,35 @@ public T read(IIdType theId, RequestDetails theRequest, boolean theDeletedOk) {\n \n \t@Override\n \tpublic BaseHasResource readEntity(IIdType theId, RequestDetails theRequest) {\n-\n \t\treturn readEntity(theId, true, theRequest);\n \t}\n \n \t@Override\n \tpublic BaseHasResource readEntity(IIdType theId, boolean theCheckForForcedId, RequestDetails theRequest) {\n \t\tvalidateResourceTypeAndThrowInvalidRequestException(theId);\n \n-\t\tResourcePersistentId pid = myIdHelperService.resolveResourcePersistentIds(getResourceName(), theId.getIdPart());\n+\t\t@Nullable PartitionId partitionId = myRequestPartitionHelperService.determineReadPartitionForRequest(theRequest, getResourceName());\n+\t\tResourcePersistentId pid = myIdHelperService.resolveResourcePersistentIds(partitionId, getResourceName(), theId.getIdPart());\n \t\tBaseHasResource entity = myEntityManager.find(ResourceTable.class, pid.getIdAsLong());\n \n+\t\t// Verify that the resource is for the correct partition\n+\t\tif (partitionId != null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 214}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjY2MTAyOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderReference.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToxNjo0OVrOGJUZ7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0MTowOFrOGJeSzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNDY4Nw==", "bodyText": "I don't think line changes the behaviour.  Did you add it for future change safety?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412424687", "createdAt": "2020-04-21T19:16:49Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderReference.java", "diffHunk": "@@ -762,6 +794,7 @@ private IQueryParameterType toParameterType(RuntimeSearchParam theParam) {\n \t\t\t\t\tqp = new SpecialParam();\n \t\t\t\t\tbreak;\n \t\t\t\t}\n+\t\t\t\tthrow new InternalErrorException(\"Don't know how to convert param type: \" + theParam.getParamType());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 405}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NjcwMg==", "bodyText": "yup", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412586702", "createdAt": "2020-04-22T00:41:08Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderReference.java", "diffHunk": "@@ -762,6 +794,7 @@ private IQueryParameterType toParameterType(RuntimeSearchParam theParam) {\n \t\t\t\t\tqp = new SpecialParam();\n \t\t\t\t\tbreak;\n \t\t\t\t}\n+\t\t\t\tthrow new InternalErrorException(\"Don't know how to convert param type: \" + theParam.getParamType());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNDY4Nw=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 405}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjY3NTUxOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderTag.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToyMDoxN1rOGJUiZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0MjozM1rOGJeU4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNjg1NA==", "bodyText": "I see these in all the predicates.  It feels dangerous to expect all the predicates to explicitly set this properly.  (Or maybe it's just an optimization thing).  Isn't there an inexpensive way to test if the query root has joins at the point where we need to know?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412426854", "createdAt": "2020-04-21T19:20:17Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderTag.java", "diffHunk": "@@ -151,13 +159,24 @@ void addPredicateTag(List<List<IQueryParameterType>> theList, String theParamNam\n \t\t\t\tdefJoin.where(tagListPredicate);\n \n \t\t\t\tcontinue;\n+\n+\t\t\t} else {\n+\n+\t\t\t\tmyQueryRoot.setHasIndexJoins();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzIzMw==", "bodyText": "it's just an optimization thing... the consequence of missing it is that an  extra predicate on the resource type + partition ends up in the SQL... that only hurts performance", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412587233", "createdAt": "2020-04-22T00:42:33Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderTag.java", "diffHunk": "@@ -151,13 +159,24 @@ void addPredicateTag(List<List<IQueryParameterType>> theList, String theParamNam\n \t\t\t\tdefJoin.where(tagListPredicate);\n \n \t\t\t\tcontinue;\n+\n+\t\t\t} else {\n+\n+\t\t\t\tmyQueryRoot.setHasIndexJoins();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQyNjg1NA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjcwNzg3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionConfigSvcImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToyNzozMVrOGJU1JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0MzoxN1rOGJeVuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzMTY1Mg==", "bodyText": "This cache timeout seems really short to me--I assume this table changes really infrequently.  Can we just invalidate the cache whenever the table is changed and set the refresh to way longer?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412431652", "createdAt": "2020-04-21T19:27:31Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionConfigSvcImpl.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.dao.data.IPartitionDao;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import com.github.benmanes.caffeine.cache.CacheLoader;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.PlatformTransactionManager;\n+import org.springframework.transaction.support.TransactionTemplate;\n+\n+import javax.annotation.PostConstruct;\n+import javax.transaction.Transactional;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+public class PartitionConfigSvcImpl implements IPartitionConfigSvc {\n+\n+\tpublic static final int DEFAULT_PERSISTED_PARTITION_ID = 0;\n+\tpublic static final String DEFAULT_PERSISTED_PARTITION_NAME = \"DEFAULT\";\n+\tprivate static final String DEFAULT_PERSISTED_PARTITION_DESC = \"Default partition\";\n+\tprivate static final Pattern PARTITION_NAME_VALID_PATTERN = Pattern.compile(\"[a-zA-Z0-9_-]+\");\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(PartitionConfigSvcImpl.class);\n+\n+\t@Autowired\n+\tprivate PlatformTransactionManager myTxManager;\n+\t@Autowired\n+\tprivate IPartitionDao myPartitionDao;\n+\n+\tprivate LoadingCache<String, PartitionEntity> myNameToPartitionCache;\n+\tprivate LoadingCache<Integer, PartitionEntity> myIdToPartitionCache;\n+\tprivate TransactionTemplate myTxTemplate;\n+\t@Autowired\n+\tprivate FhirContext myFhirCtx;\n+\n+\t@Override\n+\t@PostConstruct\n+\tpublic void start() {\n+\t\tmyNameToPartitionCache = Caffeine\n+\t\t\t.newBuilder()\n+\t\t\t.expireAfterWrite(1, TimeUnit.MINUTES)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzQ0OQ==", "bodyText": "That's dangerous in a cluster..", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412587449", "createdAt": "2020-04-22T00:43:17Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionConfigSvcImpl.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.dao.data.IPartitionDao;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import com.github.benmanes.caffeine.cache.CacheLoader;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.PlatformTransactionManager;\n+import org.springframework.transaction.support.TransactionTemplate;\n+\n+import javax.annotation.PostConstruct;\n+import javax.transaction.Transactional;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+public class PartitionConfigSvcImpl implements IPartitionConfigSvc {\n+\n+\tpublic static final int DEFAULT_PERSISTED_PARTITION_ID = 0;\n+\tpublic static final String DEFAULT_PERSISTED_PARTITION_NAME = \"DEFAULT\";\n+\tprivate static final String DEFAULT_PERSISTED_PARTITION_DESC = \"Default partition\";\n+\tprivate static final Pattern PARTITION_NAME_VALID_PATTERN = Pattern.compile(\"[a-zA-Z0-9_-]+\");\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(PartitionConfigSvcImpl.class);\n+\n+\t@Autowired\n+\tprivate PlatformTransactionManager myTxManager;\n+\t@Autowired\n+\tprivate IPartitionDao myPartitionDao;\n+\n+\tprivate LoadingCache<String, PartitionEntity> myNameToPartitionCache;\n+\tprivate LoadingCache<Integer, PartitionEntity> myIdToPartitionCache;\n+\tprivate TransactionTemplate myTxTemplate;\n+\t@Autowired\n+\tprivate FhirContext myFhirCtx;\n+\n+\t@Override\n+\t@PostConstruct\n+\tpublic void start() {\n+\t\tmyNameToPartitionCache = Caffeine\n+\t\t\t.newBuilder()\n+\t\t\t.expireAfterWrite(1, TimeUnit.MINUTES)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzMTY1Mg=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjcxNDQwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionManagementProvider.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOToyOToxMVrOGJU5Ag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0NDoxOVrOGJeXHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzMjY0Mg==", "bodyText": "I know there are \"reasons\" but man why can't we just make this a CRUD REST service?  Would probably be like 5 lines of Spring code...", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412432642", "createdAt": "2020-04-21T19:29:11Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionManagementProvider.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.util.ProviderConstants;\n+import ca.uhn.fhir.rest.annotation.Operation;\n+import ca.uhn.fhir.rest.annotation.OperationParam;\n+import ca.uhn.fhir.rest.annotation.ResourceParam;\n+import ca.uhn.fhir.util.ParametersUtil;\n+import org.hl7.fhir.instance.model.api.IBaseParameters;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.jetbrains.annotations.NotNull;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+\n+/**\n+ * This HAPI FHIR Server Plain Provider class provides the following operations:\n+ * <ul>\n+ *    <li><code>partition-management-add-partition</code></li>\n+ *    <li><code>partition-management-update-partition</code></li>\n+ *    <li><code>partition-management-delete-partition</code></li>\n+ * </ul>\n+ */\n+public class PartitionManagementProvider {\n+\n+\t@Autowired\n+\tprivate FhirContext myCtx;\n+\t@Autowired\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\n+\t/**\n+\t * Add Partition:\n+\t * <code>\n+\t * $partition-management-add-partition\n+\t * </code>\n+\t */\n+\t@Operation(name = ProviderConstants.PARTITION_MANAGEMENT_ADD_PARTITION)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4NzgwNw==", "bodyText": "that might be better... but currently not a pattern we have at all", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412587807", "createdAt": "2020-04-22T00:44:19Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionManagementProvider.java", "diffHunk": "@@ -0,0 +1,139 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.util.ProviderConstants;\n+import ca.uhn.fhir.rest.annotation.Operation;\n+import ca.uhn.fhir.rest.annotation.OperationParam;\n+import ca.uhn.fhir.rest.annotation.ResourceParam;\n+import ca.uhn.fhir.util.ParametersUtil;\n+import org.hl7.fhir.instance.model.api.IBaseParameters;\n+import org.hl7.fhir.instance.model.api.IPrimitiveType;\n+import org.jetbrains.annotations.NotNull;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+\n+/**\n+ * This HAPI FHIR Server Plain Provider class provides the following operations:\n+ * <ul>\n+ *    <li><code>partition-management-add-partition</code></li>\n+ *    <li><code>partition-management-update-partition</code></li>\n+ *    <li><code>partition-management-delete-partition</code></li>\n+ * </ul>\n+ */\n+public class PartitionManagementProvider {\n+\n+\t@Autowired\n+\tprivate FhirContext myCtx;\n+\t@Autowired\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\n+\t/**\n+\t * Add Partition:\n+\t * <code>\n+\t * $partition-management-add-partition\n+\t * </code>\n+\t */\n+\t@Operation(name = ProviderConstants.PARTITION_MANAGEMENT_ADD_PARTITION)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzMjY0Mg=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MjczNDk1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionConfigSvcImpl.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTozNDoxN1rOGJVFFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0NToxNFrOGJeYRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTczNQ==", "bodyText": "Nitpick: this looks like a PartitionLookupSvc to me as opposed to a PartitionConfigSvc.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412435735", "createdAt": "2020-04-21T19:34:17Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionConfigSvcImpl.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.dao.data.IPartitionDao;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import com.github.benmanes.caffeine.cache.CacheLoader;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.PlatformTransactionManager;\n+import org.springframework.transaction.support.TransactionTemplate;\n+\n+import javax.annotation.PostConstruct;\n+import javax.transaction.Transactional;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+public class PartitionConfigSvcImpl implements IPartitionConfigSvc {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4ODEwMA==", "bodyText": "renamed", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412588100", "createdAt": "2020-04-22T00:45:14Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/partition/PartitionConfigSvcImpl.java", "diffHunk": "@@ -0,0 +1,224 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.dao.data.IPartitionDao;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import com.github.benmanes.caffeine.cache.CacheLoader;\n+import com.github.benmanes.caffeine.cache.Caffeine;\n+import com.github.benmanes.caffeine.cache.LoadingCache;\n+import org.apache.commons.lang3.Validate;\n+import org.checkerframework.checker.nullness.qual.NonNull;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.transaction.PlatformTransactionManager;\n+import org.springframework.transaction.support.TransactionTemplate;\n+\n+import javax.annotation.PostConstruct;\n+import javax.transaction.Transactional;\n+import java.util.Optional;\n+import java.util.concurrent.TimeUnit;\n+import java.util.regex.Pattern;\n+\n+import static org.apache.commons.lang3.StringUtils.isBlank;\n+\n+public class PartitionConfigSvcImpl implements IPartitionConfigSvc {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzNTczNQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjc1NTM2OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTozOToyMlrOGJVRNQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0NjowMFrOGJeZKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzODgzNw==", "bodyText": "This is a great regression test for tracking how code changes affect db interactions.  It's the gift that keeps on giving.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412438837", "createdAt": "2020-04-21T19:39:22Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -279,8 +278,8 @@ public void testSearchUsingForcedIdReference() {\n \t\tmyCaptureQueriesListener.clear();\n \t\tassertEquals(1, myObservationDao.search(map).size().intValue());\n \t\tmyCaptureQueriesListener.logAllQueriesForCurrentThread();\n-\t\t// Resolve forced ID, Perform search, load result\n-\t\tassertEquals(3, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\t// Resolve forced ID, Perform search, load result (this time we reuse the cached forced-id resolution)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4ODMzMQ==", "bodyText": "Yeah I love this test!", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412588331", "createdAt": "2020-04-22T00:46:00Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4QueryCountTest.java", "diffHunk": "@@ -279,8 +278,8 @@ public void testSearchUsingForcedIdReference() {\n \t\tmyCaptureQueriesListener.clear();\n \t\tassertEquals(1, myObservationDao.search(map).size().intValue());\n \t\tmyCaptureQueriesListener.logAllQueriesForCurrentThread();\n-\t\t// Resolve forced ID, Perform search, load result\n-\t\tassertEquals(3, myCaptureQueriesListener.countSelectQueriesForCurrentThread());\n+\t\t// Resolve forced ID, Perform search, load result (this time we reuse the cached forced-id resolution)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQzODgzNw=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjc3ODY0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirSystemDaoR4Test.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQxOTo0NTowN1rOGJVfAQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0NjozNlrOGJeaBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MjM2OQ==", "bodyText": "the test would be clearer if it calculated this number instead of hardcoding it.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412442369", "createdAt": "2020-04-21T19:45:07Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirSystemDaoR4Test.java", "diffHunk": "@@ -609,6 +609,15 @@ public void testReindexingSingleStringHashValueIsDeleted() {\n \t\tmyResourceReindexingSvc.markAllResourcesForReindexing();\n \t\tmyResourceReindexingSvc.forceReindexingPass();\n \n+\t\trunInTransaction(()->{\n+\t\t\tResourceIndexedSearchParamString param = myResourceIndexedSearchParamStringDao.findAll()\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> t.getParamName().equals(\"family\"))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.orElseThrow(() -> new IllegalArgumentException());\n+\t\t\tassertEquals(-6332913947530887803L, param.getHashNormalizedPrefix().longValue());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4ODU1MQ==", "bodyText": "this way is safest in terms of catching accidental changes to the algorithm though", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412588551", "createdAt": "2020-04-22T00:46:36Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirSystemDaoR4Test.java", "diffHunk": "@@ -609,6 +609,15 @@ public void testReindexingSingleStringHashValueIsDeleted() {\n \t\tmyResourceReindexingSvc.markAllResourcesForReindexing();\n \t\tmyResourceReindexingSvc.forceReindexingPass();\n \n+\t\trunInTransaction(()->{\n+\t\t\tResourceIndexedSearchParamString param = myResourceIndexedSearchParamStringDao.findAll()\n+\t\t\t\t.stream()\n+\t\t\t\t.filter(t -> t.getParamName().equals(\"family\"))\n+\t\t\t\t.findFirst()\n+\t\t\t\t.orElseThrow(() -> new IllegalArgumentException());\n+\t\t\tassertEquals(-6332913947530887803L, param.getHashNormalizedPrefix().longValue());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ0MjM2OQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2Mjg0OTI1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/PartitioningR4Test.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMDowMjoxN1rOGJWI0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDo0NzoxOVrOGJea8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1MzA3Mw==", "bodyText": "this repeated line is confusing", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412453073", "createdAt": "2020-04-21T20:02:17Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/PartitioningR4Test.java", "diffHunk": "@@ -0,0 +1,2145 @@\n+package ca.uhn.fhir.jpa.dao.r4;\n+\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Interceptor;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.interceptor.model.PartitionId;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.jpa.model.entity.*;\n+import ca.uhn.fhir.jpa.partition.IPartitionConfigSvc;\n+import ca.uhn.fhir.jpa.searchparam.SearchParamConstants;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import ca.uhn.fhir.rest.api.Constants;\n+import ca.uhn.fhir.rest.api.server.IBundleProvider;\n+import ca.uhn.fhir.rest.param.DateAndListParam;\n+import ca.uhn.fhir.rest.param.DateOrListParam;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.rest.param.ReferenceParam;\n+import ca.uhn.fhir.rest.param.StringParam;\n+import ca.uhn.fhir.rest.param.TokenParam;\n+import ca.uhn.fhir.rest.param.TokenParamModifier;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import ca.uhn.fhir.rest.server.exceptions.MethodNotAllowedException;\n+import ca.uhn.fhir.rest.server.exceptions.PreconditionFailedException;\n+import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n+import ca.uhn.fhir.rest.server.exceptions.UnprocessableEntityException;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import ca.uhn.fhir.util.TestUtil;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.Validate;\n+import org.hamcrest.Matchers;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IIdType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.hl7.fhir.r4.model.Enumerations;\n+import org.hl7.fhir.r4.model.IdType;\n+import org.hl7.fhir.r4.model.Observation;\n+import org.hl7.fhir.r4.model.Organization;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.hl7.fhir.r4.model.SearchParameter;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import javax.servlet.ServletException;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+import static org.hamcrest.Matchers.matchesPattern;\n+import static org.hamcrest.Matchers.startsWith;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.when;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class PartitioningR4Test extends BaseJpaR4SystemTest {\n+\n+\tprivate static final org.slf4j.Logger ourLog = org.slf4j.LoggerFactory.getLogger(PartitioningR4Test.class);\n+\n+\tprivate MyInterceptor myPartitionInterceptor;\n+\tprivate LocalDate myPartitionDate;\n+\tprivate LocalDate myPartitionDate2;\n+\tprivate int myPartitionId;\n+\tprivate int myPartitionId2;\n+\tprivate boolean myHaveDroppedForcedIdUniqueConstraint;\n+\t@Autowired\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\n+\t@After\n+\tpublic void after() {\n+\t\tmyPartitionInterceptor.assertNoRemainingIds();\n+\n+\t\tmyPartitionSettings.setIncludePartitionInSearchHashes(new PartitionSettings().isIncludePartitionInSearchHashes());\n+\t\tmyPartitionSettings.setPartitioningEnabled(new PartitionSettings().isPartitioningEnabled());\n+\t\tmyPartitionSettings.setAllowReferencesAcrossPartitions(new PartitionSettings().getAllowReferencesAcrossPartitions());\n+\n+\t\tmyInterceptorRegistry.unregisterInterceptorsIf(t -> t instanceof MyInterceptor);\n+\t\tmyInterceptor = null;\n+\n+\t\tif (myHaveDroppedForcedIdUniqueConstraint) {\n+\t\t\trunInTransaction(() -> {\n+\t\t\t\tmyEntityManager.createNativeQuery(\"delete from HFJ_FORCED_ID\").executeUpdate();\n+\t\t\t\tmyEntityManager.createNativeQuery(\"alter table HFJ_FORCED_ID add constraint IDX_FORCEDID_TYPE_FID unique (RESOURCE_TYPE, FORCED_ID)\");\n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\t@Override\n+\t@Before\n+\tpublic void before() throws ServletException {\n+\t\tsuper.before();\n+\n+\t\tmyPartitionSettings.setPartitioningEnabled(true);\n+\t\tmyPartitionSettings.setIncludePartitionInSearchHashes(new PartitionSettings().isIncludePartitionInSearchHashes());\n+\n+\t\tmyDaoConfig.setUniqueIndexesEnabled(true);\n+\n+\t\tmyModelConfig.setDefaultSearchParamsCanBeOverridden(true);\n+\n+\t\tmyPartitionDate = LocalDate.of(2020, Month.JANUARY, 14);\n+\t\tmyPartitionDate2 = LocalDate.of(2020, Month.JANUARY, 15);\n+\t\tmyPartitionId = 1;\n+\t\tmyPartitionId2 = 2;\n+\n+\t\tmyPartitionInterceptor = new MyInterceptor();\n+\t\tmyInterceptorRegistry.registerInterceptor(myPartitionInterceptor);\n+\n+\t\tmyPartitionConfigSvc.createPartition(new PartitionEntity().setId(1).setName(\"PART-1\"));\n+\t\tmyPartitionConfigSvc.createPartition(new PartitionEntity().setId(2).setName(\"PART-2\"));\n+\t\tmyPartitionConfigSvc.createPartition(new PartitionEntity().setId(3).setName(\"PART-3\"));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateSearchParameter_DefaultPartition() {\n+\t\taddCreateNoPartition();\n+\n+\t\tSearchParameter sp = new SearchParameter();\n+\t\tsp.addBase(\"Patient\");\n+\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\tsp.setType(Enumerations.SearchParamType.REFERENCE);\n+\t\tsp.setCode(\"extpatorg\");\n+\t\tsp.setName(\"extpatorg\");\n+\t\tsp.setExpression(\"Patient.extension('http://patext').value.as(Reference)\");\n+\t\tLong id = mySearchParameterDao.create(sp).getId().getIdPartAsLong();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tResourceTable resourceTable = myResourceTableDao.findById(id).orElseThrow(IllegalArgumentException::new);\n+\t\t\tassertNull(resourceTable.getPartitionId());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_CrossPartitionReference_ByPid_Allowed() {\n+\t\tmyPartitionSettings.setAllowReferencesAcrossPartitions(PartitionSettings.CrossPartitionReferenceMode.ALLOWED_UNQUALIFIED);\n+\n+\t\t// Create patient in partition 1\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.create(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition 2\n+\t\taddCreatePartition(myPartitionId2, myPartitionDate2);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\t\tIIdType obsId = myObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tList<ResourceLink> resLinks = myResourceLinkDao.findAll();\n+\t\t\tourLog.info(\"Resource links:\\n{}\", resLinks.toString());\n+\t\t\tassertEquals(2, resLinks.size());\n+\t\t\tassertEquals(obsId.getIdPartAsLong(), resLinks.get(0).getSourceResourcePid());\n+\t\t\tassertEquals(patientId.getIdPartAsLong(), resLinks.get(0).getTargetResourcePid());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_CrossPartitionReference_ByPid_NotAllowed() {\n+\n+\t\t// Create patient in partition 1\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.create(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition 2\n+\t\taddCreatePartition(myPartitionId2, myPartitionDate2);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\n+\t\ttry {\n+\t\t\tmyObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\t\t\tfail();\n+\t\t} catch (InvalidRequestException e) {\n+\t\t\tassertThat(e.getMessage(), startsWith(\"Resource Patient/\" + patientId.getIdPart() + \" not found, specified in path: Observation.subject\"));\n+\t\t}\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_CrossPartitionReference_ByForcedId_Allowed() {\n+\t\tmyPartitionSettings.setAllowReferencesAcrossPartitions(PartitionSettings.CrossPartitionReferenceMode.ALLOWED_UNQUALIFIED);\n+\n+\t\t// Create patient in partition 1\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"ONE\");\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.update(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition 2\n+\t\taddCreatePartition(myPartitionId2, myPartitionDate2);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\t\tIIdType obsId = myObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tList<ResourceLink> resLinks = myResourceLinkDao.findAll();\n+\t\t\tourLog.info(\"Resource links:\\n{}\", resLinks.toString());\n+\t\t\tassertEquals(2, resLinks.size());\n+\t\t\tassertEquals(obsId.getIdPartAsLong(), resLinks.get(0).getSourceResourcePid());\n+\t\t\tassertEquals(patientId.getIdPart(), resLinks.get(0).getTargetResourceId());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_CrossPartitionReference_ByForcedId_NotAllowed() {\n+\n+\t\t// Create patient in partition 1\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"ONE\");\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.update(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition 2\n+\t\taddCreatePartition(myPartitionId2, myPartitionDate2);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\n+\t\ttry {\n+\t\t\tmyObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\t\t\tfail();\n+\t\t} catch (InvalidRequestException e) {\n+\t\t\tassertThat(e.getMessage(), startsWith(\"Resource Patient/ONE not found, specified in path: Observation.subject\"));\n+\t\t}\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_SamePartitionReference_DefaultPartition_ByPid() {\n+\t\t// Create patient in partition NULL\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.create(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition NULL\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\t\tIIdType obsId = myObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tList<ResourceLink> resLinks = myResourceLinkDao.findAll();\n+\t\t\tourLog.info(\"Resource links:\\n{}\", resLinks.toString());\n+\t\t\tassertEquals(2, resLinks.size());\n+\t\t\tassertEquals(obsId.getIdPartAsLong(), resLinks.get(0).getSourceResourcePid());\n+\t\t\tassertEquals(patientId.getIdPartAsLong(), resLinks.get(0).getTargetResourcePid());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_SamePartitionReference_DefaultPartition_ByForcedId() {\n+\t\t// Create patient in partition NULL\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"ONE\");\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.update(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition NULL\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\t\tIIdType obsId = myObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tList<ResourceLink> resLinks = myResourceLinkDao.findAll();\n+\t\t\tourLog.info(\"Resource links:\\n{}\", resLinks.toString());\n+\t\t\tassertEquals(2, resLinks.size());\n+\t\t\tassertEquals(obsId.getIdPartAsLong(), resLinks.get(0).getSourceResourcePid());\n+\t\t\tassertEquals(patientId.getIdPart(), resLinks.get(0).getTargetResourceId());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateSearchParameter_DefaultPartitionWithDate() {\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\n+\t\tSearchParameter sp = new SearchParameter();\n+\t\tsp.addBase(\"Patient\");\n+\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\tsp.setType(Enumerations.SearchParamType.REFERENCE);\n+\t\tsp.setCode(\"extpatorg\");\n+\t\tsp.setName(\"extpatorg\");\n+\t\tsp.setExpression(\"Patient.extension('http://patext').value.as(Reference)\");\n+\t\tLong id = mySearchParameterDao.create(sp).getId().getIdPartAsLong();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\t// HFJ_RESOURCE\n+\t\t\tResourceTable resourceTable = myResourceTableDao.findById(id).orElseThrow(IllegalArgumentException::new);\n+\t\t\tassertNull(resourceTable.getPartitionId().getPartitionId());\n+\t\t\tassertEquals(myPartitionDate, resourceTable.getPartitionId().getPartitionDate());\n+\t\t});\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testCreateSearchParameter_NonDefaultPartition() {\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\n+\t\tSearchParameter sp = new SearchParameter();\n+\t\tsp.addBase(\"Patient\");\n+\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\tsp.setType(Enumerations.SearchParamType.REFERENCE);\n+\t\tsp.setCode(\"extpatorg\");\n+\t\tsp.setName(\"extpatorg\");\n+\t\tsp.setExpression(\"Patient.extension('http://patext').value.as(Reference)\");\n+\t\ttry {\n+\t\t\tmySearchParameterDao.create(sp);\n+\t\t\tfail();\n+\t\t} catch (UnprocessableEntityException e) {\n+\t\t\tassertEquals(\"Resource type SearchParameter can not be partitioned\", e.getMessage());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_UnknownPartition() {\n+\t\taddCreatePartition(99, null);\n+\n+\t\tPatient p = new Patient();\n+\t\tp.addIdentifier().setSystem(\"system\").setValue(\"value\");\n+\t\tp.setBirthDate(new Date());\n+\t\ttry {\n+\t\t\tmyPatientDao.create(p);\n+\t\t\tfail();\n+\t\t} catch (InvalidRequestException e) {\n+\t\t\tassertEquals(\"Unknown partition ID: 99\", e.getMessage());\n+\t\t}\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_ServerId_NoPartition() {\n+\t\taddCreateNoPartition();\n+\n+\t\tPatient p = new Patient();\n+\t\tp.addIdentifier().setSystem(\"system\").setValue(\"value\");\n+\t\tp.setBirthDate(new Date());\n+\t\tLong patientId = myPatientDao.create(p).getId().getIdPartAsLong();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tResourceTable resourceTable = myResourceTableDao.findById(patientId).orElseThrow(IllegalArgumentException::new);\n+\t\t\tassertNull(resourceTable.getPartitionId());\n+\t\t});\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testCreate_ServerId_WithPartition() {\n+\t\tcreateUniqueCompositeSp();\n+\t\tcreateRequestId();\n+\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 368}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4ODc4Ng==", "bodyText": "we add 2 creates because we're about to create 2 resources... i'lll reorder to make that more clear", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412588786", "createdAt": "2020-04-22T00:47:19Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/PartitioningR4Test.java", "diffHunk": "@@ -0,0 +1,2145 @@\n+package ca.uhn.fhir.jpa.dao.r4;\n+\n+import ca.uhn.fhir.interceptor.api.Hook;\n+import ca.uhn.fhir.interceptor.api.Interceptor;\n+import ca.uhn.fhir.interceptor.api.Pointcut;\n+import ca.uhn.fhir.interceptor.model.PartitionId;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.config.PartitionSettings;\n+import ca.uhn.fhir.jpa.model.entity.*;\n+import ca.uhn.fhir.jpa.partition.IPartitionConfigSvc;\n+import ca.uhn.fhir.jpa.searchparam.SearchParamConstants;\n+import ca.uhn.fhir.jpa.searchparam.SearchParameterMap;\n+import ca.uhn.fhir.rest.api.Constants;\n+import ca.uhn.fhir.rest.api.server.IBundleProvider;\n+import ca.uhn.fhir.rest.param.DateAndListParam;\n+import ca.uhn.fhir.rest.param.DateOrListParam;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.rest.param.ReferenceParam;\n+import ca.uhn.fhir.rest.param.StringParam;\n+import ca.uhn.fhir.rest.param.TokenParam;\n+import ca.uhn.fhir.rest.param.TokenParamModifier;\n+import ca.uhn.fhir.rest.server.exceptions.InvalidRequestException;\n+import ca.uhn.fhir.rest.server.exceptions.MethodNotAllowedException;\n+import ca.uhn.fhir.rest.server.exceptions.PreconditionFailedException;\n+import ca.uhn.fhir.rest.server.exceptions.ResourceNotFoundException;\n+import ca.uhn.fhir.rest.server.exceptions.UnprocessableEntityException;\n+import ca.uhn.fhir.rest.server.servlet.ServletRequestDetails;\n+import ca.uhn.fhir.util.TestUtil;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.commons.lang3.Validate;\n+import org.hamcrest.Matchers;\n+import org.hl7.fhir.instance.model.api.IBaseResource;\n+import org.hl7.fhir.instance.model.api.IIdType;\n+import org.hl7.fhir.r4.model.BooleanType;\n+import org.hl7.fhir.r4.model.Enumerations;\n+import org.hl7.fhir.r4.model.IdType;\n+import org.hl7.fhir.r4.model.Observation;\n+import org.hl7.fhir.r4.model.Organization;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.hl7.fhir.r4.model.SearchParameter;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+\n+import javax.servlet.ServletException;\n+import java.time.LocalDate;\n+import java.time.Month;\n+import java.util.ArrayList;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import static org.apache.commons.lang3.StringUtils.isNotBlank;\n+import static org.hamcrest.Matchers.matchesPattern;\n+import static org.hamcrest.Matchers.startsWith;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertThat;\n+import static org.junit.Assert.fail;\n+import static org.mockito.Mockito.when;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class PartitioningR4Test extends BaseJpaR4SystemTest {\n+\n+\tprivate static final org.slf4j.Logger ourLog = org.slf4j.LoggerFactory.getLogger(PartitioningR4Test.class);\n+\n+\tprivate MyInterceptor myPartitionInterceptor;\n+\tprivate LocalDate myPartitionDate;\n+\tprivate LocalDate myPartitionDate2;\n+\tprivate int myPartitionId;\n+\tprivate int myPartitionId2;\n+\tprivate boolean myHaveDroppedForcedIdUniqueConstraint;\n+\t@Autowired\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\n+\t@After\n+\tpublic void after() {\n+\t\tmyPartitionInterceptor.assertNoRemainingIds();\n+\n+\t\tmyPartitionSettings.setIncludePartitionInSearchHashes(new PartitionSettings().isIncludePartitionInSearchHashes());\n+\t\tmyPartitionSettings.setPartitioningEnabled(new PartitionSettings().isPartitioningEnabled());\n+\t\tmyPartitionSettings.setAllowReferencesAcrossPartitions(new PartitionSettings().getAllowReferencesAcrossPartitions());\n+\n+\t\tmyInterceptorRegistry.unregisterInterceptorsIf(t -> t instanceof MyInterceptor);\n+\t\tmyInterceptor = null;\n+\n+\t\tif (myHaveDroppedForcedIdUniqueConstraint) {\n+\t\t\trunInTransaction(() -> {\n+\t\t\t\tmyEntityManager.createNativeQuery(\"delete from HFJ_FORCED_ID\").executeUpdate();\n+\t\t\t\tmyEntityManager.createNativeQuery(\"alter table HFJ_FORCED_ID add constraint IDX_FORCEDID_TYPE_FID unique (RESOURCE_TYPE, FORCED_ID)\");\n+\t\t\t});\n+\t\t}\n+\t}\n+\n+\t@Override\n+\t@Before\n+\tpublic void before() throws ServletException {\n+\t\tsuper.before();\n+\n+\t\tmyPartitionSettings.setPartitioningEnabled(true);\n+\t\tmyPartitionSettings.setIncludePartitionInSearchHashes(new PartitionSettings().isIncludePartitionInSearchHashes());\n+\n+\t\tmyDaoConfig.setUniqueIndexesEnabled(true);\n+\n+\t\tmyModelConfig.setDefaultSearchParamsCanBeOverridden(true);\n+\n+\t\tmyPartitionDate = LocalDate.of(2020, Month.JANUARY, 14);\n+\t\tmyPartitionDate2 = LocalDate.of(2020, Month.JANUARY, 15);\n+\t\tmyPartitionId = 1;\n+\t\tmyPartitionId2 = 2;\n+\n+\t\tmyPartitionInterceptor = new MyInterceptor();\n+\t\tmyInterceptorRegistry.registerInterceptor(myPartitionInterceptor);\n+\n+\t\tmyPartitionConfigSvc.createPartition(new PartitionEntity().setId(1).setName(\"PART-1\"));\n+\t\tmyPartitionConfigSvc.createPartition(new PartitionEntity().setId(2).setName(\"PART-2\"));\n+\t\tmyPartitionConfigSvc.createPartition(new PartitionEntity().setId(3).setName(\"PART-3\"));\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateSearchParameter_DefaultPartition() {\n+\t\taddCreateNoPartition();\n+\n+\t\tSearchParameter sp = new SearchParameter();\n+\t\tsp.addBase(\"Patient\");\n+\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\tsp.setType(Enumerations.SearchParamType.REFERENCE);\n+\t\tsp.setCode(\"extpatorg\");\n+\t\tsp.setName(\"extpatorg\");\n+\t\tsp.setExpression(\"Patient.extension('http://patext').value.as(Reference)\");\n+\t\tLong id = mySearchParameterDao.create(sp).getId().getIdPartAsLong();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tResourceTable resourceTable = myResourceTableDao.findById(id).orElseThrow(IllegalArgumentException::new);\n+\t\t\tassertNull(resourceTable.getPartitionId());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_CrossPartitionReference_ByPid_Allowed() {\n+\t\tmyPartitionSettings.setAllowReferencesAcrossPartitions(PartitionSettings.CrossPartitionReferenceMode.ALLOWED_UNQUALIFIED);\n+\n+\t\t// Create patient in partition 1\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.create(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition 2\n+\t\taddCreatePartition(myPartitionId2, myPartitionDate2);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\t\tIIdType obsId = myObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tList<ResourceLink> resLinks = myResourceLinkDao.findAll();\n+\t\t\tourLog.info(\"Resource links:\\n{}\", resLinks.toString());\n+\t\t\tassertEquals(2, resLinks.size());\n+\t\t\tassertEquals(obsId.getIdPartAsLong(), resLinks.get(0).getSourceResourcePid());\n+\t\t\tassertEquals(patientId.getIdPartAsLong(), resLinks.get(0).getTargetResourcePid());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_CrossPartitionReference_ByPid_NotAllowed() {\n+\n+\t\t// Create patient in partition 1\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.create(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition 2\n+\t\taddCreatePartition(myPartitionId2, myPartitionDate2);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\n+\t\ttry {\n+\t\t\tmyObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\t\t\tfail();\n+\t\t} catch (InvalidRequestException e) {\n+\t\t\tassertThat(e.getMessage(), startsWith(\"Resource Patient/\" + patientId.getIdPart() + \" not found, specified in path: Observation.subject\"));\n+\t\t}\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_CrossPartitionReference_ByForcedId_Allowed() {\n+\t\tmyPartitionSettings.setAllowReferencesAcrossPartitions(PartitionSettings.CrossPartitionReferenceMode.ALLOWED_UNQUALIFIED);\n+\n+\t\t// Create patient in partition 1\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"ONE\");\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.update(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition 2\n+\t\taddCreatePartition(myPartitionId2, myPartitionDate2);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\t\tIIdType obsId = myObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tList<ResourceLink> resLinks = myResourceLinkDao.findAll();\n+\t\t\tourLog.info(\"Resource links:\\n{}\", resLinks.toString());\n+\t\t\tassertEquals(2, resLinks.size());\n+\t\t\tassertEquals(obsId.getIdPartAsLong(), resLinks.get(0).getSourceResourcePid());\n+\t\t\tassertEquals(patientId.getIdPart(), resLinks.get(0).getTargetResourceId());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_CrossPartitionReference_ByForcedId_NotAllowed() {\n+\n+\t\t// Create patient in partition 1\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"ONE\");\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.update(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition 2\n+\t\taddCreatePartition(myPartitionId2, myPartitionDate2);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\n+\t\ttry {\n+\t\t\tmyObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\t\t\tfail();\n+\t\t} catch (InvalidRequestException e) {\n+\t\t\tassertThat(e.getMessage(), startsWith(\"Resource Patient/ONE not found, specified in path: Observation.subject\"));\n+\t\t}\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_SamePartitionReference_DefaultPartition_ByPid() {\n+\t\t// Create patient in partition NULL\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.create(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition NULL\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\t\tIIdType obsId = myObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tList<ResourceLink> resLinks = myResourceLinkDao.findAll();\n+\t\t\tourLog.info(\"Resource links:\\n{}\", resLinks.toString());\n+\t\t\tassertEquals(2, resLinks.size());\n+\t\t\tassertEquals(obsId.getIdPartAsLong(), resLinks.get(0).getSourceResourcePid());\n+\t\t\tassertEquals(patientId.getIdPartAsLong(), resLinks.get(0).getTargetResourcePid());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_SamePartitionReference_DefaultPartition_ByForcedId() {\n+\t\t// Create patient in partition NULL\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\t\tPatient patient = new Patient();\n+\t\tpatient.setId(\"ONE\");\n+\t\tpatient.setActive(true);\n+\t\tIIdType patientId = myPatientDao.update(patient).getId().toUnqualifiedVersionless();\n+\n+\t\t// Create observation in partition NULL\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\t\tObservation obs = new Observation();\n+\t\tobs.getSubject().setReference(patientId.getValue());\n+\t\tIIdType obsId = myObservationDao.create(obs).getId().toUnqualifiedVersionless();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tList<ResourceLink> resLinks = myResourceLinkDao.findAll();\n+\t\t\tourLog.info(\"Resource links:\\n{}\", resLinks.toString());\n+\t\t\tassertEquals(2, resLinks.size());\n+\t\t\tassertEquals(obsId.getIdPartAsLong(), resLinks.get(0).getSourceResourcePid());\n+\t\t\tassertEquals(patientId.getIdPart(), resLinks.get(0).getTargetResourceId());\n+\t\t});\n+\t}\n+\n+\t@Test\n+\tpublic void testCreateSearchParameter_DefaultPartitionWithDate() {\n+\t\taddCreateNoPartitionId(myPartitionDate);\n+\n+\t\tSearchParameter sp = new SearchParameter();\n+\t\tsp.addBase(\"Patient\");\n+\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\tsp.setType(Enumerations.SearchParamType.REFERENCE);\n+\t\tsp.setCode(\"extpatorg\");\n+\t\tsp.setName(\"extpatorg\");\n+\t\tsp.setExpression(\"Patient.extension('http://patext').value.as(Reference)\");\n+\t\tLong id = mySearchParameterDao.create(sp).getId().getIdPartAsLong();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\t// HFJ_RESOURCE\n+\t\t\tResourceTable resourceTable = myResourceTableDao.findById(id).orElseThrow(IllegalArgumentException::new);\n+\t\t\tassertNull(resourceTable.getPartitionId().getPartitionId());\n+\t\t\tassertEquals(myPartitionDate, resourceTable.getPartitionId().getPartitionDate());\n+\t\t});\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testCreateSearchParameter_NonDefaultPartition() {\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\n+\t\tSearchParameter sp = new SearchParameter();\n+\t\tsp.addBase(\"Patient\");\n+\t\tsp.setStatus(Enumerations.PublicationStatus.ACTIVE);\n+\t\tsp.setType(Enumerations.SearchParamType.REFERENCE);\n+\t\tsp.setCode(\"extpatorg\");\n+\t\tsp.setName(\"extpatorg\");\n+\t\tsp.setExpression(\"Patient.extension('http://patext').value.as(Reference)\");\n+\t\ttry {\n+\t\t\tmySearchParameterDao.create(sp);\n+\t\t\tfail();\n+\t\t} catch (UnprocessableEntityException e) {\n+\t\t\tassertEquals(\"Resource type SearchParameter can not be partitioned\", e.getMessage());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_UnknownPartition() {\n+\t\taddCreatePartition(99, null);\n+\n+\t\tPatient p = new Patient();\n+\t\tp.addIdentifier().setSystem(\"system\").setValue(\"value\");\n+\t\tp.setBirthDate(new Date());\n+\t\ttry {\n+\t\t\tmyPatientDao.create(p);\n+\t\t\tfail();\n+\t\t} catch (InvalidRequestException e) {\n+\t\t\tassertEquals(\"Unknown partition ID: 99\", e.getMessage());\n+\t\t}\n+\n+\t}\n+\n+\t@Test\n+\tpublic void testCreate_ServerId_NoPartition() {\n+\t\taddCreateNoPartition();\n+\n+\t\tPatient p = new Patient();\n+\t\tp.addIdentifier().setSystem(\"system\").setValue(\"value\");\n+\t\tp.setBirthDate(new Date());\n+\t\tLong patientId = myPatientDao.create(p).getId().getIdPartAsLong();\n+\n+\t\trunInTransaction(() -> {\n+\t\t\tResourceTable resourceTable = myResourceTableDao.findById(patientId).orElseThrow(IllegalArgumentException::new);\n+\t\t\tassertNull(resourceTable.getPartitionId());\n+\t\t});\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testCreate_ServerId_WithPartition() {\n+\t\tcreateUniqueCompositeSp();\n+\t\tcreateRequestId();\n+\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);\n+\t\taddCreatePartition(myPartitionId, myPartitionDate);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQ1MzA3Mw=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 368}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzIzMDk1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/partition/PartitionManagementProviderTest.java", "isResolved": true, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTozNzo1MFrOGJZkuA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzozODo0M1rOGJ27tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTM2OA==", "bodyText": "this is unlikely to fail, but this feels like a weak assert.\nCan you strength any() here?  can it go createPartition(eq(expectedPartition))", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412509368", "createdAt": "2020-04-21T21:37:50Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/partition/PartitionManagementProviderTest.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.util.ProviderConstants;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.client.interceptor.LoggingInterceptor;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import org.hl7.fhir.r4.model.CodeType;\n+import org.hl7.fhir.r4.model.IntegerType;\n+import org.hl7.fhir.r4.model.Parameters;\n+import org.hl7.fhir.r4.model.StringType;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.stubbing.Answer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(classes = PartitionManagementProviderTest.MyConfig.class)\n+public class PartitionManagementProviderTest {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(PartitionManagementProviderTest.class);\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\t@MockBean\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\t@Autowired\n+\tprivate PartitionManagementProvider myPartitionManagementProvider;\n+\tprivate IGenericClient myClient;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tourServerRule.getRestfulServer().registerProvider(myPartitionManagementProvider);\n+\t\tmyClient = ourServerRule.getFhirClient();\n+\t\tmyClient.registerInterceptor(new LoggingInterceptor(false));\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\tourServerRule.getRestfulServer().unregisterProvider(myPartitionManagementProvider);\n+\t}\n+\n+\t@Test\n+\tpublic void testAddPartition() {\n+\t\twhen(myPartitionConfigSvc.createPartition(any())).thenAnswer(createAnswer());\n+\n+\t\tParameters input = new Parameters();\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_ID, new IntegerType(123));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_NAME, new CodeType(\"PARTITION-123\"));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_DESC, new StringType(\"a description\"));\n+\t\tourLog.info(\"Input:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(input));\n+\n+\t\tParameters response = myClient\n+\t\t\t.operation()\n+\t\t\t.onServer()\n+\t\t\t.named(ProviderConstants.PARTITION_MANAGEMENT_ADD_PARTITION)\n+\t\t\t.withParameters(input)\n+\t\t\t.encodedXml()\n+\t\t\t.execute();\n+\n+\t\tourLog.info(\"Response:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(response));\n+\t\tverify(myPartitionConfigSvc, times(1)).createPartition(any());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3NTI2Mw==", "bodyText": "We're verifying the response, which contains the same contents we sent in, so we know it is good.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412575263", "createdAt": "2020-04-22T00:07:58Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/partition/PartitionManagementProviderTest.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.util.ProviderConstants;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.client.interceptor.LoggingInterceptor;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import org.hl7.fhir.r4.model.CodeType;\n+import org.hl7.fhir.r4.model.IntegerType;\n+import org.hl7.fhir.r4.model.Parameters;\n+import org.hl7.fhir.r4.model.StringType;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.stubbing.Answer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(classes = PartitionManagementProviderTest.MyConfig.class)\n+public class PartitionManagementProviderTest {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(PartitionManagementProviderTest.class);\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\t@MockBean\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\t@Autowired\n+\tprivate PartitionManagementProvider myPartitionManagementProvider;\n+\tprivate IGenericClient myClient;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tourServerRule.getRestfulServer().registerProvider(myPartitionManagementProvider);\n+\t\tmyClient = ourServerRule.getFhirClient();\n+\t\tmyClient.registerInterceptor(new LoggingInterceptor(false));\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\tourServerRule.getRestfulServer().unregisterProvider(myPartitionManagementProvider);\n+\t}\n+\n+\t@Test\n+\tpublic void testAddPartition() {\n+\t\twhen(myPartitionConfigSvc.createPartition(any())).thenAnswer(createAnswer());\n+\n+\t\tParameters input = new Parameters();\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_ID, new IntegerType(123));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_NAME, new CodeType(\"PARTITION-123\"));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_DESC, new StringType(\"a description\"));\n+\t\tourLog.info(\"Input:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(input));\n+\n+\t\tParameters response = myClient\n+\t\t\t.operation()\n+\t\t\t.onServer()\n+\t\t\t.named(ProviderConstants.PARTITION_MANAGEMENT_ADD_PARTITION)\n+\t\t\t.withParameters(input)\n+\t\t\t.encodedXml()\n+\t\t\t.execute();\n+\n+\t\tourLog.info(\"Response:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(response));\n+\t\tverify(myPartitionConfigSvc, times(1)).createPartition(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTM2OA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MTkzMg==", "bodyText": "but the service is mocked\nI think the ideal mock provider tests confirm that the REST parameters got properly translated to service method parameters", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412581932", "createdAt": "2020-04-22T00:26:44Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/partition/PartitionManagementProviderTest.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.util.ProviderConstants;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.client.interceptor.LoggingInterceptor;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import org.hl7.fhir.r4.model.CodeType;\n+import org.hl7.fhir.r4.model.IntegerType;\n+import org.hl7.fhir.r4.model.Parameters;\n+import org.hl7.fhir.r4.model.StringType;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.stubbing.Answer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(classes = PartitionManagementProviderTest.MyConfig.class)\n+public class PartitionManagementProviderTest {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(PartitionManagementProviderTest.class);\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\t@MockBean\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\t@Autowired\n+\tprivate PartitionManagementProvider myPartitionManagementProvider;\n+\tprivate IGenericClient myClient;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tourServerRule.getRestfulServer().registerProvider(myPartitionManagementProvider);\n+\t\tmyClient = ourServerRule.getFhirClient();\n+\t\tmyClient.registerInterceptor(new LoggingInterceptor(false));\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\tourServerRule.getRestfulServer().unregisterProvider(myPartitionManagementProvider);\n+\t}\n+\n+\t@Test\n+\tpublic void testAddPartition() {\n+\t\twhen(myPartitionConfigSvc.createPartition(any())).thenAnswer(createAnswer());\n+\n+\t\tParameters input = new Parameters();\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_ID, new IntegerType(123));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_NAME, new CodeType(\"PARTITION-123\"));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_DESC, new StringType(\"a description\"));\n+\t\tourLog.info(\"Input:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(input));\n+\n+\t\tParameters response = myClient\n+\t\t\t.operation()\n+\t\t\t.onServer()\n+\t\t\t.named(ProviderConstants.PARTITION_MANAGEMENT_ADD_PARTITION)\n+\t\t\t.withParameters(input)\n+\t\t\t.encodedXml()\n+\t\t\t.execute();\n+\n+\t\tourLog.info(\"Response:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(response));\n+\t\tverify(myPartitionConfigSvc, times(1)).createPartition(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTM2OA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjkwNjIyNA==", "bodyText": "Well yeah but that mock implementation returns the same thing it receives, not a hardcoded response. So if we see data in the response, it can only have come from the request. I'm not getting what added value testing things in the intermediate state would add, unless we didn't trust HAPI's operations framework", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412906224", "createdAt": "2020-04-22T11:39:15Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/partition/PartitionManagementProviderTest.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.util.ProviderConstants;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.client.interceptor.LoggingInterceptor;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import org.hl7.fhir.r4.model.CodeType;\n+import org.hl7.fhir.r4.model.IntegerType;\n+import org.hl7.fhir.r4.model.Parameters;\n+import org.hl7.fhir.r4.model.StringType;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.stubbing.Answer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(classes = PartitionManagementProviderTest.MyConfig.class)\n+public class PartitionManagementProviderTest {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(PartitionManagementProviderTest.class);\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\t@MockBean\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\t@Autowired\n+\tprivate PartitionManagementProvider myPartitionManagementProvider;\n+\tprivate IGenericClient myClient;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tourServerRule.getRestfulServer().registerProvider(myPartitionManagementProvider);\n+\t\tmyClient = ourServerRule.getFhirClient();\n+\t\tmyClient.registerInterceptor(new LoggingInterceptor(false));\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\tourServerRule.getRestfulServer().unregisterProvider(myPartitionManagementProvider);\n+\t}\n+\n+\t@Test\n+\tpublic void testAddPartition() {\n+\t\twhen(myPartitionConfigSvc.createPartition(any())).thenAnswer(createAnswer());\n+\n+\t\tParameters input = new Parameters();\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_ID, new IntegerType(123));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_NAME, new CodeType(\"PARTITION-123\"));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_DESC, new StringType(\"a description\"));\n+\t\tourLog.info(\"Input:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(input));\n+\n+\t\tParameters response = myClient\n+\t\t\t.operation()\n+\t\t\t.onServer()\n+\t\t\t.named(ProviderConstants.PARTITION_MANAGEMENT_ADD_PARTITION)\n+\t\t\t.withParameters(input)\n+\t\t\t.encodedXml()\n+\t\t\t.execute();\n+\n+\t\tourLog.info(\"Response:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(response));\n+\t\tverify(myPartitionConfigSvc, times(1)).createPartition(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTM2OA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5MDM4OQ==", "bodyText": "That means the test assumes that the provider returns what the service returns unchanged.  Might be a safe assumption or it might not be.  I'd need to look at the implementation to know.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412990389", "createdAt": "2020-04-22T13:38:43Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/partition/PartitionManagementProviderTest.java", "diffHunk": "@@ -0,0 +1,158 @@\n+package ca.uhn.fhir.jpa.partition;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.jpa.entity.PartitionEntity;\n+import ca.uhn.fhir.jpa.model.util.ProviderConstants;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.client.interceptor.LoggingInterceptor;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import org.hl7.fhir.r4.model.CodeType;\n+import org.hl7.fhir.r4.model.IntegerType;\n+import org.hl7.fhir.r4.model.Parameters;\n+import org.hl7.fhir.r4.model.StringType;\n+import org.jetbrains.annotations.NotNull;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.mockito.stubbing.Answer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.boot.test.mock.mockito.MockBean;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.test.context.ContextConfiguration;\n+import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.mockito.ArgumentMatchers.any;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(SpringJUnit4ClassRunner.class)\n+@ContextConfiguration(classes = PartitionManagementProviderTest.MyConfig.class)\n+public class PartitionManagementProviderTest {\n+\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(PartitionManagementProviderTest.class);\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\t@MockBean\n+\tprivate IPartitionConfigSvc myPartitionConfigSvc;\n+\t@Autowired\n+\tprivate PartitionManagementProvider myPartitionManagementProvider;\n+\tprivate IGenericClient myClient;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tourServerRule.getRestfulServer().registerProvider(myPartitionManagementProvider);\n+\t\tmyClient = ourServerRule.getFhirClient();\n+\t\tmyClient.registerInterceptor(new LoggingInterceptor(false));\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\tourServerRule.getRestfulServer().unregisterProvider(myPartitionManagementProvider);\n+\t}\n+\n+\t@Test\n+\tpublic void testAddPartition() {\n+\t\twhen(myPartitionConfigSvc.createPartition(any())).thenAnswer(createAnswer());\n+\n+\t\tParameters input = new Parameters();\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_ID, new IntegerType(123));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_NAME, new CodeType(\"PARTITION-123\"));\n+\t\tinput.addParameter(ProviderConstants.PARTITION_MANAGEMENT_PARTITION_DESC, new StringType(\"a description\"));\n+\t\tourLog.info(\"Input:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(input));\n+\n+\t\tParameters response = myClient\n+\t\t\t.operation()\n+\t\t\t.onServer()\n+\t\t\t.named(ProviderConstants.PARTITION_MANAGEMENT_ADD_PARTITION)\n+\t\t\t.withParameters(input)\n+\t\t\t.encodedXml()\n+\t\t\t.execute();\n+\n+\t\tourLog.info(\"Response:\\n{}\", ourCtx.newJsonParser().setPrettyPrint(true).encodeResourceToString(response));\n+\t\tverify(myPartitionConfigSvc, times(1)).createPartition(any());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUwOTM2OA=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 82}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzI1NjE1OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/tasks/HapiFhirJpaMigrationTasks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTo0NDozMFrOGJZyqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDowODoxMVrOGJdmcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMjkzOQ==", "bodyText": "double check version order before final merge", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412512939", "createdAt": "2020-04-21T21:44:30Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/tasks/HapiFhirJpaMigrationTasks.java", "diffHunk": "@@ -57,17 +58,68 @@ public HapiFhirJpaMigrationTasks(Set<String> theFlags) {\n \t\tinit400(); // 20190401 - 20190814\n \t\tinit410(); // 20190815 - 20191014\n \t\tinit420(); // 20191015 - 20200217\n-\t\tinit430(); // 20200218 - present\n+\t\tinit500(); // 20200218 - present\n \t}\n \n-\tprotected void init430() { // 20200218 - present\n+\tprotected void init500() { // 20200218 - present\n \t\tBuilder version = forVersion(VersionEnum.V4_3_0);\n \n \t\t// Eliminate circular dependency.\n \t\tversion.onTable(\"HFJ_RESOURCE\").dropColumn(\"20200218.1\", \"FORCED_ID_PID\");\n \t\tversion.onTable(\"HFJ_RES_VER\").dropColumn(\"20200218.2\", \"FORCED_ID_PID\");\n \t\tversion.onTable(\"HFJ_RES_VER\").addForeignKey(\"20200218.3\", \"FK_RESOURCE_HISTORY_RESOURCE\").toColumn(\"RES_ID\").references(\"HFJ_RESOURCE\", \"RES_ID\");\n \t\tversion.onTable(\"HFJ_RES_VER\").modifyColumn(\"20200220.1\", \"RES_ID\").nonNullable().failureAllowed().withType(BaseTableColumnTypeTask.ColumnTypeEnum.LONG);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3NTM0NQ==", "bodyText": "will do", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412575345", "createdAt": "2020-04-22T00:08:11Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/tasks/HapiFhirJpaMigrationTasks.java", "diffHunk": "@@ -57,17 +58,68 @@ public HapiFhirJpaMigrationTasks(Set<String> theFlags) {\n \t\tinit400(); // 20190401 - 20190814\n \t\tinit410(); // 20190815 - 20191014\n \t\tinit420(); // 20191015 - 20200217\n-\t\tinit430(); // 20200218 - present\n+\t\tinit500(); // 20200218 - present\n \t}\n \n-\tprotected void init430() { // 20200218 - present\n+\tprotected void init500() { // 20200218 - present\n \t\tBuilder version = forVersion(VersionEnum.V4_3_0);\n \n \t\t// Eliminate circular dependency.\n \t\tversion.onTable(\"HFJ_RESOURCE\").dropColumn(\"20200218.1\", \"FORCED_ID_PID\");\n \t\tversion.onTable(\"HFJ_RES_VER\").dropColumn(\"20200218.2\", \"FORCED_ID_PID\");\n \t\tversion.onTable(\"HFJ_RES_VER\").addForeignKey(\"20200218.3\", \"FK_RESOURCE_HISTORY_RESOURCE\").toColumn(\"RES_ID\").references(\"HFJ_RESOURCE\", \"RES_ID\");\n \t\tversion.onTable(\"HFJ_RES_VER\").modifyColumn(\"20200220.1\", \"RES_ID\").nonNullable().failureAllowed().withType(BaseTableColumnTypeTask.ColumnTypeEnum.LONG);\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMjkzOQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzI2MzQ5OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/tasks/HapiFhirJpaMigrationTasks.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTo0NjozMFrOGJZ24Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDowODozN1rOGJdm_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNDAxNw==", "bodyText": "I assume you're excluding the case where hashes need to be recalculated for now?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412514017", "createdAt": "2020-04-21T21:46:30Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/tasks/HapiFhirJpaMigrationTasks.java", "diffHunk": "@@ -511,7 +566,7 @@ private void init350() { // 20180601 - 20180917\n \t\t\tspidxNumber\n \t\t\t\t.addTask(new CalculateHashesTask(VersionEnum.V3_5_0, \"20180903.14\")\n \t\t\t\t\t.setColumnName(\"HASH_IDENTITY\")\n-\t\t\t\t\t.addCalculator(\"HASH_IDENTITY\", t -> BaseResourceIndexedSearchParam.calculateHashIdentity(t.getResourceType(), t.getString(\"SP_NAME\")))\n+\t\t\t\t\t.addCalculator(\"HASH_IDENTITY\", t -> BaseResourceIndexedSearchParam.calculateHashIdentity(new PartitionSettings(), null, t.getResourceType(), t.getString(\"SP_NAME\")))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3NTQ4NQ==", "bodyText": "Yeah, definitely out of scope for now", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412575485", "createdAt": "2020-04-22T00:08:37Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/tasks/HapiFhirJpaMigrationTasks.java", "diffHunk": "@@ -511,7 +566,7 @@ private void init350() { // 20180601 - 20180917\n \t\t\tspidxNumber\n \t\t\t\t.addTask(new CalculateHashesTask(VersionEnum.V3_5_0, \"20180903.14\")\n \t\t\t\t\t.setColumnName(\"HASH_IDENTITY\")\n-\t\t\t\t\t.addCalculator(\"HASH_IDENTITY\", t -> BaseResourceIndexedSearchParam.calculateHashIdentity(t.getResourceType(), t.getString(\"SP_NAME\")))\n+\t\t\t\t\t.addCalculator(\"HASH_IDENTITY\", t -> BaseResourceIndexedSearchParam.calculateHashIdentity(new PartitionSettings(), null, t.getResourceType(), t.getString(\"SP_NAME\")))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNDAxNw=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 117}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzI3MDQxOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/config/PartitionSettings.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTo0ODoyNlrOGJZ61Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoyODoyM1rOGJeCKw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTAyOQ==", "bodyText": "Consider adding:\nONLY_TO_DEFAULT_PARTITION,", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412515029", "createdAt": "2020-04-21T21:48:26Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/config/PartitionSettings.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package ca.uhn.fhir.jpa.model.config;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR Model\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+/**\n+ * @since 5.0.0\n+ */\n+public class PartitionSettings {\n+\n+\tprivate boolean myPartitioningEnabled = false;\n+\tprivate CrossPartitionReferenceMode myAllowReferencesAcrossPartitions = CrossPartitionReferenceMode.NOT_ALLOWED;\n+\tprivate boolean myIncludePartitionInSearchHashes = true;\n+\n+\t/**\n+\t * If set to <code>true</code> (default is <code>true</code>) the <code>PARTITION_ID</code> value will be factored into the\n+\t * hash values used in the <code>HFJ_SPIDX_xxx</code> tables, removing the need to explicitly add a selector\n+\t * on this column in queries. If set to <code>false</code>, an additional selector is used instead, which may perform\n+\t * better when using native database partitioning features.\n+\t * <p>\n+\t * This setting has no effect if partitioning is not enabled via {@link #isPartitioningEnabled()}.\n+\t * </p>\n+\t */\n+\tpublic boolean isIncludePartitionInSearchHashes() {\n+\t\treturn myIncludePartitionInSearchHashes;\n+\t}\n+\n+\t/**\n+\t * If set to <code>true</code> (default is <code>true</code>) the <code>PARTITION_ID</code> value will be factored into the\n+\t * hash values used in the <code>HFJ_SPIDX_xxx</code> tables, removing the need to explicitly add a selector\n+\t * on this column in queries. If set to <code>false</code>, an additional selector is used instead, which may perform\n+\t * better when using native database partitioning features.\n+\t * <p>\n+\t * This setting has no effect if partitioning is not enabled via {@link #isPartitioningEnabled()}.\n+\t * </p>\n+\t */\n+\tpublic void setIncludePartitionInSearchHashes(boolean theIncludePartitionInSearchHashes) {\n+\t\tmyIncludePartitionInSearchHashes = theIncludePartitionInSearchHashes;\n+\t}\n+\n+\t/**\n+\t * If enabled (default is <code>false</code>) the JPA server will support data partitioning\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic boolean isPartitioningEnabled() {\n+\t\treturn myPartitioningEnabled;\n+\t}\n+\n+\t/**\n+\t * If enabled (default is <code>false</code>) the JPA server will support data partitioning\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic void setPartitioningEnabled(boolean theMultiTenancyEnabled) {\n+\t\tmyPartitioningEnabled = theMultiTenancyEnabled;\n+\t}\n+\n+\t/**\n+\t * Should resources references be permitted to cross partition boundaries. Default is {@link CrossPartitionReferenceMode#NOT_ALLOWED}.\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic CrossPartitionReferenceMode getAllowReferencesAcrossPartitions() {\n+\t\treturn myAllowReferencesAcrossPartitions;\n+\t}\n+\n+\t/**\n+\t * Should resources references be permitted to cross partition boundaries. Default is {@link CrossPartitionReferenceMode#NOT_ALLOWED}.\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic void setAllowReferencesAcrossPartitions(CrossPartitionReferenceMode theAllowReferencesAcrossPartitions) {\n+\t\tmyAllowReferencesAcrossPartitions = theAllowReferencesAcrossPartitions;\n+\t}\n+\n+\n+\tpublic enum CrossPartitionReferenceMode {\n+\n+\t\t/**\n+\t\t * References between resources are not allowed to cross partition boundaries\n+\t\t */\n+\t\tNOT_ALLOWED,\n+\n+\t\t/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3NTY1MA==", "bodyText": "I'm going to leave that for a future ticket", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412575650", "createdAt": "2020-04-22T00:09:07Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/config/PartitionSettings.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package ca.uhn.fhir.jpa.model.config;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR Model\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+/**\n+ * @since 5.0.0\n+ */\n+public class PartitionSettings {\n+\n+\tprivate boolean myPartitioningEnabled = false;\n+\tprivate CrossPartitionReferenceMode myAllowReferencesAcrossPartitions = CrossPartitionReferenceMode.NOT_ALLOWED;\n+\tprivate boolean myIncludePartitionInSearchHashes = true;\n+\n+\t/**\n+\t * If set to <code>true</code> (default is <code>true</code>) the <code>PARTITION_ID</code> value will be factored into the\n+\t * hash values used in the <code>HFJ_SPIDX_xxx</code> tables, removing the need to explicitly add a selector\n+\t * on this column in queries. If set to <code>false</code>, an additional selector is used instead, which may perform\n+\t * better when using native database partitioning features.\n+\t * <p>\n+\t * This setting has no effect if partitioning is not enabled via {@link #isPartitioningEnabled()}.\n+\t * </p>\n+\t */\n+\tpublic boolean isIncludePartitionInSearchHashes() {\n+\t\treturn myIncludePartitionInSearchHashes;\n+\t}\n+\n+\t/**\n+\t * If set to <code>true</code> (default is <code>true</code>) the <code>PARTITION_ID</code> value will be factored into the\n+\t * hash values used in the <code>HFJ_SPIDX_xxx</code> tables, removing the need to explicitly add a selector\n+\t * on this column in queries. If set to <code>false</code>, an additional selector is used instead, which may perform\n+\t * better when using native database partitioning features.\n+\t * <p>\n+\t * This setting has no effect if partitioning is not enabled via {@link #isPartitioningEnabled()}.\n+\t * </p>\n+\t */\n+\tpublic void setIncludePartitionInSearchHashes(boolean theIncludePartitionInSearchHashes) {\n+\t\tmyIncludePartitionInSearchHashes = theIncludePartitionInSearchHashes;\n+\t}\n+\n+\t/**\n+\t * If enabled (default is <code>false</code>) the JPA server will support data partitioning\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic boolean isPartitioningEnabled() {\n+\t\treturn myPartitioningEnabled;\n+\t}\n+\n+\t/**\n+\t * If enabled (default is <code>false</code>) the JPA server will support data partitioning\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic void setPartitioningEnabled(boolean theMultiTenancyEnabled) {\n+\t\tmyPartitioningEnabled = theMultiTenancyEnabled;\n+\t}\n+\n+\t/**\n+\t * Should resources references be permitted to cross partition boundaries. Default is {@link CrossPartitionReferenceMode#NOT_ALLOWED}.\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic CrossPartitionReferenceMode getAllowReferencesAcrossPartitions() {\n+\t\treturn myAllowReferencesAcrossPartitions;\n+\t}\n+\n+\t/**\n+\t * Should resources references be permitted to cross partition boundaries. Default is {@link CrossPartitionReferenceMode#NOT_ALLOWED}.\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic void setAllowReferencesAcrossPartitions(CrossPartitionReferenceMode theAllowReferencesAcrossPartitions) {\n+\t\tmyAllowReferencesAcrossPartitions = theAllowReferencesAcrossPartitions;\n+\t}\n+\n+\n+\tpublic enum CrossPartitionReferenceMode {\n+\n+\t\t/**\n+\t\t * References between resources are not allowed to cross partition boundaries\n+\t\t */\n+\t\tNOT_ALLOWED,\n+\n+\t\t/**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTAyOQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 102}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU4MjQ0Mw==", "bodyText": "I know one client would really benefit from testing partition alignment on the way in, but they'll only be able to do that if a \"special\" lookup partition is excluded from the integrity check.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412582443", "createdAt": "2020-04-22T00:28:23Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/config/PartitionSettings.java", "diffHunk": "@@ -0,0 +1,109 @@\n+package ca.uhn.fhir.jpa.model.config;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR Model\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+/**\n+ * @since 5.0.0\n+ */\n+public class PartitionSettings {\n+\n+\tprivate boolean myPartitioningEnabled = false;\n+\tprivate CrossPartitionReferenceMode myAllowReferencesAcrossPartitions = CrossPartitionReferenceMode.NOT_ALLOWED;\n+\tprivate boolean myIncludePartitionInSearchHashes = true;\n+\n+\t/**\n+\t * If set to <code>true</code> (default is <code>true</code>) the <code>PARTITION_ID</code> value will be factored into the\n+\t * hash values used in the <code>HFJ_SPIDX_xxx</code> tables, removing the need to explicitly add a selector\n+\t * on this column in queries. If set to <code>false</code>, an additional selector is used instead, which may perform\n+\t * better when using native database partitioning features.\n+\t * <p>\n+\t * This setting has no effect if partitioning is not enabled via {@link #isPartitioningEnabled()}.\n+\t * </p>\n+\t */\n+\tpublic boolean isIncludePartitionInSearchHashes() {\n+\t\treturn myIncludePartitionInSearchHashes;\n+\t}\n+\n+\t/**\n+\t * If set to <code>true</code> (default is <code>true</code>) the <code>PARTITION_ID</code> value will be factored into the\n+\t * hash values used in the <code>HFJ_SPIDX_xxx</code> tables, removing the need to explicitly add a selector\n+\t * on this column in queries. If set to <code>false</code>, an additional selector is used instead, which may perform\n+\t * better when using native database partitioning features.\n+\t * <p>\n+\t * This setting has no effect if partitioning is not enabled via {@link #isPartitioningEnabled()}.\n+\t * </p>\n+\t */\n+\tpublic void setIncludePartitionInSearchHashes(boolean theIncludePartitionInSearchHashes) {\n+\t\tmyIncludePartitionInSearchHashes = theIncludePartitionInSearchHashes;\n+\t}\n+\n+\t/**\n+\t * If enabled (default is <code>false</code>) the JPA server will support data partitioning\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic boolean isPartitioningEnabled() {\n+\t\treturn myPartitioningEnabled;\n+\t}\n+\n+\t/**\n+\t * If enabled (default is <code>false</code>) the JPA server will support data partitioning\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic void setPartitioningEnabled(boolean theMultiTenancyEnabled) {\n+\t\tmyPartitioningEnabled = theMultiTenancyEnabled;\n+\t}\n+\n+\t/**\n+\t * Should resources references be permitted to cross partition boundaries. Default is {@link CrossPartitionReferenceMode#NOT_ALLOWED}.\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic CrossPartitionReferenceMode getAllowReferencesAcrossPartitions() {\n+\t\treturn myAllowReferencesAcrossPartitions;\n+\t}\n+\n+\t/**\n+\t * Should resources references be permitted to cross partition boundaries. Default is {@link CrossPartitionReferenceMode#NOT_ALLOWED}.\n+\t *\n+\t * @since 5.0.0\n+\t */\n+\tpublic void setAllowReferencesAcrossPartitions(CrossPartitionReferenceMode theAllowReferencesAcrossPartitions) {\n+\t\tmyAllowReferencesAcrossPartitions = theAllowReferencesAcrossPartitions;\n+\t}\n+\n+\n+\tpublic enum CrossPartitionReferenceMode {\n+\n+\t\t/**\n+\t\t * References between resources are not allowed to cross partition boundaries\n+\t\t */\n+\t\tNOT_ALLOWED,\n+\n+\t\t/**", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTAyOQ=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU2MzMwMzQ3OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-model/src/test/java/ca/uhn/fhir/jpa/model/entity/ResourceIndexedSearchParamStringTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTo1NzoyNFrOGJaNdA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQwMDoxNDoxMFrOGJduvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxOTc5Ng==", "bodyText": "One of these tests should compare with non-empty PartitionSettings", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412519796", "createdAt": "2020-04-21T21:57:24Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-model/src/test/java/ca/uhn/fhir/jpa/model/entity/ResourceIndexedSearchParamStringTest.java", "diffHunk": "@@ -36,10 +37,12 @@ public void testEquals() {\n \t\tResourceIndexedSearchParamString val1 = new ResourceIndexedSearchParamString()\n \t\t\t.setValueExact(\"aaa\")\n \t\t\t.setValueNormalized(\"AAA\");\n+\t\tval1.setPartitionSettings(new PartitionSettings());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU3NzQ3MQ==", "bodyText": "Done", "url": "https://github.com/hapifhir/hapi-fhir/pull/1807#discussion_r412577471", "createdAt": "2020-04-22T00:14:10Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-model/src/test/java/ca/uhn/fhir/jpa/model/entity/ResourceIndexedSearchParamStringTest.java", "diffHunk": "@@ -36,10 +37,12 @@ public void testEquals() {\n \t\tResourceIndexedSearchParamString val1 = new ResourceIndexedSearchParamString()\n \t\t\t.setValueExact(\"aaa\")\n \t\t\t.setValueNormalized(\"AAA\");\n+\t\tval1.setPartitionSettings(new PartitionSettings());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxOTc5Ng=="}, "originalCommit": {"oid": "00b1912a67ef878bc53bc0c924f6988e6e3ce77b"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1946, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}