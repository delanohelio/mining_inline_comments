{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA0MDExMDMw", "number": 1802, "title": "Improve search method binding priority", "bodyText": "", "createdAt": "2020-04-15T22:01:43Z", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802", "merged": true, "mergeCommit": {"oid": "497757501b879b3404c114af3938cda905c46c7c"}, "closed": true, "closedAt": "2020-04-17T13:28:33Z", "author": {"login": "jamesagnew"}, "timelineItems": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcX2roKAH2gAyNDA0MDExMDMwOjEwYjQ1MGJiZThmMGQ5MDA2MjNlYzgyYjQ4Y2RmNjA5N2I4MGI4MTk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcYgoZWgH2gAyNDA0MDExMDMwOjE2NWVkNzViMDRiNzE4ZWRiNjUxMzBmN2ZmYWE0OTA2ZjQ3ODljZmU=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "10b450bbe8f0d900623ec82b48cdf6097b80b819", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/10b450bbe8f0d900623ec82b48cdf6097b80b819", "committedDate": "2020-04-15T11:48:52Z", "message": "Work on search method binding priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "768d6ff00a48d40114876878f359ca49fb5b584d", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/768d6ff00a48d40114876878f359ca49fb5b584d", "committedDate": "2020-04-15T15:34:01Z", "message": "Work on method priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "47fa2dea80d4fd8db012ff4cbc74232f135d1d66", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/47fa2dea80d4fd8db012ff4cbc74232f135d1d66", "committedDate": "2020-04-15T18:02:16Z", "message": "Work on binding priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "438d7705a061898c283a78b1cd157552a37ee753", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/438d7705a061898c283a78b1cd157552a37ee753", "committedDate": "2020-04-15T19:59:39Z", "message": "Test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/a316143ddf88cd3153ccec81c77a45d3b7faea89", "committedDate": "2020-04-15T22:05:15Z", "message": "Add changelog"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTc2MDg0", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#pullrequestreview-394176084", "createdAt": "2020-04-15T22:22:18Z", "commit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMjoyMjoxOFrOGGNriQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQyMjozMTo0OVrOGGN5Xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODc3Nw==", "bodyText": "remove FIXME :-)", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409168777", "createdAt": "2020-04-15T22:22:18Z", "author": {"login": "fil512"}, "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/method/SearchMethodBinding.java", "diffHunk": "@@ -129,114 +141,215 @@ public ReturnTypeEnum getReturnType() {\n \t}\n \n \t@Override\n-\tpublic boolean incomingServerRequestMatchesMethod(RequestDetails theRequest) {\n+\tpublic MethodMatchEnum incomingServerRequestMatchesMethod(RequestDetails theRequest) {\n \n \t\tif (theRequest.getId() != null && myIdParamIndex == null) {\n \t\t\tourLog.trace(\"Method {} doesn't match because ID is not null: {}\", getMethod(), theRequest.getId());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (theRequest.getRequestType() == RequestTypeEnum.GET && theRequest.getOperation() != null && !Constants.PARAM_SEARCH.equals(theRequest.getOperation())) {\n \t\t\tourLog.trace(\"Method {} doesn't match because request type is GET but operation is not null: {}\", theRequest.getId(), theRequest.getOperation());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (theRequest.getRequestType() == RequestTypeEnum.POST && !Constants.PARAM_SEARCH.equals(theRequest.getOperation())) {\n \t\t\tourLog.trace(\"Method {} doesn't match because request type is POST but operation is not _search: {}\", theRequest.getId(), theRequest.getOperation());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (theRequest.getRequestType() != RequestTypeEnum.GET && theRequest.getRequestType() != RequestTypeEnum.POST) {\n \t\t\tourLog.trace(\"Method {} doesn't match because request type is {}\", getMethod(), theRequest.getRequestType());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (!StringUtils.equals(myCompartmentName, theRequest.getCompartmentName())) {\n \t\t\tourLog.trace(\"Method {} doesn't match because it is for compartment {} but request is compartment {}\", getMethod(), myCompartmentName, theRequest.getCompartmentName());\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \t\tif (theRequest.getParameters().get(Constants.PARAM_PAGINGACTION) != null) {\n-\t\t\treturn false;\n+\t\t\treturn MethodMatchEnum.NONE;\n \t\t}\n \n-\t\t// This is used to track all the parameters so we can reject queries that\n-\t\t// have additional params we don't understand\n-\t\tSet<String> methodParamsTemp = new HashSet<>();\n-\n-\t\tSet<String> unqualifiedNames = theRequest.getUnqualifiedToQualifiedNames().keySet();\n-\t\tSet<String> qualifiedParamNames = theRequest.getParameters().keySet();\n-\t\tfor (IParameter nextParameter : getParameters()) {\n-\t\t\tif (!(nextParameter instanceof BaseQueryParameter)) {\n-\t\t\t\tcontinue;\n-\t\t\t}\n-\t\t\tBaseQueryParameter nextQueryParameter = (BaseQueryParameter) nextParameter;\n-\t\t\tString name = nextQueryParameter.getName();\n-\t\t\tif (nextQueryParameter.isRequired()) {\n-\n-\t\t\t\tif (qualifiedParamNames.contains(name)) {\n-\t\t\t\t\tQualifierDetails qualifiers = extractQualifiersFromParameterName(name);\n-\t\t\t\t\tif (qualifiers.passes(nextQueryParameter.getQualifierWhitelist(), nextQueryParameter.getQualifierBlacklist())) {\n-\t\t\t\t\t\tmethodParamsTemp.add(name);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (unqualifiedNames.contains(name)) {\n-\t\t\t\t\tList<String> qualifiedNames = theRequest.getUnqualifiedToQualifiedNames().get(name);\n-\t\t\t\t\tqualifiedNames = processWhitelistAndBlacklist(qualifiedNames, nextQueryParameter.getQualifierWhitelist(), nextQueryParameter.getQualifierBlacklist());\n-\t\t\t\t\tmethodParamsTemp.addAll(qualifiedNames);\n-\t\t\t\t}\n-\t\t\t\tif (!qualifiedParamNames.contains(name) && !unqualifiedNames.contains(name)) {\n-\t\t\t\t\tourLog.trace(\"Method {} doesn't match param '{}' is not present\", getMethod().getName(), name);\n-\t\t\t\t\treturn false;\n-\t\t\t\t}\n-\n-\t\t\t} else {\n-\t\t\t\tif (qualifiedParamNames.contains(name)) {\n-\t\t\t\t\tQualifierDetails qualifiers = extractQualifiersFromParameterName(name);\n-\t\t\t\t\tif (qualifiers.passes(nextQueryParameter.getQualifierWhitelist(), nextQueryParameter.getQualifierBlacklist())) {\n-\t\t\t\t\t\tmethodParamsTemp.add(name);\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif (unqualifiedNames.contains(name)) {\n-\t\t\t\t\tList<String> qualifiedNames = theRequest.getUnqualifiedToQualifiedNames().get(name);\n-\t\t\t\t\tqualifiedNames = processWhitelistAndBlacklist(qualifiedNames, nextQueryParameter.getQualifierWhitelist(), nextQueryParameter.getQualifierBlacklist());\n-\t\t\t\t\tmethodParamsTemp.addAll(qualifiedNames);\n-\t\t\t\t}\n-\t\t\t\tif (!qualifiedParamNames.contains(name)) {\n-\t\t\t\t\tmethodParamsTemp.add(name);\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n \t\tif (myQueryName != null) {\n \t\t\tString[] queryNameValues = theRequest.getParameters().get(Constants.PARAM_QUERY);\n \t\t\tif (queryNameValues != null && StringUtils.isNotBlank(queryNameValues[0])) {\n \t\t\t\tString queryName = queryNameValues[0];\n \t\t\t\tif (!myQueryName.equals(queryName)) {\n \t\t\t\t\tourLog.trace(\"Query name does not match {}\", myQueryName);\n-\t\t\t\t\treturn false;\n+\t\t\t\t\treturn MethodMatchEnum.NONE;\n \t\t\t\t}\n-\t\t\t\tmethodParamsTemp.add(Constants.PARAM_QUERY);\n \t\t\t} else {\n \t\t\t\tourLog.trace(\"Query name does not match {}\", myQueryName);\n-\t\t\t\treturn false;\n+\t\t\t\treturn MethodMatchEnum.NONE;\n \t\t\t}\n \t\t} else {\n \t\t\tString[] queryNameValues = theRequest.getParameters().get(Constants.PARAM_QUERY);\n \t\t\tif (queryNameValues != null && StringUtils.isNotBlank(queryNameValues[0])) {\n \t\t\t\tourLog.trace(\"Query has name\");\n-\t\t\t\treturn false;\n+\t\t\t\treturn MethodMatchEnum.NONE;\n \t\t\t}\n \t\t}\n-\t\tfor (String next : theRequest.getParameters().keySet()) {\n-\t\t\tif (next.startsWith(\"_\") && !SPECIAL_SEARCH_PARAMS.contains(truncModifierPart(next))) {\n-\t\t\t\tmethodParamsTemp.add(next);\n+\n+\t\tSet<String> unqualifiedNames = theRequest.getUnqualifiedToQualifiedNames().keySet();\n+\t\tSet<String> qualifiedParamNames = theRequest.getParameters().keySet();\n+\n+\t\tMethodMatchEnum retVal = MethodMatchEnum.PERFECT;\n+\t\tfor (String nextRequestParam : theRequest.getParameters().keySet()) {\n+\t\t\tif (nextRequestParam.startsWith(\"_\") && !SPECIAL_SEARCH_PARAMS.contains(truncModifierPart(nextRequestParam))) {\n+\t\t\t\tcontinue;\n \t\t\t}\n+\n+\t\t\tString nextUnqualifiedRequestParam = nextRequestParam;\n+\t\t\tfor (int i = 0; i < nextUnqualifiedRequestParam.length(); i++) {\n+\t\t\t\tchar nextChar = nextUnqualifiedRequestParam.charAt(i);\n+\t\t\t\tif (nextChar == ':' || nextChar == '.') {\n+\t\t\t\t\tnextUnqualifiedRequestParam = nextUnqualifiedRequestParam.substring(0, i);\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tboolean parameterMatches = false;\n+\t\t\tboolean approx = false;\n+\t\t\tfor (BaseQueryParameter nextMethodParam : getQueryParameters()) {\n+\n+\t\t\t\tif (nextRequestParam.equals(nextMethodParam.getName())) {\n+\t\t\t\t\tQualifierDetails qualifiers = extractQualifiersFromParameterName(nextRequestParam);\n+\t\t\t\t\tif (qualifiers.passes(nextMethodParam.getQualifierWhitelist(), nextMethodParam.getQualifierBlacklist())) {\n+\t\t\t\t\t\tparameterMatches = true;\n+\t\t\t\t\t}\n+\t\t\t\t} else if (nextUnqualifiedRequestParam.equals(nextMethodParam.getName())) {\n+\t\t\t\t\tList<String> qualifiedNames = theRequest.getUnqualifiedToQualifiedNames().get(nextUnqualifiedRequestParam);\n+\t\t\t\t\tif (passesWhitelistAndBlacklist(qualifiedNames, nextMethodParam.getQualifierWhitelist(), nextMethodParam.getQualifierBlacklist())) {\n+\t\t\t\t\t\tparameterMatches = true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n+\t\t\t\t// Repetitions supplied by URL but not supported by this parameter\n+\t\t\t\tif (theRequest.getParameters().get(nextRequestParam).length > 1 != nextMethodParam.supportsRepetition()) {\n+\t\t\t\t\tapprox = true;\n+\t\t\t\t}\n+\n+\t\t\t}\n+\n+\n+\t\t\tif (parameterMatches) {\n+\n+\t\t\t\tif (approx) {\n+\t\t\t\t\tretVal = retVal.weakerOf(MethodMatchEnum.APPROXIMATE);\n+\t\t\t\t}\n+\n+\t\t\t} else {\n+\n+\t\t\t\tif (myAllowUnknownParams) {\n+\t\t\t\t\tretVal = retVal.weakerOf(MethodMatchEnum.APPROXIMATE);\n+\t\t\t\t} else {\n+\t\t\t\t\tretVal = retVal.weakerOf(MethodMatchEnum.NONE);\n+\t\t\t\t}\n+\n+\t\t\t}\n+\n+\t\t\tif (retVal == MethodMatchEnum.NONE) {\n+\t\t\t\tbreak;\n+\t\t\t}\n+\n \t\t}\n-\t\tSet<String> keySet = theRequest.getParameters().keySet();\n \n-\t\tif (myAllowUnknownParams == false) {\n-\t\t\tfor (String next : keySet) {\n-\t\t\t\tif (!methodParamsTemp.contains(next)) {\n-\t\t\t\t\treturn false;\n+\t\tif (retVal != MethodMatchEnum.NONE) {\n+\t\t\tfor (String nextRequiredParamName : myRequiredParamNames) {\n+\t\t\t\tif (!qualifiedParamNames.contains(nextRequiredParamName)) {\n+\t\t\t\t\tif (!unqualifiedNames.contains(nextRequiredParamName)) {\n+\t\t\t\t\t\tretVal = MethodMatchEnum.NONE;\n+\t\t\t\t\t\tbreak;\n+\t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t}\n-\t\treturn true;\n+\n+\t\treturn retVal;\n+\n+\t\t// FIXME: remove", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2ODg5Mw==", "bodyText": "remove FIXME :-)", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409168893", "createdAt": "2020-04-15T22:22:38Z", "author": {"login": "fil512"}, "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/method/SearchMethodBinding.java", "diffHunk": "@@ -264,6 +377,8 @@ protected boolean isAddContentLocationHeader() {\n \t\treturn false;\n \t}\n \n+\n+\t// FIXME: remove", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 323}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2OTk5Nw==", "bodyText": "Wouldn't NumberParam and QuantityParam also support repetition?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409169997", "createdAt": "2020-04-15T22:25:36Z", "author": {"login": "fil512"}, "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/method/SearchParameter.java", "diffHunk": "@@ -248,42 +249,52 @@ public void setRequired(boolean required) {\n \t\tthis.myRequired = required;\n \t}\n \n+\t@Override\n+\tprotected boolean supportsRepetition() {\n+\t\treturn mySupportsRepetition;\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n-\tpublic void setType(FhirContext theContext, final Class<?> type, Class<? extends Collection<?>> theInnerCollectionType, Class<? extends Collection<?>> theOuterCollectionType) {\n+\tpublic void setType(FhirContext theContext, final Class<?> theType, Class<? extends Collection<?>> theInnerCollectionType, Class<? extends Collection<?>> theOuterCollectionType) {\n \n \t\t\n-\t\tthis.myType = type;\n-\t\tif (IQueryParameterType.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterTypeBinder((Class<? extends IQueryParameterType>) type, myCompositeTypes);\n-\t\t} else if (IQueryParameterOr.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterOrBinder((Class<? extends IQueryParameterOr<?>>) type, myCompositeTypes);\n-\t\t} else if (IQueryParameterAnd.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterAndBinder((Class<? extends IQueryParameterAnd<?>>) type, myCompositeTypes);\n-\t\t} else if (String.class.equals(type)) {\n+\t\tthis.myType = theType;\n+\t\tif (IQueryParameterType.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterTypeBinder((Class<? extends IQueryParameterType>) theType, myCompositeTypes);\n+\t\t} else if (IQueryParameterOr.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterOrBinder((Class<? extends IQueryParameterOr<?>>) theType, myCompositeTypes);\n+\t\t} else if (IQueryParameterAnd.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterAndBinder((Class<? extends IQueryParameterAnd<?>>) theType, myCompositeTypes);\n+\t\t\tmySupportsRepetition = true;\n+\t\t} else if (String.class.equals(theType)) {\n \t\t\tmyParamBinder = new StringBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.STRING;\n-\t\t} else if (Date.class.equals(type)) {\n+\t\t} else if (Date.class.equals(theType)) {\n \t\t\tmyParamBinder = new DateBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n-\t\t} else if (Calendar.class.equals(type)) {\n+\t\t} else if (Calendar.class.equals(theType)) {\n \t\t\tmyParamBinder = new CalendarBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n-\t\t} else if (IPrimitiveType.class.isAssignableFrom(type) && ReflectionUtil.isInstantiable(type)) {\n-\t\t\tRuntimePrimitiveDatatypeDefinition def = (RuntimePrimitiveDatatypeDefinition) theContext.getElementDefinition((Class<? extends IPrimitiveType<?>>) type);\n+\t\t} else if (IPrimitiveType.class.isAssignableFrom(theType) && ReflectionUtil.isInstantiable(theType)) {\n+\t\t\tRuntimePrimitiveDatatypeDefinition def = (RuntimePrimitiveDatatypeDefinition) theContext.getElementDefinition((Class<? extends IPrimitiveType<?>>) theType);\n \t\t\tif (def.getNativeType() != null) {\n \t\t\t\tif (def.getNativeType().equals(Date.class)) {\n-\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) type);\n+\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) theType);\n \t\t\t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n \t\t\t\t} else if (def.getNativeType().equals(String.class)) {\n-\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) type);\n+\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) theType);\n \t\t\t\t\tmyParamType = RestSearchParameterTypeEnum.STRING;\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n-\t\t\tthrow new ConfigurationException(\"Unsupported data type for parameter: \" + type.getCanonicalName());\n+\t\t\tthrow new ConfigurationException(\"Unsupported data theType for parameter: \" + theType.getCanonicalName());\n+\t\t}\n+\n+\t\tif (DateRangeParam.class.isAssignableFrom(theType)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MDMxNw==", "bodyText": "Consider changing to:\nif (theType.supportsRepetition())", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409170317", "createdAt": "2020-04-15T22:26:33Z", "author": {"login": "fil512"}, "path": "hapi-fhir-server/src/main/java/ca/uhn/fhir/rest/server/method/SearchParameter.java", "diffHunk": "@@ -248,42 +249,52 @@ public void setRequired(boolean required) {\n \t\tthis.myRequired = required;\n \t}\n \n+\t@Override\n+\tprotected boolean supportsRepetition() {\n+\t\treturn mySupportsRepetition;\n+\t}\n+\n \t@SuppressWarnings(\"unchecked\")\n-\tpublic void setType(FhirContext theContext, final Class<?> type, Class<? extends Collection<?>> theInnerCollectionType, Class<? extends Collection<?>> theOuterCollectionType) {\n+\tpublic void setType(FhirContext theContext, final Class<?> theType, Class<? extends Collection<?>> theInnerCollectionType, Class<? extends Collection<?>> theOuterCollectionType) {\n \n \t\t\n-\t\tthis.myType = type;\n-\t\tif (IQueryParameterType.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterTypeBinder((Class<? extends IQueryParameterType>) type, myCompositeTypes);\n-\t\t} else if (IQueryParameterOr.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterOrBinder((Class<? extends IQueryParameterOr<?>>) type, myCompositeTypes);\n-\t\t} else if (IQueryParameterAnd.class.isAssignableFrom(type)) {\n-\t\t\tmyParamBinder = new QueryParameterAndBinder((Class<? extends IQueryParameterAnd<?>>) type, myCompositeTypes);\n-\t\t} else if (String.class.equals(type)) {\n+\t\tthis.myType = theType;\n+\t\tif (IQueryParameterType.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterTypeBinder((Class<? extends IQueryParameterType>) theType, myCompositeTypes);\n+\t\t} else if (IQueryParameterOr.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterOrBinder((Class<? extends IQueryParameterOr<?>>) theType, myCompositeTypes);\n+\t\t} else if (IQueryParameterAnd.class.isAssignableFrom(theType)) {\n+\t\t\tmyParamBinder = new QueryParameterAndBinder((Class<? extends IQueryParameterAnd<?>>) theType, myCompositeTypes);\n+\t\t\tmySupportsRepetition = true;\n+\t\t} else if (String.class.equals(theType)) {\n \t\t\tmyParamBinder = new StringBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.STRING;\n-\t\t} else if (Date.class.equals(type)) {\n+\t\t} else if (Date.class.equals(theType)) {\n \t\t\tmyParamBinder = new DateBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n-\t\t} else if (Calendar.class.equals(type)) {\n+\t\t} else if (Calendar.class.equals(theType)) {\n \t\t\tmyParamBinder = new CalendarBinder();\n \t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n-\t\t} else if (IPrimitiveType.class.isAssignableFrom(type) && ReflectionUtil.isInstantiable(type)) {\n-\t\t\tRuntimePrimitiveDatatypeDefinition def = (RuntimePrimitiveDatatypeDefinition) theContext.getElementDefinition((Class<? extends IPrimitiveType<?>>) type);\n+\t\t} else if (IPrimitiveType.class.isAssignableFrom(theType) && ReflectionUtil.isInstantiable(theType)) {\n+\t\t\tRuntimePrimitiveDatatypeDefinition def = (RuntimePrimitiveDatatypeDefinition) theContext.getElementDefinition((Class<? extends IPrimitiveType<?>>) theType);\n \t\t\tif (def.getNativeType() != null) {\n \t\t\t\tif (def.getNativeType().equals(Date.class)) {\n-\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) type);\n+\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) theType);\n \t\t\t\t\tmyParamType = RestSearchParameterTypeEnum.DATE;\n \t\t\t\t} else if (def.getNativeType().equals(String.class)) {\n-\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) type);\n+\t\t\t\t\tmyParamBinder = new FhirPrimitiveBinder((Class<IPrimitiveType<?>>) theType);\n \t\t\t\t\tmyParamType = RestSearchParameterTypeEnum.STRING;\n \t\t\t\t}\n \t\t\t}\n \t\t} else {\n-\t\t\tthrow new ConfigurationException(\"Unsupported data type for parameter: \" + type.getCanonicalName());\n+\t\t\tthrow new ConfigurationException(\"Unsupported data theType for parameter: \" + theType.getCanonicalName());\n+\t\t}\n+\n+\t\tif (DateRangeParam.class.isAssignableFrom(theType)) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE2OTk5Nw=="}, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MDcxOA==", "bodyText": "Is EXACT more descriptive than PERFECT?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409170718", "createdAt": "2020-04-15T22:27:41Z", "author": {"login": "fil512"}, "path": "hapi-fhir-server/src/test/java/ca/uhn/fhir/rest/server/method/MethodMatchEnumTest.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package ca.uhn.fhir.rest.server.method;\n+\n+import org.junit.Test;\n+\n+import static org.junit.Assert.*;\n+\n+public class MethodMatchEnumTest {\n+\n+\t@Test\n+\tpublic void testOrder() {\n+\t\tassertEquals(0, MethodMatchEnum.NONE.ordinal());\n+\t\tassertEquals(1, MethodMatchEnum.APPROXIMATE.ordinal());\n+\t\tassertEquals(2, MethodMatchEnum.PERFECT.ordinal());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MTAxMQ==", "bodyText": ":-) :-)", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409171011", "createdAt": "2020-04-15T22:28:28Z", "author": {"login": "fil512"}, "path": "hapi-fhir-structures-r4/src/test/java/ca/uhn/fhir/rest/server/SearchDateParamPriorityTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package ca.uhn.fhir.rest.server;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.rest.annotation.RequiredParam;\n+import ca.uhn.fhir.rest.annotation.Search;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import com.google.common.collect.Lists;\n+import org.hl7.fhir.r4.model.Bundle;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SearchDateParamPriorityTest {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchDateParamPriorityTest.class);\n+\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MTQwOQ==", "bodyText": "Can we add an unregisterAllProviders() method to RestfulServer?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409171409", "createdAt": "2020-04-15T22:29:22Z", "author": {"login": "fil512"}, "path": "hapi-fhir-structures-r4/src/test/java/ca/uhn/fhir/rest/server/SearchDateParamPriorityTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package ca.uhn.fhir.rest.server;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.rest.annotation.RequiredParam;\n+import ca.uhn.fhir.rest.annotation.Search;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import com.google.common.collect.Lists;\n+import org.hl7.fhir.r4.model.Bundle;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SearchDateParamPriorityTest {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchDateParamPriorityTest.class);\n+\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\tprivate String myLastMethod;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tmyLastMethod = null;\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\twhile (ourServerRule.getRestfulServer().getResourceProviders().size() > 0) {\n+\t\t\tourServerRule.getRestfulServer().unregisterProvider(ourServerRule.getRestfulServer().getResourceProviders().iterator().next());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MjExNQ==", "bodyText": "This is a really beautiful test.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409172115", "createdAt": "2020-04-15T22:31:12Z", "author": {"login": "fil512"}, "path": "hapi-fhir-structures-r4/src/test/java/ca/uhn/fhir/rest/server/SearchDateParamPriorityTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package ca.uhn.fhir.rest.server;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.rest.annotation.RequiredParam;\n+import ca.uhn.fhir.rest.annotation.Search;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import com.google.common.collect.Lists;\n+import org.hl7.fhir.r4.model.Bundle;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SearchDateParamPriorityTest {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchDateParamPriorityTest.class);\n+\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\tprivate String myLastMethod;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tmyLastMethod = null;\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\twhile (ourServerRule.getRestfulServer().getResourceProviders().size() > 0) {\n+\t\t\tourServerRule.getRestfulServer().unregisterProvider(ourServerRule.getRestfulServer().getResourceProviders().iterator().next());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testDateRangeSelectedWhenMultipleParametersProvided() {\n+\t\tPatientResourceProvider provider = new PatientResourceProvider();\n+\t\tourServerRule.getRestfulServer().registerProviders(provider);\n+\n+\t\tIGenericClient client = ourServerRule.getFhirClient();\n+\t\tclient\n+\t\t\t.search()\n+\t\t\t.forResource(\"Patient\")\n+\t\t\t.where(Patient.BIRTHDATE.after().day(\"2001-01-01\"))\n+\t\t\t.and(Patient.BIRTHDATE.before().day(\"2002-01-01\"))\n+\t\t\t.returnBundle(Bundle.class)\n+\t\t\t.execute();\n+\n+\t\tassertEquals(\"findDateRangeParam\", myLastMethod);\n+\t}\n+\n+\t@Test\n+\tpublic void testDateRangeNotSelectedWhenSingleParameterProvided() {\n+\t\tPatientResourceProvider provider = new PatientResourceProvider();\n+\t\tourServerRule.getRestfulServer().registerProviders(provider);\n+\n+\t\tIGenericClient client = ourServerRule.getFhirClient();\n+\t\tclient\n+\t\t\t.search()\n+\t\t\t.forResource(\"Patient\")\n+\t\t\t.where(Patient.BIRTHDATE.after().day(\"2001-01-01\"))\n+\t\t\t.returnBundle(Bundle.class)\n+\t\t\t.execute();\n+\n+\t\tassertEquals(\"findDateParam\", myLastMethod);\n+\t}\n+\n+\t@Test\n+\tpublic void testEmptySearchProvidedWithNoParameters() {\n+\t\tPatientResourceProvider provider = new PatientResourceProvider();\n+\t\tourServerRule.getRestfulServer().registerProviders(provider);\n+\n+\t\tIGenericClient client = ourServerRule.getFhirClient();\n+\t\tclient\n+\t\t\t.search()\n+\t\t\t.forResource(\"Patient\")\n+\t\t\t.returnBundle(Bundle.class)\n+\t\t\t.execute();\n+\n+\t\tassertEquals(\"find\", myLastMethod);\n+\t}\n+\n+\tpublic class PatientResourceProvider implements IResourceProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTE3MjMxOQ==", "bodyText": "Throw the above two lines in a @before", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#discussion_r409172319", "createdAt": "2020-04-15T22:31:49Z", "author": {"login": "fil512"}, "path": "hapi-fhir-structures-r4/src/test/java/ca/uhn/fhir/rest/server/SearchDateParamPriorityTest.java", "diffHunk": "@@ -0,0 +1,122 @@\n+package ca.uhn.fhir.rest.server;\n+\n+import ca.uhn.fhir.context.FhirContext;\n+import ca.uhn.fhir.rest.annotation.RequiredParam;\n+import ca.uhn.fhir.rest.annotation.Search;\n+import ca.uhn.fhir.rest.client.api.IGenericClient;\n+import ca.uhn.fhir.rest.param.DateParam;\n+import ca.uhn.fhir.rest.param.DateRangeParam;\n+import ca.uhn.fhir.test.utilities.server.RestfulServerRule;\n+import com.google.common.collect.Lists;\n+import org.hl7.fhir.r4.model.Bundle;\n+import org.hl7.fhir.r4.model.Patient;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.ClassRule;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+public class SearchDateParamPriorityTest {\n+\tprivate static final Logger ourLog = LoggerFactory.getLogger(SearchDateParamPriorityTest.class);\n+\n+\tprivate static FhirContext ourCtx = FhirContext.forR4();\n+\n+\t@ClassRule\n+\tpublic static RestfulServerRule ourServerRule = new RestfulServerRule(ourCtx);\n+\tprivate String myLastMethod;\n+\n+\t@Before\n+\tpublic void before() {\n+\t\tmyLastMethod = null;\n+\t}\n+\n+\t@After\n+\tpublic void after() {\n+\t\twhile (ourServerRule.getRestfulServer().getResourceProviders().size() > 0) {\n+\t\t\tourServerRule.getRestfulServer().unregisterProvider(ourServerRule.getRestfulServer().getResourceProviders().iterator().next());\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void testDateRangeSelectedWhenMultipleParametersProvided() {\n+\t\tPatientResourceProvider provider = new PatientResourceProvider();\n+\t\tourServerRule.getRestfulServer().registerProviders(provider);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTgwNzE2", "url": "https://github.com/hapifhir/hapi-fhir/pull/1802#pullrequestreview-394180716", "createdAt": "2020-04-15T22:32:59Z", "commit": {"oid": "a316143ddf88cd3153ccec81c77a45d3b7faea89"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c683a949722fe20895a91419ed62fd3a41c2c707", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/c683a949722fe20895a91419ed62fd3a41c2c707", "committedDate": "2020-04-16T12:55:10Z", "message": "Test fixes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6ae1eb5465798e2c2965ceb94f70cb2f96455461", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/6ae1eb5465798e2c2965ceb94f70cb2f96455461", "committedDate": "2020-04-16T14:07:25Z", "message": "Merge branch 'master' into ja_20200415_search_binding_priority"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "63e9507f7c729c6a9822c5c618dfbae6751367d2", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/63e9507f7c729c6a9822c5c618dfbae6751367d2", "committedDate": "2020-04-16T14:12:02Z", "message": "compile fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ed8402fede0348644108fb537c9bf189bb51ad4", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/5ed8402fede0348644108fb537c9bf189bb51ad4", "committedDate": "2020-04-16T14:14:41Z", "message": "One more comple fix"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "24e25f11ff0f75525c80c4cca6e99a4dd980cd3b", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/24e25f11ff0f75525c80c4cca6e99a4dd980cd3b", "committedDate": "2020-04-16T14:19:43Z", "message": "Test cleanup"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "165ed75b04b718edb65130f7ffaa4906f4789cfe", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/165ed75b04b718edb65130f7ffaa4906f4789cfe", "committedDate": "2020-04-17T12:41:21Z", "message": "Test fix"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4044, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}