{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzNDQ4NTIz", "number": 1873, "title": "Improve Period range indexing", "bodyText": "", "createdAt": "2020-05-26T20:32:52Z", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873", "merged": true, "mergeCommit": {"oid": "7f72305f578516227b5e1dcbb0c7955e88038411"}, "closed": true, "closedAt": "2020-05-28T12:56:44Z", "author": {"login": "jamesagnew"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABclKS7GAH2gAyNDIzNDQ4NTIzOmQ4MDI0MzQ5MjgyMDRkZmRmMmE2MzY3NWI0OTU0NmE5MjE3MTY2Nzg=", "endCursor": "Y3Vyc29yOnYyOpPPAAABclsC-QgH2gAyNDIzNDQ4NTIzOjllY2YyOTEyY2Q4MThiMzljOWNjMzYxOTgyYTU3YTU1ZGMyYWM1ZGE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "d802434928204dfdf2a63675b49546a921716678", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/d802434928204dfdf2a63675b49546a921716678", "committedDate": "2020-05-26T20:01:00Z", "message": "Fix #1871 - Handle period range searches better"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "27bef521c94aceee6ebbdace4bd9d89c9f79c970", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/27bef521c94aceee6ebbdace4bd9d89c9f79c970", "committedDate": "2020-05-26T20:32:00Z", "message": "Add changelog"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "447f5745d8318fd90f38bb8b9d3b715eb31759ab", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/447f5745d8318fd90f38bb8b9d3b715eb31759ab", "committedDate": "2020-05-26T22:18:39Z", "message": "FIx tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/9e5be6f5c6ab47c0f09947bdb809bf156629badf", "committedDate": "2020-05-26T23:42:58Z", "message": "Add test logging"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDE5NjUwODg1", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#pullrequestreview-419650885", "createdAt": "2020-05-27T22:22:41Z", "commit": {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjoyMjo0MVrOGbfOxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0yN1QyMjozMDo0MFrOGbfazQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQyMQ==", "bodyText": "Why not 0000-01-01 and 9999-12-31 ?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431476421", "createdAt": "2020-05-27T22:22:41Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/entity/ModelConfig.java", "diffHunk": "@@ -50,6 +54,8 @@\n \t\t\"http://hl7.org/fhir/StructureDefinition/*\")));\n \n \tpublic static final String DEFAULT_WEBSOCKET_CONTEXT_PATH = \"/websocket\";\n+\tprotected static final String DEFAULT_PERIOD_INDEX_START_OF_TIME = \"1700-01-01\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjkyOQ==", "bodyText": "Someone might want to store genealogy data (or even ancestral disease information) that predates this date.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431476929", "createdAt": "2020-05-27T22:23:53Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/entity/ModelConfig.java", "diffHunk": "@@ -50,6 +54,8 @@\n \t\t\"http://hl7.org/fhir/StructureDefinition/*\")));\n \n \tpublic static final String DEFAULT_WEBSOCKET_CONTEXT_PATH = \"/websocket\";\n+\tprotected static final String DEFAULT_PERIOD_INDEX_START_OF_TIME = \"1700-01-01\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQyMQ=="}, "originalCommit": {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NzE1NQ==", "bodyText": "On the other hand, we should check that these dates work okay on the main databases, esp the timestamp versions of them.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431477155", "createdAt": "2020-05-27T22:24:34Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-model/src/main/java/ca/uhn/fhir/jpa/model/entity/ModelConfig.java", "diffHunk": "@@ -50,6 +54,8 @@\n \t\t\"http://hl7.org/fhir/StructureDefinition/*\")));\n \n \tpublic static final String DEFAULT_WEBSOCKET_CONTEXT_PATH = \"/websocket\";\n+\tprotected static final String DEFAULT_PERIOD_INDEX_START_OF_TIME = \"1700-01-01\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3NjQyMQ=="}, "originalCommit": {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODQyMg==", "bodyText": "I'm surprised you didn't need the DatePredicate logic.  I guess those queries just never worked?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431478422", "createdAt": "2020-05-27T22:27:52Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-searchparam/src/main/java/ca/uhn/fhir/jpa/searchparam/extractor/BaseSearchParamExtractor.java", "diffHunk": "@@ -677,6 +677,16 @@ private void addDate_Period(String theResourceType, Set<ResourceIndexedSearchPar\n \t\tString endAsString = extractValueAsString(myPeriodEndValueChild, theValue);\n \n \t\tif (start != null || end != null) {\n+\n+\t\t\tif (start == null) {\n+\t\t\t\tstart = myModelConfig.getPeriodIndexStartOfTime().getValue();\n+\t\t\t\tstartAsString = myModelConfig.getPeriodIndexStartOfTime().getValueAsString();\n+\t\t\t}\n+\t\t\tif (end == null) {\n+\t\t\t\tend = myModelConfig.getPeriodIndexEndOfTime().getValue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3ODg2OA==", "bodyText": "Did this case just not work, so the assert was commented out?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431478868", "createdAt": "2020-05-27T22:29:07Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4Test.java", "diffHunk": "@@ -1118,143 +1118,6 @@ public void testCreateWrongType() {\n \t\t}\n \t}\n \n-\t@Test\n-\tpublic void testDatePeriodParamEndOnly() {\n-\t\t{\n-\t\t\tEncounter enc = new Encounter();\n-\t\t\tenc.addIdentifier().setSystem(\"testDatePeriodParam\").setValue(\"02\");\n-\t\t\tenc.getPeriod().getEndElement().setValueAsString(\"2001-01-02\");\n-\t\t\tmyEncounterDao.create(enc, mySrd);\n-\t\t}\n-\t\tSearchParameterMap params;\n-\t\tList<Encounter> encs;\n-\n-\t\tparams = new SearchParameterMap();\n-\t\tparams.add(Encounter.SP_DATE, new DateRangeParam(null, \"2001-01-03\"));\n-\t\tparams.add(Encounter.SP_IDENTIFIER, new TokenParam(\"testDatePeriodParam\", \"02\"));\n-\t\tencs = toList(myEncounterDao.search(params));\n-\t\tassertEquals(1, encs.size());\n-\n-\t\tparams = new SearchParameterMap();\n-\t\tparams.add(Encounter.SP_DATE, new DateRangeParam(\"2001-01-01\", \"2001-01-03\"));\n-\t\tparams.add(Encounter.SP_IDENTIFIER, new TokenParam(\"testDatePeriodParam\", \"02\"));\n-\t\t// encs = toList(ourEncounterDao.search(params));\n-\t\t// assertEquals(1, encs.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTQ3OTUwMQ==", "bodyText": "Does this work now if you uncomment it?  Should it work?", "url": "https://github.com/hapifhir/hapi-fhir/pull/1873#discussion_r431479501", "createdAt": "2020-05-27T22:30:40Z", "author": {"login": "fil512"}, "path": "hapi-fhir-jpaserver-base/src/test/java/ca/uhn/fhir/jpa/dao/r4/FhirResourceDaoR4SearchNoFtTest.java", "diffHunk": "@@ -1690,6 +1691,338 @@ public void testSearchDateWrongParam() {\n \n \t}\n \n+\n+\t@Test\n+\tpublic void testDateRangeOnPeriod_SearchByDateTime_NoUpperBound() {\n+\t\tEncounter enc = new Encounter();\n+\t\tenc.getPeriod().getStartElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n+\t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n+\n+\t\trunInTransaction(()->{\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\t});\n+\n+\t\t// ge -> above the lower bound\n+\t\tSearchParameterMap map = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-26T13:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider results = myEncounterDao.search(map);\n+\t\tList<String> ids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// ge -> Below the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-26T11:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> above the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-26T13:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> Below the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-26T11:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, empty());\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testDateRangeOnPeriod_SearchByDate_NoUpperBound() {\n+\t\tEncounter enc = new Encounter();\n+\t\tenc.getPeriod().getStartElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n+\t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n+\n+\t\trunInTransaction(()->{\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\t});\n+\n+\t\t// ge -> above the lower bound\n+\t\tSearchParameterMap map = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-27\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider results = myEncounterDao.search(map);\n+\t\tList<String> ids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// ge -> Below the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-25\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> above the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-27\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> Below the lower bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-25\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, empty());\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testDateRangeOnPeriod_SearchByDateTime_NoLowerBound() {\n+\t\tEncounter enc = new Encounter();\n+\t\tenc.getPeriod().getEndElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n+\t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n+\n+\t\trunInTransaction(()->{\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\t});\n+\n+\t\t// le -> above the upper bound\n+\t\tSearchParameterMap map = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-26T13:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider results = myEncounterDao.search(map);\n+\t\tList<String> ids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> Below the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-26T11:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// ge -> above the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-26T13:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, empty());\n+\n+\t\t// ge -> Below the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-26T11:00:00Z\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testDateRangeOnPeriod_SearchByDate_NoLowerBound() {\n+\t\tEncounter enc = new Encounter();\n+\t\tenc.getPeriod().getEndElement().setValueAsString(\"2020-05-26T12:00:00Z\");\n+\t\tString id1 = myEncounterDao.create(enc).getId().toUnqualifiedVersionless().getValue();\n+\n+\t\trunInTransaction(()->{\n+\t\t\tourLog.info(\"Date indexes:\\n * {}\", myResourceIndexedSearchParamDateDao.findAll().stream().map(t->t.toString()).collect(Collectors.joining(\"\\n * \")));\n+\t\t});\n+\n+\t\t// le -> above the upper bound\n+\t\tSearchParameterMap map = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-27\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tIBundleProvider results = myEncounterDao.search(map);\n+\t\tList<String> ids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// le -> Below the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"le2020-05-25\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\n+\t\t// ge -> above the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-27\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, empty());\n+\n+\t\t// ge -> Below the upper bound\n+\t\tmap = SearchParameterMap.newSynchronous();\n+\t\tmap.add(Encounter.SP_DATE, new DateParam(\"ge2020-05-25\"));\n+\t\tmyCaptureQueriesListener.clear();\n+\t\tresults = myEncounterDao.search(map);\n+\t\tids = toUnqualifiedVersionlessIdValues(results);\n+\t\tmyCaptureQueriesListener.logSelectQueriesForCurrentThread();\n+\t\tassertThat(ids, contains(id1));\n+\t}\n+\n+\n+\t@Test\n+\tpublic void testDatePeriodParamEndOnly() {\n+\t\t{\n+\t\t\tEncounter enc = new Encounter();\n+\t\t\tenc.addIdentifier().setSystem(\"testDatePeriodParam\").setValue(\"02\");\n+\t\t\tenc.getPeriod().getEndElement().setValueAsString(\"2001-01-02\");\n+\t\t\tmyEncounterDao.create(enc, mySrd);\n+\t\t}\n+\t\tSearchParameterMap params;\n+\t\tList<Encounter> encs;\n+\n+\t\tparams = new SearchParameterMap();\n+\t\tparams.add(Encounter.SP_DATE, new DateRangeParam(null, \"2001-01-03\"));\n+\t\tparams.add(Encounter.SP_IDENTIFIER, new TokenParam(\"testDatePeriodParam\", \"02\"));\n+\t\tencs = toList(myEncounterDao.search(params));\n+\t\tassertEquals(1, encs.size());\n+\n+\t\tparams = new SearchParameterMap();\n+\t\tparams.add(Encounter.SP_DATE, new DateRangeParam(\"2001-01-01\", \"2001-01-03\"));\n+\t\tparams.add(Encounter.SP_IDENTIFIER, new TokenParam(\"testDatePeriodParam\", \"02\"));\n+\t\t// encs = toList(ourEncounterDao.search(params));\n+\t\t// assertEquals(1, encs.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9e5be6f5c6ab47c0f09947bdb809bf156629badf"}, "originalPosition": 226}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9ecf2912cd818b39c9cc361982a57a55dc2ac5da", "author": {"user": {"login": "jamesagnew", "name": "James Agnew"}}, "url": "https://github.com/hapifhir/hapi-fhir/commit/9ecf2912cd818b39c9cc361982a57a55dc2ac5da", "committedDate": "2020-05-28T11:20:21Z", "message": "Address review comments"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3917, "cost": 1, "resetAt": "2021-11-01T14:51:55Z"}}}