{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc5ODM2OTAx", "number": 1730, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMzoyNjo1N1rODjdloA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxOTo1NzoxMVrODj73EA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM4NTExNTIwOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/test/resources/logback-test.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yN1QxMzoyNjo1N1rOFvSGdw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowMDoyM1rOFxYIgQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyMzk1OQ==", "bodyText": "This should probably get switched back down prior to merge", "url": "https://github.com/hapifhir/hapi-fhir/pull/1730#discussion_r385123959", "createdAt": "2020-02-27T13:26:57Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/test/resources/logback-test.xml", "diffHunk": "@@ -27,7 +27,7 @@\n \t\t<appender-ref ref=\"STDOUT\" />\n \t</logger>\n \n-\t<logger name=\"ca.uhn.fhir.jpa.dao\" additivity=\"false\" level=\"info\">\n+\t<logger name=\"ca.uhn.fhir.jpa.dao\" additivity=\"false\" level=\"trace\">", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1d7072c42d20e15d319675a923c51961b30e6c3"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxOTkzNw==", "bodyText": "addressed in df7a991", "url": "https://github.com/hapifhir/hapi-fhir/pull/1730#discussion_r387319937", "createdAt": "2020-03-03T22:00:23Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/test/resources/logback-test.xml", "diffHunk": "@@ -27,7 +27,7 @@\n \t\t<appender-ref ref=\"STDOUT\" />\n \t</logger>\n \n-\t<logger name=\"ca.uhn.fhir.jpa.dao\" additivity=\"false\" level=\"info\">\n+\t<logger name=\"ca.uhn.fhir.jpa.dao\" additivity=\"false\" level=\"trace\">", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTEyMzk1OQ=="}, "originalCommit": {"oid": "b1d7072c42d20e15d319675a923c51961b30e6c3"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDA1NTI5OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderDate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxOTo1MjoyMFrOFwA9SQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowMDo1NVrOFxYJhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5MTY1Nw==", "bodyText": "I feel like instead of having a whole bunch of if (isOrdinalComparison) for each of these, you could have one at the top where you say\nif (isOrdinalComparison) {\n   lowFieldName = \"myValueLowDateOrdinal\";\n} else {\n   lowFieldName = \"myValueLow\";\n... and avoid most of the duplication below.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1730#discussion_r385891657", "createdAt": "2020-02-28T19:52:20Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderDate.java", "diffHunk": "@@ -150,67 +152,111 @@ private Predicate createPredicateDate(IQueryParameterType theParam,\n \t\treturn p;\n \t}\n \n+\tprivate boolean isNullOrDayPrecision(DateParam theDateParam) {\n+\t\treturn theDateParam == null || theDateParam.getPrecision().ordinal() == TemporalPrecisionEnum.DAY.ordinal();\n+\t}\n \tprivate Predicate createPredicateDateFromRange(CriteriaBuilder theBuilder,\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  From<?, ResourceIndexedSearchParamDate> theFrom,\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  DateRangeParam theRange,\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  SearchFilterParser.CompareOperation operation) {\n-\t\tDate lowerBound = theRange.getLowerBoundAsInstant();\n-\t\tDate upperBound = theRange.getUpperBoundAsInstant();\n+\t\tDate lowerBoundInstant = theRange.getLowerBoundAsInstant();\n+\t\tDate upperBoundInstant = theRange.getUpperBoundAsInstant();\n+\n+\t\tDateParam lowerBound = theRange.getLowerBound();\n+\t\tDateParam upperBound = theRange.getUpperBound();\n+\t\tInteger lowerBoundAsOrdinal = theRange.getLowerBoundAsDateInteger();\n+\t\tInteger upperBoundAsOrdinal = theRange.getUpperBoundAsDateInteger();\n+\n+\t\t/**\n+\t\t * If all present search parameters are of DAY precision, and {@link DaoConfig#getUseOrdinalDatesForDayPrecisionSearches()} is true,\n+\t\t * then we attempt to use the ordinal field for date comparisons instead of the date field.\n+\t\t */\n+\t\tboolean isOrdinalComparison = isNullOrDayPrecision(lowerBound) && isNullOrDayPrecision(upperBound) && myDaoConfig.getModelConfig().getUseOrdinalDatesForDayPrecisionSearches();\n+\n \t\tPredicate lt = null;\n \t\tPredicate gt = null;\n \t\tPredicate lb = null;\n \t\tPredicate ub = null;\n \n \t\tif (operation == SearchFilterParser.CompareOperation.lt) {\n-\t\t\tif (lowerBound == null) {\n+\t\t\tif (lowerBoundInstant == null) {\n \t\t\t\tthrow new InvalidRequestException(\"lowerBound value not correctly specified for compare operation\");\n \t\t\t}\n-\t\t\tlb = theBuilder.lessThan(theFrom.get(\"myValueLow\"), lowerBound);\n+\t\t\t//im like 80% sure this should be ub and not lb, as it is an UPPER bound.\n+\t\t\tif (isOrdinalComparison) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1d7072c42d20e15d319675a923c51961b30e6c3"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMDE5Nw==", "bodyText": "Addressed in 6123e4b", "url": "https://github.com/hapifhir/hapi-fhir/pull/1730#discussion_r387320197", "createdAt": "2020-03-03T22:00:55Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderDate.java", "diffHunk": "@@ -150,67 +152,111 @@ private Predicate createPredicateDate(IQueryParameterType theParam,\n \t\treturn p;\n \t}\n \n+\tprivate boolean isNullOrDayPrecision(DateParam theDateParam) {\n+\t\treturn theDateParam == null || theDateParam.getPrecision().ordinal() == TemporalPrecisionEnum.DAY.ordinal();\n+\t}\n \tprivate Predicate createPredicateDateFromRange(CriteriaBuilder theBuilder,\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  From<?, ResourceIndexedSearchParamDate> theFrom,\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  DateRangeParam theRange,\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t  SearchFilterParser.CompareOperation operation) {\n-\t\tDate lowerBound = theRange.getLowerBoundAsInstant();\n-\t\tDate upperBound = theRange.getUpperBoundAsInstant();\n+\t\tDate lowerBoundInstant = theRange.getLowerBoundAsInstant();\n+\t\tDate upperBoundInstant = theRange.getUpperBoundAsInstant();\n+\n+\t\tDateParam lowerBound = theRange.getLowerBound();\n+\t\tDateParam upperBound = theRange.getUpperBound();\n+\t\tInteger lowerBoundAsOrdinal = theRange.getLowerBoundAsDateInteger();\n+\t\tInteger upperBoundAsOrdinal = theRange.getUpperBoundAsDateInteger();\n+\n+\t\t/**\n+\t\t * If all present search parameters are of DAY precision, and {@link DaoConfig#getUseOrdinalDatesForDayPrecisionSearches()} is true,\n+\t\t * then we attempt to use the ordinal field for date comparisons instead of the date field.\n+\t\t */\n+\t\tboolean isOrdinalComparison = isNullOrDayPrecision(lowerBound) && isNullOrDayPrecision(upperBound) && myDaoConfig.getModelConfig().getUseOrdinalDatesForDayPrecisionSearches();\n+\n \t\tPredicate lt = null;\n \t\tPredicate gt = null;\n \t\tPredicate lb = null;\n \t\tPredicate ub = null;\n \n \t\tif (operation == SearchFilterParser.CompareOperation.lt) {\n-\t\t\tif (lowerBound == null) {\n+\t\t\tif (lowerBoundInstant == null) {\n \t\t\t\tthrow new InvalidRequestException(\"lowerBound value not correctly specified for compare operation\");\n \t\t\t}\n-\t\t\tlb = theBuilder.lessThan(theFrom.get(\"myValueLow\"), lowerBound);\n+\t\t\t//im like 80% sure this should be ub and not lb, as it is an UPPER bound.\n+\t\t\tif (isOrdinalComparison) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5MTY1Nw=="}, "originalCommit": {"oid": "b1d7072c42d20e15d319675a923c51961b30e6c3"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDA2MjAzOnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderDate.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxOTo1MzoyN1rOFwBAqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QyMjowMjo1OFrOFxYNkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5MjUyMg==", "bodyText": "this should probably be an else", "url": "https://github.com/hapifhir/hapi-fhir/pull/1730#discussion_r385892522", "createdAt": "2020-02-28T19:53:27Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderDate.java", "diffHunk": "@@ -221,8 +267,10 @@ private Predicate createPredicateDateFromRange(CriteriaBuilder theBuilder,\n \t\t\tthrow new InvalidRequestException(String.format(\"Unsupported operator specified, operator=%s\",\n \t\t\t\toperation.name()));\n \t\t}\n-\n-\t\tourLog.trace(\"Date range is {} - {}\", lowerBound, upperBound);\n+\t\tif (isOrdinalComparison) {\n+\t\t\tourLog.trace(\"Ordinal date range is {} - {} \", lowerBoundAsOrdinal, upperBoundAsOrdinal);\n+\t\t}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1d7072c42d20e15d319675a923c51961b30e6c3"}, "originalPosition": 165}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMyMTIzMw==", "bodyText": "Addressed in a510543", "url": "https://github.com/hapifhir/hapi-fhir/pull/1730#discussion_r387321233", "createdAt": "2020-03-03T22:02:58Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-base/src/main/java/ca/uhn/fhir/jpa/dao/predicate/PredicateBuilderDate.java", "diffHunk": "@@ -221,8 +267,10 @@ private Predicate createPredicateDateFromRange(CriteriaBuilder theBuilder,\n \t\t\tthrow new InvalidRequestException(String.format(\"Unsupported operator specified, operator=%s\",\n \t\t\t\toperation.name()));\n \t\t}\n-\n-\t\tourLog.trace(\"Date range is {} - {}\", lowerBound, upperBound);\n+\t\tif (isOrdinalComparison) {\n+\t\t\tourLog.trace(\"Ordinal date range is {} - {} \", lowerBoundAsOrdinal, upperBoundAsOrdinal);\n+\t\t}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5MjUyMg=="}, "originalCommit": {"oid": "b1d7072c42d20e15d319675a923c51961b30e6c3"}, "originalPosition": 165}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM5MDA3NTA0OnYy", "diffSide": "RIGHT", "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/taskdef/BaseColumnCalculatorTask.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOFQxOTo1NzoxMVrOFwBIZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNFQwMDoyMDowMlrOFxbXFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NDUwMg==", "bodyText": "I'm actually not sure this will work for the dates.. The reason is that it's possible for one of the dates (either SP_VALUE_HIGH or SP_VALUE_LOW to be saved as null even if the other isn't. For example if we were indexing a Period with a start date but no finish date...\nIt's probably gonna require something like SELECT FROM HFJ_SPIDX_DATE WHERE SP_VALUE_LOW IS NOT NULL AND SP_VALUE_LOW_ORDINAL IS NULL", "url": "https://github.com/hapifhir/hapi-fhir/pull/1730#discussion_r385894502", "createdAt": "2020-02-28T19:57:11Z", "author": {"login": "jamesagnew"}, "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/taskdef/BaseColumnCalculatorTask.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package ca.uhn.fhir.jpa.migrate.taskdef;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Migration\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.jpa.migrate.JdbcUtils;\n+import ca.uhn.fhir.util.StopWatch;\n+import ca.uhn.fhir.util.VersionEnum;\n+import com.google.common.collect.ForwardingMap;\n+import org.apache.commons.lang3.Validate;\n+import org.apache.commons.lang3.concurrent.BasicThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.jdbc.core.ColumnMapRowMapper;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.function.Function;\n+\n+public abstract class BaseColumnCalculatorTask extends BaseTableColumnTask<BaseColumnCalculatorTask> {\n+\n+\tprotected static final Logger ourLog = LoggerFactory.getLogger(BaseColumnCalculatorTask.class);\n+\tprivate int myBatchSize = 10000;\n+\tprivate Map<String, Function<MandatoryKeyMap<String, Object>, Object>> myCalculators = new HashMap<>();\n+\tprivate ThreadPoolExecutor myExecutor;\n+\n+\tpublic void setBatchSize(int theBatchSize) {\n+\t\tmyBatchSize = theBatchSize;\n+\t}\n+\n+\t/**\n+\t * Constructor\n+\t */\n+\tpublic BaseColumnCalculatorTask(VersionEnum theRelease, String theVersion) {\n+\t\tsuper(theRelease.toString(), theVersion);\n+\t}\n+\n+\t/**\n+\t * Allows concrete implementations to decide if they should be skipped.\n+\t * @return a boolean indicating whether or not to skip execution of the task.\n+\t */\n+\tprotected abstract boolean shouldSkipTask();\n+\n+\t@Override\n+\tpublic synchronized void doExecute() throws SQLException {\n+\t\tif (isDryRun() || shouldSkipTask()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tinitializeExecutor();\n+\n+\t\ttry {\n+\n+\t\t\twhile(true) {\n+\t\t\t\tMyRowCallbackHandler rch = new MyRowCallbackHandler();\n+\t\t\t\tgetTxTemplate().execute(t -> {\n+\t\t\t\t\tJdbcTemplate jdbcTemplate = newJdbcTemplate();\n+\t\t\t\t\tjdbcTemplate.setMaxRows(100000);\n+\t\t\t\t\tString sql = \"SELECT * FROM \" + getTableName() + \" WHERE \" + getColumnName() + \" IS NULL\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b1d7072c42d20e15d319675a923c51961b30e6c3"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM3MjgyMg==", "bodyText": "Attempted to address this in 8b223a1, but this issue probably merits a minor refactor to more easily allow calculators, or table tasks, to determine their WHERE clauses. This is a hacky solution but it'll do until we can figure out a minor rework.", "url": "https://github.com/hapifhir/hapi-fhir/pull/1730#discussion_r387372822", "createdAt": "2020-03-04T00:20:02Z", "author": {"login": "tadgh"}, "path": "hapi-fhir-jpaserver-migrate/src/main/java/ca/uhn/fhir/jpa/migrate/taskdef/BaseColumnCalculatorTask.java", "diffHunk": "@@ -0,0 +1,271 @@\n+package ca.uhn.fhir.jpa.migrate.taskdef;\n+\n+/*-\n+ * #%L\n+ * HAPI FHIR JPA Server - Migration\n+ * %%\n+ * Copyright (C) 2014 - 2020 University Health Network\n+ * %%\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ * #L%\n+ */\n+\n+import ca.uhn.fhir.jpa.migrate.JdbcUtils;\n+import ca.uhn.fhir.util.StopWatch;\n+import ca.uhn.fhir.util.VersionEnum;\n+import com.google.common.collect.ForwardingMap;\n+import org.apache.commons.lang3.Validate;\n+import org.apache.commons.lang3.concurrent.BasicThreadFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.jdbc.core.ColumnMapRowMapper;\n+import org.springframework.jdbc.core.JdbcTemplate;\n+import org.springframework.jdbc.core.RowCallbackHandler;\n+\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.*;\n+import java.util.concurrent.*;\n+import java.util.function.Function;\n+\n+public abstract class BaseColumnCalculatorTask extends BaseTableColumnTask<BaseColumnCalculatorTask> {\n+\n+\tprotected static final Logger ourLog = LoggerFactory.getLogger(BaseColumnCalculatorTask.class);\n+\tprivate int myBatchSize = 10000;\n+\tprivate Map<String, Function<MandatoryKeyMap<String, Object>, Object>> myCalculators = new HashMap<>();\n+\tprivate ThreadPoolExecutor myExecutor;\n+\n+\tpublic void setBatchSize(int theBatchSize) {\n+\t\tmyBatchSize = theBatchSize;\n+\t}\n+\n+\t/**\n+\t * Constructor\n+\t */\n+\tpublic BaseColumnCalculatorTask(VersionEnum theRelease, String theVersion) {\n+\t\tsuper(theRelease.toString(), theVersion);\n+\t}\n+\n+\t/**\n+\t * Allows concrete implementations to decide if they should be skipped.\n+\t * @return a boolean indicating whether or not to skip execution of the task.\n+\t */\n+\tprotected abstract boolean shouldSkipTask();\n+\n+\t@Override\n+\tpublic synchronized void doExecute() throws SQLException {\n+\t\tif (isDryRun() || shouldSkipTask()) {\n+\t\t\treturn;\n+\t\t}\n+\n+\t\tinitializeExecutor();\n+\n+\t\ttry {\n+\n+\t\t\twhile(true) {\n+\t\t\t\tMyRowCallbackHandler rch = new MyRowCallbackHandler();\n+\t\t\t\tgetTxTemplate().execute(t -> {\n+\t\t\t\t\tJdbcTemplate jdbcTemplate = newJdbcTemplate();\n+\t\t\t\t\tjdbcTemplate.setMaxRows(100000);\n+\t\t\t\t\tString sql = \"SELECT * FROM \" + getTableName() + \" WHERE \" + getColumnName() + \" IS NULL\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTg5NDUwMg=="}, "originalCommit": {"oid": "b1d7072c42d20e15d319675a923c51961b30e6c3"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1910, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}