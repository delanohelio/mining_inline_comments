{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NjY1Njc0", "number": 1109, "title": "Allows scope decorators to synchorize \"extra fields\" to logging context", "bodyText": "This pulls up a major feature currently only available in Sleuth:\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/289ec4755e6bcda77830a25c958c19fb1f5af7e2/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/log/Slf4jScopeDecorator.java#L111-L119\nEx.\ncurrentTraceContext = ThreadLocalCurrentTraceContext.newBuilder()\n  .addScopeDecorator(MDCScopeDecorator.newBuilder()\n    .addExtraField(\"user-id\") // this pushes the extra field into log scope\n    .build())\n  .build();", "createdAt": "2020-03-06T07:02:15Z", "url": "https://github.com/openzipkin/brave/pull/1109", "merged": true, "mergeCommit": {"oid": "7ca012171a7c0643bcbf348fbfeb04da4d3d0e63"}, "closed": true, "closedAt": "2020-03-28T10:37:58Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcK6oDXAFqTM3MDExNjMxOA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcSBJnyAH2gAyMzg0NjY1Njc0OmM4ODM2ZGEyMmYwOWYzZmJlMmJiMmZmZDIzOTBjYzM5N2JmZWIzODA=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTE2MzE4", "url": "https://github.com/openzipkin/brave/pull/1109#pullrequestreview-370116318", "createdAt": "2020-03-06T07:03:34Z", "commit": {"oid": "4a290d9747b21c09563c9e91f8ef914076b6fc99"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzowMzozNFrOFyu4Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzowMzozNFrOFyu4Qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTE4Nw==", "bodyText": "using a mutable array here is intentional. It allows a later change to implement immediate flushing #682", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388741187", "createdAt": "2020-03-06T07:03:34Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -13,85 +13,184 @@\n  */\n package brave.internal.propagation;\n \n+import brave.Tracer;\n+import brave.internal.InternalPropagation;\n import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import brave.propagation.CurrentTraceContext;\n import brave.propagation.CurrentTraceContext.Scope;\n import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import brave.propagation.ExtraFieldPropagation;\n import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Set;\n \n /**\n- * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@link\n- * brave.Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n+ * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@linkplain\n+ * Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n  * \"parentId\" is used for scenarios such as log parsing that reconstructs the trace tree. \"sampled\"\n  * is used as a hint that a span found in logs might be in Zipkin.\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  final Updater[] updaters;\n+\n+  protected static abstract class Builder<B extends Builder<B>> {\n+    final Set<String> extraFields = new LinkedHashSet<>(); // insertion order;\n+\n+    /**\n+     * Adds a field from {@link ExtraFieldPropagation} into the correlation context.\n+     *\n+     * @since 5.11\n+     */\n+    public B addExtraField(String name) {\n+      if (name == null) throw new NullPointerException(\"name == null\");\n+      String lowercase = name.toLowerCase(Locale.ROOT); // contract of extra fields internally\n+      extraFields.add(lowercase);\n+      return (B) this;\n+    }\n+\n+    public abstract CurrentTraceContext.ScopeDecorator build();\n+  }\n+\n+  protected CorrelationFieldScopeDecorator(Builder<?> builder) {\n+    String[] extraFields = builder.extraFields.toArray(new String[0]);\n+    updaters = new Updater[4 + extraFields.length];\n+    updaters[0] = new TraceIdUpdater(this);\n+    updaters[1] = new ParentSpanIdUpdater(this);\n+    updaters[2] = new SpanIdUpdater(this);\n+    updaters[3] = new SampledUpdater(this);\n+    for (int i = 0; i < extraFields.length; i++) {\n+      updaters[4 + i] = new ExtraFieldUpdater(this, extraFields[i]);\n+    }\n+  }\n \n   /**\n    * When the input is not null \"traceId\", \"parentId\", \"spanId\" and \"sampled\" correlation properties\n    * are saved off and replaced with those of the current span. When the input is null, these\n    * properties are removed. Either way, \"traceId\", \"parentId\", \"spanId\" and \"sampled\" properties\n    * are restored on {@linkplain Scope#close()}.\n    */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    String previousTraceId = get(\"traceId\");\n-    String previousSpanId = get(\"spanId\");\n-    String previousParentId = get(\"parentId\");\n-    String previousSampled = get(\"sampled\");\n-\n-    if (currentSpan != null) {\n-      maybeReplaceTraceContext(\n-        currentSpan, previousTraceId, previousParentId, previousSpanId, previousSampled);\n-    } else {\n-      remove(\"traceId\");\n-      remove(\"parentId\");\n-      remove(\"spanId\");\n-      remove(\"sampled\");\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    String[] previousValues = new String[updaters.length];", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4a290d9747b21c09563c9e91f8ef914076b6fc99"}, "originalPosition": 86}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTU2MTY1", "url": "https://github.com/openzipkin/brave/pull/1109#pullrequestreview-370156165", "createdAt": "2020-03-06T08:38:33Z", "commit": {"oid": "2fb5c2374d62e0669f77a46606c92dcbe2140560"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODozODozM1rOFyw0lw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwODo1MDo1M1rOFyxJRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3MzAxNQ==", "bodyText": "Not completely sure but I thought the immediate flushing would mean there are extra fields added, so doesn't it need to be expandable like a List?", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388773015", "createdAt": "2020-03-06T08:38:33Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -13,85 +13,184 @@\n  */\n package brave.internal.propagation;\n \n+import brave.Tracer;\n+import brave.internal.InternalPropagation;\n import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import brave.propagation.CurrentTraceContext;\n import brave.propagation.CurrentTraceContext.Scope;\n import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import brave.propagation.ExtraFieldPropagation;\n import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Set;\n \n /**\n- * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@link\n- * brave.Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n+ * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@linkplain\n+ * Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n  * \"parentId\" is used for scenarios such as log parsing that reconstructs the trace tree. \"sampled\"\n  * is used as a hint that a span found in logs might be in Zipkin.\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  final Updater[] updaters;\n+\n+  protected static abstract class Builder<B extends Builder<B>> {\n+    final Set<String> extraFields = new LinkedHashSet<>(); // insertion order;\n+\n+    /**\n+     * Adds a field from {@link ExtraFieldPropagation} into the correlation context.\n+     *\n+     * @since 5.11\n+     */\n+    public B addExtraField(String name) {\n+      if (name == null) throw new NullPointerException(\"name == null\");\n+      String lowercase = name.toLowerCase(Locale.ROOT); // contract of extra fields internally\n+      extraFields.add(lowercase);\n+      return (B) this;\n+    }\n+\n+    public abstract CurrentTraceContext.ScopeDecorator build();\n+  }\n+\n+  protected CorrelationFieldScopeDecorator(Builder<?> builder) {\n+    String[] extraFields = builder.extraFields.toArray(new String[0]);\n+    updaters = new Updater[4 + extraFields.length];\n+    updaters[0] = new TraceIdUpdater(this);\n+    updaters[1] = new ParentSpanIdUpdater(this);\n+    updaters[2] = new SpanIdUpdater(this);\n+    updaters[3] = new SampledUpdater(this);\n+    for (int i = 0; i < extraFields.length; i++) {\n+      updaters[4 + i] = new ExtraFieldUpdater(this, extraFields[i]);\n+    }\n+  }\n \n   /**\n    * When the input is not null \"traceId\", \"parentId\", \"spanId\" and \"sampled\" correlation properties\n    * are saved off and replaced with those of the current span. When the input is null, these\n    * properties are removed. Either way, \"traceId\", \"parentId\", \"spanId\" and \"sampled\" properties\n    * are restored on {@linkplain Scope#close()}.\n    */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    String previousTraceId = get(\"traceId\");\n-    String previousSpanId = get(\"spanId\");\n-    String previousParentId = get(\"parentId\");\n-    String previousSampled = get(\"sampled\");\n-\n-    if (currentSpan != null) {\n-      maybeReplaceTraceContext(\n-        currentSpan, previousTraceId, previousParentId, previousSpanId, previousSampled);\n-    } else {\n-      remove(\"traceId\");\n-      remove(\"parentId\");\n-      remove(\"spanId\");\n-      remove(\"sampled\");\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    String[] previousValues = new String[updaters.length];", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc0MTE4Nw=="}, "originalCommit": {"oid": "4a290d9747b21c09563c9e91f8ef914076b6fc99"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3NjAwNw==", "bodyText": "Small nit this is probably easier to read if the if/else pattern is consistent, currently this line seems particularly special for some reason.\nif (current != null) {\n  return update(previous, current);\n} else if (previous != null) {\n  decorator.remove(field);\n  return true;\n} else {\n  return false;\n}\nCould remove the elses if desired.", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388776007", "createdAt": "2020-03-06T08:45:44Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -13,85 +13,176 @@\n  */\n package brave.internal.propagation;\n \n+import brave.Tracer;\n+import brave.internal.InternalPropagation;\n import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import brave.propagation.CurrentTraceContext;\n import brave.propagation.CurrentTraceContext.Scope;\n import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import brave.propagation.ExtraFieldPropagation;\n import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Set;\n \n /**\n- * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@link\n- * brave.Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n+ * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@linkplain\n+ * Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n  * \"parentId\" is used for scenarios such as log parsing that reconstructs the trace tree. \"sampled\"\n  * is used as a hint that a span found in logs might be in Zipkin.\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  final Updater[] updaters;\n+\n+  protected static abstract class Builder<B extends Builder<B>> {\n+    final Set<String> extraFields = new LinkedHashSet<>(); // insertion order;\n+\n+    /**\n+     * Adds a field from {@link ExtraFieldPropagation} into the correlation context.\n+     *\n+     * @since 5.11\n+     */\n+    public B addExtraField(String name) {\n+      if (name == null) throw new NullPointerException(\"name == null\");\n+      String lowercase = name.toLowerCase(Locale.ROOT); // contract of extra fields internally\n+      extraFields.add(lowercase);\n+      return (B) this;\n+    }\n+\n+    public abstract CurrentTraceContext.ScopeDecorator build();\n+  }\n+\n+  protected CorrelationFieldScopeDecorator(Builder<?> builder) {\n+    String[] extraFields = builder.extraFields.toArray(new String[0]);\n+    updaters = new Updater[4 + extraFields.length];\n+    updaters[0] = new TraceIdUpdater(this);\n+    updaters[1] = new ParentSpanIdUpdater(this);\n+    updaters[2] = new SpanIdUpdater(this);\n+    updaters[3] = new SampledUpdater(this);\n+    for (int i = 0; i < extraFields.length; i++) {\n+      updaters[4 + i] = new ExtraFieldUpdater(this, extraFields[i]);\n+    }\n+  }\n \n   /**\n    * When the input is not null \"traceId\", \"parentId\", \"spanId\" and \"sampled\" correlation properties\n    * are saved off and replaced with those of the current span. When the input is null, these\n    * properties are removed. Either way, \"traceId\", \"parentId\", \"spanId\" and \"sampled\" properties\n    * are restored on {@linkplain Scope#close()}.\n    */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    String previousTraceId = get(\"traceId\");\n-    String previousSpanId = get(\"spanId\");\n-    String previousParentId = get(\"parentId\");\n-    String previousSampled = get(\"sampled\");\n-\n-    if (currentSpan != null) {\n-      maybeReplaceTraceContext(\n-        currentSpan, previousTraceId, previousParentId, previousSpanId, previousSampled);\n-    } else {\n-      remove(\"traceId\");\n-      remove(\"parentId\");\n-      remove(\"spanId\");\n-      remove(\"sampled\");\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    String[] previousValues = new String[updaters.length];\n+\n+    boolean changed = false;\n+    for (int i = 0; i < updaters.length; i++) {\n+      previousValues[i] = get(updaters[i].field);\n+      if (context != null) {\n+        if (updaters[i].update(context, previousValues[i])) {\n+          changed = true;\n+        }\n+      } else if (previousValues[i] != null) {\n+        remove(updaters[i].field);\n+        changed = true;\n+      }\n     }\n \n+    if (!changed) return scope;\n+\n     class CorrelationFieldCurrentTraceContextScope implements Scope {\n       @Override public void close() {\n         scope.close();\n-        replace(\"traceId\", previousTraceId);\n-        replace(\"parentId\", previousParentId);\n-        replace(\"spanId\", previousSpanId);\n-        replace(\"sampled\", previousSampled);\n+        for (int i = 0; i < updaters.length; i++) {\n+          replace(updaters[i].field, previousValues[i]);\n+        }\n       }\n     }\n     return new CorrelationFieldCurrentTraceContextScope();\n   }\n \n-  /**\n-   * Idempotently sets correlation properties to hex representation of trace identifiers in this\n-   * context.\n-   */\n-  void maybeReplaceTraceContext(\n-    TraceContext currentSpan,\n-    String previousTraceId,\n-    @Nullable String previousParentId,\n-    String previousSpanId,\n-    @Nullable String previousSampled\n-  ) {\n-    String traceId = currentSpan.traceIdString();\n-    if (!traceId.equals(previousTraceId)) put(\"traceId\", currentSpan.traceIdString());\n-\n-    String parentId = currentSpan.parentIdString();\n-    if (parentId == null) {\n-      remove(\"parentId\");\n-    } else {\n-      boolean sameParentId = parentId.equals(previousParentId);\n-      if (!sameParentId) put(\"parentId\", parentId);\n+  static final class ExtraFieldUpdater extends Updater {\n+    final Class<? extends PropagationFields<String, String>> propagationType;\n+\n+    ExtraFieldUpdater(CorrelationFieldScopeDecorator decorator, String name) {\n+      super(decorator, name);\n+      this.propagationType = InternalPropagation.instance.extraPropagationFieldsType();\n+    }\n+\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      String current = PropagationFields.get(context, field, propagationType);\n+      return updateNullable(previous, current);\n     }\n+  }\n \n-    String spanId = currentSpan.spanIdString();\n-    if (!spanId.equals(previousSpanId)) put(\"spanId\", spanId);\n+  static final class TraceIdUpdater extends Updater {\n+    TraceIdUpdater(CorrelationFieldScopeDecorator decorator) {\n+      super(decorator, \"traceId\");\n+    }\n \n-    Boolean sampled = currentSpan.sampled();\n-    if (sampled == null) {\n-      remove(\"sampled\");\n-    } else {\n-      String sampledString = sampled.toString();\n-      boolean sameSampled = sampledString.equals(previousSampled);\n-      if (!sameSampled) put(\"sampled\", sampledString);\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      return update(previous, context.traceIdString());\n+    }\n+  }\n+\n+  static final class ParentSpanIdUpdater extends Updater {\n+    ParentSpanIdUpdater(CorrelationFieldScopeDecorator decorator) {\n+      super(decorator, \"parentId\");\n+    }\n+\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      return updateNullable(previous, context.parentIdString());\n+    }\n+  }\n+\n+  static final class SpanIdUpdater extends Updater {\n+    SpanIdUpdater(CorrelationFieldScopeDecorator decorator) {\n+      super(decorator, \"spanId\");\n+    }\n+\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      return update(previous, context.spanIdString());\n+    }\n+  }\n+\n+  static final class SampledUpdater extends Updater {\n+    SampledUpdater(CorrelationFieldScopeDecorator decorator) {\n+      super(decorator, \"sampled\");\n+    }\n+\n+    @Override boolean update(TraceContext context, @Nullable String previous) {\n+      Boolean sampled = context.sampled();\n+      return updateNullable(previous, sampled != null ? sampled.toString() : null);\n+    }\n+  }\n+\n+  static abstract class Updater {\n+    final CorrelationFieldScopeDecorator decorator;\n+    final String field;\n+\n+    Updater(CorrelationFieldScopeDecorator decorator, String field) {\n+      this.decorator = decorator;\n+      this.field = field;\n+    }\n+\n+    /** Returns true if there was a change to the correlation field. */\n+    abstract boolean update(TraceContext context, @Nullable String previous);\n+\n+    boolean update(@Nullable String previous, String current) {\n+      if (!current.equals(previous)) {\n+        decorator.put(field, current);\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    boolean updateNullable(@Nullable String previous, @Nullable String current) {\n+      if (current != null) return update(previous, current);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fb5c2374d62e0669f77a46606c92dcbe2140560"}, "originalPosition": 223}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc3ODMwOQ==", "bodyText": "Just want to confirm ExtraFieldPropagation is the only type of propagation this would ever make sense for?", "url": "https://github.com/openzipkin/brave/pull/1109#discussion_r388778309", "createdAt": "2020-03-06T08:50:53Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/propagation/CorrelationFieldScopeDecorator.java", "diffHunk": "@@ -13,85 +13,176 @@\n  */\n package brave.internal.propagation;\n \n+import brave.Tracer;\n+import brave.internal.InternalPropagation;\n import brave.internal.Nullable;\n+import brave.internal.PropagationFields;\n+import brave.propagation.CurrentTraceContext;\n import brave.propagation.CurrentTraceContext.Scope;\n import brave.propagation.CurrentTraceContext.ScopeDecorator;\n+import brave.propagation.ExtraFieldPropagation;\n import brave.propagation.TraceContext;\n+import java.util.LinkedHashSet;\n+import java.util.Locale;\n+import java.util.Set;\n \n /**\n- * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@link\n- * brave.Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n+ * Adds correlation properties \"traceId\", \"parentId\", \"spanId\" and \"sampled\" when a {@linkplain\n+ * Tracer#currentSpan() span is current}. \"traceId\" and \"spanId\" are used in log correlation.\n  * \"parentId\" is used for scenarios such as log parsing that reconstructs the trace tree. \"sampled\"\n  * is used as a hint that a span found in logs might be in Zipkin.\n  */\n public abstract class CorrelationFieldScopeDecorator implements ScopeDecorator {\n+  final Updater[] updaters;\n+\n+  protected static abstract class Builder<B extends Builder<B>> {\n+    final Set<String> extraFields = new LinkedHashSet<>(); // insertion order;\n+\n+    /**\n+     * Adds a field from {@link ExtraFieldPropagation} into the correlation context.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2fb5c2374d62e0669f77a46606c92dcbe2140560"}, "originalPosition": 39}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db45071c2524aec135ad037dc1d599e0976107e3", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/db45071c2524aec135ad037dc1d599e0976107e3", "committedDate": "2020-03-28T04:30:03Z", "message": "Allows scope decorators to synchorize \"extra fields\" to logging context\n\nThis pulls up a major feature currently only available in Sleuth:\n\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/289ec4755e6bcda77830a25c958c19fb1f5af7e2/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/log/Slf4jScopeDecorator.java#L111-L119\n\nEx.\n```java\ncurrentTraceContext = ThreadLocalCurrentTraceContext.newBuilder()\n  .addScopeDecorator(MDCScopeDecorator.newBuilder()\n    .addExtraField(\"user-id\") // this pushes the extra field into log scope\n    .build())\n  .build();\n```"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2fb5c2374d62e0669f77a46606c92dcbe2140560", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/2fb5c2374d62e0669f77a46606c92dcbe2140560", "committedDate": "2020-03-06T07:06:04Z", "message": "a little less code"}, "afterCommit": {"oid": "db45071c2524aec135ad037dc1d599e0976107e3", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/db45071c2524aec135ad037dc1d599e0976107e3", "committedDate": "2020-03-28T04:30:03Z", "message": "Allows scope decorators to synchorize \"extra fields\" to logging context\n\nThis pulls up a major feature currently only available in Sleuth:\n\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/289ec4755e6bcda77830a25c958c19fb1f5af7e2/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/log/Slf4jScopeDecorator.java#L111-L119\n\nEx.\n```java\ncurrentTraceContext = ThreadLocalCurrentTraceContext.newBuilder()\n  .addScopeDecorator(MDCScopeDecorator.newBuilder()\n    .addExtraField(\"user-id\") // this pushes the extra field into log scope\n    .build())\n  .build();\n```"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "89241811b0b8847249432918e35431fd263f2d8c", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/89241811b0b8847249432918e35431fd263f2d8c", "committedDate": "2020-03-28T05:23:46Z", "message": "Adds the ability to opt-out of fields"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgzMjg2NTUz", "url": "https://github.com/openzipkin/brave/pull/1109#pullrequestreview-383286553", "createdAt": "2020-03-28T05:51:37Z", "commit": {"oid": "89241811b0b8847249432918e35431fd263f2d8c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1df20e9f9f131f145a5ad077adc56d504f964c57", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/1df20e9f9f131f145a5ad077adc56d504f964c57", "committedDate": "2020-03-28T06:09:16Z", "message": "fixes remove"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "7c96ed13f322ac2a772354a698d925ebbc622224", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/7c96ed13f322ac2a772354a698d925ebbc622224", "committedDate": "2020-03-28T07:05:09Z", "message": "fixes stuff"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ef2eb455541f2bf8f61340551d829899f59d0664", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/ef2eb455541f2bf8f61340551d829899f59d0664", "committedDate": "2020-03-28T08:30:31Z", "message": "Rewrote to fast-path single element contexts"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64160e6b3403c3436f53e76b064b21c244d28f8d", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/64160e6b3403c3436f53e76b064b21c244d28f8d", "committedDate": "2020-03-28T08:34:59Z", "message": "license"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8836da22f09f3fbe2bb2ffd2390cc397bfeb380", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/c8836da22f09f3fbe2bb2ffd2390cc397bfeb380", "committedDate": "2020-03-28T08:37:08Z", "message": "fuzz"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1864, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}