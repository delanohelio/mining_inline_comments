{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNjY1OTA2", "number": 1144, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzowNzoyMVrODv3DpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzowNzoyMVrODv3DpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTExNzE3OnYy", "diffSide": "RIGHT", "path": "brave/src/test/java/brave/features/propagation/HackedTraceIdTest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzowNzoyMVrOGChtgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzowODoxMlrOGChu-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwMjY1Ng==", "bodyText": "Delete I guess", "url": "https://github.com/openzipkin/brave/pull/1144#discussion_r405302656", "createdAt": "2020-04-08T07:07:21Z", "author": {"login": "anuraaga"}, "path": "brave/src/test/java/brave/features/propagation/HackedTraceIdTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.propagation;\n+\n+import brave.propagation.B3Propagation;\n+import brave.propagation.Propagation;\n+import brave.propagation.Propagation.KeyFactory;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContext.Extractor;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * This shows how people constrained to only propagating a trace ID can stash numerical data into\n+ * the trace ID. For example, a load balancer can set some bit flags like this.\n+ *\n+ * <p>Rumor has it that Twitter used to do this for embedding device information to ensure a\n+ * specific device couldn't absorb the entire random space. It isn't known if the amount of bits\n+ * stolen was a nibble or a byte.\n+ *\n+ * <p>See https://github.com/spring-cloud/spring-cloud-sleuth/issues/1106\n+ */\n+public class HackedTraceIdTest {\n+  String customTraceIdName = \"trace_id\";\n+  // CustomTraceIdPropagation.Factory substitutes for B3Propagation.FACTORY in real config.\n+  Propagation.Factory propagationFactory =\n+    CustomTraceIdPropagation.create(B3Propagation.FACTORY, customTraceIdName);\n+  Propagation<String> propagation = propagationFactory.create(KeyFactory.STRING);\n+  Extractor<Map<String, String>> extractor = propagation.extractor(Map::get);\n+  Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n+\n+  // Let's say environment number zero is invalid, and its desired value is 3\n+  // There are at least 3 ways to embed this!\n+  @Test public void testFormatThatEmbedsEnvironmentNumber() {\n+    // Lead with single-digit, then pad-right zeros until the real trace ID.\n+    //\n+    // This is not great because it limits to 9 environment numbers. However, parsing is easy\n+    // as you look only at the first character.\n+    headers.put(customTraceIdName, \"3000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"3000000000000000e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+    headers.put(customTraceIdName, \"3000000000000000\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"3000000000000000\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"3000000000000000\"));\n+\n+    // Use the upper 64-bits (left 16 hex) as the environment ID\n+    //\n+    // This allows a lot of env numbers, and is easy to parse. This still gives 64-bit trace IDs\n+    headers.put(customTraceIdName, \"0000000000000003e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"0000000000000003e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+    headers.put(customTraceIdName, \"3e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"0000000000000003e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+\n+    // Steal the upper nibble (first hex character) of the 64-bit trace ID as the environment ID\n+    //\n+    // This allows 15 env numbers, and is easy to parse. It allows 60-bits for the trace ID, which\n+    // is good enough for most sites.\n+    String customTraceIdString = \"3457b5a2e4d86bd1\";\n+    headers.put(customTraceIdName, customTraceIdString);\n+    TraceContext extractedContext = extractor.extract(headers).context();\n+    assertThat(extractedContext)\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(customTraceIdString))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(customTraceIdString))\n+      .satisfies(c -> assertThat((c.traceId() >>> 64 - 4L) & 0xf).isEqualTo(3));\n+  }\n+\n+  @Test public void testB3SingleWins() {\n+    headers.put(\"b3\", \"1111111111111111-2222222222222222\");\n+    headers.put(customTraceIdName, \"1000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"1111111111111111\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"2222222222222222\"));\n+  }\n+\n+  @Test public void testB3MultiWins() {\n+    headers.put(\"X-B3-TraceId\", \"1111111111111111\");\n+    headers.put(\"X-B3-SpanId\", \"2222222222222222\");\n+    headers.put(customTraceIdName, \"1000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"1111111111111111\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"2222222222222222\"));\n+  }\n+\n+  @Test public void invalidTraceIdsDontCrash() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5b4d401c9e60def0cf65ee4d14148b3a2a4667a8"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwMzAzMw==", "bodyText": "thx!", "url": "https://github.com/openzipkin/brave/pull/1144#discussion_r405303033", "createdAt": "2020-04-08T07:08:12Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/features/propagation/HackedTraceIdTest.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.propagation;\n+\n+import brave.propagation.B3Propagation;\n+import brave.propagation.Propagation;\n+import brave.propagation.Propagation.KeyFactory;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContext.Extractor;\n+import java.util.Map;\n+import java.util.TreeMap;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * This shows how people constrained to only propagating a trace ID can stash numerical data into\n+ * the trace ID. For example, a load balancer can set some bit flags like this.\n+ *\n+ * <p>Rumor has it that Twitter used to do this for embedding device information to ensure a\n+ * specific device couldn't absorb the entire random space. It isn't known if the amount of bits\n+ * stolen was a nibble or a byte.\n+ *\n+ * <p>See https://github.com/spring-cloud/spring-cloud-sleuth/issues/1106\n+ */\n+public class HackedTraceIdTest {\n+  String customTraceIdName = \"trace_id\";\n+  // CustomTraceIdPropagation.Factory substitutes for B3Propagation.FACTORY in real config.\n+  Propagation.Factory propagationFactory =\n+    CustomTraceIdPropagation.create(B3Propagation.FACTORY, customTraceIdName);\n+  Propagation<String> propagation = propagationFactory.create(KeyFactory.STRING);\n+  Extractor<Map<String, String>> extractor = propagation.extractor(Map::get);\n+  Map<String, String> headers = new TreeMap<>(String.CASE_INSENSITIVE_ORDER);\n+\n+  // Let's say environment number zero is invalid, and its desired value is 3\n+  // There are at least 3 ways to embed this!\n+  @Test public void testFormatThatEmbedsEnvironmentNumber() {\n+    // Lead with single-digit, then pad-right zeros until the real trace ID.\n+    //\n+    // This is not great because it limits to 9 environment numbers. However, parsing is easy\n+    // as you look only at the first character.\n+    headers.put(customTraceIdName, \"3000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"3000000000000000e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+    headers.put(customTraceIdName, \"3000000000000000\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"3000000000000000\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"3000000000000000\"));\n+\n+    // Use the upper 64-bits (left 16 hex) as the environment ID\n+    //\n+    // This allows a lot of env numbers, and is easy to parse. This still gives 64-bit trace IDs\n+    headers.put(customTraceIdName, \"0000000000000003e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"0000000000000003e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+    headers.put(customTraceIdName, \"3e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"0000000000000003e457b5a2e4d86bd1\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"e457b5a2e4d86bd1\"));\n+\n+    // Steal the upper nibble (first hex character) of the 64-bit trace ID as the environment ID\n+    //\n+    // This allows 15 env numbers, and is easy to parse. It allows 60-bits for the trace ID, which\n+    // is good enough for most sites.\n+    String customTraceIdString = \"3457b5a2e4d86bd1\";\n+    headers.put(customTraceIdName, customTraceIdString);\n+    TraceContext extractedContext = extractor.extract(headers).context();\n+    assertThat(extractedContext)\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(customTraceIdString))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(customTraceIdString))\n+      .satisfies(c -> assertThat((c.traceId() >>> 64 - 4L) & 0xf).isEqualTo(3));\n+  }\n+\n+  @Test public void testB3SingleWins() {\n+    headers.put(\"b3\", \"1111111111111111-2222222222222222\");\n+    headers.put(customTraceIdName, \"1000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"1111111111111111\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"2222222222222222\"));\n+  }\n+\n+  @Test public void testB3MultiWins() {\n+    headers.put(\"X-B3-TraceId\", \"1111111111111111\");\n+    headers.put(\"X-B3-SpanId\", \"2222222222222222\");\n+    headers.put(customTraceIdName, \"1000000000000000e457b5a2e4d86bd1\");\n+    assertThat(extractor.extract(headers).context())\n+      .satisfies(c -> assertThat(c.traceIdString()).isEqualTo(\"1111111111111111\"))\n+      .satisfies(c -> assertThat(c.spanIdString()).isEqualTo(\"2222222222222222\"));\n+  }\n+\n+  @Test public void invalidTraceIdsDontCrash() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMwMjY1Ng=="}, "originalCommit": {"oid": "5b4d401c9e60def0cf65ee4d14148b3a2a4667a8"}, "originalPosition": 104}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1623, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}