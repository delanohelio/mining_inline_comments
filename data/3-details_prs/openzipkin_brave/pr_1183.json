{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNDE1NzA4", "number": 1183, "title": "Adds local field redaction and decouples \"extra\" handling from baggage", "bodyText": "This addresses all issues mentioned here, except the decode side of\nBaggageCodec, which is just saved for a different PR.\n#1182 (comment)\nNotably, this decouples Extra from ExtraBaggageFields even more\ncleanly than before. This allows tests to be focused and also allows us\nto reuse the base infrastructure for sampling as we did before.\nInstead of having two data structure implementations of Baggage, this\nuses one. The only difference between static and dynamic is that the\nlatter is allowed to add up to 64 more fields that aren't in the\nwhitelist.\nThis fixes the problem where local fields were leaked to the Baggage\nencoder. This is implemented by a filtered map.\nAll baggage state is now implemented by UnsafeArrayMap which is a\nview over a pair-wise array of baggage fields and potentially null\nvalues.", "createdAt": "2020-05-02T08:02:55Z", "url": "https://github.com/openzipkin/brave/pull/1183", "merged": true, "mergeCommit": {"oid": "1bad69266bd80b3e1ea9de2f55c4ad4bdd585bc5"}, "closed": true, "closedAt": "2020-05-04T23:45:22Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcdRwo-AFqTQwNDUwOTgwMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcd6XLnAH2gAyNDEyNDE1NzA4OmJjNWUxYjVhMjA3NjYyYmY5ZDU5OGZmNzlkMDQxMjM1ODJhYzI0Mjg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTA5ODAx", "url": "https://github.com/openzipkin/brave/pull/1183#pullrequestreview-404509801", "createdAt": "2020-05-02T08:11:24Z", "commit": {"oid": "618dc6d3cd282c4773bc911cf401c603d2c6104a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwODoxMToyNFrOGPhaOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwODoxMToyNFrOGPhaOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyOTIxMQ==", "bodyText": "this is the best part of the change. Now the codec needn't do work BaggagePropagation should be doing. Notably, it shouldn't ever even see local fields.", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418929211", "createdAt": "2020-05-02T08:11:24Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/features/baggage/BaggageInSingleHeaderTest.java", "diffHunk": "@@ -38,10 +38,7 @@\n       .injectFormat(B3Propagation.Format.SINGLE).build())\n       .add(SingleBaggageField.remote(field1))\n       .add(SingleBaggageField.local(field2))\n-      .add(InternalBaggage.instance.newBaggagePropagationConfig(\n-          // BaggageCodec can see every baggage field, so it must be told what to not serialize\n-          SingleHeaderCodec.newBuilder().blacklistField(field2).build()\n-      ))\n+      .add(InternalBaggage.instance.newBaggagePropagationConfig(SingleHeaderCodec.get()))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618dc6d3cd282c4773bc911cf401c603d2c6104a"}, "originalPosition": 8}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTA5OTMx", "url": "https://github.com/openzipkin/brave/pull/1183#pullrequestreview-404509931", "createdAt": "2020-05-02T08:14:13Z", "commit": {"oid": "618dc6d3cd282c4773bc911cf401c603d2c6104a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwODoxNDoxM1rOGPhbMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwODoxNDoxM1rOGPhbMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyOTQ1OQ==", "bodyText": "It is important to understand that with or without dynamic fields, something like a consolidated header is possible. All \"dynamic does\" is allow you to use fields not whitelisted in BaggagePropagation setup. Encode/decode is decoupled from these details now, especially in a follow-up change that will remove the \"extra\" parameter from decode.", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418929459", "createdAt": "2020-05-02T08:14:13Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java", "diffHunk": "@@ -77,7 +46,9 @@ public BaggageCodec build() {\n   }\n \n   @Override public boolean decode(ExtraBaggageFields extra, Object request, String value) {\n-    assert extra.isDynamic() : \"This is unlikely to work with fixed fields!\";\n+    if (!extra.isDynamic()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618dc6d3cd282c4773bc911cf401c603d2c6104a"}, "originalPosition": 72}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTEwMDk1", "url": "https://github.com/openzipkin/brave/pull/1183#pullrequestreview-404510095", "createdAt": "2020-05-02T08:17:11Z", "commit": {"oid": "618dc6d3cd282c4773bc911cf401c603d2c6104a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwODoxNzoxMVrOGPhcjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwODoxNzoxMVrOGPhcjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkyOTgwNQ==", "bodyText": "even though  UnsafeArrayMap is package private and only used to implement baggage fields. I kept it a generic map type as it makes testing easier. In other words, that this takes arbitrary generic type params != a plan to expose this. Mostly UnsafeArrayMap allows us to safely share views of all baggage state without copying arrays or values into new map.", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418929805", "createdAt": "2020-05-02T08:17:11Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/internal/baggage/UnsafeArrayMapTest.java", "diffHunk": "@@ -0,0 +1,338 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import java.util.Collection;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import org.assertj.core.api.AbstractMapAssert;\n+import org.junit.Test;\n+\n+import static java.util.Arrays.asList;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+public class UnsafeArrayMapTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "618dc6d3cd282c4773bc911cf401c603d2c6104a"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0NTE1MDQy", "url": "https://github.com/openzipkin/brave/pull/1183#pullrequestreview-404515042", "createdAt": "2020-05-02T09:45:20Z", "commit": {"oid": "cb98a5a8164fe32f27a868650a60dcfae2a7733c"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwOTo0NToyMVrOGPh70g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQxMDowMDo1MVrOGPiBsw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNzgxMA==", "bodyText": "Would use !filtered instead of continue", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418937810", "createdAt": "2020-05-02T09:45:21Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb98a5a8164fe32f27a868650a60dcfae2a7733c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNzk2MQ==", "bodyText": "Might use a counter instead too\nnumFiltered++;\nif (numFiltered == 0) return this;\nif (numFiltered == toIndex / 2) return EMPTY", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418937961", "createdAt": "2020-05-02T09:46:38Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzNzgxMA=="}, "originalCommit": {"oid": "cb98a5a8164fe32f27a868650a60dcfae2a7733c"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODE1OQ==", "bodyText": "Can we use Collections.emptyMap() instead and remove the size == 0 special casing?", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418938159", "createdAt": "2020-05-02T09:48:50Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb98a5a8164fe32f27a868650a60dcfae2a7733c"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODM1Mg==", "bodyText": "This this method is only called in one place. I'd remove it mainly since the toIndex shadow is a bit unclear (or otherwise would make this static and accept all the parameters instead)", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418938352", "createdAt": "2020-05-02T09:50:51Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;\n+      filteredAll = false;\n+    }\n+    if (filteredBitSet == 0) return this;\n+    if (filteredAll) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, toIndex, filteredBitSet);\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredKeys;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredKeys) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredKeys = filteredKeys;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredKeys);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null || size == 0) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    if (size == 0) return false;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (equal(o, array[i + 1]) && !isSet(filteredKeys, i / 2)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null || size == 0) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? (V) array[i + 1] : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    return arrayIndexOfKey(o, 0, toIndex);\n+  }\n+\n+  int arrayIndexOfKey(Object o, int fromIndex, int toIndex) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb98a5a8164fe32f27a868650a60dcfae2a7733c"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODQ5MQ==", "bodyText": "The element at array index i is array[i] by definition of arrays :) Perhaps entryIndex?", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418938491", "createdAt": "2020-05-02T09:52:14Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;\n+      filteredAll = false;\n+    }\n+    if (filteredBitSet == 0) return this;\n+    if (filteredAll) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, toIndex, filteredBitSet);\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredKeys;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredKeys) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredKeys = filteredKeys;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredKeys);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null || size == 0) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    if (size == 0) return false;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (equal(o, array[i + 1]) && !isSet(filteredKeys, i / 2)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null || size == 0) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? (V) array[i + 1] : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    return arrayIndexOfKey(o, 0, toIndex);\n+  }\n+\n+  int arrayIndexOfKey(Object o, int fromIndex, int toIndex) {\n+    int result = -1;\n+    for (int i = fromIndex; i < toIndex; i += 2) {\n+      if (o.equals(array[i]) && !isSet(filteredKeys, i / 2)) {\n+        return i;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    return size == 0 ? Collections.emptySet() : new KeySetView();\n+  }\n+\n+  @Override public Collection<V> values() {\n+    return size == 0 ? Collections.emptyList() : new ValuesView();\n+  }\n+\n+  @Override public Set<Map.Entry<K, V>> entrySet() {\n+    return size == 0 ? Collections.emptySet() : new EntrySetView();\n+  }\n+\n+  @Override public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public V remove(Object key) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void putAll(Map<? extends K, ? extends V> m) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void clear() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  final class KeySetView extends CollectionView<K> implements Set<K> {\n+    KeySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override K elementAtArrayIndex(int i) {\n+      return (K) array[i];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+  }\n+\n+  final class ValuesView extends CollectionView<V> {\n+    ValuesView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override V elementAtArrayIndex(int i) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb98a5a8164fe32f27a868650a60dcfae2a7733c"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzODgzOQ==", "bodyText": "Believe you can use arrayIndexOfKey and check result + 1 equals that.getValue() since not a multimap. That will fix that this doesn't seem to take into account filtered keys too", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418938839", "createdAt": "2020-05-02T09:55:44Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;\n+      filteredAll = false;\n+    }\n+    if (filteredBitSet == 0) return this;\n+    if (filteredAll) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, toIndex, filteredBitSet);\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredKeys;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredKeys) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredKeys = filteredKeys;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredKeys);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null || size == 0) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    if (size == 0) return false;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (equal(o, array[i + 1]) && !isSet(filteredKeys, i / 2)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null || size == 0) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? (V) array[i + 1] : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    return arrayIndexOfKey(o, 0, toIndex);\n+  }\n+\n+  int arrayIndexOfKey(Object o, int fromIndex, int toIndex) {\n+    int result = -1;\n+    for (int i = fromIndex; i < toIndex; i += 2) {\n+      if (o.equals(array[i]) && !isSet(filteredKeys, i / 2)) {\n+        return i;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    return size == 0 ? Collections.emptySet() : new KeySetView();\n+  }\n+\n+  @Override public Collection<V> values() {\n+    return size == 0 ? Collections.emptyList() : new ValuesView();\n+  }\n+\n+  @Override public Set<Map.Entry<K, V>> entrySet() {\n+    return size == 0 ? Collections.emptySet() : new EntrySetView();\n+  }\n+\n+  @Override public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public V remove(Object key) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void putAll(Map<? extends K, ? extends V> m) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void clear() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  final class KeySetView extends CollectionView<K> implements Set<K> {\n+    KeySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override K elementAtArrayIndex(int i) {\n+      return (K) array[i];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+  }\n+\n+  final class ValuesView extends CollectionView<V> {\n+    ValuesView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override V elementAtArrayIndex(int i) {\n+      return (V) array[i + 1];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsValue(o);\n+    }\n+  }\n+\n+  final class EntrySetView extends CollectionView<Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n+    EntrySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override Map.Entry<K, V> elementAtArrayIndex(int i) {\n+      return new Entry<>((K) array[i], (V) array[i + 1]);\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      if (!(o instanceof Map.Entry) || ((Map.Entry) o).getKey() == null) return false;\n+      Map.Entry that = (Map.Entry) o;\n+      for (int i = 0; i < toIndex; i += 2) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb98a5a8164fe32f27a868650a60dcfae2a7733c"}, "originalPosition": 204}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODkzOTMxNQ==", "bodyText": "Didn't think about the performance implications, but what could we save and where would we lose some performance if implementing AbstractMap?", "url": "https://github.com/openzipkin/brave/pull/1183#discussion_r418939315", "createdAt": "2020-05-02T10:00:51Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/UnsafeArrayMap.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.internal.Nullable;\n+import java.lang.reflect.Array;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n+\n+import static brave.internal.baggage.LongBitSet.isSet;\n+import static brave.internal.baggage.LongBitSet.setBit;\n+\n+/**\n+ * A potentially read-only map which is a view over an array of {@code key, value} pairs. No key can\n+ * be {@code null}. However, values can be {@code null}.\n+ *\n+ * <p>The array is shared with the caller to {@link #create}, hence being called \"unsafe\".\n+ * This type supports cheap views over data using thread-local or copy-on-write arrays.\n+ *\n+ * <p>As this is an immutable view, operations like {@link #keySet()}, {@link #values()} and {@link\n+ * #entrySet()} might return constants. As expected, stateful objects such as {@link Iterator} will\n+ * never be shared.\n+ */\n+class UnsafeArrayMap<K, V> implements Map<K, V> {\n+  static final UnsafeArrayMap EMPTY_MAP = new UnsafeArrayMap(new Object[0], 0, 0);\n+\n+  static final int MAX_FILTERED_KEYS = LongBitSet.MAX_SIZE;\n+\n+  static <K, V> UnsafeArrayMap<K, V> create(Object[] array) {\n+    if (array == null) throw new NullPointerException(\"array == null\");\n+    int i = 0;\n+    for (; i < array.length; i += 2) {\n+      Object key = array[i];\n+      if (key == null) break; // we ignore anything starting at first null key\n+    }\n+    if (i == 0) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, i, 0);\n+  }\n+\n+  /** Resets redaction based on the input. */\n+  Map<K, V> filterKeys(K... filteredKeys) {\n+    if (filteredKeys == null || filteredKeys.length == 0) return this;\n+\n+    if (filteredKeys.length > MAX_FILTERED_KEYS) {\n+      throw new IllegalArgumentException(\"cannot redact more than \" + MAX_FILTERED_KEYS + \" keys\");\n+    }\n+\n+    long filteredBitSet = 0;\n+    boolean filteredAll = true;\n+    int i = 0;\n+    for (; i < toIndex; i += 2) {\n+      Object key = array[i];\n+      boolean filtered = false;\n+      for (K filteredKey : filteredKeys) {\n+        if (filteredKey.equals(key)) {\n+          filteredBitSet = setBit(filteredBitSet, i / 2);\n+          filtered = true;\n+          break;\n+        }\n+      }\n+      if (filtered) continue;\n+      filteredAll = false;\n+    }\n+    if (filteredBitSet == 0) return this;\n+    if (filteredAll) return EMPTY_MAP;\n+    return new UnsafeArrayMap<>(array, toIndex, filteredBitSet);\n+  }\n+\n+  final Object[] array;\n+  final int toIndex, size;\n+  final long filteredKeys;\n+\n+  UnsafeArrayMap(Object[] array, int toIndex, long filteredKeys) {\n+    this.array = array;\n+    this.toIndex = toIndex;\n+    this.filteredKeys = filteredKeys;\n+    this.size = toIndex / 2 - LongBitSet.size(filteredKeys);\n+  }\n+\n+  @Override public int size() {\n+    return size;\n+  }\n+\n+  @Override public boolean containsKey(Object o) {\n+    if (o == null || size == 0) return false; // null keys are not allowed\n+    return arrayIndexOfKey(o) != -1;\n+  }\n+\n+  @Override public boolean containsValue(Object o) {\n+    if (size == 0) return false;\n+    for (int i = 0; i < toIndex; i += 2) {\n+      if (equal(o, array[i + 1]) && !isSet(filteredKeys, i / 2)) return true;\n+    }\n+    return false;\n+  }\n+\n+  @Override public V get(Object o) {\n+    if (o == null || size == 0) return null; // null keys are not allowed\n+    int i = arrayIndexOfKey(o);\n+    return i != -1 ? (V) array[i + 1] : null;\n+  }\n+\n+  int arrayIndexOfKey(Object o) {\n+    return arrayIndexOfKey(o, 0, toIndex);\n+  }\n+\n+  int arrayIndexOfKey(Object o, int fromIndex, int toIndex) {\n+    int result = -1;\n+    for (int i = fromIndex; i < toIndex; i += 2) {\n+      if (o.equals(array[i]) && !isSet(filteredKeys, i / 2)) {\n+        return i;\n+      }\n+    }\n+    return result;\n+  }\n+\n+  @Override public Set<K> keySet() {\n+    return size == 0 ? Collections.emptySet() : new KeySetView();\n+  }\n+\n+  @Override public Collection<V> values() {\n+    return size == 0 ? Collections.emptyList() : new ValuesView();\n+  }\n+\n+  @Override public Set<Map.Entry<K, V>> entrySet() {\n+    return size == 0 ? Collections.emptySet() : new EntrySetView();\n+  }\n+\n+  @Override public boolean isEmpty() {\n+    return size == 0;\n+  }\n+\n+  @Override public V put(K key, V value) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public V remove(Object key) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void putAll(Map<? extends K, ? extends V> m) {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override public void clear() {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  final class KeySetView extends CollectionView<K> implements Set<K> {\n+    KeySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override K elementAtArrayIndex(int i) {\n+      return (K) array[i];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsKey(o);\n+    }\n+  }\n+\n+  final class ValuesView extends CollectionView<V> {\n+    ValuesView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override V elementAtArrayIndex(int i) {\n+      return (V) array[i + 1];\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      return containsValue(o);\n+    }\n+  }\n+\n+  final class EntrySetView extends CollectionView<Map.Entry<K, V>> implements Set<Map.Entry<K, V>> {\n+    EntrySetView() {\n+      super(0, UnsafeArrayMap.this.toIndex);\n+    }\n+\n+    @Override Map.Entry<K, V> elementAtArrayIndex(int i) {\n+      return new Entry<>((K) array[i], (V) array[i + 1]);\n+    }\n+\n+    @Override public boolean contains(Object o) {\n+      if (!(o instanceof Map.Entry) || ((Map.Entry) o).getKey() == null) return false;\n+      Map.Entry that = (Map.Entry) o;\n+      for (int i = 0; i < toIndex; i += 2) {\n+        if (that.getKey().equals(array[i]) && equal(that.getValue(), array[i + 1])) return true;\n+      }\n+      return false;\n+    }\n+  }\n+\n+  abstract class CollectionView<E> implements Collection<E> {\n+    final int fromIndex, toIndex, size;\n+\n+    protected CollectionView(int fromIndex, int toIndex) {\n+      this.fromIndex = fromIndex;\n+      this.toIndex = toIndex;\n+      this.size = calculateSize(fromIndex, toIndex);\n+    }\n+\n+    int advancePastFiltered(int i) {\n+      while (i < toIndex && isFilteredKey(i)) i += 2;\n+      return i;\n+    }\n+\n+    @Override public int size() {\n+      return size;\n+    }\n+\n+    abstract E elementAtArrayIndex(int i);\n+\n+    @Override public Iterator<E> iterator() {\n+      return new ReadOnlyIterator();\n+    }\n+\n+    @Override public Object[] toArray() {\n+      return copyTo(new Object[size]);\n+    }\n+\n+    @Override public <T> T[] toArray(T[] a) {\n+      T[] result = a.length >= size ? a\n+          : (T[]) Array.newInstance(a.getClass().getComponentType(), size());\n+      return copyTo(result);\n+    }\n+\n+    <T> T[] copyTo(T[] dest) {\n+      for (int i = fromIndex, d = 0; i < toIndex; i += 2) {\n+        if (isFilteredKey(i)) continue;\n+        dest[d++] = (T) elementAtArrayIndex(i);\n+      }\n+      return dest;\n+    }\n+\n+    final class ReadOnlyIterator implements Iterator<E> {\n+      int i = advancePastFiltered(fromIndex);\n+\n+      @Override public boolean hasNext() {\n+        i = advancePastFiltered(i);\n+        return i < toIndex;\n+      }\n+\n+      @Override public E next() {\n+        if (!hasNext()) throw new NoSuchElementException();\n+        E result = elementAtArrayIndex(i);\n+        i += 2;\n+        return result;\n+      }\n+\n+      @Override public void remove() {\n+        throw new UnsupportedOperationException();\n+      }\n+    }\n+\n+    @Override public boolean containsAll(Collection<?> c) {\n+      if (c == null) return false;\n+      if (c.isEmpty()) return true;\n+\n+      for (Object element : c) {\n+        if (!contains(element)) return false;\n+      }\n+      return true;\n+    }\n+\n+    @Override public boolean isEmpty() {\n+      return size == 0;\n+    }\n+\n+    @Override public boolean add(E e) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean remove(Object o) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean addAll(Collection<? extends E> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean retainAll(Collection<?> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public boolean removeAll(Collection<?> c) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override public void clear() {\n+      throw new UnsupportedOperationException();\n+    }\n+  }\n+\n+  static final class Entry<K, V> implements Map.Entry<K, V> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cb98a5a8164fe32f27a868650a60dcfae2a7733c"}, "originalPosition": 312}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "16c0324ab5fe25b5087463ee60aa1b8ab7c4c297", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/16c0324ab5fe25b5087463ee60aa1b8ab7c4c297", "committedDate": "2020-05-03T01:16:23Z", "message": "Adds rationale"}, "afterCommit": {"oid": "6967d775aa5548360bf0729796e88191cd3fe2ad", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/6967d775aa5548360bf0729796e88191cd3fe2ad", "committedDate": "2020-05-04T07:07:09Z", "message": "Adds local field redaction and decouples \"extra\" handling from baggage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6967d775aa5548360bf0729796e88191cd3fe2ad", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/6967d775aa5548360bf0729796e88191cd3fe2ad", "committedDate": "2020-05-04T07:07:09Z", "message": "Adds local field redaction and decouples \"extra\" handling from baggage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc5e1b5a207662bf9d598ff79d04123582ac2428", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/bc5e1b5a207662bf9d598ff79d04123582ac2428", "committedDate": "2020-05-04T07:29:42Z", "message": "rationale drift"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1704, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}