{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4OTk1NTE3", "number": 1173, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMTozOTo0NFrOD2OInA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjo0NjoyMlrOD2OsUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MTgxMjc2OnYy", "diffSide": "RIGHT", "path": "instrumentation/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMTozOTo0NFrOGL8-mg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMTozOTo0NFrOGL8-mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE4NjU4Ng==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This may sound intuitive to those thinking in terms of callback nesting depth,\n          \n          \n            \n            This may sound unintuitive to those thinking in terms of callback nesting depth,", "url": "https://github.com/openzipkin/brave/pull/1173#discussion_r415186586", "createdAt": "2020-04-26T01:39:44Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/RATIONALE.md", "diffHunk": "@@ -2,6 +2,94 @@\n Rationale here applies to common decisions made in this directory. See\n [Brave's RATIONALE](../brave/RATIONALE.md) for internal rationale.\n \n+## Why does the client response callback run in the invocation context?\n+This rationale applies equally to CLIENT and PRODUCER spans.\n+\n+Asynchronous code is often modeled in terms of callbacks. For example, the\n+following pseudo code represents a chain of 3 client calls.\n+```java\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  client.call(\"1\")\n+        .flatMap((r) -> client.call(\"2\"))\n+        .flatMap((r) -> client.call(\"3\"));\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+It might be surprising that calls \"2\" and \"3\" execute in the \"parent\" trace\n+context, as opposed to the preceding client call. Put another way, response\n+callbacks run in the invocation context, which cause new spans to appear as\n+as a siblings, as opposed to children of the previous callback (in this case\n+a client).\n+\n+This may sound intuitive to those thinking in terms of callback nesting depth,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "455167556c1b485333d1a41108babc8384421e17"}, "originalPosition": 26}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU4MTkwNDE4OnYy", "diffSide": "RIGHT", "path": "instrumentation/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMjo0NjoyMlrOGL9lVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNlQwMzozNzoyMVrOGL-DmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5NjUwMg==", "bodyText": "How about also talking about local spans (span without kind)? I guess some people want to model grouped client spans and intuitively think the group should also be a client span, though in our model, where we want to describe inter-service links, this should be a local span.", "url": "https://github.com/openzipkin/brave/pull/1173#discussion_r415196502", "createdAt": "2020-04-26T02:46:22Z", "author": {"login": "anuraaga"}, "path": "instrumentation/RATIONALE.md", "diffHunk": "@@ -2,6 +2,100 @@\n Rationale here applies to common decisions made in this directory. See\n [Brave's RATIONALE](../brave/RATIONALE.md) for internal rationale.\n \n+## Why does the client response callback run in the invocation context?\n+This rationale applies equally to CLIENT and PRODUCER spans.\n+\n+Asynchronous code is often modeled in terms of callbacks. For example, the\n+following pseudo code represents a chain of 3 client calls.\n+```java\n+// Assume you are reactive: assembling a call doesn't invoke it.\n+call = client.call(\"1\")\n+             .flatMap((r) -> client.call(\"2\"))\n+             .flatMap((r) -> client.call(\"3\"));\n+\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  // In reactive style, subscribe attaches the trace context\n+  call.subscribe(subscriber);\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+It might be surprising that calls \"2\" and \"3\" execute in the \"parent\" trace\n+context, as opposed to the preceding client call. Put another way, response\n+callbacks run in the invocation context, which cause new spans to appear as\n+as a siblings, as opposed to children of the previous callback (in this case\n+a client).\n+\n+This may sound unintuitive to those thinking in terms of callback nesting depth,\n+but having a consistent structure allows traces to appear similar regardless of\n+imperative vs async invocation. It also is more easy to reason with, but we'll\n+touch on that later.\n+\n+Let's consider the above async pseudo code with the logical equivalent in\n+synchronous code. In each case, there are 3 client calls made in sequence. In\n+each case, there's a potential data dependency, but it isn't actually used!\n+```java\n+// synchronous\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  client.call(\"1\");\n+  client.call(\"2\");\n+  client.call(\"3\");\n+} finally {\n+  parent.finish();\n+}\n+\n+// reactive\n+call = client.call(\"1\")\n+             .flatMap((r) -> client.call(\"2\"))\n+             .flatMap((r) -> client.call(\"3\"));\n+\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  call.subscribe(subscriber);\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+We mention that data is ignored to highlight one deduction one can make, which\n+is that the hierarchy should represent data dependency, as opposed to logical\n+or time wise. While this is interesting, it is difficult to execute in\n+practice. Instrumentation are usually at a lower level than the application\n+code that they run. Hierarchy is already chosen before it would know if data\n+would be read or not. In most cases, it would be unknowable if data were read\n+or used at that level of abstraction. In other words, such a relationship is\n+more fitting for span tags at a higher level, and decoupled from span\n+hierarchy.\n+\n+Even throwing out the data dependency argument, some may think why not model\n+callback depth anyway? We should model spans how the code looks, right?\n+\n+Only three calls may not seem that bad. Perhaps it is easy to reason with\n+what's going on. However, what if there were 100 or 1000? It would be very\n+difficult to reason with the actual parent which may be 999 levels up the tree.\n+Some backend code perform operations like counting children, in order to\n+determine fan out counts. This code would become useless as there would only\n+ever be one child! Put visually, imagine clicking '-' 999 times to find the\n+real parent in a typical trace UI!\n+\n+We acknowledge that using the invocation context as the parent of follow-up\n+requests (response callback) is imperfect. It means any data dependency between\n+one response and the next request is not represented in the hierarchy. It also\n+means callback depth with not manifest in the trace hierarchy. That said,\n+follow-up requests still share not just the same trace, but also the same local\n+root, and also direct parent. As the clocks are the same (and in fact locked\n+against skew), the happens after relationship manifests in span timing. At any\n+rate, if a data dependency is important, you can consider mapping it as a tag.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "488aabc331d2dd2c5760e139801ebde78aa03555"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5Nzg4MQ==", "bodyText": "sounds good will add", "url": "https://github.com/openzipkin/brave/pull/1173#discussion_r415197881", "createdAt": "2020-04-26T02:55:32Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/RATIONALE.md", "diffHunk": "@@ -2,6 +2,100 @@\n Rationale here applies to common decisions made in this directory. See\n [Brave's RATIONALE](../brave/RATIONALE.md) for internal rationale.\n \n+## Why does the client response callback run in the invocation context?\n+This rationale applies equally to CLIENT and PRODUCER spans.\n+\n+Asynchronous code is often modeled in terms of callbacks. For example, the\n+following pseudo code represents a chain of 3 client calls.\n+```java\n+// Assume you are reactive: assembling a call doesn't invoke it.\n+call = client.call(\"1\")\n+             .flatMap((r) -> client.call(\"2\"))\n+             .flatMap((r) -> client.call(\"3\"));\n+\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  // In reactive style, subscribe attaches the trace context\n+  call.subscribe(subscriber);\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+It might be surprising that calls \"2\" and \"3\" execute in the \"parent\" trace\n+context, as opposed to the preceding client call. Put another way, response\n+callbacks run in the invocation context, which cause new spans to appear as\n+as a siblings, as opposed to children of the previous callback (in this case\n+a client).\n+\n+This may sound unintuitive to those thinking in terms of callback nesting depth,\n+but having a consistent structure allows traces to appear similar regardless of\n+imperative vs async invocation. It also is more easy to reason with, but we'll\n+touch on that later.\n+\n+Let's consider the above async pseudo code with the logical equivalent in\n+synchronous code. In each case, there are 3 client calls made in sequence. In\n+each case, there's a potential data dependency, but it isn't actually used!\n+```java\n+// synchronous\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  client.call(\"1\");\n+  client.call(\"2\");\n+  client.call(\"3\");\n+} finally {\n+  parent.finish();\n+}\n+\n+// reactive\n+call = client.call(\"1\")\n+             .flatMap((r) -> client.call(\"2\"))\n+             .flatMap((r) -> client.call(\"3\"));\n+\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  call.subscribe(subscriber);\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+We mention that data is ignored to highlight one deduction one can make, which\n+is that the hierarchy should represent data dependency, as opposed to logical\n+or time wise. While this is interesting, it is difficult to execute in\n+practice. Instrumentation are usually at a lower level than the application\n+code that they run. Hierarchy is already chosen before it would know if data\n+would be read or not. In most cases, it would be unknowable if data were read\n+or used at that level of abstraction. In other words, such a relationship is\n+more fitting for span tags at a higher level, and decoupled from span\n+hierarchy.\n+\n+Even throwing out the data dependency argument, some may think why not model\n+callback depth anyway? We should model spans how the code looks, right?\n+\n+Only three calls may not seem that bad. Perhaps it is easy to reason with\n+what's going on. However, what if there were 100 or 1000? It would be very\n+difficult to reason with the actual parent which may be 999 levels up the tree.\n+Some backend code perform operations like counting children, in order to\n+determine fan out counts. This code would become useless as there would only\n+ever be one child! Put visually, imagine clicking '-' 999 times to find the\n+real parent in a typical trace UI!\n+\n+We acknowledge that using the invocation context as the parent of follow-up\n+requests (response callback) is imperfect. It means any data dependency between\n+one response and the next request is not represented in the hierarchy. It also\n+means callback depth with not manifest in the trace hierarchy. That said,\n+follow-up requests still share not just the same trace, but also the same local\n+root, and also direct parent. As the clocks are the same (and in fact locked\n+against skew), the happens after relationship manifests in span timing. At any\n+rate, if a data dependency is important, you can consider mapping it as a tag.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5NjUwMg=="}, "originalCommit": {"oid": "488aabc331d2dd2c5760e139801ebde78aa03555"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5ODY0OA==", "bodyText": "I think it is a different topic, so I'll add a different section.\nIs there a coherent link between this and that or just something that caught your mind. I'm not sure where to join the points as this is about the response callback and not the span kind vs no span kind topic..\nI know we have another #1172 about that..", "url": "https://github.com/openzipkin/brave/pull/1173#discussion_r415198648", "createdAt": "2020-04-26T03:00:46Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/RATIONALE.md", "diffHunk": "@@ -2,6 +2,100 @@\n Rationale here applies to common decisions made in this directory. See\n [Brave's RATIONALE](../brave/RATIONALE.md) for internal rationale.\n \n+## Why does the client response callback run in the invocation context?\n+This rationale applies equally to CLIENT and PRODUCER spans.\n+\n+Asynchronous code is often modeled in terms of callbacks. For example, the\n+following pseudo code represents a chain of 3 client calls.\n+```java\n+// Assume you are reactive: assembling a call doesn't invoke it.\n+call = client.call(\"1\")\n+             .flatMap((r) -> client.call(\"2\"))\n+             .flatMap((r) -> client.call(\"3\"));\n+\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  // In reactive style, subscribe attaches the trace context\n+  call.subscribe(subscriber);\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+It might be surprising that calls \"2\" and \"3\" execute in the \"parent\" trace\n+context, as opposed to the preceding client call. Put another way, response\n+callbacks run in the invocation context, which cause new spans to appear as\n+as a siblings, as opposed to children of the previous callback (in this case\n+a client).\n+\n+This may sound unintuitive to those thinking in terms of callback nesting depth,\n+but having a consistent structure allows traces to appear similar regardless of\n+imperative vs async invocation. It also is more easy to reason with, but we'll\n+touch on that later.\n+\n+Let's consider the above async pseudo code with the logical equivalent in\n+synchronous code. In each case, there are 3 client calls made in sequence. In\n+each case, there's a potential data dependency, but it isn't actually used!\n+```java\n+// synchronous\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  client.call(\"1\");\n+  client.call(\"2\");\n+  client.call(\"3\");\n+} finally {\n+  parent.finish();\n+}\n+\n+// reactive\n+call = client.call(\"1\")\n+             .flatMap((r) -> client.call(\"2\"))\n+             .flatMap((r) -> client.call(\"3\"));\n+\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  call.subscribe(subscriber);\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+We mention that data is ignored to highlight one deduction one can make, which\n+is that the hierarchy should represent data dependency, as opposed to logical\n+or time wise. While this is interesting, it is difficult to execute in\n+practice. Instrumentation are usually at a lower level than the application\n+code that they run. Hierarchy is already chosen before it would know if data\n+would be read or not. In most cases, it would be unknowable if data were read\n+or used at that level of abstraction. In other words, such a relationship is\n+more fitting for span tags at a higher level, and decoupled from span\n+hierarchy.\n+\n+Even throwing out the data dependency argument, some may think why not model\n+callback depth anyway? We should model spans how the code looks, right?\n+\n+Only three calls may not seem that bad. Perhaps it is easy to reason with\n+what's going on. However, what if there were 100 or 1000? It would be very\n+difficult to reason with the actual parent which may be 999 levels up the tree.\n+Some backend code perform operations like counting children, in order to\n+determine fan out counts. This code would become useless as there would only\n+ever be one child! Put visually, imagine clicking '-' 999 times to find the\n+real parent in a typical trace UI!\n+\n+We acknowledge that using the invocation context as the parent of follow-up\n+requests (response callback) is imperfect. It means any data dependency between\n+one response and the next request is not represented in the hierarchy. It also\n+means callback depth with not manifest in the trace hierarchy. That said,\n+follow-up requests still share not just the same trace, but also the same local\n+root, and also direct parent. As the clocks are the same (and in fact locked\n+against skew), the happens after relationship manifests in span timing. At any\n+rate, if a data dependency is important, you can consider mapping it as a tag.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5NjUwMg=="}, "originalCommit": {"oid": "488aabc331d2dd2c5760e139801ebde78aa03555"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTIwNDI0OA==", "bodyText": "moved to #1172", "url": "https://github.com/openzipkin/brave/pull/1173#discussion_r415204248", "createdAt": "2020-04-26T03:37:21Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/RATIONALE.md", "diffHunk": "@@ -2,6 +2,100 @@\n Rationale here applies to common decisions made in this directory. See\n [Brave's RATIONALE](../brave/RATIONALE.md) for internal rationale.\n \n+## Why does the client response callback run in the invocation context?\n+This rationale applies equally to CLIENT and PRODUCER spans.\n+\n+Asynchronous code is often modeled in terms of callbacks. For example, the\n+following pseudo code represents a chain of 3 client calls.\n+```java\n+// Assume you are reactive: assembling a call doesn't invoke it.\n+call = client.call(\"1\")\n+             .flatMap((r) -> client.call(\"2\"))\n+             .flatMap((r) -> client.call(\"3\"));\n+\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  // In reactive style, subscribe attaches the trace context\n+  call.subscribe(subscriber);\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+It might be surprising that calls \"2\" and \"3\" execute in the \"parent\" trace\n+context, as opposed to the preceding client call. Put another way, response\n+callbacks run in the invocation context, which cause new spans to appear as\n+as a siblings, as opposed to children of the previous callback (in this case\n+a client).\n+\n+This may sound unintuitive to those thinking in terms of callback nesting depth,\n+but having a consistent structure allows traces to appear similar regardless of\n+imperative vs async invocation. It also is more easy to reason with, but we'll\n+touch on that later.\n+\n+Let's consider the above async pseudo code with the logical equivalent in\n+synchronous code. In each case, there are 3 client calls made in sequence. In\n+each case, there's a potential data dependency, but it isn't actually used!\n+```java\n+// synchronous\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  client.call(\"1\");\n+  client.call(\"2\");\n+  client.call(\"3\");\n+} finally {\n+  parent.finish();\n+}\n+\n+// reactive\n+call = client.call(\"1\")\n+             .flatMap((r) -> client.call(\"2\"))\n+             .flatMap((r) -> client.call(\"3\"));\n+\n+ScopedSpan parent = tracer.startScopedSpan(\"parent\");\n+try {\n+  call.subscribe(subscriber);\n+} finally {\n+  parent.finish();\n+}\n+```\n+\n+We mention that data is ignored to highlight one deduction one can make, which\n+is that the hierarchy should represent data dependency, as opposed to logical\n+or time wise. While this is interesting, it is difficult to execute in\n+practice. Instrumentation are usually at a lower level than the application\n+code that they run. Hierarchy is already chosen before it would know if data\n+would be read or not. In most cases, it would be unknowable if data were read\n+or used at that level of abstraction. In other words, such a relationship is\n+more fitting for span tags at a higher level, and decoupled from span\n+hierarchy.\n+\n+Even throwing out the data dependency argument, some may think why not model\n+callback depth anyway? We should model spans how the code looks, right?\n+\n+Only three calls may not seem that bad. Perhaps it is easy to reason with\n+what's going on. However, what if there were 100 or 1000? It would be very\n+difficult to reason with the actual parent which may be 999 levels up the tree.\n+Some backend code perform operations like counting children, in order to\n+determine fan out counts. This code would become useless as there would only\n+ever be one child! Put visually, imagine clicking '-' 999 times to find the\n+real parent in a typical trace UI!\n+\n+We acknowledge that using the invocation context as the parent of follow-up\n+requests (response callback) is imperfect. It means any data dependency between\n+one response and the next request is not represented in the hierarchy. It also\n+means callback depth with not manifest in the trace hierarchy. That said,\n+follow-up requests still share not just the same trace, but also the same local\n+root, and also direct parent. As the clocks are the same (and in fact locked\n+against skew), the happens after relationship manifests in span timing. At any\n+rate, if a data dependency is important, you can consider mapping it as a tag.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTE5NjUwMg=="}, "originalCommit": {"oid": "488aabc331d2dd2c5760e139801ebde78aa03555"}, "originalPosition": 90}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1381, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}