{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyNDg0MzYz", "number": 1155, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjowMjo1MFrODxJkPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjoxNjo1MFrODxJtNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODYzNTUwOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tracing.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjowMjo1MFrOGEdnSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjozOTo1M1rOGEeMFQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzMjY4Mg==", "bodyText": "Should this import be gone too?", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407332682", "createdAt": "2020-04-13T06:02:50Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracing.java", "diffHunk": "@@ -34,10 +35,7 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import zipkin2.reporter.AsyncReporter;\n import zipkin2.reporter.Reporter;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzMzIwOA==", "bodyText": "That being said, I think it's still fairly standard to import even from optional dependencies.", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407333208", "createdAt": "2020-04-13T06:05:01Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracing.java", "diffHunk": "@@ -34,10 +35,7 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import zipkin2.reporter.AsyncReporter;\n import zipkin2.reporter.Reporter;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzMjY4Mg=="}, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MjEwMQ==", "bodyText": "no worries I'll revert it. this was accidental as I was trying to find where everything was called.", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407342101", "createdAt": "2020-04-13T06:39:53Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tracing.java", "diffHunk": "@@ -34,10 +35,7 @@\n import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.concurrent.atomic.AtomicReference;\n import java.util.logging.Level;\n-import java.util.logging.Logger;\n-import zipkin2.reporter.AsyncReporter;\n import zipkin2.reporter.Reporter;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzMjY4Mg=="}, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODYzODA1OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tracing.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjowNDoyMVrOGEdoxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjo0MDo1NFrOGEeNHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzMzA2Mg==", "bodyText": "Maybe an <a> tag linking to the module or something. Currently, it's hard to know this is a maven artifact.", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407333062", "createdAt": "2020-04-13T06:04:21Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracing.java", "diffHunk": "@@ -210,11 +208,9 @@ public Builder endpoint(zipkin2.Endpoint endpoint) {\n     }\n \n     /**\n-     * Controls how spans are reported. Defaults to logging, but often an {@link AsyncReporter}\n-     * which batches spans before sending to Zipkin.\n-     *\n-     * The {@link AsyncReporter} includes a {@link Sender}, which is a driver for transports like\n-     * http, kafka and scribe.\n+     * Controls how {@linkplain TraceContext#sampled() remote sampled} spans report to a {@code\n+     * io.zipkin.reporter2:zipkin-reporter} destination. This input is usually a {@link", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MjM2Nw==", "bodyText": "good idea", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407342367", "createdAt": "2020-04-13T06:40:54Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tracing.java", "diffHunk": "@@ -210,11 +208,9 @@ public Builder endpoint(zipkin2.Endpoint endpoint) {\n     }\n \n     /**\n-     * Controls how spans are reported. Defaults to logging, but often an {@link AsyncReporter}\n-     * which batches spans before sending to Zipkin.\n-     *\n-     * The {@link AsyncReporter} includes a {@link Sender}, which is a driver for transports like\n-     * http, kafka and scribe.\n+     * Controls how {@linkplain TraceContext#sampled() remote sampled} spans report to a {@code\n+     * io.zipkin.reporter2:zipkin-reporter} destination. This input is usually a {@link", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzMzA2Mg=="}, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODY1MzEyOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/internal/handler/MutableSpanConverter.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjoxMzo1MVrOGEdxhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNzoxODozMVrOGEe46w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNTMwMA==", "bodyText": "Think you still need to compare the values in case of hash collision", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407335300", "createdAt": "2020-04-13T06:13:51Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/handler/MutableSpanConverter.java", "diffHunk": "@@ -65,38 +76,30 @@ void convert(MutableSpan span, Span.Builder result) {\n         .build());\n     }\n \n-    String errorTag = span.tag(\"error\");\n-    if (errorTag == null && span.error() != null) {\n-      errorParser.error(span.error(), span);\n-    }\n-\n     span.forEachTag(Consumer.INSTANCE, result);\n     span.forEachAnnotation(Consumer.INSTANCE, result);\n     if (span.shared()) result.shared(true);\n+    if (span.debug()) result.debug(true);\n   }\n \n   // avoid re-allocating an endpoint when we have the same data\n-  void addLocalEndpoint(String serviceName, @Nullable String ip, int port, Span.Builder span) {\n-    if (serviceName == null) serviceName = localServiceName;\n-    if (ip == null) ip = localIp;\n-    if (port <= 0) port = localPort;\n-    if (localServiceName.equals(serviceName)\n-      && (localIp == null ? ip == null : localIp.equals(ip))\n-      && localPort == port) {\n-      span.localEndpoint(localEndpoint);\n+  void addLocalEndpoint(@Nullable String serviceName, @Nullable String ip, int port, Builder span) {\n+    if (serviceName != null) serviceName = serviceName.toLowerCase(Locale.ROOT);\n+    if (hashEndpointParameters(serviceName, ip, port) == defaultEndpointHashCode) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNjc4OQ==", "bodyText": "fair enough :)", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407336789", "createdAt": "2020-04-13T06:19:22Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/handler/MutableSpanConverter.java", "diffHunk": "@@ -65,38 +76,30 @@ void convert(MutableSpan span, Span.Builder result) {\n         .build());\n     }\n \n-    String errorTag = span.tag(\"error\");\n-    if (errorTag == null && span.error() != null) {\n-      errorParser.error(span.error(), span);\n-    }\n-\n     span.forEachTag(Consumer.INSTANCE, result);\n     span.forEachAnnotation(Consumer.INSTANCE, result);\n     if (span.shared()) result.shared(true);\n+    if (span.debug()) result.debug(true);\n   }\n \n   // avoid re-allocating an endpoint when we have the same data\n-  void addLocalEndpoint(String serviceName, @Nullable String ip, int port, Span.Builder span) {\n-    if (serviceName == null) serviceName = localServiceName;\n-    if (ip == null) ip = localIp;\n-    if (port <= 0) port = localPort;\n-    if (localServiceName.equals(serviceName)\n-      && (localIp == null ? ip == null : localIp.equals(ip))\n-      && localPort == port) {\n-      span.localEndpoint(localEndpoint);\n+  void addLocalEndpoint(@Nullable String serviceName, @Nullable String ip, int port, Builder span) {\n+    if (serviceName != null) serviceName = serviceName.toLowerCase(Locale.ROOT);\n+    if (hashEndpointParameters(serviceName, ip, port) == defaultEndpointHashCode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNTMwMA=="}, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MDM3Ng==", "bodyText": "I didn't think about this. luckily somewhere I have a string that has a different value with same hashcode.. /me digs", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407340376", "createdAt": "2020-04-13T06:33:28Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/handler/MutableSpanConverter.java", "diffHunk": "@@ -65,38 +76,30 @@ void convert(MutableSpan span, Span.Builder result) {\n         .build());\n     }\n \n-    String errorTag = span.tag(\"error\");\n-    if (errorTag == null && span.error() != null) {\n-      errorParser.error(span.error(), span);\n-    }\n-\n     span.forEachTag(Consumer.INSTANCE, result);\n     span.forEachAnnotation(Consumer.INSTANCE, result);\n     if (span.shared()) result.shared(true);\n+    if (span.debug()) result.debug(true);\n   }\n \n   // avoid re-allocating an endpoint when we have the same data\n-  void addLocalEndpoint(String serviceName, @Nullable String ip, int port, Span.Builder span) {\n-    if (serviceName == null) serviceName = localServiceName;\n-    if (ip == null) ip = localIp;\n-    if (port <= 0) port = localPort;\n-    if (localServiceName.equals(serviceName)\n-      && (localIp == null ? ip == null : localIp.equals(ip))\n-      && localPort == port) {\n-      span.localEndpoint(localEndpoint);\n+  void addLocalEndpoint(@Nullable String serviceName, @Nullable String ip, int port, Builder span) {\n+    if (serviceName != null) serviceName = serviceName.toLowerCase(Locale.ROOT);\n+    if (hashEndpointParameters(serviceName, ip, port) == defaultEndpointHashCode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNTMwMA=="}, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 107}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM1MzU3OQ==", "bodyText": "thanks for the tip on gitter https://dzone.com/articles/what-is-wrong-with-hashcode-in-javalangstring", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407353579", "createdAt": "2020-04-13T07:18:31Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/handler/MutableSpanConverter.java", "diffHunk": "@@ -65,38 +76,30 @@ void convert(MutableSpan span, Span.Builder result) {\n         .build());\n     }\n \n-    String errorTag = span.tag(\"error\");\n-    if (errorTag == null && span.error() != null) {\n-      errorParser.error(span.error(), span);\n-    }\n-\n     span.forEachTag(Consumer.INSTANCE, result);\n     span.forEachAnnotation(Consumer.INSTANCE, result);\n     if (span.shared()) result.shared(true);\n+    if (span.debug()) result.debug(true);\n   }\n \n   // avoid re-allocating an endpoint when we have the same data\n-  void addLocalEndpoint(String serviceName, @Nullable String ip, int port, Span.Builder span) {\n-    if (serviceName == null) serviceName = localServiceName;\n-    if (ip == null) ip = localIp;\n-    if (port <= 0) port = localPort;\n-    if (localServiceName.equals(serviceName)\n-      && (localIp == null ? ip == null : localIp.equals(ip))\n-      && localPort == port) {\n-      span.localEndpoint(localEndpoint);\n+  void addLocalEndpoint(@Nullable String serviceName, @Nullable String ip, int port, Builder span) {\n+    if (serviceName != null) serviceName = serviceName.toLowerCase(Locale.ROOT);\n+    if (hashEndpointParameters(serviceName, ip, port) == defaultEndpointHashCode) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNTMwMA=="}, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODY1NDc2OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/internal/handler/MutableSpanConverter.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjoxNDo0M1rOGEdycA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjo0MzozNVrOGEeQBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNTUzNg==", "bodyText": "Possibly was due to refactoring - suggest putting Span back here", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407335536", "createdAt": "2020-04-13T06:14:43Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/handler/MutableSpanConverter.java", "diffHunk": "@@ -65,38 +76,30 @@ void convert(MutableSpan span, Span.Builder result) {\n         .build());\n     }\n \n-    String errorTag = span.tag(\"error\");\n-    if (errorTag == null && span.error() != null) {\n-      errorParser.error(span.error(), span);\n-    }\n-\n     span.forEachTag(Consumer.INSTANCE, result);\n     span.forEachAnnotation(Consumer.INSTANCE, result);\n     if (span.shared()) result.shared(true);\n+    if (span.debug()) result.debug(true);\n   }\n \n   // avoid re-allocating an endpoint when we have the same data\n-  void addLocalEndpoint(String serviceName, @Nullable String ip, int port, Span.Builder span) {\n-    if (serviceName == null) serviceName = localServiceName;\n-    if (ip == null) ip = localIp;\n-    if (port <= 0) port = localPort;\n-    if (localServiceName.equals(serviceName)\n-      && (localIp == null ? ip == null : localIp.equals(ip))\n-      && localPort == port) {\n-      span.localEndpoint(localEndpoint);\n+  void addLocalEndpoint(@Nullable String serviceName, @Nullable String ip, int port, Builder span) {\n+    if (serviceName != null) serviceName = serviceName.toLowerCase(Locale.ROOT);\n+    if (hashEndpointParameters(serviceName, ip, port) == defaultEndpointHashCode) {\n+      span.localEndpoint(defaultEndpoint);\n     } else {\n       span.localEndpoint(Endpoint.newBuilder().serviceName(serviceName).ip(ip).port(port).build());\n     }\n   }\n \n-  enum Consumer implements TagConsumer<Span.Builder>, AnnotationConsumer<Span.Builder> {\n+  enum Consumer implements TagConsumer<Builder>, AnnotationConsumer<Builder> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MzExMA==", "bodyText": "it was line wrap, but yeah ok.", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407343110", "createdAt": "2020-04-13T06:43:35Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/handler/MutableSpanConverter.java", "diffHunk": "@@ -65,38 +76,30 @@ void convert(MutableSpan span, Span.Builder result) {\n         .build());\n     }\n \n-    String errorTag = span.tag(\"error\");\n-    if (errorTag == null && span.error() != null) {\n-      errorParser.error(span.error(), span);\n-    }\n-\n     span.forEachTag(Consumer.INSTANCE, result);\n     span.forEachAnnotation(Consumer.INSTANCE, result);\n     if (span.shared()) result.shared(true);\n+    if (span.debug()) result.debug(true);\n   }\n \n   // avoid re-allocating an endpoint when we have the same data\n-  void addLocalEndpoint(String serviceName, @Nullable String ip, int port, Span.Builder span) {\n-    if (serviceName == null) serviceName = localServiceName;\n-    if (ip == null) ip = localIp;\n-    if (port <= 0) port = localPort;\n-    if (localServiceName.equals(serviceName)\n-      && (localIp == null ? ip == null : localIp.equals(ip))\n-      && localPort == port) {\n-      span.localEndpoint(localEndpoint);\n+  void addLocalEndpoint(@Nullable String serviceName, @Nullable String ip, int port, Builder span) {\n+    if (serviceName != null) serviceName = serviceName.toLowerCase(Locale.ROOT);\n+    if (hashEndpointParameters(serviceName, ip, port) == defaultEndpointHashCode) {\n+      span.localEndpoint(defaultEndpoint);\n     } else {\n       span.localEndpoint(Endpoint.newBuilder().serviceName(serviceName).ip(ip).port(port).build());\n     }\n   }\n \n-  enum Consumer implements TagConsumer<Span.Builder>, AnnotationConsumer<Span.Builder> {\n+  enum Consumer implements TagConsumer<Builder>, AnnotationConsumer<Builder> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNTUzNg=="}, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 115}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODY1ODQ0OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/handler/MutableSpan.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjoxNjo1MFrOGEd0ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjo0NToxM1rOGEeSIg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNjA5NA==", "bodyText": "If not mistaken, this has been added mainly to support defaultSpan. Since defaultSpan only has three fields specified, it seems like it might be a net-loss to copy all these other default fields when creating a span.", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407336094", "createdAt": "2020-04-13T06:16:50Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -74,113 +83,204 @@\n   ArrayList<Object> annotations;\n   Throwable error;\n \n+  /** @since 5.4 */\n   public MutableSpan() {\n-    // this cheats because it will not need to grow unless there are more than 5 tags\n-    tags = new ArrayList<>();\n-    // lazy initialize annotations\n-  }\n-\n-  /** Returns true if there was no data added. Usually this indicates an instrumentation bug. */\n-  public boolean isEmpty() {\n-    return kind == null\n-      && !shared\n-      && startTimestamp == 0L\n-      && finishTimestamp == 0L\n-      && name == null\n-      && localServiceName == null\n-      && localIp == null\n-      && remoteServiceName == null\n-      && remoteIp == null\n-      && localPort == 0\n-      && remotePort == 0\n-      && tags.isEmpty()\n-      && annotations == null\n-      && error == null;\n-  }\n-\n-  /** Returns the {@link brave.Span#name(String) span name} or null */\n+  }\n+\n+  /** @since 5.12 */\n+  public MutableSpan(MutableSpan toCopy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MzY1MA==", "bodyText": "not exactly but close. empty is checked, so we have to cycle through all state anyway. seems higher leverage to implement equals vs do maintenance on 3 fields that we expect to be the comparison state, yet could drift later for any reason (ex if we implement default tags with MutableSpan later)", "url": "https://github.com/openzipkin/brave/pull/1155#discussion_r407343650", "createdAt": "2020-04-13T06:45:13Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -74,113 +83,204 @@\n   ArrayList<Object> annotations;\n   Throwable error;\n \n+  /** @since 5.4 */\n   public MutableSpan() {\n-    // this cheats because it will not need to grow unless there are more than 5 tags\n-    tags = new ArrayList<>();\n-    // lazy initialize annotations\n-  }\n-\n-  /** Returns true if there was no data added. Usually this indicates an instrumentation bug. */\n-  public boolean isEmpty() {\n-    return kind == null\n-      && !shared\n-      && startTimestamp == 0L\n-      && finishTimestamp == 0L\n-      && name == null\n-      && localServiceName == null\n-      && localIp == null\n-      && remoteServiceName == null\n-      && remoteIp == null\n-      && localPort == 0\n-      && remotePort == 0\n-      && tags.isEmpty()\n-      && annotations == null\n-      && error == null;\n-  }\n-\n-  /** Returns the {@link brave.Span#name(String) span name} or null */\n+  }\n+\n+  /** @since 5.12 */\n+  public MutableSpan(MutableSpan toCopy) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzMzNjA5NA=="}, "originalCommit": {"oid": "a870c0aa8b65e9daf6497797bc27b085304f0c1e"}, "originalPosition": 93}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1650, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}