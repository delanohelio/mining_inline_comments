{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NzQ1MTc0", "number": 1133, "title": "Adds Tag, Tags and HttpTags", "bodyText": "This adds a long overdue feature to ease support of tagging spans. Tag\nbakes in all logic needed to add a tag to a Span, ScopedSpan,\nSpanCustomizer or MutableSpan leaving the user left only to decide\nwhat the key is and how to parse it.\nThis also takes care of error handling and obviation of parsing into a\nno-op span.\nHere's an example of a potentially expensive tag:\nSUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n  @Override protected String parseValue(Summarizer input, TraceContext context) {\n    return input.computeSummary();\n  }\n}\n\n// This works for any variant of span\nSUMMARY_TAG.tag(summarizer, span);\nWe need to solve a common case for BaggageField which is to add that\nas a span tag. This is the best time to fix this problem.\nThe closest type we have is ErrorParser as that does a similar\ndispatch. Externally, the closest is OpenTracing Tag.\nOur approach is different notably as we seal everything except how to\nparse the value. This helps avoid leaking exceptions or accidentally\nadding null values.", "createdAt": "2020-04-01T04:00:50Z", "url": "https://github.com/openzipkin/brave/pull/1133", "merged": true, "mergeCommit": {"oid": "eee993f998ae57b08644cc357a6d478827428710"}, "closed": true, "closedAt": "2020-04-01T07:10:58Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcTQPnjgFqTM4NTI2MDM4MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcTSGg7gFqTM4NTMwODkzMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MjYwMzgx", "url": "https://github.com/openzipkin/brave/pull/1133#pullrequestreview-385260381", "createdAt": "2020-04-01T04:38:00Z", "commit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "state": "APPROVED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNDozODowMFrOF-wjuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNDo0MjoxM1rOF-wnPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MTYwOQ==", "bodyText": "I guess it's either Nullable result or Possibly null result. Though maybe better to phrase something like The result to add as a span tag. {@code null} means no tag will be added.", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401351609", "createdAt": "2020-04-01T04:38:00Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjI5Mg==", "bodyText": "Maybe can leave off these docs at Tags the value parsed from the {@code input}.. The non-null is really a job of parseValue, and there's no way to tag a no-op span anyways, the key point is we don't waste time parsing when it's no-op but that's an implementation detail.", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401352292", "createdAt": "2020-04-01T04:41:10Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA==", "bodyText": "I'm sure it must have been thought no need for detail - any thoughts on a shared interface?", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401352508", "createdAt": "2020-04-01T04:42:13Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null and the {@linkplain ScopedSpan#isNoop() span is not no-op}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, span.context());\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  // ex void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+  public final void tag(I input, TraceContext context, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (context == null) throw new NullPointerException(\"context == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    if (span == NoopSpanCustomizer.INSTANCE) return;\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    TraceContext context = null;\n+    if (span instanceof Span) {\n+      Span asSpan = (Span) span;\n+      if (asSpan.isNoop()) return;\n+      context = asSpan.context();\n+    } else if (span == NoopSpanCustomizer.INSTANCE) {\n+      return;\n+    }\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain MutableSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null.\n+   *\n+   * @see FinishedSpanHandler#handle(TraceContext, MutableSpan)\n+   * @since 5.11\n+   */\n+  public final void tag(I input, TraceContext context, MutableSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, context);\n+  }\n+\n+  final String key;\n+\n+  /** @since 5.11 */\n+  protected Tag(String key) {\n+    this.key = validateNonEmpty(\"key\", key);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + key + \"}\";\n+  }\n+\n+  final void tag(Object span, I input, @Nullable TraceContext context) {\n+    String value;\n+    try {\n+      value = parseValue(input, context);\n+    } catch (Throwable e) {\n+      propagateIfFatal(e);\n+      Platform.get().log(\"Error parsing tag value of input %s\", input, e);\n+      return;\n+    }\n+    if (value == null) return;\n+    if (span instanceof SpanCustomizer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 139}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/4b88cd4bd589b7ae433162c60252d90ec58f09c5", "committedDate": "2020-04-01T04:00:21Z", "message": "Adds Tag, Tags and HttpTags\n\nThis adds a long overdue feature to ease support of tagging spans. `Tag`\nbakes in all logic needed to add a tag to a `Span`, `ScopedSpan`,\n`SpanCustomizer` or `MutableSpan` leaving the user left only to decide\nwhat the key is and how to parse it.\n\nThis also takes care of error handling and obviation of parsing into a\nno-op span.\n\nHere's an example of a potentially expensive tag:\n```java\nSUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n  @Override protected String parseValue(Summarizer input, TraceContext context) {\n    return input.computeSummary();\n  }\n}\n\n// This works for any variant of span\nSUMMARY_TAG.tag(summarizer, span);\n```\n\nWe need to solve a common case for `BaggageField` which is to add that\nas a span tag. This is the best time to fix this problem.\n\nThe closest type we have is `ErrorParser` as that does a similar\ndispatch. Externally, the closest is [OpenTracing Tag](https://github.com/opentracing/opentracing-java/blob/master/opentracing-api/src/main/java/io/opentracing/tag/Tag.java).\n\nOur approach is different notably as we seal everything except how to\nparse the value. This helps avoid leaking exceptions or accidentally\nadding null values."}, "afterCommit": {"oid": "63033a81b5ba02c2d60eacf1851672020ed10b7a", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/63033a81b5ba02c2d60eacf1851672020ed10b7a", "committedDate": "2020-04-01T05:58:38Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "82c81817ed490b0f4e16760bd62fbce33540eeb7", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/82c81817ed490b0f4e16760bd62fbce33540eeb7", "committedDate": "2020-04-01T06:38:49Z", "message": "Adds Tag, Tags and HttpTags\n\nThis adds a long overdue feature to ease support of tagging spans. `Tag`\nbakes in all logic needed to add a tag to a `Span`, `ScopedSpan`,\n`SpanCustomizer` or `MutableSpan` leaving the user left only to decide\nwhat the key is and how to parse it.\n\nThis also takes care of error handling and obviation of parsing into a\nno-op span.\n\nHere's an example of a potentially expensive tag:\n```java\nSUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n  @Override protected String parseValue(Summarizer input, TraceContext context) {\n    return input.computeSummary();\n  }\n}\n\n// This works for any variant of span\nSUMMARY_TAG.tag(summarizer, span);\n```\n\nWe need to solve a common case for `BaggageField` which is to add that\nas a span tag. This is the best time to fix this problem.\n\nThe closest type we have is `ErrorParser` as that does a similar\ndispatch. Externally, the closest is [OpenTracing Tag](https://github.com/opentracing/opentracing-java/blob/master/opentracing-api/src/main/java/io/opentracing/tag/Tag.java).\n\nOur approach is different notably as we seal everything except how to\nparse the value. This helps avoid leaking exceptions or accidentally\nadding null values."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "committedDate": "2020-04-01T06:43:53Z", "message": "feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "63033a81b5ba02c2d60eacf1851672020ed10b7a", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/63033a81b5ba02c2d60eacf1851672020ed10b7a", "committedDate": "2020-04-01T05:58:38Z", "message": "feedback"}, "afterCommit": {"oid": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/43119912aa9f69a78251eb0fd5109d8ac4a5b9ac", "committedDate": "2020-04-01T06:43:53Z", "message": "feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MzAzNzM4", "url": "https://github.com/openzipkin/brave/pull/1133#pullrequestreview-385303738", "createdAt": "2020-04-01T06:45:38Z", "commit": {"oid": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNjo0NTozOFrOF-y29g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNjo0NTozOFrOF-y29g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4OTMwMg==", "bodyText": "I left these overloads to help reduce branching to get noop", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401389302", "createdAt": "2020-04-01T06:45:38Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return The result to add as a span tag. {@code null} means no tag will be added. Note: empty\n+   * string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * Tags the value parsed from the {@code input}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac"}, "originalPosition": 63}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MzA4OTMy", "url": "https://github.com/openzipkin/brave/pull/1133#pullrequestreview-385308932", "createdAt": "2020-04-01T06:56:03Z", "commit": {"oid": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1910, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}