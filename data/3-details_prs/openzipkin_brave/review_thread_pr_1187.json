{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyNTg5MDQz", "number": 1187, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMTozNjo0MlrOD4wyJA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMjozMjo0NVrOD41qCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwODQ2MTE2OnYy", "diffSide": "RIGHT", "path": "brave/RATIONALE.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMTozNjo0MlrOGPrQQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMTozNjo0MlrOGPrQQA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5MDQ5Ng==", "bodyText": "this was just moved", "url": "https://github.com/openzipkin/brave/pull/1187#discussion_r419090496", "createdAt": "2020-05-03T11:36:42Z", "author": {"login": "codefromthecrypt"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -228,6 +228,101 @@ implementations proposed in these papers are different to the implementation\n here, but conceptually the goal is the same: to propagate \"arbitrary stuff\"\n with a request.\n \n+### Context storage\n+`FixedBaggageState` is copy-on-write context storage of `BaggageField` values.\n+It is added only once to a request extraction or trace context regardless of\n+the count of fields.\n+\n+Copy-on-write means a call to `BaggageField.updateValue` will replace its\n+internal state with a copy of the prior (usually the parent). Until an update\n+occurs (possibly never!), a constant `initialState` is shared by all trace\n+contexts. In other words, if baggage is configured, but never used, the only\n+overhead is one state wrapper (`FixedBaggageState`) per `TraceContext`. If\n+only one context has a change in that local root, then only one copy of the\n+state is made.\n+\n+Put short the copy-on-write aspect limits overhead under the assumption that\n+changes to `BaggageField` values are infrequent. We believe this assumption\n+holds due to practice. For example, common baggage are immutable after parsing\n+a request, such as request ID, country code, device ID, etc.\n+\n+#### Internal state is an `Object[]`\n+`BaggageField` values are `String`, so to hold state means an association of\n+some kind between `BaggageField` and a single `String` value. Updates to\n+baggage are generally infrequent, sometimes never, and many times only when\n+extracting headers from a request. As such, we choose pair-wise layout in an\n+object array (`Object[]`).\n+\n+To remind, pair-wise means an association `{k1=v1, k2=v2}` is laid out in an\n+array as `[k1, v1, k2, v2]`. The size of the association is `array.length/2`.\n+Retrieving a value means finding the key's index and returning `array[i+1]`\n+\n+In our specific case, we add `null` values for all known fields. For example,\n+if `BaggageConfiguration` is initialized with fields countryCode and deviceId,\n+the initial state array is `[countryCode, null, deviceId, null]`\n+\n+Retaining fields even when `null` allows among many things, the following:\n+* Queries for all potential field names (remote propagation)\n+* Constant time index lookup of predefined fields.\n+\n+In practice, we use a constant `HashMap` to find the index of a predefined\n+fields. This is how we achieve constant time index lookup, while also keeping\n+iteration performance of an array!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6b6035c7944d7dba926cb395472abec1f63d849"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwODQ2MTQ5OnYy", "diffSide": "RIGHT", "path": "brave/RATIONALE.md", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMTozNzoxOFrOGPrQcw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMTozNzoxOFrOGPrQcw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5MDU0Nw==", "bodyText": "This also was just moved (I moved them as I noticed we already had a baggage heading!", "url": "https://github.com/openzipkin/brave/pull/1187#discussion_r419090547", "createdAt": "2020-05-03T11:37:18Z", "author": {"login": "codefromthecrypt"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -228,6 +228,101 @@ implementations proposed in these papers are different to the implementation\n here, but conceptually the goal is the same: to propagate \"arbitrary stuff\"\n with a request.\n \n+### Context storage\n+`FixedBaggageState` is copy-on-write context storage of `BaggageField` values.\n+It is added only once to a request extraction or trace context regardless of\n+the count of fields.\n+\n+Copy-on-write means a call to `BaggageField.updateValue` will replace its\n+internal state with a copy of the prior (usually the parent). Until an update\n+occurs (possibly never!), a constant `initialState` is shared by all trace\n+contexts. In other words, if baggage is configured, but never used, the only\n+overhead is one state wrapper (`FixedBaggageState`) per `TraceContext`. If\n+only one context has a change in that local root, then only one copy of the\n+state is made.\n+\n+Put short the copy-on-write aspect limits overhead under the assumption that\n+changes to `BaggageField` values are infrequent. We believe this assumption\n+holds due to practice. For example, common baggage are immutable after parsing\n+a request, such as request ID, country code, device ID, etc.\n+\n+#### Internal state is an `Object[]`\n+`BaggageField` values are `String`, so to hold state means an association of\n+some kind between `BaggageField` and a single `String` value. Updates to\n+baggage are generally infrequent, sometimes never, and many times only when\n+extracting headers from a request. As such, we choose pair-wise layout in an\n+object array (`Object[]`).\n+\n+To remind, pair-wise means an association `{k1=v1, k2=v2}` is laid out in an\n+array as `[k1, v1, k2, v2]`. The size of the association is `array.length/2`.\n+Retrieving a value means finding the key's index and returning `array[i+1]`\n+\n+In our specific case, we add `null` values for all known fields. For example,\n+if `BaggageConfiguration` is initialized with fields countryCode and deviceId,\n+the initial state array is `[countryCode, null, deviceId, null]`\n+\n+Retaining fields even when `null` allows among many things, the following:\n+* Queries for all potential field names (remote propagation)\n+* Constant time index lookup of predefined fields.\n+\n+In practice, we use a constant `HashMap` to find the index of a predefined\n+fields. This is how we achieve constant time index lookup, while also keeping\n+iteration performance of an array!\n+\n+### Encoding and decoding baggage from remote fields\n+\n+`BaggageCodec` handles encoding and decoding of baggage fields for remote\n+propagation. There are some subtle points easy to miss about the design.\n+\n+* Decode is called before a trace context exists, so there's no `context` parameter.\n+  * First successful decode returns `true`.\n+    * This allows us to prioritize and leniently read, multiple header names.\n+  * The `ValueUpdater` parameter allows us to hide or mute context storage\n+    * We considered `Propagation.Setter`, but it doesn't return boolean\n+  * The `request` parameter allows secondary sampling to use `SamplerFunction` on inbound requests.\n+  * The `value` parameter could be a delimited string, or a plain value to set.\n+\n+* Encode is called only when a baggage exists and isn't all redacted\n+  * The `Map<String, String>` parameter allows implementations to encode all\n+    baggage in one string.\n+  * The `context` parameter allows `BaggageField.getValue` in simple case (more\n+    efficient than map).\n+    * The `context` parameter also allows secondary sampling to write down the\n+      `spanId`\n+  * The `request` parameter allows secondary sampling to use `SamplerFunction`\n+    on outbound requests.\n+\n+#### Why does decode not accept a Map?\n+When looking at the encode vs decode side, it might seem curious why they don't\n+both implement `Map`. `Map` is definitely needed on the encode side, as it\n+supports encoding all baggage in a single header. While decoding one header can\n+result in multiple baggage fields, the code to accomplish that is as easy with\n+a map as a functional interface. It is also easier for the baggage code to\n+implement a function over `BaggageField.updateValue` vs try to implement the\n+entire write side of `Map`.\n+\n+### `Map` views over `BaggageField` values\n+As `Map` is a standard type, it is a safer type to expose to consumers of all\n+baggage fields. We decided to use an unmodifiable `Map` instead of an internal\n+type for use cases such as coalescing all baggage into a single header. This\n+map must also hide local fields from propagation.\n+\n+#### Why not a standard `Map` type\n+We considered copying the internal state array to an existing `Map` type, such\n+as `LinkedHashMap`. However, doing so would add overhead regardless of it that\n+`Map` was ever used, or if that map had a value for the field the consumer was\n+interested in! Concretely, we'd pay to create the map, to copy the values in\n+the array into it, and also pay implicit cost of iterator allocation for\n+operations such as `entrySet()` even if the entry desired was not present. This\n+holds present even extending `AbstractMap`, as most operations, even `get()`\n+allocate iterators.\n+\n+#### `UnsafeArrayMap`\n+We created `UnsafeArrayMap` as a view over our pair-wise internal state array.\n+The implementation is very simple except that we have a redaction use case to\n+address, which implies filtering keys. To address that, we keep a bitmap of all\n+filtered keys and consider that when performing any scan operations.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6b6035c7944d7dba926cb395472abec1f63d849"}, "originalPosition": 97}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwODQ2MTgyOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/internal/baggage/ExtraBaggageFields.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMTozNzo1M1rOGPrQpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wM1QxMTozNzo1M1rOGPrQpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTA5MDU5Ng==", "bodyText": "notice only change is @Override", "url": "https://github.com/openzipkin/brave/pull/1187#discussion_r419090596", "createdAt": "2020-05-03T11:37:53Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/baggage/ExtraBaggageFields.java", "diffHunk": "@@ -69,16 +69,7 @@ public boolean isDynamic() {\n     return internal.getValue(field);\n   }\n \n-  /**\n-   * Updates a state object to include a value change.\n-   *\n-   * @param field the field that was updated\n-   * @param value {@code null} means remove the mapping to this field.\n-   * @return true implies a a change in the underlying state\n-   * @see BaggageField#updateValue(TraceContext, String)\n-   * @see BaggageField#updateValue(TraceContextOrSamplingFlags, String)\n-   */\n-  public boolean updateValue(BaggageField field, @Nullable String value) {\n+  @Override public boolean updateValue(BaggageField field, @Nullable String value) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f6b6035c7944d7dba926cb395472abec1f63d849"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTE4MTExOnYy", "diffSide": "RIGHT", "path": "brave/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDo1NDo0NlrOGPw3zQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDo1NDo0NlrOGPw3zQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE4MjU0MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              * The `ValueUpdater parameter allows us to safely collect values from\n          \n          \n            \n              * The `ValueUpdater` parameter allows us to safely collect values from", "url": "https://github.com/openzipkin/brave/pull/1187#discussion_r419182541", "createdAt": "2020-05-04T00:54:46Z", "author": {"login": "codefromthecrypt"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -228,6 +228,199 @@ implementations proposed in these papers are different to the implementation\n here, but conceptually the goal is the same: to propagate \"arbitrary stuff\"\n with a request.\n \n+### `BaggageField.ValueUpdater`\n+`BaggageField.ValueUpdater` is a functional interface that allows field\n+updates, possibly to `null`. It returns a `boolean` to avoid synchronizing\n+contexts when an update resulted in no change.\n+\n+Concretely, when an update returns `false`, we don't attempt to flush changes\n+to a correlation context such as `MDC`.\n+\n+### Context storage\n+`FixedBaggageState` is copy-on-write context storage of `BaggageField` values.\n+It is added only once to a request extraction or trace context regardless of\n+the count of fields.\n+\n+Copy-on-write means a call to `BaggageField.updateValue` will replace its\n+internal state with a copy of the prior (usually the parent). Until an update\n+occurs (possibly never!), a constant `initialState` is shared by all trace\n+contexts. In other words, if baggage is configured, but never used, the only\n+overhead is one state wrapper (`FixedBaggageState`) per `TraceContext`. If\n+only one context has a change in that local root, then only one copy of the\n+state is made.\n+\n+Put short the copy-on-write aspect limits overhead under the assumption that\n+changes to `BaggageField` values are infrequent. We believe this assumption\n+holds due to practice. For example, common baggage are immutable after parsing\n+a request, such as request ID, country code, device ID, etc.\n+\n+#### Internal state is an `Object[]`\n+`BaggageField` values are `String`, so to hold state means an association of\n+some kind between `BaggageField` and a single `String` value. Updates to\n+baggage are generally infrequent, sometimes never, and many times only when\n+extracting headers from a request. As such, we choose pair-wise layout in an\n+object array (`Object[]`).\n+\n+To remind, pair-wise means an association `{k1=v1, k2=v2}` is laid out in an\n+array as `[k1, v1, k2, v2]`. The size of the association is `array.length/2`.\n+Retrieving a value means finding the key's index and returning `array[i+1]`\n+\n+In our specific case, we add `null` values for all known fields. For example,\n+if `BaggageConfiguration` is initialized with fields countryCode and deviceId,\n+the initial state array is `[countryCode, null, deviceId, null]`\n+\n+Retaining fields even when `null` allows among many things, the following:\n+* Queries for all potential field names (remote propagation)\n+* Constant time index lookup of predefined fields.\n+\n+In practice, we use a constant `HashMap` to find the index of a predefined\n+fields. This is how we achieve constant time index lookup, while also keeping\n+iteration performance of an array!\n+\n+### `BaggageField.ValueUpdater`\n+`BaggageField.ValueUpdater` is a functional interface that allows field\n+updates, possibly to `null`.\n+\n+It returns a `boolean` to inform callers an update was ignored, which can\n+happen when the value didn't change or the field is disallowed. We use this to\n+avoid unnecessary overhead when flushing changes to `MDC`.\n+\n+Being a functional interface, it is also safer to use when exposing state to\n+outside callers. For example, we can provide a write view over a mutable array,\n+and decouple that connection when decoding completes.\n+\n+### Encoding and decoding baggage from remote fields\n+\n+`BaggageCodec` handles encoding and decoding of baggage fields for remote\n+propagation. There are some subtle points easy to miss about the design.\n+\n+* Decode is called before a trace context exists, hence no `context` parameter.\n+  * First successful decode returns `true`.\n+    * This allows us to prioritize and leniently read, multiple header names.\n+  * The `ValueUpdater parameter allows us to safely collect values from", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "469b8ce7cef12fa37e753089c9511fc0bd2e28ec"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTE4MjU1OnYy", "diffSide": "RIGHT", "path": "brave/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDo1NjozOFrOGPw4hA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDo1NjozOFrOGPw4hA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE4MjcyNA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              more safe underneath to not expose read-ops, such as iterators.\n          \n          \n            \n              more safe underneath to prevent read-ops, such as iterators.", "url": "https://github.com/openzipkin/brave/pull/1187#discussion_r419182724", "createdAt": "2020-05-04T00:56:38Z", "author": {"login": "codefromthecrypt"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -228,6 +228,199 @@ implementations proposed in these papers are different to the implementation\n here, but conceptually the goal is the same: to propagate \"arbitrary stuff\"\n with a request.\n \n+### `BaggageField.ValueUpdater`\n+`BaggageField.ValueUpdater` is a functional interface that allows field\n+updates, possibly to `null`. It returns a `boolean` to avoid synchronizing\n+contexts when an update resulted in no change.\n+\n+Concretely, when an update returns `false`, we don't attempt to flush changes\n+to a correlation context such as `MDC`.\n+\n+### Context storage\n+`FixedBaggageState` is copy-on-write context storage of `BaggageField` values.\n+It is added only once to a request extraction or trace context regardless of\n+the count of fields.\n+\n+Copy-on-write means a call to `BaggageField.updateValue` will replace its\n+internal state with a copy of the prior (usually the parent). Until an update\n+occurs (possibly never!), a constant `initialState` is shared by all trace\n+contexts. In other words, if baggage is configured, but never used, the only\n+overhead is one state wrapper (`FixedBaggageState`) per `TraceContext`. If\n+only one context has a change in that local root, then only one copy of the\n+state is made.\n+\n+Put short the copy-on-write aspect limits overhead under the assumption that\n+changes to `BaggageField` values are infrequent. We believe this assumption\n+holds due to practice. For example, common baggage are immutable after parsing\n+a request, such as request ID, country code, device ID, etc.\n+\n+#### Internal state is an `Object[]`\n+`BaggageField` values are `String`, so to hold state means an association of\n+some kind between `BaggageField` and a single `String` value. Updates to\n+baggage are generally infrequent, sometimes never, and many times only when\n+extracting headers from a request. As such, we choose pair-wise layout in an\n+object array (`Object[]`).\n+\n+To remind, pair-wise means an association `{k1=v1, k2=v2}` is laid out in an\n+array as `[k1, v1, k2, v2]`. The size of the association is `array.length/2`.\n+Retrieving a value means finding the key's index and returning `array[i+1]`\n+\n+In our specific case, we add `null` values for all known fields. For example,\n+if `BaggageConfiguration` is initialized with fields countryCode and deviceId,\n+the initial state array is `[countryCode, null, deviceId, null]`\n+\n+Retaining fields even when `null` allows among many things, the following:\n+* Queries for all potential field names (remote propagation)\n+* Constant time index lookup of predefined fields.\n+\n+In practice, we use a constant `HashMap` to find the index of a predefined\n+fields. This is how we achieve constant time index lookup, while also keeping\n+iteration performance of an array!\n+\n+### `BaggageField.ValueUpdater`\n+`BaggageField.ValueUpdater` is a functional interface that allows field\n+updates, possibly to `null`.\n+\n+It returns a `boolean` to inform callers an update was ignored, which can\n+happen when the value didn't change or the field is disallowed. We use this to\n+avoid unnecessary overhead when flushing changes to `MDC`.\n+\n+Being a functional interface, it is also safer to use when exposing state to\n+outside callers. For example, we can provide a write view over a mutable array,\n+and decouple that connection when decoding completes.\n+\n+### Encoding and decoding baggage from remote fields\n+\n+`BaggageCodec` handles encoding and decoding of baggage fields for remote\n+propagation. There are some subtle points easy to miss about the design.\n+\n+* Decode is called before a trace context exists, hence no `context` parameter.\n+  * First successful decode returns `true`.\n+    * This allows us to prioritize and leniently read, multiple header names.\n+  * The `ValueUpdater` parameter allows us to safely collect values from\n+    multiple contributors.\n+  * The `request` parameter allows secondary sampling to use `SamplerFunction`\n+    on inbound requests.\n+  * The `value` parameter could be a delimited string, or a plain value to set.\n+\n+* Encode is called only when a baggage exists and isn't all redacted\n+  * The `Map<String, String>` parameter allows implementations to encode all\n+    baggage in one string.\n+    * Not `Map<BaggageField, String>` as we checked all implementations only\n+      read the field name and non-null values.\n+  * The `context` parameter allows `BaggageField.getValue` in simple case (more\n+    efficient than map).\n+    * The `context` parameter also allows secondary sampling to write down the\n+      `spanId`\n+  * The `request` parameter allows secondary sampling to use `SamplerFunction`\n+    on outbound requests.\n+\n+#### Why not decode into a Map?\n+When looking at the encode vs decode side, it might seem curious why they don't\n+both implement `Map`. `Map` is helpful on the encode side. For example,\n+implementing  single-header encoding, is easier this way.\n+\n+```java\n+joiner = Joiner.on(',').withKeyValueSeparator('=');\n+\n+String encoded = joiner.join(baggageValues);\n+```\n+\n+On the read side, the above iteration is stable because the underlying state is\n+immutable. There's no chance of a concurrent modification or otherwise\n+corrupting the encoded value. This applies even when the implementation ignores\n+the documentation and holds a reference to the map after encoding.\n+\n+The reverse isn't true. Decoding has different concerns entirely.\n+* `BaggageField` instances are typically constant, so updates should be a\n+  function of `BaggageField`, not String.\n+* There may be multiple decoders contributing to the same baggage state. It is\n+  more safe underneath to not expose read-ops, such as iterators.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "52ae02375cebfcb89a73560c46b3b3e791b5230b"}, "originalPosition": 111}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTE4MzMxOnYy", "diffSide": "RIGHT", "path": "brave/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDo1Nzo0M1rOGPw48Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDo1Nzo0M1rOGPw48Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE4MjgzMw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            In practice, encoding formats typically have rules that splitters libraries\n          \n          \n            \n            In practice, encoding formats typically have rules that splitter libraries", "url": "https://github.com/openzipkin/brave/pull/1187#discussion_r419182833", "createdAt": "2020-05-04T00:57:43Z", "author": {"login": "codefromthecrypt"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -228,6 +228,199 @@ implementations proposed in these papers are different to the implementation\n here, but conceptually the goal is the same: to propagate \"arbitrary stuff\"\n with a request.\n \n+### `BaggageField.ValueUpdater`\n+`BaggageField.ValueUpdater` is a functional interface that allows field\n+updates, possibly to `null`. It returns a `boolean` to avoid synchronizing\n+contexts when an update resulted in no change.\n+\n+Concretely, when an update returns `false`, we don't attempt to flush changes\n+to a correlation context such as `MDC`.\n+\n+### Context storage\n+`FixedBaggageState` is copy-on-write context storage of `BaggageField` values.\n+It is added only once to a request extraction or trace context regardless of\n+the count of fields.\n+\n+Copy-on-write means a call to `BaggageField.updateValue` will replace its\n+internal state with a copy of the prior (usually the parent). Until an update\n+occurs (possibly never!), a constant `initialState` is shared by all trace\n+contexts. In other words, if baggage is configured, but never used, the only\n+overhead is one state wrapper (`FixedBaggageState`) per `TraceContext`. If\n+only one context has a change in that local root, then only one copy of the\n+state is made.\n+\n+Put short the copy-on-write aspect limits overhead under the assumption that\n+changes to `BaggageField` values are infrequent. We believe this assumption\n+holds due to practice. For example, common baggage are immutable after parsing\n+a request, such as request ID, country code, device ID, etc.\n+\n+#### Internal state is an `Object[]`\n+`BaggageField` values are `String`, so to hold state means an association of\n+some kind between `BaggageField` and a single `String` value. Updates to\n+baggage are generally infrequent, sometimes never, and many times only when\n+extracting headers from a request. As such, we choose pair-wise layout in an\n+object array (`Object[]`).\n+\n+To remind, pair-wise means an association `{k1=v1, k2=v2}` is laid out in an\n+array as `[k1, v1, k2, v2]`. The size of the association is `array.length/2`.\n+Retrieving a value means finding the key's index and returning `array[i+1]`\n+\n+In our specific case, we add `null` values for all known fields. For example,\n+if `BaggageConfiguration` is initialized with fields countryCode and deviceId,\n+the initial state array is `[countryCode, null, deviceId, null]`\n+\n+Retaining fields even when `null` allows among many things, the following:\n+* Queries for all potential field names (remote propagation)\n+* Constant time index lookup of predefined fields.\n+\n+In practice, we use a constant `HashMap` to find the index of a predefined\n+fields. This is how we achieve constant time index lookup, while also keeping\n+iteration performance of an array!\n+\n+### `BaggageField.ValueUpdater`\n+`BaggageField.ValueUpdater` is a functional interface that allows field\n+updates, possibly to `null`.\n+\n+It returns a `boolean` to inform callers an update was ignored, which can\n+happen when the value didn't change or the field is disallowed. We use this to\n+avoid unnecessary overhead when flushing changes to `MDC`.\n+\n+Being a functional interface, it is also safer to use when exposing state to\n+outside callers. For example, we can provide a write view over a mutable array,\n+and decouple that connection when decoding completes.\n+\n+### Encoding and decoding baggage from remote fields\n+\n+`BaggageCodec` handles encoding and decoding of baggage fields for remote\n+propagation. There are some subtle points easy to miss about the design.\n+\n+* Decode is called before a trace context exists, hence no `context` parameter.\n+  * First successful decode returns `true`.\n+    * This allows us to prioritize and leniently read, multiple header names.\n+  * The `ValueUpdater` parameter allows us to safely collect values from\n+    multiple contributors.\n+  * The `request` parameter allows secondary sampling to use `SamplerFunction`\n+    on inbound requests.\n+  * The `value` parameter could be a delimited string, or a plain value to set.\n+\n+* Encode is called only when a baggage exists and isn't all redacted\n+  * The `Map<String, String>` parameter allows implementations to encode all\n+    baggage in one string.\n+    * Not `Map<BaggageField, String>` as we checked all implementations only\n+      read the field name and non-null values.\n+  * The `context` parameter allows `BaggageField.getValue` in simple case (more\n+    efficient than map).\n+    * The `context` parameter also allows secondary sampling to write down the\n+      `spanId`\n+  * The `request` parameter allows secondary sampling to use `SamplerFunction`\n+    on outbound requests.\n+\n+#### Why not decode into a Map?\n+When looking at the encode vs decode side, it might seem curious why they don't\n+both implement `Map`. `Map` is helpful on the encode side. For example,\n+implementing  single-header encoding, is easier this way.\n+\n+```java\n+joiner = Joiner.on(',').withKeyValueSeparator('=');\n+\n+String encoded = joiner.join(baggageValues);\n+```\n+\n+On the read side, the above iteration is stable because the underlying state is\n+immutable. There's no chance of a concurrent modification or otherwise\n+corrupting the encoded value. This applies even when the implementation ignores\n+the documentation and holds a reference to the map after encoding.\n+\n+The reverse isn't true. Decoding has different concerns entirely.\n+* `BaggageField` instances are typically constant, so updates should be a\n+  function of `BaggageField`, not String.\n+* There may be multiple decoders contributing to the same baggage state. It is\n+  more safe underneath to prevent read-ops, such as iterators.\n+* If we used a `Map`, implementations who ignore the documentation and hold a\n+  reference to it could later corrupt the state, violating copy-on-write.\n+  * defending against this is possible, but inefficient and distracting code.\n+\n+It is true that there are tools that can split common data structures into a\n+map. To do the same with another function could seem annoying.\n+\n+Ex.\n+```java\n+splitter = Splitter.on(',').withKeyValueSeparator('=');\n+\n+values = splitter.split(encoded);\n+```\n+\n+However, if you look above, this assumes the key type is `String`. Such an\n+implementation would still need to loop over the result, possibly reuse an\n+existing `BaggageField`, then .. copy into the correct map!\n+\n+Ex.\n+```java\n+splitter = Splitter.on(',').withKeyValueSeparator('=');\n+\n+...\n+for (Entry<String, String> entry: splitter.split(encoded).entrySet()) {\n+  BaggageField field = lookupOrCreateField(entry.getKey());\n+  baggageValues.put(field, entry.getValue());\n+}\n+```\n+\n+When put in this view, it isn't much different than just using `ValueUpdater`.\n+Ex.\n+```java\n+splitter = Splitter.on(',').withKeyValueSeparator('=');\n+\n+...\n+for (Entry<String, String> entry: splitter.split(encoded).entrySet()) {\n+  BaggageField field = lookupOrCreateField(entry.getKey());\n+  valueUpdater.updateValue(field, entry.getValue());\n+}\n+```\n+\n+A closing point is that the above splitter example is contrived, mainly to show\n+a design weakness in not choosing map.\n+\n+In practice, encoding formats typically have rules that splitters libraries", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9f1c3e0d1a4132941a42fefd662b7ae8b8707f14"}, "originalPosition": 156}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTE4MzY5OnYy", "diffSide": "RIGHT", "path": "brave/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDo1ODoxNlrOGPw5KQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMDo1ODoxNlrOGPw5KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE4Mjg4OQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            handle bad data. In general, it is better to assume a format-specific encoder\n          \n          \n            \n            handle bad data. In general, it is better to assume a format-specific decoder", "url": "https://github.com/openzipkin/brave/pull/1187#discussion_r419182889", "createdAt": "2020-05-04T00:58:16Z", "author": {"login": "codefromthecrypt"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -228,6 +228,199 @@ implementations proposed in these papers are different to the implementation\n here, but conceptually the goal is the same: to propagate \"arbitrary stuff\"\n with a request.\n \n+### `BaggageField.ValueUpdater`\n+`BaggageField.ValueUpdater` is a functional interface that allows field\n+updates, possibly to `null`. It returns a `boolean` to avoid synchronizing\n+contexts when an update resulted in no change.\n+\n+Concretely, when an update returns `false`, we don't attempt to flush changes\n+to a correlation context such as `MDC`.\n+\n+### Context storage\n+`FixedBaggageState` is copy-on-write context storage of `BaggageField` values.\n+It is added only once to a request extraction or trace context regardless of\n+the count of fields.\n+\n+Copy-on-write means a call to `BaggageField.updateValue` will replace its\n+internal state with a copy of the prior (usually the parent). Until an update\n+occurs (possibly never!), a constant `initialState` is shared by all trace\n+contexts. In other words, if baggage is configured, but never used, the only\n+overhead is one state wrapper (`FixedBaggageState`) per `TraceContext`. If\n+only one context has a change in that local root, then only one copy of the\n+state is made.\n+\n+Put short the copy-on-write aspect limits overhead under the assumption that\n+changes to `BaggageField` values are infrequent. We believe this assumption\n+holds due to practice. For example, common baggage are immutable after parsing\n+a request, such as request ID, country code, device ID, etc.\n+\n+#### Internal state is an `Object[]`\n+`BaggageField` values are `String`, so to hold state means an association of\n+some kind between `BaggageField` and a single `String` value. Updates to\n+baggage are generally infrequent, sometimes never, and many times only when\n+extracting headers from a request. As such, we choose pair-wise layout in an\n+object array (`Object[]`).\n+\n+To remind, pair-wise means an association `{k1=v1, k2=v2}` is laid out in an\n+array as `[k1, v1, k2, v2]`. The size of the association is `array.length/2`.\n+Retrieving a value means finding the key's index and returning `array[i+1]`\n+\n+In our specific case, we add `null` values for all known fields. For example,\n+if `BaggageConfiguration` is initialized with fields countryCode and deviceId,\n+the initial state array is `[countryCode, null, deviceId, null]`\n+\n+Retaining fields even when `null` allows among many things, the following:\n+* Queries for all potential field names (remote propagation)\n+* Constant time index lookup of predefined fields.\n+\n+In practice, we use a constant `HashMap` to find the index of a predefined\n+fields. This is how we achieve constant time index lookup, while also keeping\n+iteration performance of an array!\n+\n+### `BaggageField.ValueUpdater`\n+`BaggageField.ValueUpdater` is a functional interface that allows field\n+updates, possibly to `null`.\n+\n+It returns a `boolean` to inform callers an update was ignored, which can\n+happen when the value didn't change or the field is disallowed. We use this to\n+avoid unnecessary overhead when flushing changes to `MDC`.\n+\n+Being a functional interface, it is also safer to use when exposing state to\n+outside callers. For example, we can provide a write view over a mutable array,\n+and decouple that connection when decoding completes.\n+\n+### Encoding and decoding baggage from remote fields\n+\n+`BaggageCodec` handles encoding and decoding of baggage fields for remote\n+propagation. There are some subtle points easy to miss about the design.\n+\n+* Decode is called before a trace context exists, hence no `context` parameter.\n+  * First successful decode returns `true`.\n+    * This allows us to prioritize and leniently read, multiple header names.\n+  * The `ValueUpdater` parameter allows us to safely collect values from\n+    multiple contributors.\n+  * The `request` parameter allows secondary sampling to use `SamplerFunction`\n+    on inbound requests.\n+  * The `value` parameter could be a delimited string, or a plain value to set.\n+\n+* Encode is called only when a baggage exists and isn't all redacted\n+  * The `Map<String, String>` parameter allows implementations to encode all\n+    baggage in one string.\n+    * Not `Map<BaggageField, String>` as we checked all implementations only\n+      read the field name and non-null values.\n+  * The `context` parameter allows `BaggageField.getValue` in simple case (more\n+    efficient than map).\n+    * The `context` parameter also allows secondary sampling to write down the\n+      `spanId`\n+  * The `request` parameter allows secondary sampling to use `SamplerFunction`\n+    on outbound requests.\n+\n+#### Why not decode into a Map?\n+When looking at the encode vs decode side, it might seem curious why they don't\n+both implement `Map`. `Map` is helpful on the encode side. For example,\n+implementing  single-header encoding, is easier this way.\n+\n+```java\n+joiner = Joiner.on(',').withKeyValueSeparator('=');\n+\n+String encoded = joiner.join(baggageValues);\n+```\n+\n+On the read side, the above iteration is stable because the underlying state is\n+immutable. There's no chance of a concurrent modification or otherwise\n+corrupting the encoded value. This applies even when the implementation ignores\n+the documentation and holds a reference to the map after encoding.\n+\n+The reverse isn't true. Decoding has different concerns entirely.\n+* `BaggageField` instances are typically constant, so updates should be a\n+  function of `BaggageField`, not String.\n+* There may be multiple decoders contributing to the same baggage state. It is\n+  more safe underneath to prevent read-ops, such as iterators.\n+* If we used a `Map`, implementations who ignore the documentation and hold a\n+  reference to it could later corrupt the state, violating copy-on-write.\n+  * defending against this is possible, but inefficient and distracting code.\n+\n+It is true that there are tools that can split common data structures into a\n+map. To do the same with another function could seem annoying.\n+\n+Ex.\n+```java\n+splitter = Splitter.on(',').withKeyValueSeparator('=');\n+\n+values = splitter.split(encoded);\n+```\n+\n+However, if you look above, this assumes the key type is `String`. Such an\n+implementation would still need to loop over the result, possibly reuse an\n+existing `BaggageField`, then .. copy into the correct map!\n+\n+Ex.\n+```java\n+splitter = Splitter.on(',').withKeyValueSeparator('=');\n+\n+...\n+for (Entry<String, String> entry: splitter.split(encoded).entrySet()) {\n+  BaggageField field = lookupOrCreateField(entry.getKey());\n+  baggageValues.put(field, entry.getValue());\n+}\n+```\n+\n+When put in this view, it isn't much different than just using `ValueUpdater`.\n+Ex.\n+```java\n+splitter = Splitter.on(',').withKeyValueSeparator('=');\n+\n+...\n+for (Entry<String, String> entry: splitter.split(encoded).entrySet()) {\n+  BaggageField field = lookupOrCreateField(entry.getKey());\n+  valueUpdater.updateValue(field, entry.getValue());\n+}\n+```\n+\n+A closing point is that the above splitter example is contrived, mainly to show\n+a design weakness in not choosing map.\n+\n+In practice, encoding formats typically have rules that splitter libraries\n+weren't written for. These include limits, character set constraints, etc.\n+Decoding a format is always harder than encoding due to rules about how to\n+handle bad data. In general, it is better to assume a format-specific encoder", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "04043d20d1c0dcac1daad10baeb0dc838c5b00c8"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwOTI1OTYxOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/baggage/BaggageField.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMjozMjo0NVrOGPxjgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNFQwMjozMjo0NVrOGPxjgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTE5MzczMQ==", "bodyText": "Override toString too?", "url": "https://github.com/openzipkin/brave/pull/1187#discussion_r419193731", "createdAt": "2020-05-04T02:32:45Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/baggage/BaggageField.java", "diffHunk": "@@ -101,6 +101,31 @@\n  * @since 5.11\n  */\n public final class BaggageField {\n+  /**\n+   * Used to decouple baggage value updates from {@link TraceContext} or {@link\n+   * TraceContextOrSamplingFlags} storage.\n+   *\n+   * @since 5.12\n+   */\n+  public interface ValueUpdater {\n+    /** @since 5.12 */\n+    ValueUpdater NOOP = new ValueUpdater() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f4db647004e35ee05214105f45b86dd124a6e525"}, "originalPosition": 12}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1408, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}