{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyMTM2MTk1", "number": 1149, "title": "Ensures currentSpan, toSpan and joinSpan use existing context references", "bodyText": "Before, Tracer.currentSpan, toSpan and joinSpan either didn't\ndecorate external contexts (in no-op) or needlessly recreated context\ninstances when a span was already present in the pending map.i\nThis not only adds overhead, but interferes with our ability to track\nthe difference between a newly allocated span vs incidental changes to\nan existing one due to use of currentSpan, toSpan or joinSpan.\nThis change is necessary to support SpanHandler when powered by\nidentity maps.\nSee #1148", "createdAt": "2020-04-11T04:03:53Z", "url": "https://github.com/openzipkin/brave/pull/1149", "merged": true, "mergeCommit": {"oid": "f83510f357888513364a7e8650f0b11f43107c57"}, "closed": true, "closedAt": "2020-04-11T08:05:11Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWdq4XAFqTM5MTczMzg1MQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWggL4AFqTM5MTc0NDA5OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzMzODUx", "url": "https://github.com/openzipkin/brave/pull/1149#pullrequestreview-391733851", "createdAt": "2020-04-11T04:06:29Z", "commit": {"oid": "cdb9635603615134033eb8fbd7498124285484fb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNDowNjoyOVrOGEKLUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNDowNjoyOVrOGEKLUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAxNDIyNw==", "bodyText": "this one is very hard to grok, but basically if the input context is the same ids as the one garbage collected, but a different instance, it is effectively resurrection from the POV of the user (as they wouldn't know about ref swapping anyway). I can remove this or revise this comment if confusing", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407014227", "createdAt": "2020-04-11T04:06:29Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb9635603615134033eb8fbd7498124285484fb"}, "originalPosition": 60}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "committedDate": "2020-04-11T06:16:52Z", "message": "Ensures currentSpan, toSpan and joinSpan use existing context references\n\nBefore, `Tracer.currentSpan`, `toSpan` and `joinSpan` either didn't\ndecorate external contexts (in no-op) or needlessly recreated context\ninstances when a span was already present in the pending map.i\n\nThis not only adds overhead, but interferes with our ability to track\nthe difference between a newly allocated span vs incidental changes to\nan existing one due to use of `currentSpan`, `toSpan` or `joinSpan`.\n\nThis change is necessary to support `SpanHandler` when powered by\nidentity maps."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "eabe2ae7a7a99f97d05be15b89de3fd8b2b6f74a", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/eabe2ae7a7a99f97d05be15b89de3fd8b2b6f74a", "committedDate": "2020-04-11T05:15:14Z", "message": "fixes nonsense test"}, "afterCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d", "committedDate": "2020-04-11T06:16:52Z", "message": "Ensures currentSpan, toSpan and joinSpan use existing context references\n\nBefore, `Tracer.currentSpan`, `toSpan` and `joinSpan` either didn't\ndecorate external contexts (in no-op) or needlessly recreated context\ninstances when a span was already present in the pending map.i\n\nThis not only adds overhead, but interferes with our ability to track\nthe difference between a newly allocated span vs incidental changes to\nan existing one due to use of `currentSpan`, `toSpan` or `joinSpan`.\n\nThis change is necessary to support `SpanHandler` when powered by\nidentity maps."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzQyNTE3", "url": "https://github.com/openzipkin/brave/pull/1149#pullrequestreview-391742517", "createdAt": "2020-04-11T06:55:20Z", "commit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNjo1NToyMFrOGEK-9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNzowMTowN1rOGELA0A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzQ0NA==", "bodyText": "maybe a one liner why not comparing to real span?", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027444", "createdAt": "2020-04-11T06:55:20Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/NoopSpan.java", "diffHunk": "@@ -92,10 +92,22 @@\n     return \"NoopSpan(\" + context + \")\";\n   }\n \n+  /**\n+   * This also matches equals against a lazy span. The rationale is least surprise to the user, as\n+   * code should not act differently given an instance of lazy or {@link NoopSpan}.\n+   */\n   @Override public boolean equals(Object o) {\n     if (o == this) return true;\n-    if (!(o instanceof NoopSpan)) return false;\n-    return context.equals(((NoopSpan) o).context);\n+    return isEqualToNoopOrLazySpan(context, o);\n+  }\n+\n+  static boolean isEqualToNoopOrLazySpan(TraceContext context, Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzU2MQ==", "bodyText": "IIUC Recreated would be more intuitive - not sure what it means to resurrect an object in Java", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027561", "createdAt": "2020-04-11T06:56:53Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAxNDIyNw=="}, "originalCommit": {"oid": "cdb9635603615134033eb8fbd7498124285484fb"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzU3Mg==", "bodyText": "each other", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027572", "createdAt": "2020-04-11T06:57:12Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)\n+    // * Ad-hoc usage of TraceContext.Builder (localRootId not set, as only settable internally)\n+    //\n+    // The first two scenarios are currently indistinguishable from eachother. If we had a way to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 63}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA==", "bodyText": "I don't think this type is exposed to users and can be leaked by them. Can't we use a normal reference?", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027920", "createdAt": "2020-04-11T07:01:07Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/recorder/PendingSpan.java", "diffHunk": "@@ -15,17 +15,32 @@\n \n import brave.Clock;\n import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n \n-public final class PendingSpan {\n+/**\n+ * This includes a weak reference of the trace context, which allows externalized forms of the trace\n+ * context to be swapped for the one in use.\n+ *\n+ * <p>This is a weak reference to ensure that {@link PendingSpans} can clean up on GC.\n+ */\n+public final class PendingSpan extends WeakReference<TraceContext> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4845c462251924b941d0d2a018d7fd4a79ef9172", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/4845c462251924b941d0d2a018d7fd4a79ef9172", "committedDate": "2020-04-11T07:16:14Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e9608db6074c33a1ca7b2079b82e05c7e6eb7d0b", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/e9608db6074c33a1ca7b2079b82e05c7e6eb7d0b", "committedDate": "2020-04-11T07:19:08Z", "message": "try to clarify"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzQ0MDk5", "url": "https://github.com/openzipkin/brave/pull/1149#pullrequestreview-391744099", "createdAt": "2020-04-11T07:24:32Z", "commit": {"oid": "e9608db6074c33a1ca7b2079b82e05c7e6eb7d0b"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1938, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}