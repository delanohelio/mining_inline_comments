{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk2NzQ1MTc0", "number": 1133, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNDozODowMFrODtX5PA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNjo0NTozOFrODtZaPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTAzOTk2OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tag.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNDozODowMFrOF-wjuQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNTo1MzozN1rOF-xu5g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MTYwOQ==", "bodyText": "I guess it's either Nullable result or Possibly null result. Though maybe better to phrase something like The result to add as a span tag. {@code null} means no tag will be added.", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401351609", "createdAt": "2020-04-01T04:38:00Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 53}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3MDg1NA==", "bodyText": "sgtm", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401370854", "createdAt": "2020-04-01T05:53:37Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MTYwOQ=="}, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 53}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTA0NDYwOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tag.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNDo0MToxMFrOF-wmZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNTo1NTowNVrOF-xwwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjI5Mg==", "bodyText": "Maybe can leave off these docs at Tags the value parsed from the {@code input}.. The non-null is really a job of parseValue, and there's no way to tag a no-op span anyways, the key point is we don't waste time parsing when it's no-op but that's an implementation detail.", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401352292", "createdAt": "2020-04-01T04:41:10Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3MTMyOQ==", "bodyText": "cool", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401371329", "createdAt": "2020-04-01T05:55:05Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjI5Mg=="}, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTA0NjA0OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tag.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNDo0MjoxM1rOF-wnPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNjoxMzozNVrOF-yIpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA==", "bodyText": "I'm sure it must have been thought no need for detail - any thoughts on a shared interface?", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401352508", "createdAt": "2020-04-01T04:42:13Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null and the {@linkplain ScopedSpan#isNoop() span is not no-op}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, span.context());\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  // ex void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+  public final void tag(I input, TraceContext context, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (context == null) throw new NullPointerException(\"context == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    if (span == NoopSpanCustomizer.INSTANCE) return;\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    TraceContext context = null;\n+    if (span instanceof Span) {\n+      Span asSpan = (Span) span;\n+      if (asSpan.isNoop()) return;\n+      context = asSpan.context();\n+    } else if (span == NoopSpanCustomizer.INSTANCE) {\n+      return;\n+    }\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain MutableSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null.\n+   *\n+   * @see FinishedSpanHandler#handle(TraceContext, MutableSpan)\n+   * @since 5.11\n+   */\n+  public final void tag(I input, TraceContext context, MutableSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, context);\n+  }\n+\n+  final String key;\n+\n+  /** @since 5.11 */\n+  protected Tag(String key) {\n+    this.key = validateNonEmpty(\"key\", key);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + key + \"}\";\n+  }\n+\n+  final void tag(Object span, I input, @Nullable TraceContext context) {\n+    String value;\n+    try {\n+      value = parseValue(input, context);\n+    } catch (Throwable e) {\n+      propagateIfFatal(e);\n+      Platform.get().log(\"Error parsing tag value of input %s\", input, e);\n+      return;\n+    }\n+    if (value == null) return;\n+    if (span instanceof SpanCustomizer) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3MjMzOA==", "bodyText": "sure. here's the context\nSpan is indeed instanceof SpanCustomizer\nScopedSpan doesn't allow name overrides\nMutableSpan doesn't have an implicit timestamp", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401372338", "createdAt": "2020-04-01T05:58:14Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null and the {@linkplain ScopedSpan#isNoop() span is not no-op}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, span.context());\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  // ex void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+  public final void tag(I input, TraceContext context, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (context == null) throw new NullPointerException(\"context == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    if (span == NoopSpanCustomizer.INSTANCE) return;\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    TraceContext context = null;\n+    if (span instanceof Span) {\n+      Span asSpan = (Span) span;\n+      if (asSpan.isNoop()) return;\n+      context = asSpan.context();\n+    } else if (span == NoopSpanCustomizer.INSTANCE) {\n+      return;\n+    }\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain MutableSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null.\n+   *\n+   * @see FinishedSpanHandler#handle(TraceContext, MutableSpan)\n+   * @since 5.11\n+   */\n+  public final void tag(I input, TraceContext context, MutableSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, context);\n+  }\n+\n+  final String key;\n+\n+  /** @since 5.11 */\n+  protected Tag(String key) {\n+    this.key = validateNonEmpty(\"key\", key);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + key + \"}\";\n+  }\n+\n+  final void tag(Object span, I input, @Nullable TraceContext context) {\n+    String value;\n+    try {\n+      value = parseValue(input, context);\n+    } catch (Throwable e) {\n+      propagateIfFatal(e);\n+      Platform.get().log(\"Error parsing tag value of input %s\", input, e);\n+      return;\n+    }\n+    if (value == null) return;\n+    if (span instanceof SpanCustomizer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA=="}, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3Mjg5Nw==", "bodyText": "we could allow ScopedSpan to override its name.. now wouldn't be a bad time to do that..", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401372897", "createdAt": "2020-04-01T05:59:42Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null and the {@linkplain ScopedSpan#isNoop() span is not no-op}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, span.context());\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  // ex void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+  public final void tag(I input, TraceContext context, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (context == null) throw new NullPointerException(\"context == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    if (span == NoopSpanCustomizer.INSTANCE) return;\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    TraceContext context = null;\n+    if (span instanceof Span) {\n+      Span asSpan = (Span) span;\n+      if (asSpan.isNoop()) return;\n+      context = asSpan.context();\n+    } else if (span == NoopSpanCustomizer.INSTANCE) {\n+      return;\n+    }\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain MutableSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null.\n+   *\n+   * @see FinishedSpanHandler#handle(TraceContext, MutableSpan)\n+   * @since 5.11\n+   */\n+  public final void tag(I input, TraceContext context, MutableSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, context);\n+  }\n+\n+  final String key;\n+\n+  /** @since 5.11 */\n+  protected Tag(String key) {\n+    this.key = validateNonEmpty(\"key\", key);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + key + \"}\";\n+  }\n+\n+  final void tag(Object span, I input, @Nullable TraceContext context) {\n+    String value;\n+    try {\n+      value = parseValue(input, context);\n+    } catch (Throwable e) {\n+      propagateIfFatal(e);\n+      Platform.get().log(\"Error parsing tag value of input %s\", input, e);\n+      return;\n+    }\n+    if (value == null) return;\n+    if (span instanceof SpanCustomizer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA=="}, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM3NzQ0Ng==", "bodyText": "#1134", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401377446", "createdAt": "2020-04-01T06:13:35Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see ScopedSpan#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return possibly nullable result. Note: empty string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * {@linkplain ScopedSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null and the {@linkplain ScopedSpan#isNoop() span is not no-op}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, span.context());\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  // ex void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+  public final void tag(I input, TraceContext context, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (context == null) throw new NullPointerException(\"context == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    if (span == NoopSpanCustomizer.INSTANCE) return;\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain SpanCustomizer#tag(String, String) Tags} the value parsed from the {@code input}\n+   * when non-null and the span is not no-op.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, SpanCustomizer span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    TraceContext context = null;\n+    if (span instanceof Span) {\n+      Span asSpan = (Span) span;\n+      if (asSpan.isNoop()) return;\n+      context = asSpan.context();\n+    } else if (span == NoopSpanCustomizer.INSTANCE) {\n+      return;\n+    }\n+    tag(span, input, context);\n+  }\n+\n+  /**\n+   * {@linkplain MutableSpan#tag(String, String) Tags} the value parsed from the {@code input} when\n+   * non-null.\n+   *\n+   * @see FinishedSpanHandler#handle(TraceContext, MutableSpan)\n+   * @since 5.11\n+   */\n+  public final void tag(I input, TraceContext context, MutableSpan span) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (span == null) throw new NullPointerException(\"span == null\");\n+    tag(span, input, context);\n+  }\n+\n+  final String key;\n+\n+  /** @since 5.11 */\n+  protected Tag(String key) {\n+    this.key = validateNonEmpty(\"key\", key);\n+  }\n+\n+  @Override public String toString() {\n+    return getClass().getSimpleName() + \"{\" + key + \"}\";\n+  }\n+\n+  final void tag(Object span, I input, @Nullable TraceContext context) {\n+    String value;\n+    try {\n+      value = parseValue(input, context);\n+    } catch (Throwable e) {\n+      propagateIfFatal(e);\n+      Platform.get().log(\"Error parsing tag value of input %s\", input, e);\n+      return;\n+    }\n+    if (value == null) return;\n+    if (span instanceof SpanCustomizer) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM1MjUwOA=="}, "originalCommit": {"oid": "4b88cd4bd589b7ae433162c60252d90ec58f09c5"}, "originalPosition": 139}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4OTI4ODI5OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tag.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNjo0NTozOFrOF-y29g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wMVQwNjo0NTozOFrOF-y29g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTM4OTMwMg==", "bodyText": "I left these overloads to help reduce branching to get noop", "url": "https://github.com/openzipkin/brave/pull/1133#discussion_r401389302", "createdAt": "2020-04-01T06:45:38Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tag.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+import brave.handler.FinishedSpanHandler;\n+import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/**\n+ * This is a centralized type to parse a tag into any variant of a span. This also avoids the\n+ * clutter of checking null or guarding on exceptions.\n+ *\n+ * Here's an example of a potentially expensive tag:\n+ * <pre>{@code\n+ * SUMMARY_TAG = new Tag<Summarizer>(\"summary\") {\n+ *   @Override protected String parseValue(Summarizer input, TraceContext context) {\n+ *     return input.computeSummary();\n+ *   }\n+ * }\n+ * SUMMARY_TAG.tag(span);\n+ * }</pre>\n+ *\n+ * @see Tags\n+ * @see SpanCustomizer#tag(String, String)\n+ * @see MutableSpan#tag(String, String)\n+ * @since 5.11\n+ */\n+public abstract class Tag<I> {\n+  public final String key() {\n+    return key;\n+  }\n+\n+  /**\n+   * Override to change what data from the input are parsed into the span modeling it. Any\n+   * exceptions will be logged and ignored.\n+   *\n+   * @return The result to add as a span tag. {@code null} means no tag will be added. Note: empty\n+   * string is a valid tag value!\n+   * @since 5.11\n+   */\n+  @Nullable protected abstract String parseValue(I input, @Nullable TraceContext context);\n+\n+  /**\n+   * Tags the value parsed from the {@code input}.\n+   *\n+   * @since 5.11\n+   */\n+  public final void tag(I input, ScopedSpan span) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "43119912aa9f69a78251eb0fd5109d8ac4a5b9ac"}, "originalPosition": 63}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1608, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}