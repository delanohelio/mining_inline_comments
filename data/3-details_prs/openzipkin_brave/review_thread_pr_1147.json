{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxODAxODEx", "number": 1147, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1NjoxM1rODwrXTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODozNjozOFrODwr6yw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzY4NzE4OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1NjoxM1rOGDz4lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1NjoxM1rOGDz4lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODk4MA==", "bodyText": "note this is not really much different than before.. I can revert it.. I was just playing around.", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406648980", "createdAt": "2020-04-10T07:56:13Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -92,12 +92,21 @@ public void clear() {\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    class ThreadLocalScope implements Scope {\n-      @Override public void close() {\n-        local.set(previous);\n-      }\n-    }\n-    Scope result = new ThreadLocalScope();\n+    Scope result = new ThreadLocalScope(local, previous);\n     return decorateScope(currentSpan, result);\n   }\n+\n+  static final class ThreadLocalScope implements Scope {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzY4NzYyOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tracing.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1NjoyN1rOGDz42Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1NjoyN1rOGDz42Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTA0OQ==", "bodyText": "Agree - the JVM has no idea what's in these brackets anyways without reflection", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406649049", "createdAt": "2020-04-10T07:56:27Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracing.java", "diffHunk": "@@ -49,8 +49,7 @@\n  * for example via spring or when mocking.\n  */\n public abstract class Tracing implements Closeable {\n-  // AtomicReference<Object> instead of AtomicReference<Tracing> to ensure unloadable\n-  static final AtomicReference<Object> CURRENT = new AtomicReference<>();\n+  static final AtomicReference<Tracing> CURRENT = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzY5MTc5OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1ODoxMlrOGDz7PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODowNzowM1rOGD0G1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTY2MQ==", "bodyText": "This seems nice - seems like it could fix something?", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406649661", "createdAt": "2020-04-10T07:58:12Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -92,12 +92,21 @@ public void clear() {\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    class ThreadLocalScope implements Scope {\n-      @Override public void close() {\n-        local.set(previous);\n-      }\n-    }\n-    Scope result = new ThreadLocalScope();\n+    Scope result = new ThreadLocalScope(local, previous);\n     return decorateScope(currentSpan, result);\n   }\n+\n+  static final class ThreadLocalScope implements Scope {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1MDkyMw==", "bodyText": "well  I'll update.. with where I was going.. basically revert to null can be a singleton. I still can't get the thing to unload when leaked as the cover type is brave's.", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406650923", "createdAt": "2020-04-10T08:01:51Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -92,12 +92,21 @@ public void clear() {\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    class ThreadLocalScope implements Scope {\n-      @Override public void close() {\n-        local.set(previous);\n-      }\n-    }\n-    Scope result = new ThreadLocalScope();\n+    Scope result = new ThreadLocalScope(local, previous);\n     return decorateScope(currentSpan, result);\n   }\n+\n+  static final class ThreadLocalScope implements Scope {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTY2MQ=="}, "originalCommit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY1MjYyOQ==", "bodyText": "ptal", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406652629", "createdAt": "2020-04-10T08:07:03Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -92,12 +92,21 @@ public void clear() {\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    class ThreadLocalScope implements Scope {\n-      @Override public void close() {\n-        local.set(previous);\n-      }\n-    }\n-    Scope result = new ThreadLocalScope();\n+    Scope result = new ThreadLocalScope(local, previous);\n     return decorateScope(currentSpan, result);\n   }\n+\n+  static final class ThreadLocalScope implements Scope {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTY2MQ=="}, "originalCommit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyMzc3ODAzOnYy", "diffSide": "RIGHT", "path": "brave-tests/src/test/java/brave/propagation/ThreadLocalCurrentTraceContextClassLoaderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODozNjozOFrOGD0umQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODozNjozOFrOGD0umQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY2MjgwOQ==", "bodyText": "Doesn't block this PR at all, just to record my thought and maybe @felixbarny has some ideas too.\nI haven't worked with unloading scenarios much but wonder whether this is so odd - since most things get cleaned up when GC happens, it seems natural to me for unloaded classes to also wait until GC to be cleaned up.", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406662809", "createdAt": "2020-04-10T08:36:38Z", "author": {"login": "anuraaga"}, "path": "brave-tests/src/test/java/brave/propagation/ThreadLocalCurrentTraceContextClassLoaderTest.java", "diffHunk": "@@ -43,9 +43,24 @@\n     }\n   }\n \n+  @Test public void leakedNullScope() {\n+    assertRunIsUnloadable(LeakedNullScope.class, getClass().getClassLoader());\n+  }\n+\n+  static class LeakedNullScope implements Runnable {\n+    @Override public void run() {\n+      CurrentTraceContext current = ThreadLocalCurrentTraceContext.newBuilder().build();\n+      current.newScope(null);\n+    }\n+  }\n+\n   /**\n-   * TODO: While it is an instrumentation bug to leak a scope, we should be tolerant, for example\n-   * considering weak references or similar.\n+   * TODO: While it is an instrumentation bug to leak a scope, we should be tolerant.\n+   *\n+   * <p>The current design problem is we don't know a reference type we can use that clears when\n+   * the classloader is unloaded, regardless of GC. For example, having {@link Scope} extend {@link\n+   * java.lang.ref.WeakReference} to hold the value to revert. This would only help if GC happened", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d984a69aeec9d0687a6fd5de9f00abd91cd69b3d"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1629, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}