{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzc1ODg1MDQ3", "number": 1084, "title": "Introduces HttpRequestParser and HttpResponseParser", "bodyText": "This completes the transition of HTTP instrumentation to the new HttpRequest\nand HttpResponse types by implementing parsing. Notably, the new parsing\nfunctions can be implemented by lambdas and pass a TraceContext vs scoping.\nThe main change is implementing parsers more simply.\nEx before:\nhttpTracing = httpTracing.toBuilder()\n    .clientParser(new HttpClientParser() {\n      @Override\n      public <Req> void request(HttpAdapter<Req, ?> adapter, Req req, SpanCustomizer span) {\n        span.name(adapter.method(req)); // default span name\n        span.tag(\"http.url\", adapter.url(req)); // the whole url, not just the path\n      }\n    })\n    .build();\nNow\nhttpTracing = httpTracing.toBuilder()\n    .clientRequestParser((req, context, span) -> {\n      span.name(req.method()); // default span name\n      span.tag(\"http.url\", req.url()); // the whole url, not just the path\n    })\n    .build();\nThis increased performance and allows easier access to extra fields. For\nexample, a commonly request was to add extra fields as tags. This can now\nbe done in the parser instead of the FinishedSpanHandler, if desired.\nEx.\nhttpTracing = httpTracing.toBuilder()\n    .clientRequestParser((req, context, span) -> {\n      HttpClientRequestParser.DEFAULT.parse(req, context, span);\n      String userName = ExtraFieldPropagation.get(context, \"user-name\");\n      if (userName != null) span.tag(\"user-name\", userName);\n    })\n    .build();\nIn order to not break api, all the other logic was kept in\nHttpParserAdapter, which we can't remove until the next major release.", "createdAt": "2020-02-16T23:06:16Z", "url": "https://github.com/openzipkin/brave/pull/1084", "merged": true, "mergeCommit": {"oid": "2d6a61d64144dcaa379264d39062e7f550d45cb3"}, "closed": true, "closedAt": "2020-02-22T23:02:51Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcFFIMrgFqTM1OTQ2MTc2NQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcGy5KVgH2gAyMzc1ODg1MDQ3Ojg4NGMzZDAwNWZlYTI3OTEzNTEyMDViZjBhNDQyOGQyYmJlM2E1Nzk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NDYxNzY1", "url": "https://github.com/openzipkin/brave/pull/1084#pullrequestreview-359461765", "createdAt": "2020-02-17T02:33:25Z", "commit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwMjozMzoyNVrOFqXJXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwMzo1MjowMVrOFqX4KQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2Mzc0MQ==", "bodyText": "Returns the instrumentation-specific response object used to create this {@link Response}, or {@code this} otherwise.", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379963741", "createdAt": "2020-02-17T02:33:25Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Response.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+/**\n+ * Abstract response type used for parsing.\n+ *\n+ * <h3>No extensions outside Brave</h3>\n+ * While this is an abstract type, it should not be subclassed outside the Brave repository. In\n+ * other words, subtypes are sealed within this source tree.\n+ *\n+ * @see Request\n+ * @since 5.10\n+ */\n+public abstract class Response {\n+  /** The remote {@link Span.Kind} describing the direction and type of the response. */\n+  public abstract Span.Kind spanKind();\n+\n+  /**\n+   * Returns the underlying response object or {@code this} if there is none. Here are some response", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2Mzk4NQ==", "bodyText": "Is this better than null as a fallback? Since the return type of this unwrap is Object, which has no shared interface, I can't imagine the fallback to this actually being used other than as a comparison for checking whether it was unwrapped. On the flip side, I see our code checking null anyways for this method.", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379963985", "createdAt": "2020-02-17T02:34:52Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Response.java", "diffHunk": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave;\n+\n+/**\n+ * Abstract response type used for parsing.\n+ *\n+ * <h3>No extensions outside Brave</h3>\n+ * While this is an abstract type, it should not be subclassed outside the Brave repository. In\n+ * other words, subtypes are sealed within this source tree.\n+ *\n+ * @see Request\n+ * @since 5.10\n+ */\n+public abstract class Response {\n+  /** The remote {@link Span.Kind} describing the direction and type of the response. */\n+  public abstract Span.Kind spanKind();\n+\n+  /**\n+   * Returns the underlying response object or {@code this} if there is none. Here are some response", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2Mzc0MQ=="}, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NDc2NQ==", "bodyText": "Extra parenthesis around lambda", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379964765", "createdAt": "2020-02-17T02:40:04Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java", "diffHunk": "@@ -202,6 +202,39 @@ public void reportsServerAddress() throws Exception {\n   @Test public void supportsPortableCustomization() throws Exception {\n     String uri = \"/foo/bar?z=2&yAA=1\";\n \n+    close();\n+    httpTracing = httpTracing.toBuilder()\n+      .clientRequestParser((request, context, span) -> {\n+        span.name(request.method().toLowerCase() + \" \" + request.path());\n+        span.tag(\"http.url\", request.url()); // just the path is logged by default\n+        span.tag(\"request_customizer.is_span\", (span instanceof brave.Span) + \"\");\n+      })\n+      .clientResponseParser(((response, error, context, span) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NDg0Mg==", "bodyText": "Extra paren around lambda", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379964842", "createdAt": "2020-02-17T02:40:37Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java", "diffHunk": "@@ -219,6 +220,31 @@ public void defaultSpanNameIsMethodNameOrRoute() throws Exception {\n \n   @Test\n   public void supportsPortableCustomization() throws Exception {\n+    httpTracing = httpTracing.toBuilder()\n+      .serverRequestParser((request, context, span) -> {\n+        span.name(request.method().toLowerCase() + \" \" + request.path());\n+        span.tag(\"http.url\", request.url()); // just the path is logged by default\n+        span.tag(\"request_customizer.is_span\", (span instanceof brave.Span) + \"\");\n+      })\n+      .serverResponseParser(((response, error, context, span) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NDkyMw==", "bodyText": "common request", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379964923", "createdAt": "2020-02-17T02:41:05Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/README.md", "diffHunk": "@@ -64,6 +64,23 @@ overrideSpanName = new HttpClientParser() {\n Note that span name can be overwritten any time, for example, when\n parsing the response, which is the case when route-based names are used.\n \n+This increased performance and allows easier access to extra fields. For\n+example, a commonly request was to add extra fields as tags. This can now", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NTA5NA==", "bodyText": "There are many classes, so not sure, but is this @Deprecated?", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379965094", "createdAt": "2020-02-17T02:42:04Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpAdapter.java", "diffHunk": "@@ -13,113 +13,57 @@\n  */\n package brave.http;\n \n-import brave.Clock;\n-import brave.Span;\n import brave.internal.Nullable;\n-import brave.propagation.TraceContext;\n import java.net.URI;\n \n public abstract class HttpAdapter<Req, Resp> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk2NTU1OQ==", "bodyText": "Keep this check?", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379965559", "createdAt": "2020-02-17T02:44:49Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpClientHandler.java", "diffHunk": "@@ -196,22 +207,12 @@ public Span handleSend(HttpClientRequest request, Span span) {\n    * @since 4.3\n    */\n   public void handleReceive(@Nullable Resp response, @Nullable Throwable error, Span span) {\n-    if (response == null && error == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MTI0OA==", "bodyText": "Just wondering is there any ordering requirement between these two lines?", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379971248", "createdAt": "2020-02-17T03:21:34Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpClientParserAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.ErrorParser;\n+import brave.SpanCustomizer;\n+import brave.propagation.CurrentTraceContext;\n+\n+/** Added to allow us to keep compatabilty with deprecated {@link HttpTracing#clientParser()} */\n+@Deprecated final class HttpClientParserAdapter extends HttpClientParser {\n+  final HttpRequestParser requestParser;\n+  final HttpResponseParser responseParser;\n+  final CurrentTraceContext currentTraceContext;\n+  final ErrorParser errorParser;\n+\n+  HttpClientParserAdapter(\n+    HttpRequestParser requestParser,\n+    HttpResponseParser responseParser,\n+    CurrentTraceContext currentTraceContext,\n+    ErrorParser errorParser\n+  ) {\n+    this.requestParser = requestParser;\n+    this.responseParser = responseParser;\n+    this.currentTraceContext = currentTraceContext;\n+    this.errorParser = errorParser;\n+  }\n+\n+  @Override protected ErrorParser errorParser() {\n+    return errorParser;\n+  }\n+\n+  @Override\n+  public <Req> void request(HttpAdapter<Req, ?> adapter, Req req, SpanCustomizer customizer) {\n+    HttpRequest request;\n+    if (req instanceof HttpClientRequest) {\n+      request = new HttpClientRequest.FromHttpAdapter((HttpClientAdapter) adapter, req);\n+    } else if (adapter instanceof HttpClientRequest.ToHttpAdapter) {\n+      request = ((HttpClientRequest.ToHttpAdapter) adapter).delegate;\n+    } else {\n+      throw new AssertionError(\"programming bug\");\n+    }\n+    requestParser.parse(request, currentTraceContext.get(), customizer);\n+  }\n+\n+  @Override public <Resp> void response(HttpAdapter<?, Resp> adapter, Resp res, Throwable error,\n+    SpanCustomizer customizer) {\n+    HttpResponse response;\n+    if (res instanceof HttpClientResponse) {\n+      response = new HttpClientResponse.FromHttpAdapter((HttpClientAdapter) adapter, res);\n+    } else if (adapter instanceof HttpClientResponse.ToHttpAdapter) {\n+      response = ((HttpClientResponse.ToHttpAdapter) adapter).delegate;\n+    } else {\n+      throw new AssertionError(\"programming bug\");\n+    }\n+    errorParser.error(error, customizer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MTcxNw==", "bodyText": "HttpRequest type", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379971717", "createdAt": "2020-02-17T03:24:54Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpParserAdapter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Span;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.TraceContext;\n+\n+/** Adapts {@link HttpParser} to the new request and response objects. */\n+@Deprecated final class HttpParserAdapter implements HttpRequestParser, HttpResponseParser {\n+  final CurrentTraceContext currentTraceContext;\n+  final HttpParser parser;\n+\n+  HttpParserAdapter(CurrentTraceContext currentTraceContext, HttpParser parser) {\n+    this.currentTraceContext = currentTraceContext;\n+    this.parser = parser;\n+  }\n+\n+  @Override public void parse(HttpRequest request, TraceContext context, SpanCustomizer span) {\n+    HttpAdapter<Object, ?> adapter;\n+    Object req;\n+\n+    // The order matters here because the deprecated HttpClientHandler.create(httpTracing, adapter)\n+    // can be used even with the new HttpRequest type. This means we have to check the HttpResponse", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MTg4OQ==", "bodyText": "Is it ok to have the else? (we don't have it above)", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379971889", "createdAt": "2020-02-17T03:26:07Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpParserAdapter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Span;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.TraceContext;\n+\n+/** Adapts {@link HttpParser} to the new request and response objects. */\n+@Deprecated final class HttpParserAdapter implements HttpRequestParser, HttpResponseParser {\n+  final CurrentTraceContext currentTraceContext;\n+  final HttpParser parser;\n+\n+  HttpParserAdapter(CurrentTraceContext currentTraceContext, HttpParser parser) {\n+    this.currentTraceContext = currentTraceContext;\n+    this.parser = parser;\n+  }\n+\n+  @Override public void parse(HttpRequest request, TraceContext context, SpanCustomizer span) {\n+    HttpAdapter<Object, ?> adapter;\n+    Object req;\n+\n+    // The order matters here because the deprecated HttpClientHandler.create(httpTracing, adapter)\n+    // can be used even with the new HttpRequest type. This means we have to check the HttpResponse\n+    // type after checking to see if we are in an adapter scenario.\n+    if (request instanceof HttpClientRequest.FromHttpAdapter) {\n+      HttpClientRequest.FromHttpAdapter wrapped = (HttpClientRequest.FromHttpAdapter) request;\n+      adapter = wrapped.adapter;\n+      req = wrapped.request;\n+    } else if (request instanceof HttpServerRequest.FromHttpAdapter) {\n+      HttpServerRequest.FromHttpAdapter wrapped = (HttpServerRequest.FromHttpAdapter) request;\n+      adapter = wrapped.adapter;\n+      req = wrapped.request;\n+    }\n+    if (request instanceof HttpClientRequest) {\n+      req = request.unwrap();\n+      if (req == null) return; // unwrap() shouldn't return null, but we shouldn't crash either.\n+      adapter = new HttpClientRequest.ToHttpAdapter((HttpClientRequest) request);\n+    } else if (request instanceof HttpServerRequest) {\n+      req = request.unwrap();\n+      if (req == null) return; // unwrap() shouldn't return null, but we shouldn't crash either.\n+      adapter = new HttpServerRequest.ToHttpAdapter((HttpServerRequest) request);\n+    } else {\n+      throw new AssertionError(\"programming bug\");\n+    }\n+\n+    Scope ws = currentTraceContext.maybeScope(context);\n+    try {\n+      parser.request(adapter, req, span);\n+    } finally {\n+      ws.close();\n+    }\n+  }\n+\n+  @Override public void parse(@Nullable HttpResponse response, @Nullable Throwable error,\n+    TraceContext context, SpanCustomizer span) {\n+    HttpAdapter<?, Object> adapter;\n+    Object res;\n+\n+    // The order matters here because the deprecated HttpClientHandler.create(httpTracing, adapter)\n+    // can be used even with the new HttpResponse type. This means we have to check the HttpResponse\n+    // type after checking to see if we are in an adapter scenario.\n+    if (response instanceof HttpClientResponse.FromHttpAdapter) {\n+      HttpClientResponse.FromHttpAdapter wrapped = (HttpClientResponse.FromHttpAdapter) response;\n+      adapter = wrapped.adapter;\n+      res = wrapped.response;\n+    } else if (response instanceof HttpServerResponse.FromHttpAdapter) {\n+      HttpServerResponse.FromHttpAdapter wrapped = (HttpServerResponse.FromHttpAdapter) response;\n+      adapter = wrapped.adapter;\n+      res = wrapped.response;\n+    } else if (response instanceof HttpClientResponse) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MjAyMg==", "bodyText": "This class is mostly impossible to grok ;) But we can leave it at that since it's deprecated, I wonder if there isn't a small readability improvement possible though by splitting client and server.", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379972022", "createdAt": "2020-02-17T03:27:04Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpParserAdapter.java", "diffHunk": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Span;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.CurrentTraceContext;\n+import brave.propagation.CurrentTraceContext.Scope;\n+import brave.propagation.TraceContext;\n+\n+/** Adapts {@link HttpParser} to the new request and response objects. */\n+@Deprecated final class HttpParserAdapter implements HttpRequestParser, HttpResponseParser {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MzUwOQ==", "bodyText": "Seal to only allow subclasses in brave?", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379973509", "createdAt": "2020-02-17T03:36:56Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpResponse.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Clock;\n+import brave.Response;\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of http clients and servers.\n+ *\n+ * @see HttpClientResponse\n+ * @see HttpServerResponse\n+ * @since 5.10\n+ */\n+public abstract class HttpResponse extends Response {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3MzY5Mg==", "bodyText": "I think it's good to add the method as a tag either way, but for this statement, can't we pass the request to the response parser?", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379973692", "createdAt": "2020-02-17T03:38:11Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpRequestParser.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.SpanCustomizer;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the request data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that changes the span name and records the HTTP url instead of the path.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientRequestParser((request, context, span) -> {\n+ *     span.name(spanName(adapter, request)); // default span name\n+ *     span.tag(\"http.url\", request.url()); // the whole url, not just the path\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>\n+ * This handles the request side of what {@link HttpParser} formerly did. This uses the {@link\n+ * HttpRequest} type directly, avoiding the deprecated {@link HttpAdapter} type. By constraining\n+ * this to only request data, it is implementable as a lambda or method reference. This also passes\n+ * the trace context as a parameter, lowering parsing overhead vs relying on the current span.\n+ *\n+ * <h3>The {@link TraceContext} parameter</h3>\n+ * The {@link TraceContext} parameter provides for advanced data handling, such as {@link\n+ * ExtraFieldPropagation#get(TraceContext, String) extra fields}. This is explicitly passed as you\n+ * cannot rely on {@link brave.Tracer#currentSpan()} being the same value.\n+ *\n+ * @see HttpResponseParser\n+ */\n+public interface HttpRequestParser {\n+  HttpRequestParser DEFAULT = new HttpRequestParser.Default();\n+\n+  /**\n+   * Implement to choose what data from the http request are parsed into the span representing it.\n+   *\n+   * @see Default\n+   */\n+  void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+\n+  /**\n+   * The default data policy sets the span name to the HTTP method and adds the \"http.method\" and\n+   * \"http.path\" tags.\n+   */\n+  // Eventhough the default span name is the method, we have no way of knowing that a user hasn't\n+  // overwritten the name to something else. If that occurs during response parsing, it is too late", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3Mzc2NA==", "bodyText": "Related to above comment, isn't it easier to reason about (and possibly more powerful) if we pass the request during response parsing instead of duplicating fields into the response?", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379973764", "createdAt": "2020-02-17T03:38:39Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpResponse.java", "diffHunk": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.Clock;\n+import brave.Response;\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of http clients and servers.\n+ *\n+ * @see HttpClientResponse\n+ * @see HttpServerResponse\n+ * @since 5.10\n+ */\n+public abstract class HttpResponse extends Response {\n+  /**\n+   * Like {@link HttpRequest#method()} except used in response parsing.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDIwNw==", "bodyText": "To keep the javadoc of modern, non-deprecated types simpler for users, maybe this sort of reasoning should be in the javadoc of the deprecated type instead.", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379974207", "createdAt": "2020-02-17T03:41:47Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpResponseParser.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.ErrorParser;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the response data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that adds all HTTP status codes, not just the error ones.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientResponseParser((response, error, context, span) -> {\n+ *     HttpResponseParser.DEFAULT.parse(response, error, context, span);\n+ *     int statusCode = response != null ? response.statusCode() : 0;\n+ *     if (statusCode > 0) span.tag(\"http.status_code\", String.valueOf(statusCode));\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDYyOQ==", "bodyText": "It's probably too late now due to backwards compatibility, but I guess we didn't need to use @Nullable on attributes that are directly part of the HTTP spec. e.g., an HttpRequest without a method never exists and doesn't make sense. I find the business logic hard to follow because of the null checks that end up scattered around.", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379974629", "createdAt": "2020-02-17T03:44:55Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpRequest.java", "diffHunk": "@@ -24,21 +26,63 @@\n  * @since 5.8\n  */\n public abstract class HttpRequest extends Request {\n-  /** @see HttpAdapter#startTimestamp(Object) */\n+  /**\n+   * The timestamp in epoch microseconds of the beginning of this request or zero to take this\n+   * implicitly from the current clock. Defaults to zero.\n+   *\n+   * <p>This is helpful in two scenarios: late parsing and avoiding redundant timestamp overhead.\n+   * If a server span, this helps reach the \"original\" beginning of the request, which is always\n+   * prior to parsing.\n+   *\n+   * <p>Note: Overriding has the same problems as using {@link brave.Span#start(long)}. For\n+   * example, it can result in negative duration if the clock used is allowed to correct backwards.\n+   * It can also result in misalignments in the trace, unless {@link brave.Tracing.Builder#clock(Clock)}\n+   * uses the same implementation.\n+   *\n+   * @see HttpResponse#finishTimestamp()\n+   * @see brave.Span#start(long)\n+   * @see brave.Tracing#clock(TraceContext)\n+   * @since 5.8\n+   */\n   public long startTimestamp() {\n     return 0L;\n   }\n \n-  /** @see HttpAdapter#method(Object) */\n+  /**\n+   * The HTTP method, or verb, such as \"GET\" or \"POST\" or null if unreadable.\n+   *\n+   * <p>Conventionally associated with the key \"http.method\"\n+   *\n+   * <h3>Note</h3>\n+   * <p>It is part of the <a href=\"https://tools.ietf.org/html/rfc7231#section-4.1\">HTTP RFC</a>\n+   * that an HTTP method is case-sensitive. Do not downcase results. If you do, not only will\n+   * integration tests fail, but you will surprise any consumers who expect compliant results.\n+   */\n   @Nullable public abstract String method();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NDgxMA==", "bodyText": "For example here, the fact that method is allowed to be null makes this single line of code a lot more complex (what are the implications of not setting name, for example)", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379974810", "createdAt": "2020-02-17T03:46:03Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpRequestParser.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.SpanCustomizer;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the request data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that changes the span name and records the HTTP url instead of the path.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientRequestParser((request, context, span) -> {\n+ *     span.name(spanName(adapter, request)); // default span name\n+ *     span.tag(\"http.url\", request.url()); // the whole url, not just the path\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>\n+ * This handles the request side of what {@link HttpParser} formerly did. This uses the {@link\n+ * HttpRequest} type directly, avoiding the deprecated {@link HttpAdapter} type. By constraining\n+ * this to only request data, it is implementable as a lambda or method reference. This also passes\n+ * the trace context as a parameter, lowering parsing overhead vs relying on the current span.\n+ *\n+ * <h3>The {@link TraceContext} parameter</h3>\n+ * The {@link TraceContext} parameter provides for advanced data handling, such as {@link\n+ * ExtraFieldPropagation#get(TraceContext, String) extra fields}. This is explicitly passed as you\n+ * cannot rely on {@link brave.Tracer#currentSpan()} being the same value.\n+ *\n+ * @see HttpResponseParser\n+ */\n+public interface HttpRequestParser {\n+  HttpRequestParser DEFAULT = new HttpRequestParser.Default();\n+\n+  /**\n+   * Implement to choose what data from the http request are parsed into the span representing it.\n+   *\n+   * @see Default\n+   */\n+  void parse(HttpRequest request, TraceContext context, SpanCustomizer span);\n+\n+  /**\n+   * The default data policy sets the span name to the HTTP method and adds the \"http.method\" and\n+   * \"http.path\" tags.\n+   */\n+  // Eventhough the default span name is the method, we have no way of knowing that a user hasn't\n+  // overwritten the name to something else. If that occurs during response parsing, it is too late\n+  // to go back and get the http method. Adding http method by default ensures span naming doesn't\n+  // prevent basic HTTP info from being visible. A cost of this is another tag, but it is small with\n+  // very limited cardinality. Moreover, users who care strictly about size can override this.\n+  class Default implements HttpRequestParser {\n+    /**\n+     * This sets the span name to the HTTP method and adds the \"http.method\" and \"http.path\" tags.\n+     *\n+     * <p>If you only want to change the span name, subclass and override {@link\n+     * #spanName(HttpRequest, TraceContext)}.\n+     */\n+    @Override public void parse(HttpRequest req, TraceContext context, SpanCustomizer span) {\n+      String name = spanName(req, context);\n+      if (name != null) span.name(name);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTMwOA==", "bodyText": "I guess most 3xx are redirects, but not 304 Not Modified.", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379975308", "createdAt": "2020-02-17T03:49:38Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpResponseParser.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.ErrorParser;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the response data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that adds all HTTP status codes, not just the error ones.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientResponseParser((response, error, context, span) -> {\n+ *     HttpResponseParser.DEFAULT.parse(response, error, context, span);\n+ *     int statusCode = response != null ? response.statusCode() : 0;\n+ *     if (statusCode > 0) span.tag(\"http.status_code\", String.valueOf(statusCode));\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>\n+ * This handles the response side of what {@link HttpParser} formerly did. This uses the {@link\n+ * HttpResponse} type directly, avoiding the deprecated {@link HttpAdapter} type. By constraining\n+ * this to only response data, it is implementable as a lambda or method reference.\n+ *\n+ * <p>This also fixes a few problems noticed in practice with {@link HttpParser}:\n+ * <ul>\n+ *   <li>Implementation complexity of {@link ErrorParser}: this is now handled outside</li>\n+ *   <li>Overhead of scoping the current span: {@link TraceContext} is now a parameter</li>\n+ *   <li>Boxing of the HTTP status code: the integer form is now used</li>\n+ * </ul>\n+ *\n+ * <h3>The {@link TraceContext} parameter</h3>\n+ * The {@link TraceContext} parameter provides for advanced data handling, such as\n+ * {@link ExtraFieldPropagation#get(TraceContext, String) extra fields}. This is explicitly passed\n+ * as you cannot rely on {@link brave.Tracer#currentSpan()} being the same value.\n+ *\n+ * @see HttpRequestParser\n+ */\n+public interface HttpResponseParser {\n+  HttpResponseParser DEFAULT = new HttpResponseParser.Default();\n+\n+  /**\n+   * Implement to choose what data from the http response are parsed into the span representing it.\n+   *\n+   * <p>Note: Either the response or error parameters may be null, but not both.\n+   *\n+   * @see Default\n+   */\n+  void parse(@Nullable HttpResponse response, @Nullable Throwable error, TraceContext context,\n+    SpanCustomizer customizer);\n+\n+  /**\n+   * The default data policy sets the span name to the HTTP route when available, and sets the and\n+   * adds the \"http.status_code\" and \"error\" tags.\n+   *\n+   * <p><h3>Route-based span name</h3>\n+   * If routing is supported, and a GET didn't match due to 404, the span name will be \"get\n+   * not_found\". If it didn't match due to redirect, the span name will be \"get redirected\". If\n+   * routing is not supported, the span name is left alone.\n+   */\n+  // This accepts response or exception because sometimes http 500 is an exception and sometimes not\n+  // If this were not an abstraction, we'd use separate hooks for response and error.\n+  class Default implements HttpResponseParser {\n+\n+    /**\n+     * This tags \"http.status_code\" when it is not 2xx. If the there is no exception and the status\n+     * code is neither 2xx nor 3xx, it tags \"error\". This also overrides the span name based on the\n+     * {@link HttpResponse#method()} and {@link HttpResponse#route()} where possible (ex \"get\n+     * /users/:userId\").\n+     *\n+     * <p>If you only want to change how exceptions are parsed, override {@link #error(int,\n+     * Throwable, TraceContext, SpanCustomizer)} instead.\n+     */\n+    @Override public void parse(@Nullable HttpResponse response, @Nullable Throwable error,\n+      TraceContext context, SpanCustomizer customizer) {\n+      int statusCode = 0;\n+      if (response != null) {\n+        statusCode = response.statusCode();\n+        String nameFromRoute = spanNameFromRoute(response, statusCode);\n+        if (nameFromRoute != null) customizer.name(nameFromRoute);\n+        String maybeStatus = maybeStatusAsString(statusCode, 299);\n+        if (maybeStatus != null) customizer.tag(\"http.status_code\", maybeStatus);\n+      }\n+      error(statusCode, error, context, customizer);\n+    }\n+\n+    /** The intent of this is to by default add \"http.status_code\", when not a success code */\n+    @Nullable String maybeStatusAsString(int statusCode, int upperRange) {\n+      if (statusCode != 0 && (statusCode < 200 || statusCode > upperRange)) {\n+        return String.valueOf(statusCode);\n+      }\n+      return null;\n+    }\n+\n+    static String spanNameFromRoute(HttpResponse response, int statusCode) {\n+      String method = response.method();\n+      if (method == null) return null; // don't undo a valid name elsewhere\n+      String route = response.route();\n+      if (route == null) return null; // don't undo a valid name elsewhere\n+      if (!\"\".equals(route)) return method + \" \" + route;\n+      if (statusCode / 100 == 3) return method + \" redirected\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTY3OA==", "bodyText": "It's not brave's job to validate HTTP, so this comment is a bit overkill", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379975678", "createdAt": "2020-02-17T03:51:44Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpResponseParser.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.http;\n+\n+import brave.ErrorParser;\n+import brave.SpanCustomizer;\n+import brave.internal.Nullable;\n+import brave.propagation.ExtraFieldPropagation;\n+import brave.propagation.TraceContext;\n+\n+/**\n+ * Use this to control the response data recorded for an {@link TraceContext#sampledLocal() sampled\n+ * HTTP client or server span}.\n+ *\n+ * <p>Here's an example that adds all HTTP status codes, not just the error ones.\n+ * <pre>{@code\n+ * httpTracing = httpTracing.toBuilder()\n+ *   .clientResponseParser((response, error, context, span) -> {\n+ *     HttpResponseParser.DEFAULT.parse(response, error, context, span);\n+ *     int statusCode = response != null ? response.statusCode() : 0;\n+ *     if (statusCode > 0) span.tag(\"http.status_code\", String.valueOf(statusCode));\n+ *   }).build();\n+ * }</pre>\n+ *\n+ * <h3>Relationship to {@link HttpParser}</h3>\n+ * This handles the response side of what {@link HttpParser} formerly did. This uses the {@link\n+ * HttpResponse} type directly, avoiding the deprecated {@link HttpAdapter} type. By constraining\n+ * this to only response data, it is implementable as a lambda or method reference.\n+ *\n+ * <p>This also fixes a few problems noticed in practice with {@link HttpParser}:\n+ * <ul>\n+ *   <li>Implementation complexity of {@link ErrorParser}: this is now handled outside</li>\n+ *   <li>Overhead of scoping the current span: {@link TraceContext} is now a parameter</li>\n+ *   <li>Boxing of the HTTP status code: the integer form is now used</li>\n+ * </ul>\n+ *\n+ * <h3>The {@link TraceContext} parameter</h3>\n+ * The {@link TraceContext} parameter provides for advanced data handling, such as\n+ * {@link ExtraFieldPropagation#get(TraceContext, String) extra fields}. This is explicitly passed\n+ * as you cannot rely on {@link brave.Tracer#currentSpan()} being the same value.\n+ *\n+ * @see HttpRequestParser\n+ */\n+public interface HttpResponseParser {\n+  HttpResponseParser DEFAULT = new HttpResponseParser.Default();\n+\n+  /**\n+   * Implement to choose what data from the http response are parsed into the span representing it.\n+   *\n+   * <p>Note: Either the response or error parameters may be null, but not both.\n+   *\n+   * @see Default\n+   */\n+  void parse(@Nullable HttpResponse response, @Nullable Throwable error, TraceContext context,\n+    SpanCustomizer customizer);\n+\n+  /**\n+   * The default data policy sets the span name to the HTTP route when available, and sets the and\n+   * adds the \"http.status_code\" and \"error\" tags.\n+   *\n+   * <p><h3>Route-based span name</h3>\n+   * If routing is supported, and a GET didn't match due to 404, the span name will be \"get\n+   * not_found\". If it didn't match due to redirect, the span name will be \"get redirected\". If\n+   * routing is not supported, the span name is left alone.\n+   */\n+  // This accepts response or exception because sometimes http 500 is an exception and sometimes not\n+  // If this were not an abstraction, we'd use separate hooks for response and error.\n+  class Default implements HttpResponseParser {\n+\n+    /**\n+     * This tags \"http.status_code\" when it is not 2xx. If the there is no exception and the status\n+     * code is neither 2xx nor 3xx, it tags \"error\". This also overrides the span name based on the\n+     * {@link HttpResponse#method()} and {@link HttpResponse#route()} where possible (ex \"get\n+     * /users/:userId\").\n+     *\n+     * <p>If you only want to change how exceptions are parsed, override {@link #error(int,\n+     * Throwable, TraceContext, SpanCustomizer)} instead.\n+     */\n+    @Override public void parse(@Nullable HttpResponse response, @Nullable Throwable error,\n+      TraceContext context, SpanCustomizer customizer) {\n+      int statusCode = 0;\n+      if (response != null) {\n+        statusCode = response.statusCode();\n+        String nameFromRoute = spanNameFromRoute(response, statusCode);\n+        if (nameFromRoute != null) customizer.name(nameFromRoute);\n+        String maybeStatus = maybeStatusAsString(statusCode, 299);\n+        if (maybeStatus != null) customizer.tag(\"http.status_code\", maybeStatus);\n+      }\n+      error(statusCode, error, context, customizer);\n+    }\n+\n+    /** The intent of this is to by default add \"http.status_code\", when not a success code */\n+    @Nullable String maybeStatusAsString(int statusCode, int upperRange) {\n+      if (statusCode != 0 && (statusCode < 200 || statusCode > upperRange)) {\n+        return String.valueOf(statusCode);\n+      }\n+      return null;\n+    }\n+\n+    static String spanNameFromRoute(HttpResponse response, int statusCode) {\n+      String method = response.method();\n+      if (method == null) return null; // don't undo a valid name elsewhere\n+      String route = response.route();\n+      if (route == null) return null; // don't undo a valid name elsewhere\n+      if (!\"\".equals(route)) return method + \" \" + route;\n+      if (statusCode / 100 == 3) return method + \" redirected\";\n+      if (statusCode == 404) return method + \" not_found\";\n+      return null; // unexpected\n+    }\n+\n+    /**\n+     * Override to change what data from the HTTP error are parsed into the span modeling it. By\n+     * default, this tags \"error\" as the the status code, if the error parameter was null and the\n+     * HTTP status is below 1xx or above 3xx.\n+     *\n+     * <p>Note: Either the httpStatus can be zero or the error parameter null, but not both. This\n+     * does not parse the error, as it is assumed that the {@link ErrorParser has done so prior}.\n+     *\n+     * <p>Conventionally associated with the tag key \"error\"\n+     */\n+    protected void error(int httpStatus, @Nullable Throwable error, TraceContext context,\n+      SpanCustomizer customizer) {\n+      if (error != null) return; // the call site used the ErrorParser\n+\n+      // Instrumentation error should not make span errors. We don't know the difference between a\n+      // library being unable to get the http status and a bad status (0). We don't classify zero as\n+      // error in case instrumentation cannot read the status. This prevents tagging every response as\n+      // error.\n+      if (httpStatus == 0) return;\n+\n+      // Unlike success path tagging, we only want to indicate something as error if it is not in a\n+      // success range. 1xx-3xx are not errors. It is endpoint-specific if client codes like 404 are\n+      // in fact errors. That's why this is overridable.\n+\n+      // 1xx, 2xx, and 3xx codes are not all valid, but the math is good enough vs drift and opinion", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTk3NTcyMQ==", "bodyText": "Keep this check?", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r379975721", "createdAt": "2020-02-17T03:52:01Z", "author": {"login": "anuraaga"}, "path": "instrumentation/http/src/main/java/brave/http/HttpServerHandler.java", "diffHunk": "@@ -148,22 +151,12 @@ Span nextSpan(TraceContextOrSamplingFlags extracted, HttpServerRequest request)\n    * @since 4.3\n    */\n   public void handleSend(@Nullable Resp response, @Nullable Throwable error, Span span) {\n-    if (response == null && error == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "25ee51e62857c0f222944a33aec0347fb8fda5c9"}, "originalPosition": 53}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5OTk1NzI4", "url": "https://github.com/openzipkin/brave/pull/1084#pullrequestreview-359995728", "createdAt": "2020-02-17T22:55:21Z", "commit": {"oid": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMjo1NToyMVrOFqxOFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QyMzozNDowNVrOFqxpEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MDkzMw==", "bodyText": "nit: extra parenthesis in function", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380390933", "createdAt": "2020-02-17T22:55:21Z", "author": {"login": "jeqo"}, "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpClient.java", "diffHunk": "@@ -155,9 +157,12 @@\n     String path = \"/foo\";\n \n     close();\n-    httpTracing = httpTracing.toBuilder().clientSampler(HttpRuleSampler.newBuilder()\n+\n+    SamplerFunction<HttpRequest> sampler = (HttpRuleSampler.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MTIwMA==", "bodyText": "nit: extra parenthesis around function", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380391200", "createdAt": "2020-02-17T22:56:39Z", "author": {"login": "jeqo"}, "path": "instrumentation/http-tests/src/main/java/brave/test/http/ITHttpServer.java", "diffHunk": "@@ -133,9 +137,11 @@ public void samplingDisabled() throws Exception {\n   @Test public void customSampler() throws Exception {\n     String path = \"/foo\";\n \n-    httpTracing = httpTracing.toBuilder().serverSampler(HttpRuleSampler.newBuilder()\n+    SamplerFunction<HttpRequest> sampler = (HttpRuleSampler.newBuilder()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5MjYyNg==", "bodyText": "Should L35 be updates from:\n * @deprecated Since 5.8, use {@code RequestSampler<HttpRequest>}.\n\nto\n * @deprecated Since 5.8, use {@code SamplerFunction<HttpRequest>}.", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380392626", "createdAt": "2020-02-17T23:04:22Z", "author": {"login": "jeqo"}, "path": "instrumentation/http/src/main/java/brave/http/HttpSampler.java", "diffHunk": "@@ -75,9 +75,9 @@\n     if (request == null) return null;\n     HttpAdapter<Object, Void> adapter;\n     if (request instanceof HttpClientRequest) {\n-      adapter = new HttpClientRequest.ToHttpAdapter((HttpClientRequest) request);\n+      adapter = new HttpClientAdapters.ToRequestAdapter((HttpClientRequest) request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5Nzg0Mg==", "bodyText": "@anuraaga this is the check that was moved from HttpClientHandler#handleReceive, but I'm also not sure if this check should be moved back to the beginning of handleReceive", "url": "https://github.com/openzipkin/brave/pull/1084#discussion_r380397842", "createdAt": "2020-02-17T23:34:05Z", "author": {"login": "jeqo"}, "path": "instrumentation/http/src/main/java/brave/http/HttpHandler.java", "diffHunk": "@@ -13,68 +13,66 @@\n  */\n package brave.http;\n \n+import brave.ErrorParser;\n import brave.Span;\n+import brave.SpanCustomizer;\n import brave.internal.Nullable;\n-import brave.propagation.CurrentTraceContext;\n-import brave.propagation.CurrentTraceContext.Scope;\n \n abstract class HttpHandler {\n-  final CurrentTraceContext currentTraceContext;\n-  final HttpParser parser;\n+  final HttpRequestParser requestParser;\n+  final HttpResponseParser responseParser;\n+  final ErrorParser errorParser;\n \n-  HttpHandler(CurrentTraceContext currentTraceContext, HttpParser parser) {\n-    this.currentTraceContext = currentTraceContext;\n-    this.parser = parser;\n+  HttpHandler(\n+    HttpRequestParser requestParser,\n+    HttpResponseParser responseParser,\n+    ErrorParser errorParser\n+  ) {\n+    this.requestParser = requestParser;\n+    this.responseParser = responseParser;\n+    this.errorParser = errorParser;\n   }\n \n-  <Req> Span handleStart(HttpAdapter<Req, ?> adapter, Req request, Span span) {\n+  Span handleStart(HttpRequest request, Span span) {\n     if (span.isNoop()) return span;\n-    Scope ws = currentTraceContext.maybeScope(span.context());\n+\n+    span.kind(request.spanKind());\n     try {\n-      parseRequest(adapter, request, span);\n+      parseRequest(request, span);\n     } finally {\n-      ws.close();\n-    }\n-\n-    // all of the above parsing happened before a timestamp on the span\n-    long timestamp = adapter.startTimestamp(request);\n-    if (timestamp == 0L) {\n-      span.start();\n-    } else {\n-      span.start(timestamp);\n+      // all of the above parsing happened before a timestamp on the span\n+      long timestamp = request.startTimestamp();\n+      if (timestamp == 0L) {\n+        span.start();\n+      } else {\n+        span.start(timestamp);\n+      }\n     }\n     return span;\n   }\n \n-  /** parses remote IP:port and tags while the span is in scope (for logging for example) */\n-  abstract <Req> void parseRequest(HttpAdapter<Req, ?> adapter, Req request, Span span);\n+  abstract void parseRequest(HttpRequest request, Span span);\n \n+  void handleFinish(@Nullable HttpResponse response, @Nullable Throwable error, Span span) {\n+    if (response == null && error == null) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5"}, "originalPosition": 66}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3474cc42c0cd0f412f9bc4b3929b7631c70e56f5", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/3474cc42c0cd0f412f9bc4b3929b7631c70e56f5", "committedDate": "2020-02-17T08:07:05Z", "message": "Tries to isolate code only there to support deprecated code"}, "afterCommit": {"oid": "5da79b48766f63f1a1d74deea30f5c040fa69b8a", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/5da79b48766f63f1a1d74deea30f5c040fa69b8a", "committedDate": "2020-02-20T11:37:08Z", "message": "Introduces HttpRequestParser and HttpResponseParser\n\nThis completes the transition of HTTP instrumentation to the new HttpRequest\nand HttpResponse types by implementing parsing. Notably, the new parsing\nfunctions can be implemented by lambdas and pass a TraceContext vs scoping.\n\nThe main change is implementing parsers more simply.\n\nEx before:\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientParser(new HttpClientParser() {\n      @Override\n      public <Req> void request(HttpAdapter<Req, ?> adapter, Req req, SpanCustomizer span) {\n        span.name(adapter.method(req)); // default span name\n        span.tag(\"http.url\", adapter.url(req)); // the whole url, not just the path\n      }\n    })\n    .build();\n```\n\nNow\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientRequestParser((req, context, span) -> {\n      span.name(req.method()); // default span name\n      span.tag(\"http.url\", req.url()); // the whole url, not just the path\n    })\n    .build();\n```\n\nThis increased performance and allows easier access to extra fields. For\nexample, a commonly request was to add extra fields as tags. This can now\nbe done in the parser instead of the FinishedSpanHandler, if desired.\n\nEx.\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientRequestParser((req, context, span) -> {\n      HttpClientRequestParser.DEFAULT.parse(req, context, span);\n      String userName = ExtraFieldPropagation.get(context, \"user-name\");\n      if (userName != null) span.tag(\"user-name\", userName);\n    })\n    .build();\n```\n\nIn order to not break api, all the other logic was kept in\n`HttpParserAdapter`, which we can't remove until the next release."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5da79b48766f63f1a1d74deea30f5c040fa69b8a", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/5da79b48766f63f1a1d74deea30f5c040fa69b8a", "committedDate": "2020-02-20T11:37:08Z", "message": "Introduces HttpRequestParser and HttpResponseParser\n\nThis completes the transition of HTTP instrumentation to the new HttpRequest\nand HttpResponse types by implementing parsing. Notably, the new parsing\nfunctions can be implemented by lambdas and pass a TraceContext vs scoping.\n\nThe main change is implementing parsers more simply.\n\nEx before:\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientParser(new HttpClientParser() {\n      @Override\n      public <Req> void request(HttpAdapter<Req, ?> adapter, Req req, SpanCustomizer span) {\n        span.name(adapter.method(req)); // default span name\n        span.tag(\"http.url\", adapter.url(req)); // the whole url, not just the path\n      }\n    })\n    .build();\n```\n\nNow\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientRequestParser((req, context, span) -> {\n      span.name(req.method()); // default span name\n      span.tag(\"http.url\", req.url()); // the whole url, not just the path\n    })\n    .build();\n```\n\nThis increased performance and allows easier access to extra fields. For\nexample, a commonly request was to add extra fields as tags. This can now\nbe done in the parser instead of the FinishedSpanHandler, if desired.\n\nEx.\n```java\nhttpTracing = httpTracing.toBuilder()\n    .clientRequestParser((req, context, span) -> {\n      HttpClientRequestParser.DEFAULT.parse(req, context, span);\n      String userName = ExtraFieldPropagation.get(context, \"user-name\");\n      if (userName != null) span.tag(\"user-name\", userName);\n    })\n    .build();\n```\n\nIn order to not break api, all the other logic was kept in\n`HttpParserAdapter`, which we can't remove until the next release."}, "afterCommit": {"oid": "848562daa3d601c5124e4e0454bd081358b89a2c", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/848562daa3d601c5124e4e0454bd081358b89a2c", "committedDate": "2020-02-21T07:12:07Z", "message": "WIP: Introduces HttpRequestParser and HttpResponseParser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "848562daa3d601c5124e4e0454bd081358b89a2c", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/848562daa3d601c5124e4e0454bd081358b89a2c", "committedDate": "2020-02-21T07:12:07Z", "message": "WIP: Introduces HttpRequestParser and HttpResponseParser"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "02614ca813ba888d2ffb0ac0b23d1e7c43196888", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/02614ca813ba888d2ffb0ac0b23d1e7c43196888", "committedDate": "2020-02-21T07:37:48Z", "message": "feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYyNDQ2NDcx", "url": "https://github.com/openzipkin/brave/pull/1084#pullrequestreview-362446471", "createdAt": "2020-02-21T07:46:07Z", "commit": {"oid": "02614ca813ba888d2ffb0ac0b23d1e7c43196888"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "307f6f1e598fdb841286b5d751bfbefc4c964d49", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/307f6f1e598fdb841286b5d751bfbefc4c964d49", "committedDate": "2020-02-21T07:57:31Z", "message": "much nicer signature"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d794293175675781d861b017d6bd703a4b4f822", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/8d794293175675781d861b017d6bd703a4b4f822", "committedDate": "2020-02-21T08:24:33Z", "message": "polish"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c00a8d761a6e3d72a7b99682eb9a43628d227450", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/c00a8d761a6e3d72a7b99682eb9a43628d227450", "committedDate": "2020-02-22T09:35:30Z", "message": "refactor and test backfill"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMDIwMzU3", "url": "https://github.com/openzipkin/brave/pull/1084#pullrequestreview-363020357", "createdAt": "2020-02-22T09:40:51Z", "commit": {"oid": "c00a8d761a6e3d72a7b99682eb9a43628d227450"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "884c3d005fea2791351205bf0a4428d2bbe3a579", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/884c3d005fea2791351205bf0a4428d2bbe3a579", "committedDate": "2020-02-22T11:47:19Z", "message": "missing tests"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1832, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}