{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg5MDAxOTQ2", "number": 1115, "reviewThreads": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNTo0ODowMlrODoMa7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo0MTo1NVrODoQMyw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDczMTMzOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNTo0ODowM1rOF2mLpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNTo0ODowM1rOF2mLpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc5Mjk5OQ==", "bodyText": "forgot we were in the same package before. this removes duplicate logic.", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392792999", "createdAt": "2020-03-16T05:48:03Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,100 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n+\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n+\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n+\n       if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n         }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+          if (isEof) break; // fields after span ID are optional\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos -1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d87b477c3f1326a03c721297893cbd7511a28105"}, "originalPosition": 151}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDc1NjYyOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNjowNTozNlrOF2mbVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNjowNTozNlrOF2mbVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjc5NzAxNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Otherwise, we'd have to process again when outside the loop.\n          \n          \n            \n                // Otherwise, we'd have to process again when outside the loop to handle dangling data on EOF.", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392797015", "createdAt": "2020-03-16T06:05:36Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDg5NTg1OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzowNDoxNVrOF2nvew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwODozMDoyOFrOF2pzSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxODU1NQ==", "bodyText": "Realize this is the same as current, but if pursuing more benchmarking, maybe worth looking into either having a switch with sixteen cases or a lookup table.", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392818555", "createdAt": "2020-03-16T07:04:15Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;\n+\n+          if (!isEof) {\n+            Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n+            return null;\n+          }\n         }\n+\n+        buffer = 0L;\n+        currentFieldLength = 0;\n+        continue;\n+      } else if (currentField == Field.TRACE_ID && beginIndex + 16 == pos) {\n+        // special casing the only valid non-hyphen at position 16\n+        // we don't guard against all zeros as traceIdHigh can be all zeros for 128-bit\n+        traceIdHigh = buffer;\n+\n+        // This character is the next hex. If it isn't, the next iteration will throw. Either way,\n+        // reset so that we can capture the next 16 characters of the trace ID.\n+        buffer = 0;\n+        currentFieldLength = 0;\n       }\n+\n+      // The rest of this is normal lower-hex decoding\n+      buffer <<= 4;\n+      if (c >= '0' && c <= '9') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyNzIwNA==", "bodyText": "ooo I like", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392827204", "createdAt": "2020-03-16T07:27:14Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;\n+\n+          if (!isEof) {\n+            Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n+            return null;\n+          }\n         }\n+\n+        buffer = 0L;\n+        currentFieldLength = 0;\n+        continue;\n+      } else if (currentField == Field.TRACE_ID && beginIndex + 16 == pos) {\n+        // special casing the only valid non-hyphen at position 16\n+        // we don't guard against all zeros as traceIdHigh can be all zeros for 128-bit\n+        traceIdHigh = buffer;\n+\n+        // This character is the next hex. If it isn't, the next iteration will throw. Either way,\n+        // reset so that we can capture the next 16 characters of the trace ID.\n+        buffer = 0;\n+        currentFieldLength = 0;\n       }\n+\n+      // The rest of this is normal lower-hex decoding\n+      buffer <<= 4;\n+      if (c >= '0' && c <= '9') {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxODU1NQ=="}, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 183}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg1MjI5Ng==", "bodyText": "running benchmarks again now. I did all the other tricks I could think of along the way", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392852296", "createdAt": "2020-03-16T08:30:28Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;\n+\n+          if (!isEof) {\n+            Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n+            return null;\n+          }\n         }\n+\n+        buffer = 0L;\n+        currentFieldLength = 0;\n+        continue;\n+      } else if (currentField == Field.TRACE_ID && beginIndex + 16 == pos) {\n+        // special casing the only valid non-hyphen at position 16\n+        // we don't guard against all zeros as traceIdHigh can be all zeros for 128-bit\n+        traceIdHigh = buffer;\n+\n+        // This character is the next hex. If it isn't, the next iteration will throw. Either way,\n+        // reset so that we can capture the next 16 characters of the trace ID.\n+        buffer = 0;\n+        currentFieldLength = 0;\n       }\n+\n+      // The rest of this is normal lower-hex decoding\n+      buffer <<= 4;\n+      if (c >= '0' && c <= '9') {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxODU1NQ=="}, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 183}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDkwNDA5OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzowNjoxOVrOF2n0mw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzozMToyNFrOF2oWpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxOTg2Nw==", "bodyText": "Think it's helpful to have one of\nassert currentField == Field.PARENT_SPAN_ID;\n// Parent Span ID", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392819867", "createdAt": "2020-03-16T07:06:19Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 159}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyODU4MQ==", "bodyText": "yeah intellij kept getting mad at me for the redundant else if. this is better though", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392828581", "createdAt": "2020-03-16T07:31:24Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgxOTg2Nw=="}, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 159}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDkxOTM0OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzoxMjozMFrOF2n-rg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzozMDoyN1rOF2oVWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyMjQ0Ng==", "bodyText": "Reasoning this continue out is tough since it's buried among much code. IIUC, this just avoids a single buffer = 0L so maybe not worth special casing?", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392822446", "createdAt": "2020-03-16T07:12:30Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyODI0OQ==", "bodyText": "this was fuzz indeed.. good eye!", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392828249", "createdAt": "2020-03-16T07:30:27Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyMjQ0Ng=="}, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 155}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNDkyMDk4OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzoxMzoyOFrOF2n_uw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwNzozMjoyN1rOF2oYBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyMjcxNQ==", "bodyText": "The above if block is huge so I'd add a comment\n  continue;\n}\n\n// Not a hyphen\n\nif (currentField == Field.TRACE_ID...", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392822715", "createdAt": "2020-03-16T07:13:28Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;\n+\n+          if (!isEof) {\n+            Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n+            return null;\n+          }\n         }\n+\n+        buffer = 0L;\n+        currentFieldLength = 0;\n+        continue;\n+      } else if (currentField == Field.TRACE_ID && beginIndex + 16 == pos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 170}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyODkzNA==", "bodyText": "good idea", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392828934", "createdAt": "2020-03-16T07:32:27Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,79 +171,98 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n-      if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n-        }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n-      }\n-    }\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n \n-    if (indexOfFirstHyphen == -1) {\n-      Platform.get().log(\"Truncated reading trace ID\", null);\n-      return null;\n-    } else if (hyphenCount > 3) {\n-      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n-      return null;\n-    }\n+    Field currentField = Field.TRACE_ID;\n+    int currentFieldLength = 0;\n+    long buffer = 0L;\n \n-    int pos = beginIndex;\n-\n-    long traceIdHigh, traceId;\n-    int traceIdLength = indexOfFirstHyphen - beginIndex;\n-    if (traceIdLength == 32) {\n-      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n-      pos += 16; // upper 64 bits of the trace ID\n-    } else if (traceIdLength == 16) {\n-      traceIdHigh = 0L;\n-    } else {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n-      return null;\n-    }\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n \n-    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n-    if (traceId == 0) return null;\n-    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+      if (c == '-') {\n+        if (currentField == Field.SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = Field.PARENT_SPAN_ID;\n+          }\n+        }\n \n-    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n-    if (spanId == 0) return null;\n-    pos += 16; // spanid\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n \n-    int flags = 0;\n-    long parentId = 0L;\n-    if (hyphenCount > 1) { // traceid-spanid-\n-      pos++; // consume the hyphen\n-\n-      if (hyphenCount == 3) { // we should parse sampled AND parent ID\n-        flags = tryParseSampledFlags(value, endIndex, pos);\n-        if (flags == 0) return null;\n-        pos += 2; // consume the sampled flag and hyphen\n-        parentId = tryParseParentId(value, endIndex, pos);\n-        if (parentId == 0L) return null;\n-      } else { // we should parse sampled OR parent ID\n-        if (endIndex - pos <= 1) {\n-          flags = tryParseSampledFlags(value, endIndex, pos);\n-          if (flags == 0) return null;\n+        if (currentField.required && buffer == 0L) {\n+          Platform.get().log(\"Invalid input: read all zeroes {0}\", currentField.name, null);\n+          return null;\n+        }\n+\n+        if (currentField.equals(Field.TRACE_ID)) {\n+          traceId = buffer;\n+\n+          currentField = Field.SPAN_ID;\n+        } else if (currentField.equals(Field.SPAN_ID)) {\n+          spanId = buffer;\n+\n+          // The handle malformed cases like below, it is easier to assume the next field is sampled\n+          // and revert if definitely not vs try to determine if it is definitely sampled.\n+          // 'traceId-spanId--parentSpanId'\n+          // 'traceId-spanId-'\n+          currentField = Field.SAMPLED;\n+        } else if (currentField.equals(Field.SAMPLED)) {\n+          SamplingFlags samplingFlags = tryParseSamplingFlags(value.charAt(pos - 1));\n+          if (samplingFlags == null) return null;\n+          flags = samplingFlags.flags;\n+\n+          currentField = Field.PARENT_SPAN_ID;\n+          currentFieldLength = 0;\n+          continue;\n         } else {\n-          parentId = tryParseParentId(value, endIndex, pos);\n-          if (parentId == 0L) return null;\n+          parentId = buffer;\n+\n+          if (!isEof) {\n+            Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n+            return null;\n+          }\n         }\n+\n+        buffer = 0L;\n+        currentFieldLength = 0;\n+        continue;\n+      } else if (currentField == Field.TRACE_ID && beginIndex + 16 == pos) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjgyMjcxNQ=="}, "originalCommit": {"oid": "0ae33e296967aec8378715a5417d2626848d1172"}, "originalPosition": 170}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTM0NTU0OnYy", "diffSide": "RIGHT", "path": "brave-tests/src/main/java/brave/test/propagation/B3SingleFormatClassLoaderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo0MDo0NFrOF2sDag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo0MDo0NFrOF2sDag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4OTE5NA==", "bodyText": "added this because we usually do when we use thread locals", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392889194", "createdAt": "2020-03-16T09:40:44Z", "author": {"login": "codefromthecrypt"}, "path": "brave-tests/src/main/java/brave/test/propagation/B3SingleFormatClassLoaderTest.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.test.propagation;\n+\n+import brave.propagation.B3SingleFormat;\n+import org.junit.Test;\n+\n+import static brave.test.util.ClassLoaders.assertRunIsUnloadable;\n+\n+public class B3SingleFormatClassLoaderTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5856dcb979be070310c6435068c72b762a849546"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQzNTM1MDUxOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo0MTo1NVrOF2sGUg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xNlQwOTo0MTo1NVrOF2sGUg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Mjg4OTkzOA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        // The handle malformed cases like below, it is easier to assume the next field is\n          \n          \n            \n                        // To handle malformed cases like below, it is easier to assume the next field is", "url": "https://github.com/openzipkin/brave/pull/1115#discussion_r392889938", "createdAt": "2020-03-16T09:41:55Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -158,81 +161,118 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value\n       Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n     } else if (length == 1) { // possibly sampling flags\n-      return tryParseSamplingFlags(value.charAt(beginIndex));\n+      SamplingFlags flags = tryParseSamplingFlags(value.charAt(beginIndex));\n+      return flags != null ? TraceContextOrSamplingFlags.create(flags) : null;\n     } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n-    // they need to consider, and if there are not enough or too many fields.\n-    int hyphenCount = 0;\n-    int indexOfFirstHyphen = -1;\n-    for (int i = beginIndex; i < endIndex; i++) {\n-      char c = value.charAt(i);\n+    long traceIdHigh = 0L, traceId = 0L, spanId = 0L, parentId = 0L;\n+    int flags = 0;\n+\n+    // Assume it is a 128-bit trace ID and revise back as necessary\n+    int currentField = FIELD_TRACE_ID_HIGH, currentFieldLength = 0;\n+    // Used for hex-decoding, performed by bitwise addition\n+    long buffer = 0L;\n+\n+    // Instead of pos < endIndex, this uses pos <= endIndex to keep field processing consolidated.\n+    // Otherwise, we'd have to process again when outside the loop to handle dangling data on EOF.\n+    for (int pos = beginIndex; pos <= endIndex; pos++) {\n+      // treat EOF same as a hyphen for simplicity\n+      boolean isEof = pos == endIndex;\n+      char c = isEof ? '-' : value.charAt(pos);\n+\n       if (c == '-') {\n-        if (indexOfFirstHyphen == -1) {\n-          indexOfFirstHyphen = i;\n+        if (currentField == FIELD_SAMPLED) {\n+          // The last field could be sampled or parent ID. Revise assumption if longer than 1 char.\n+          if (isEof && currentFieldLength > 1) {\n+            currentField = FIELD_PARENT_SPAN_ID;\n+          }\n+        } else if (currentField == FIELD_TRACE_ID_HIGH) {\n+          // We reached a hyphen before the 17th hex character. This means it is a 64-bit trace ID.\n+          currentField = FIELD_TRACE_ID;\n         }\n-        hyphenCount++;\n-      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n-        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n-        return null;\n+\n+        if (!validateFieldLength(currentField, currentFieldLength)) {\n+          return null;\n+        }\n+\n+        switch (currentField) {\n+          case FIELD_TRACE_ID:\n+            traceId = buffer;\n+\n+            currentField = FIELD_SPAN_ID;\n+            break;\n+          case FIELD_SPAN_ID:\n+            spanId = buffer;\n+\n+            // The handle malformed cases like below, it is easier to assume the next field is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5856dcb979be070310c6435068c72b762a849546"}, "originalPosition": 89}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1562, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}