{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg3NTkzODAw", "number": 1114, "title": "Fixes bugs in B3 single parsing and completes coverage", "bodyText": "This hardens the code, as it formerly conflated missing fields or too many fields with truncation in general. It also formerly checked valid characters in multiple places.\nIt sporadically mentioned an offset, which is not helpful as the source is not logged and is often a reusable buffer. Instead, this mentions the field that had an error as opposed to the string position.\nThis is preparation for the trace context format as it is a simplification of the B3 single code.", "createdAt": "2020-03-13T05:05:07Z", "url": "https://github.com/openzipkin/brave/pull/1114", "merged": true, "mergeCommit": {"oid": "413718f4a60fd7e19c138bda61c2d0c4ea8615c1"}, "closed": true, "closedAt": "2020-03-13T08:09:45Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcNI-REgH2gAyMzg3NTkzODAwOjcxN2NjMmU1ZGRkNTE4NzRiNzE4ZTNmYmMxYzBjNDdiNmUxNTY4NTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNLijuAFqTM3NDEwMjU3OQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "717cc2e5ddd51874b718e3fbc1c0c47b6e156852", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/717cc2e5ddd51874b718e3fbc1c0c47b6e156852", "committedDate": "2020-03-13T04:54:21Z", "message": "Fixes bugs in B3 single parsing and completes coverage"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5ba130facad712541ff28b581b574d355bf1cd04", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/5ba130facad712541ff28b581b574d355bf1cd04", "committedDate": "2020-03-13T05:05:17Z", "message": "dead"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6507edaf85ae6cc071b049c003b497fd93c215a1", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/6507edaf85ae6cc071b049c003b497fd93c215a1", "committedDate": "2020-03-13T05:07:58Z", "message": "copy/paste fail"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64d960ef33d2d56824adf23d976354212c54407e", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/64d960ef33d2d56824adf23d976354212c54407e", "committedDate": "2020-03-13T05:59:39Z", "message": "more fuzz"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6797b668ca300cd84fd533c330caf98b3b5d6796", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/6797b668ca300cd84fd533c330caf98b3b5d6796", "committedDate": "2020-03-13T06:01:22Z", "message": "another fuzz"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MDY1NTA0", "url": "https://github.com/openzipkin/brave/pull/1114#pullrequestreview-374065504", "createdAt": "2020-03-13T06:00:19Z", "commit": {"oid": "64d960ef33d2d56824adf23d976354212c54407e"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNjowMDoxOVrOF14cFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNjowMDo1NFrOF14crw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0MzU0Mg==", "bodyText": "the sequence isn't necessarily all lowerHex", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392043542", "createdAt": "2020-03-13T06:00:19Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/HexCodec.java", "diffHunk": "@@ -33,19 +33,36 @@ public static long lowerHexToUnsignedLong(CharSequence lowerHex) {\n   /**\n    * Parses a 16 character lower-hex string with no prefix into an unsigned long, starting at the\n    * specified index.\n+   *\n+   * <p>This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a lower-hex encoded unsigned long.\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first lower-hex character representing the unsigned long.\n    */\n-  public static long lowerHexToUnsignedLong(CharSequence lowerHex, int index) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64d960ef33d2d56824adf23d976354212c54407e"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0MzY5NQ==", "bodyText": "the sequence isn't necessarily all b3 data", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392043695", "createdAt": "2020-03-13T06:00:54Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -135,106 +135,114 @@ static int writeB3SingleFormat(TraceContext context, long parentId, char[] resul\n   }\n \n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n-    return parseB3SingleFormat(b3, 0, b3.length());\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value) {\n+    return parseB3SingleFormat(value, 0, value.length());\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64d960ef33d2d56824adf23d976354212c54407e"}, "originalPosition": 38}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MDY1NzM4", "url": "https://github.com/openzipkin/brave/pull/1114#pullrequestreview-374065738", "createdAt": "2020-03-13T06:01:09Z", "commit": {"oid": "64d960ef33d2d56824adf23d976354212c54407e"}, "state": "APPROVED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNjowNTozMVrOF14g3w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNjoyMTo0MFrOF14wSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0NDc2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  pos++; // consume the delimiter\n          \n          \n            \n                  pos++; // consume the hyphen", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392044767", "createdAt": "2020-03-13T06:05:31Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,101 +140,109 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n+    int length = endIndex - beginIndex;\n \n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n-\n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (hyphenCount < 1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseId(\"trace\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseId(\"span\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n     if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n+      pos++; // consume the delimiter", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6797b668ca300cd84fd533c330caf98b3b5d6796"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0NjkxNg==", "bodyText": "If the precision in the error messages isn't important, it might be nice to have these checks in the validation loop above so it's all together.", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392046916", "createdAt": "2020-03-13T06:14:47Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,101 +140,109 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n+    int length = endIndex - beginIndex;\n \n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n-\n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (hyphenCount < 1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseId(\"trace\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseId(\"span\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n     if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n+      pos++; // consume the delimiter\n+\n+      if (endIndex == pos) { // traceid-spanid-\n+        Platform.get().log(\"Truncated after reading span ID\", null);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6797b668ca300cd84fd533c330caf98b3b5d6796"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0NzYzMw==", "bodyText": "My mind is being blown by nextChar and nextPos not being the same position here. Is it possible to remove nextPos for readability?", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392047633", "createdAt": "2020-03-13T06:17:43Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,101 +140,109 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n+    int length = endIndex - beginIndex;\n \n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n-\n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (hyphenCount < 1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseId(\"trace\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseId(\"span\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n     if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n+      pos++; // consume the delimiter\n+\n+      if (endIndex == pos) { // traceid-spanid-\n+        Platform.get().log(\"Truncated after reading span ID\", null);\n         return null;\n       }\n \n-      // If we are at this point, we have more than just traceId-spanId.\n-      // If the sampling field is present, we'll have a delimiter 2 characters from now. Ex \"-1\"\n-      // If it is absent, but a parent ID is (which is strange), we'll have at least 17 characters.\n-      // Therefore, if we have less than two characters, the input is truncated.\n-      if (endIndex == pos + 1) {\n-        Platform.get().log(\"Invalid input: truncated\", null);\n+      char nextChar = value.charAt(pos);\n+      if (nextChar == '-') { // traceid-spanid--...\n+        Platform.get().log(\"Invalid input: empty sampled field\", null);\n         return null;\n       }\n-      if (!checkHyphen(b3, pos++)) return null;\n \n-      // If our position is at the end of the string, or another delimiter is one character past our\n-      // position, try to read sampled status.\n-      boolean afterSampledField = notHexFollowsPos(b3, pos, endIndex);\n-      if (endIndex == pos + 1 || afterSampledField) {\n-        flags = parseFlags(b3, pos);\n+      // At this point, we are either at the sampling field, or first character of the parentId\n+      int nextPos = pos + 1;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6797b668ca300cd84fd533c330caf98b3b5d6796"}, "originalPosition": 161}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0ODA2Mg==", "bodyText": "Think this is supposed to be pos - if not then minutes of staring still hasn't let my brain fully grok nextPos", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392048062", "createdAt": "2020-03-13T06:19:22Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,101 +140,109 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n+    int length = endIndex - beginIndex;\n \n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n-\n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (hyphenCount < 1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseId(\"trace\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseId(\"span\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n     if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n+      pos++; // consume the delimiter\n+\n+      if (endIndex == pos) { // traceid-spanid-\n+        Platform.get().log(\"Truncated after reading span ID\", null);\n         return null;\n       }\n \n-      // If we are at this point, we have more than just traceId-spanId.\n-      // If the sampling field is present, we'll have a delimiter 2 characters from now. Ex \"-1\"\n-      // If it is absent, but a parent ID is (which is strange), we'll have at least 17 characters.\n-      // Therefore, if we have less than two characters, the input is truncated.\n-      if (endIndex == pos + 1) {\n-        Platform.get().log(\"Invalid input: truncated\", null);\n+      char nextChar = value.charAt(pos);\n+      if (nextChar == '-') { // traceid-spanid--...\n+        Platform.get().log(\"Invalid input: empty sampled field\", null);\n         return null;\n       }\n-      if (!checkHyphen(b3, pos++)) return null;\n \n-      // If our position is at the end of the string, or another delimiter is one character past our\n-      // position, try to read sampled status.\n-      boolean afterSampledField = notHexFollowsPos(b3, pos, endIndex);\n-      if (endIndex == pos + 1 || afterSampledField) {\n-        flags = parseFlags(b3, pos);\n+      // At this point, we are either at the sampling field, or first character of the parentId\n+      int nextPos = pos + 1;\n+      boolean hasSampledAndParent = hyphenCount == 3;\n+      if (nextPos == endIndex || hasSampledAndParent) {\n+        flags = parseSampledFlags(nextChar);\n+        pos++; // consume the sampled field\n         if (flags == 0) return null;\n-        pos++; // consume the sampled status\n-        if (afterSampledField && !checkHyphen(b3, pos++)) return null; // consume the delimiter\n+        if (hasSampledAndParent && value.charAt(pos++) != '-') {\n+          Platform.get().log(\"Invalid input: sampled is too long\", null);\n+          return null;\n+        }\n       }\n \n-      if (endIndex > pos || afterSampledField) {\n+      if (endIndex > nextPos) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6797b668ca300cd84fd533c330caf98b3b5d6796"}, "originalPosition": 176}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA0ODcxNA==", "bodyText": "Not sure if this method is used elsewhere - but at a glance it seems this duplicates some validation with the validation code in parseB3SingleFormat. Maybe fine to be safer than sorry though.", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392048714", "createdAt": "2020-03-13T06:21:40Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -251,69 +259,48 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, i\n   }\n \n   /** Returns zero if truncated, malformed, or too big after logging */\n-  static long tryParseParentId(CharSequence b3, int pos, int endIndex) {\n-    if (endIndex < pos + 16) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+  static long tryParseId(String name, CharSequence value, int beginIndex, int endIndex) {\n+    int endOfId = beginIndex + 16;\n+    if (beginIndex == endIndex || value.charAt(beginIndex) == '-') {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6797b668ca300cd84fd533c330caf98b3b5d6796"}, "originalPosition": 192}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8b3b9bd38f3cb2b8629adcf3c5f4d0276da5f3d8", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/8b3b9bd38f3cb2b8629adcf3c5f4d0276da5f3d8", "committedDate": "2020-03-13T06:29:32Z", "message": "Update brave/src/main/java/brave/propagation/B3SingleFormat.java\n\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1a15b6bfd31c37bf7da605dc2a5bfd952b309e80", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/1a15b6bfd31c37bf7da605dc2a5bfd952b309e80", "committedDate": "2020-03-13T07:49:26Z", "message": "another pass"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc0MTAyNTc5", "url": "https://github.com/openzipkin/brave/pull/1114#pullrequestreview-374102579", "createdAt": "2020-03-13T07:52:36Z", "commit": {"oid": "1a15b6bfd31c37bf7da605dc2a5bfd952b309e80"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNzo1MjozNlrOF16Vxg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0xM1QwNzo1MjozNlrOF16Vxg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MjA3NDY5NA==", "bodyText": "Thanks this is very clear now!", "url": "https://github.com/openzipkin/brave/pull/1114#discussion_r392074694", "createdAt": "2020-03-13T07:52:36Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/B3SingleFormat.java", "diffHunk": "@@ -140,102 +140,96 @@ public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3) {\n   }\n \n   /**\n-   * @param beginIndex the start index, inclusive\n-   * @param endIndex the end index, exclusive\n+   * This reads a trace context a sequence potentially larger than the format. The use-case is\n+   * reducing garbage, by re-using the input {@code value} across multiple parse operations.\n+   *\n+   * @param value the sequence that contains a B3 single formatted trace context\n+   * @param beginIndex the inclusive begin index: {@linkplain CharSequence#charAt(int) index} of the\n+   * first character in B3 single format.\n+   * @param endIndex the exclusive end index: {@linkplain CharSequence#charAt(int) index}\n+   * <em>after</em> the last character in B3 single format.\n    */\n   @Nullable\n-  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence b3, int beginIndex,\n+  public static TraceContextOrSamplingFlags parseB3SingleFormat(CharSequence value, int beginIndex,\n     int endIndex) {\n-    if (beginIndex == endIndex) {\n-      Platform.get().log(\"Invalid input: empty\", null);\n-      return null;\n-    }\n-\n-    int pos = beginIndex;\n-    if (pos + 1 == endIndex) { // possibly sampling flags\n-      return tryParseSamplingFlags(b3, pos);\n-    }\n+    int length = endIndex - beginIndex;\n \n-    // At this point we minimally expect a traceId-spanId pair\n-    if (endIndex < 16 + 1 + 16 /* traceid64-spanid */) {\n-      Platform.get().log(\"Invalid input: truncated\", null);\n+    if (length == 0) {\n+      Platform.get().log(\"Invalid input: empty\", null);\n       return null;\n-    } else if (endIndex > FORMAT_MAX_LENGTH) {\n+    } else if (length == 1) { // possibly sampling flags\n+      return tryParseSamplingFlags(value.charAt(beginIndex));\n+    } else if (length > FORMAT_MAX_LENGTH) {\n       Platform.get().log(\"Invalid input: too long\", null);\n       return null;\n     }\n \n-    // Cheaply check for only ASCII characters. This allows for more precise messages later, but\n-    // kicks out early on data such as unicode.\n+    // This initial scan helps simplify other parsing logic by constraining the amount of characters\n+    // they need to consider, and if there are not enough or too many fields.\n+    int hyphenCount = 0;\n+    int indexOfFirstHyphen = -1;\n     for (int i = beginIndex; i < endIndex; i++) {\n-      if (b3.charAt(i) >= 128) {\n-        Platform.get().log(\"Invalid input: non-ASCII character at offset {0}\", i, null);\n+      char c = value.charAt(i);\n+      if (c == '-') {\n+        if (indexOfFirstHyphen == -1) {\n+          indexOfFirstHyphen = i;\n+        }\n+        hyphenCount++;\n+      } else if ((c < '0' || c > '9') && (c < 'a' || c > 'f')) {\n+        Platform.get().log(\"Invalid input: only valid characters are lower-hex and hyphen\", null);\n         return null;\n       }\n     }\n \n-    long traceIdHigh, traceId;\n-    if (b3.charAt(pos + 32) == '-') {\n-      traceIdHigh = tryParse16HexCharacters(b3, pos, endIndex);\n-      pos += 16; // upper 64 bits of the trace ID\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    } else {\n-      traceIdHigh = 0L;\n-      traceId = tryParse16HexCharacters(b3, pos, endIndex);\n-    }\n-    pos += 16; // traceId\n-\n-    if (traceIdHigh == 0L && traceId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID at offset 0\", null);\n+    if (indexOfFirstHyphen == -1) {\n+      Platform.get().log(\"Truncated reading trace ID\", null);\n       return null;\n-    }\n-\n-    if (isLowerHex(b3.charAt(pos))) {\n-      Platform.get().log(\"Invalid input: trace ID is too long\", null);\n+    } else if (hyphenCount > 3) {\n+      Platform.get().log(\"Invalid input: more than 4 fields exist\", null);\n       return null;\n     }\n \n-    if (!checkHyphen(b3, pos++)) return null;\n+    int pos = beginIndex;\n \n-    long spanId = tryParse16HexCharacters(b3, pos, endIndex);\n-    if (spanId == 0L) {\n-      Platform.get().log(\"Invalid input: expected a 16 lower hex span ID at offset {0}\", pos, null);\n+    long traceIdHigh, traceId;\n+    int traceIdLength = indexOfFirstHyphen - beginIndex;\n+    if (traceIdLength == 32) {\n+      traceIdHigh = lenientLowerHexToUnsignedLong(value, pos, pos + 16);\n+      pos += 16; // upper 64 bits of the trace ID\n+    } else if (traceIdLength == 16) {\n+      traceIdHigh = 0L;\n+    } else {\n+      Platform.get().log(\"Invalid input: expected a 16 or 32 lower hex trace ID\", null);\n       return null;\n     }\n+\n+    traceId = tryParseHex(\"trace ID\", value, pos, endIndex);\n+    if (traceId == 0) return null;\n+    pos += 17; // lower 64 bits of the trace ID and the hyphen\n+\n+    long spanId = tryParseHex(\"span ID\", value, pos, endIndex);\n+    if (spanId == 0) return null;\n     pos += 16; // spanid\n \n     int flags = 0;\n     long parentId = 0L;\n-    if (endIndex > pos) {\n-      if (isLowerHex(b3.charAt(pos))) {\n-        Platform.get().log(\"Invalid input: span ID is too long\", null);\n-        return null;\n-      }\n+    if (hyphenCount > 1) { // traceid-spanid-\n+      pos++; // consume the hyphen\n \n-      // If we are at this point, we have more than just traceId-spanId.\n-      // If the sampling field is present, we'll have a delimiter 2 characters from now. Ex \"-1\"\n-      // If it is absent, but a parent ID is (which is strange), we'll have at least 17 characters.\n-      // Therefore, if we have less than two characters, the input is truncated.\n-      if (endIndex == pos + 1) {\n-        Platform.get().log(\"Invalid input: truncated\", null);\n-        return null;\n-      }\n-      if (!checkHyphen(b3, pos++)) return null;\n-\n-      // If our position is at the end of the string, or another delimiter is one character past our\n-      // position, try to read sampled status.\n-      boolean afterSampledField = notHexFollowsPos(b3, pos, endIndex);\n-      if (endIndex == pos + 1 || afterSampledField) {\n-        flags = parseFlags(b3, pos);\n+      if (hyphenCount == 3) { // we should parse sampled AND parent ID", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1a15b6bfd31c37bf7da605dc2a5bfd952b309e80"}, "originalPosition": 155}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1868, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}