{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0MDAwNDYw", "number": 1192, "title": "Extracts MapExtra from BaggageFields and decouples tests", "bodyText": "Before, all coverage of \"extra\" routed through BaggageFields.\nIncidentally, it also used tracer when it didn't need to. This pulls\nup MapExtra so that the concerns around maps are decoupled from\nBaggageFields. This will allow us to reuse the bulk of the code in\ntrace-context format and secondary sampling.", "createdAt": "2020-05-06T10:09:08Z", "url": "https://github.com/openzipkin/brave/pull/1192", "merged": true, "mergeCommit": {"oid": "146718760740c1947aff52820a146390b909dac2"}, "closed": true, "closedAt": "2020-05-06T13:39:17Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 15, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcel1FmgH2gAyNDE0MDAwNDYwOjEzYzIzY2Q0OWNkZWE0ZjJiOTFhMzBjODg1ZWM3NjEzNTc1NWIwMGY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABceoRfXgFqTQwNjU4NTk0Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "13c23cd49cdea4f2b91a30c885ec76135755b00f", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/13c23cd49cdea4f2b91a30c885ec76135755b00f", "committedDate": "2020-05-06T10:08:17Z", "message": "Extracts MapExtra from BaggageFields and decouples tests\n\nBefore, all coverage of \"extra\" routed through BaggageFields.\nIncidentally, it also used tracer when it didn't need to. This pulls\nup `MapExtra` so that the concerns around maps are decoupled from\n`BaggageFields`. This will allow us to reuse the bulk of the code in\ntrace-context format and secondary sampling."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDcyNTI1", "url": "https://github.com/openzipkin/brave/pull/1192#pullrequestreview-406472525", "createdAt": "2020-05-06T10:09:46Z", "commit": {"oid": "13c23cd49cdea4f2b91a30c885ec76135755b00f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDowOTo0NlrOGRMRaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDowOTo0NlrOGRMRaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4MDA0Mw==", "bodyText": "you'll notice while the generics are a bit wild in the base type, the eventual result is fairly simple.", "url": "https://github.com/openzipkin/brave/pull/1192#discussion_r420680043", "createdAt": "2020-05-06T10:09:46Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/baggage/BaggageFields.java", "diffHunk": "@@ -14,29 +14,25 @@\n package brave.internal.baggage;\n \n import brave.baggage.BaggageField;\n-import brave.internal.Nullable;\n-import brave.internal.Platform;\n-import brave.internal.collect.LongBitSet;\n import brave.internal.collect.UnsafeArrayMap;\n import brave.internal.collect.UnsafeArrayMap.Mapper;\n+import brave.internal.extra.MapExtra;\n+import brave.internal.extra.MapExtraFactory;\n import brave.propagation.TraceContext;\n import brave.propagation.TraceContextOrSamplingFlags;\n import java.util.ArrayList;\n-import java.util.Arrays;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n \n-import static brave.internal.baggage.BaggageFieldsHandler.MAX_DYNAMIC_FIELDS;\n-import static brave.internal.collect.LongBitSet.isSet;\n-import static brave.internal.collect.LongBitSet.setBit;\n-\n /**\n  * Holds one or more baggage fields in {@link TraceContext#extra()} or {@link\n  * TraceContextOrSamplingFlags#extra()}.\n  */\n-public final class BaggageFields extends Extra<BaggageFields, BaggageFieldsFactory>\n+public final class BaggageFields\n+    extends MapExtra<BaggageField, String, BaggageFields, BaggageFields.Factory>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c23cd49cdea4f2b91a30c885ec76135755b00f"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDczMTIz", "url": "https://github.com/openzipkin/brave/pull/1192#pullrequestreview-406473123", "createdAt": "2020-05-06T10:10:38Z", "commit": {"oid": "13c23cd49cdea4f2b91a30c885ec76135755b00f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxMDozOFrOGRMTDw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxMDozOFrOGRMTDw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4MDQ2Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Returns a possibly set of all keys even if values are {@code null}. */\n          \n          \n            \n              /** Returns a possibly empty set of all keys even if values are {@code null}. */", "url": "https://github.com/openzipkin/brave/pull/1192#discussion_r420680463", "createdAt": "2020-05-06T10:10:38Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/extra/MapExtra.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.extra;\n+\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.internal.collect.LongBitSet;\n+import brave.internal.collect.UnsafeArrayMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static brave.internal.collect.LongBitSet.isSet;\n+import static brave.internal.collect.LongBitSet.setBit;\n+import static brave.internal.extra.MapExtraFactory.MAX_DYNAMIC_ENTRIES;\n+\n+public class MapExtra<K, V, A extends MapExtra<K, V, A, F>,\n+    F extends MapExtraFactory<K, V, A, F>> extends Extra<A, F> {\n+  protected MapExtra(F factory) {\n+    super(factory);\n+  }\n+\n+  Object[] state() {\n+    return (Object[]) state;\n+  }\n+\n+  /** When true, calls to {@link #asReadOnlyMap()}, {@link Map#keySet()} cannot be cached. */\n+  public final boolean isDynamic() {\n+    return factory.maxDynamicEntries > 0;\n+  }\n+\n+  /** Returns a possibly set of all keys even if values are {@code null}. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13c23cd49cdea4f2b91a30c885ec76135755b00f"}, "originalPosition": 45}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3f77e2c905e2f6571b5b530b33f4bcd15f2d0c76", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/3f77e2c905e2f6571b5b530b33f4bcd15f2d0c76", "committedDate": "2020-05-06T10:10:44Z", "message": "Update brave/src/main/java/brave/internal/extra/MapExtra.java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1cb7c5582cc4351a261c4e00d28649747e7f431", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/e1cb7c5582cc4351a261c4e00d28649747e7f431", "committedDate": "2020-05-06T10:14:08Z", "message": "less blinding"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "264cf771b9ab791866643e5d4d780f387d5dd521", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/264cf771b9ab791866643e5d4d780f387d5dd521", "committedDate": "2020-05-06T10:15:53Z", "message": "dead code"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDc2OTU2", "url": "https://github.com/openzipkin/brave/pull/1192#pullrequestreview-406476956", "createdAt": "2020-05-06T10:16:29Z", "commit": {"oid": "264cf771b9ab791866643e5d4d780f387d5dd521"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxNjoyOVrOGRMedQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxNjoyOVrOGRMedQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4MzM4MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Returns a possibly empty map of all name to non-{@code null} values. */\n          \n          \n            \n              /** Returns a possibly empty map of all key to non-{@code null} values. */", "url": "https://github.com/openzipkin/brave/pull/1192#discussion_r420683381", "createdAt": "2020-05-06T10:16:29Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/extra/MapExtra.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.extra;\n+\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.internal.collect.LongBitSet;\n+import brave.internal.collect.UnsafeArrayMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static brave.internal.collect.LongBitSet.isSet;\n+import static brave.internal.collect.LongBitSet.setBit;\n+import static brave.internal.extra.MapExtraFactory.MAX_DYNAMIC_ENTRIES;\n+\n+public class MapExtra<K, V, A extends MapExtra<K, V, A, F>,\n+    F extends MapExtraFactory<K, V, A, F>> extends Extra<A, F> {\n+  protected MapExtra(F factory) {\n+    super(factory);\n+  }\n+\n+  Object[] state() {\n+    return (Object[]) state;\n+  }\n+\n+  /** When true, calls to {@link #asReadOnlyMap()}, {@link Map#keySet()} cannot be cached. */\n+  public final boolean isDynamic() {\n+    return factory.maxDynamicEntries > 0;\n+  }\n+\n+  /** Returns a possibly empty set of all keys even if values are {@code null}. */\n+  public Set<K> keySet() {\n+    if (!isDynamic()) return factory.initialFieldIndices.keySet();\n+    Object[] state = state();\n+    Set<K> result = new LinkedHashSet<>(state.length / 2);\n+    for (int i = 0; i < state.length; i += 2) {\n+      result.add((K) state[i]);\n+    }\n+    return Collections.unmodifiableSet(result);\n+  }\n+\n+  /** Returns a possibly empty map of all name to non-{@code null} values. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "264cf771b9ab791866643e5d4d780f387d5dd521"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4135a803587b643ebe1778d57545b98b72c93a41", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/4135a803587b643ebe1778d57545b98b72c93a41", "committedDate": "2020-05-06T10:16:33Z", "message": "Update brave/src/main/java/brave/internal/extra/MapExtra.java"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDc3NDUx", "url": "https://github.com/openzipkin/brave/pull/1192#pullrequestreview-406477451", "createdAt": "2020-05-06T10:17:16Z", "commit": {"oid": "4135a803587b643ebe1778d57545b98b72c93a41"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxNzoxNlrOGRMf5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxNzoxNlrOGRMf5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4Mzc1MQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Updates the value of the field, or ignores if read-only or not configured.\n          \n          \n            \n               * Updates the value of the {@code key}, or ignores if read-only or not configured.", "url": "https://github.com/openzipkin/brave/pull/1192#discussion_r420683751", "createdAt": "2020-05-06T10:17:16Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/extra/MapExtra.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.extra;\n+\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.internal.collect.LongBitSet;\n+import brave.internal.collect.UnsafeArrayMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static brave.internal.collect.LongBitSet.isSet;\n+import static brave.internal.collect.LongBitSet.setBit;\n+import static brave.internal.extra.MapExtraFactory.MAX_DYNAMIC_ENTRIES;\n+\n+public class MapExtra<K, V, A extends MapExtra<K, V, A, F>,\n+    F extends MapExtraFactory<K, V, A, F>> extends Extra<A, F> {\n+  protected MapExtra(F factory) {\n+    super(factory);\n+  }\n+\n+  Object[] state() {\n+    return (Object[]) state;\n+  }\n+\n+  /** When true, calls to {@link #asReadOnlyMap()}, {@link Map#keySet()} cannot be cached. */\n+  public final boolean isDynamic() {\n+    return factory.maxDynamicEntries > 0;\n+  }\n+\n+  /** Returns a possibly empty set of all keys even if values are {@code null}. */\n+  public Set<K> keySet() {\n+    if (!isDynamic()) return factory.initialFieldIndices.keySet();\n+    Object[] state = state();\n+    Set<K> result = new LinkedHashSet<>(state.length / 2);\n+    for (int i = 0; i < state.length; i += 2) {\n+      result.add((K) state[i]);\n+    }\n+    return Collections.unmodifiableSet(result);\n+  }\n+\n+  /** Returns a possibly empty map of all key to non-{@code null} values. */\n+  public Map<K, V> asReadOnlyMap() {\n+    return UnsafeArrayMap.<K, V>newBuilder().build(state());\n+  }\n+\n+  /** Returns the value of the key with the specified name or {@code null} if not available. */\n+  @Nullable public V get(K key) {\n+    if (key == null) return null;\n+    Object[] state = state();\n+    int i = indexOfExistingKey(state, key);\n+    return i != -1 ? (V) state[i + 1] : null;\n+  }\n+\n+  /**\n+   * Updates the value of the field, or ignores if read-only or not configured.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4135a803587b643ebe1778d57545b98b72c93a41"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDc3ODAx", "url": "https://github.com/openzipkin/brave/pull/1192#pullrequestreview-406477801", "createdAt": "2020-05-06T10:17:49Z", "commit": {"oid": "4135a803587b643ebe1778d57545b98b72c93a41"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxNzo0OVrOGRMg2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxNzo0OVrOGRMg2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4Mzk5Mw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              /** Returns the value of the key with the specified name or {@code null} if not available. */\n          \n          \n            \n              /** Returns the value of the {@code key} or {@code null} if not available. */", "url": "https://github.com/openzipkin/brave/pull/1192#discussion_r420683993", "createdAt": "2020-05-06T10:17:49Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/extra/MapExtra.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.extra;\n+\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.internal.collect.LongBitSet;\n+import brave.internal.collect.UnsafeArrayMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static brave.internal.collect.LongBitSet.isSet;\n+import static brave.internal.collect.LongBitSet.setBit;\n+import static brave.internal.extra.MapExtraFactory.MAX_DYNAMIC_ENTRIES;\n+\n+public class MapExtra<K, V, A extends MapExtra<K, V, A, F>,\n+    F extends MapExtraFactory<K, V, A, F>> extends Extra<A, F> {\n+  protected MapExtra(F factory) {\n+    super(factory);\n+  }\n+\n+  Object[] state() {\n+    return (Object[]) state;\n+  }\n+\n+  /** When true, calls to {@link #asReadOnlyMap()}, {@link Map#keySet()} cannot be cached. */\n+  public final boolean isDynamic() {\n+    return factory.maxDynamicEntries > 0;\n+  }\n+\n+  /** Returns a possibly empty set of all keys even if values are {@code null}. */\n+  public Set<K> keySet() {\n+    if (!isDynamic()) return factory.initialFieldIndices.keySet();\n+    Object[] state = state();\n+    Set<K> result = new LinkedHashSet<>(state.length / 2);\n+    for (int i = 0; i < state.length; i += 2) {\n+      result.add((K) state[i]);\n+    }\n+    return Collections.unmodifiableSet(result);\n+  }\n+\n+  /** Returns a possibly empty map of all key to non-{@code null} values. */\n+  public Map<K, V> asReadOnlyMap() {\n+    return UnsafeArrayMap.<K, V>newBuilder().build(state());\n+  }\n+\n+  /** Returns the value of the key with the specified name or {@code null} if not available. */", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4135a803587b643ebe1778d57545b98b72c93a41"}, "originalPosition": 61}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NDc4MTk0", "url": "https://github.com/openzipkin/brave/pull/1192#pullrequestreview-406478194", "createdAt": "2020-05-06T10:18:25Z", "commit": {"oid": "4135a803587b643ebe1778d57545b98b72c93a41"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxODoyNVrOGRMiEw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNlQxMDoxODoyNVrOGRMiEw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDY4NDMwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Fields are never deleted, only their valuse set {@code null}. This means existing indexes are\n          \n          \n            \n               * Keys are never deleted, only their valuse set {@code null}. This means existing indexes are", "url": "https://github.com/openzipkin/brave/pull/1192#discussion_r420684307", "createdAt": "2020-05-06T10:18:25Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/extra/MapExtra.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.extra;\n+\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.internal.collect.LongBitSet;\n+import brave.internal.collect.UnsafeArrayMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static brave.internal.collect.LongBitSet.isSet;\n+import static brave.internal.collect.LongBitSet.setBit;\n+import static brave.internal.extra.MapExtraFactory.MAX_DYNAMIC_ENTRIES;\n+\n+public class MapExtra<K, V, A extends MapExtra<K, V, A, F>,\n+    F extends MapExtraFactory<K, V, A, F>> extends Extra<A, F> {\n+  protected MapExtra(F factory) {\n+    super(factory);\n+  }\n+\n+  Object[] state() {\n+    return (Object[]) state;\n+  }\n+\n+  /** When true, calls to {@link #asReadOnlyMap()}, {@link Map#keySet()} cannot be cached. */\n+  public final boolean isDynamic() {\n+    return factory.maxDynamicEntries > 0;\n+  }\n+\n+  /** Returns a possibly empty set of all keys even if values are {@code null}. */\n+  public Set<K> keySet() {\n+    if (!isDynamic()) return factory.initialFieldIndices.keySet();\n+    Object[] state = state();\n+    Set<K> result = new LinkedHashSet<>(state.length / 2);\n+    for (int i = 0; i < state.length; i += 2) {\n+      result.add((K) state[i]);\n+    }\n+    return Collections.unmodifiableSet(result);\n+  }\n+\n+  /** Returns a possibly empty map of all key to non-{@code null} values. */\n+  public Map<K, V> asReadOnlyMap() {\n+    return UnsafeArrayMap.<K, V>newBuilder().build(state());\n+  }\n+\n+  /** Returns the value of the key with the specified name or {@code null} if not available. */\n+  @Nullable public V get(K key) {\n+    if (key == null) return null;\n+    Object[] state = state();\n+    int i = indexOfExistingKey(state, key);\n+    return i != -1 ? (V) state[i + 1] : null;\n+  }\n+\n+  /**\n+   * Updates the value of the field, or ignores if read-only or not configured.\n+   *\n+   * @param value {@code null} is an attempt to remove the value\n+   * @return {@code true} if the underlying state changed\n+   * @since 5.12\n+   */\n+  public boolean put(K key, @Nullable V value) {\n+    if (key == null) return false;\n+\n+    int i = indexOfExistingKey(state(), key);\n+    if (i == -1 && factory.maxDynamicEntries == 0) {\n+      Platform.get().log(\"Ignoring request to add a dynamic key\", null);\n+      return false;\n+    }\n+\n+    synchronized (lock) {\n+      Object[] prior = state();\n+\n+      // double-check lost race in dynamic case\n+      if (i == -1) i = indexOfDynamicKey(prior, key);\n+      if (i == -1) return addNewEntry(prior, key, value);\n+\n+      if (equal(value, prior[i + 1])) return false;\n+\n+      Object[] newState = Arrays.copyOf(prior, prior.length); // copy-on-write\n+      newState[i + 1] = value;\n+      this.state = newState;\n+      return true;\n+    }\n+  }\n+\n+  @Override protected void mergeStateKeepingOursOnConflict(A theirFields) {\n+    Object[] ourstate = state(), theirstate = theirFields.state();\n+\n+    // scan first to see if we need to grow our state.\n+    long newToOurs = 0;\n+    for (int i = 0; i < theirstate.length; i += 2) {\n+      if (theirstate[i] == null) break; // end of keys\n+      int ourIndex = indexOfExistingKey(ourstate, (K) theirstate[i]);\n+      if (ourIndex == -1) newToOurs = setBit(newToOurs, i / 2);\n+    }\n+\n+    boolean growthAllowed = true;\n+    int newstateLength = ourstate.length + LongBitSet.size(newToOurs) * 2;\n+    if (newstateLength > ourstate.length) {\n+      if (newstateLength / 2 > factory.maxDynamicEntries) {\n+        Platform.get().log(\"Ignoring request to add > %s dynamic keys\", MAX_DYNAMIC_ENTRIES, null);\n+        growthAllowed = false;\n+      }\n+    }\n+\n+    // To implement copy-on-write, we provision a new state large enough for all changes.\n+    Object[] newState = null;\n+\n+    // Now, we iterate through all changes and apply them\n+    int endOfOurs = ourstate.length;\n+    for (int i = 0; i < theirstate.length; i += 2) {\n+      if (theirstate[i] == null) break; // end of keys\n+      Object theirValue = theirstate[i + 1];\n+\n+      // Check if the current index is a new key\n+      if (isSet(newToOurs, i / 2)) {\n+        if (!growthAllowed) continue;\n+\n+        if (newState == null) newState = Arrays.copyOf(ourstate, newstateLength);\n+        newState[endOfOurs] = theirstate[i];\n+        newState[endOfOurs + 1] = theirValue;\n+        endOfOurs += 2;\n+        continue;\n+      }\n+\n+      // Now, check if this key exists in our state, potentially with the same value.\n+      int ourIndex = indexOfExistingKey(ourstate, (K) theirstate[i]);\n+      assert ourIndex != -1;\n+\n+      // Ensure we don't mutate the state when our value should win\n+      Object ourValue = ourstate[ourIndex + 1];\n+      if (ourValue != null || theirValue == null) continue;\n+\n+      // At this point, we have a change to an existing key, apply it.\n+      if (newState == null) newState = Arrays.copyOf(ourstate, newstateLength);\n+      newState[ourIndex + 1] = theirValue;\n+    }\n+    if (newState != null) state = newState;\n+  }\n+\n+  int indexOfExistingKey(Object[] state, K key) {\n+    int i = indexOfInitialKey(key);\n+    if (i == -1 && factory.maxDynamicEntries > 0) {\n+      i = indexOfDynamicKey(state, key);\n+    }\n+    return i;\n+  }\n+\n+  /**\n+   * Fields are never deleted, only their valuse set {@code null}. This means existing indexes are", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4135a803587b643ebe1778d57545b98b72c93a41"}, "originalPosition": 165}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a47bbd74974332207f41ad60e183ec0a8a9cf44", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/8a47bbd74974332207f41ad60e183ec0a8a9cf44", "committedDate": "2020-05-06T10:18:41Z", "message": "drift"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12640c703ededea842104c93c5d0b9310b114e4e", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/12640c703ededea842104c93c5d0b9310b114e4e", "committedDate": "2020-05-06T10:39:18Z", "message": "adds isEmpty as needed by secondary sampling"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a25435b4ead0112654684c472758d7f8042c17f1", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/a25435b4ead0112654684c472758d7f8042c17f1", "committedDate": "2020-05-06T11:00:53Z", "message": "more protected less symbols"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA2NTg1OTQz", "url": "https://github.com/openzipkin/brave/pull/1192#pullrequestreview-406585943", "createdAt": "2020-05-06T12:59:07Z", "commit": {"oid": "a25435b4ead0112654684c472758d7f8042c17f1"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1724, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}