{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxODU1NjM3", "number": 1148, "title": "Adds SpanHandler", "bodyText": "SpanHandler deprecates FinishedSpanHandler and allows tracking data recorded by brave. Notably, this allows aggregations not formerly possible, such as child counting, and data correlation.", "createdAt": "2020-04-10T10:32:28Z", "url": "https://github.com/openzipkin/brave/pull/1148", "merged": true, "mergeCommit": {"oid": "ae2b26adda5ffd6080f698024a20e81c32c291fe"}, "closed": true, "closedAt": "2020-05-08T11:57:26Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWOoatAFqTM5MTM3OTMwMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfP-AJAH2gAyNDAxODU1NjM3OjkxYTQ5ZWU5MTYzMzQyY2QyZDllNWYyMTZlM2NmODY3NWRiNTZlNTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzc5MzAx", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-391379301", "createdAt": "2020-04-10T10:35:14Z", "commit": {"oid": "b4bd7d0ae5ee4a81fb70a9958d7478506572b912"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDozNToxNFrOGD3KpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQxMDozNToxNFrOGD3KpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjcwMjc1Nw==", "bodyText": "yay we can implement child_span_count in the future with a native brave SpanHandler for stackdriver\ncc @meltsufin @saturnism\nhttps://cloud.google.com/trace/docs/reference/v2/rpc/google.devtools.cloudtrace.v2#google.devtools.cloudtrace.v2.Span", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r406702757", "createdAt": "2020-04-10T10:35:14Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/features/handler/CountingChildrenTest.java", "diffHunk": "@@ -103,7 +104,7 @@\n     assertThat(spans)\n       .extracting(Span::name, s -> s.tags().get(\"childCount\"))\n       .containsExactly(\n-        tuple(\"root1\", \"0\"), tuple(\"root1child1\", \"0\"), tuple(\"root1child2\", \"0\")\n+        tuple(\"root1\", \"2\"), tuple(\"root1child1\", \"0\"), tuple(\"root1child2\", \"0\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b4bd7d0ae5ee4a81fb70a9958d7478506572b912"}, "originalPosition": 20}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1a1b94dcc327f6a5f59df4fbd0f206615a4a619a", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/1a1b94dcc327f6a5f59df4fbd0f206615a4a619a", "committedDate": "2020-04-11T09:32:52Z", "message": "foo"}, "afterCommit": {"oid": "09c5bf58f41e59b7342a653c9024718027ca9b27", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/09c5bf58f41e59b7342a653c9024718027ca9b27", "committedDate": "2020-04-11T09:33:30Z", "message": "WIP span handler"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzU3NjU1", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-391757655", "createdAt": "2020-04-11T11:12:40Z", "commit": {"oid": "58e986d8c7b4bb3e3732f8184fa0eef4e5641e92"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMToxMjo0MFrOGEMa_Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMToxMjo0MFrOGEMa_Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MTAwNQ==", "bodyText": "This is the important file", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407051005", "createdAt": "2020-04-11T11:12:40Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "58e986d8c7b4bb3e3732f8184fa0eef4e5641e92"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxNzU4NzE4", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-391758718", "createdAt": "2020-04-11T11:31:40Z", "commit": {"oid": "91900f1552c9be81a89bcc03443f77deffec30e4"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMTozMTo0MFrOGEMhrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQxMTozMTo0MFrOGEMhrA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA1MjcxNg==", "bodyText": "PS I plan to shade @raphw's https://github.com/raphw/weak-lock-free/blob/master/src/main/java/com/blogspot/mydailyjava/weaklockfree/WeakConcurrentMap.java into the core jar to support orphan tracker as it is much nicer to use a weak map instead of a hacky field. The code is small (won't make the jar too big), has the same bytecode level as us (Java 6) and stable. We can cite it in the NOTICE file.\nIf you think this is a bad idea, do scream at some point :D", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407052716", "createdAt": "2020-04-11T11:31:40Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/recorder/OrphanTracker.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.recorder;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.InternalHandler;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+\n+// TODO make a weak map of MutableSpan -> Throwable instead of a hacky field in MutableSpan", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "91900f1552c9be81a89bcc03443f77deffec30e4"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODIwMTgw", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-391820180", "createdAt": "2020-04-12T04:16:15Z", "commit": {"oid": "d265ebb3b6075749f7e45820fcf55550f2b59e2e"}, "state": "APPROVED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQwNDoxNjoxNVrOGESDlg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQwNDoyNDo0OVrOGESGBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzMxOA==", "bodyText": "abstract? Even in NOOP we subclass it :)", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143318", "createdAt": "2020-04-12T04:16:15Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d265ebb3b6075749f7e45820fcf55550f2b59e2e"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzU1Ng==", "bodyText": "is incomplete", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143556", "createdAt": "2020-04-12T04:19:33Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>\n+   *   <li>{@link #onFlush} if this was intentionally reported incomplete</li>\n+   *   <li>{@link #onOrphan} if this was reported incomplete due to garbage collection</li>\n+   *   <li>{@link #onFinish} if this was reported complete</li>\n+   * </ol>\n+   *\n+   * <p>The {@code parent} can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#abandon()}.\n+   *\n+   * <p>This is useful when counting children. Decrement your counter when this occurs as the span\n+   * will not be reported.\n+   *\n+   * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error. Some\n+   * instrumentation speculatively create a span for possible outcomes such as retry.\n+   */\n+  public void onAbandon(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#flush()}.\n+   *\n+   * <p>Even though the span here will is incomplete (missing {@link MutableSpan#finishTimestamp()},", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d265ebb3b6075749f7e45820fcf55550f2b59e2e"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzYxOQ==", "bodyText": "One of the following will be called later when the created span is no longer in use.", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143619", "createdAt": "2020-04-12T04:20:13Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d265ebb3b6075749f7e45820fcf55550f2b59e2e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzY0Nw==", "bodyText": "Currently I was surprised since it reads like these are called right away", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143647", "createdAt": "2020-04-12T04:20:37Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzYxOQ=="}, "originalCommit": {"oid": "d265ebb3b6075749f7e45820fcf55550f2b59e2e"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0MzY3Mg==", "bodyText": "I guess it instead of this", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143672", "createdAt": "2020-04-12T04:21:02Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d265ebb3b6075749f7e45820fcf55550f2b59e2e"}, "originalPosition": 55}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE0Mzk0Mg==", "bodyText": "Not sure if it's necessarily better, but I was sort of expecting there to just be one implementation of SafeSpanListener and this would actually be a SpanListener. We could possibly make it public too since it could be helpful for users to be able to combine multiple listeners but don't have to right now.", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407143942", "createdAt": "2020-04-12T04:24:49Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/handler/SafeSpanListener.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.Nullable;\n+import brave.internal.Platform;\n+import brave.propagation.TraceContext;\n+import java.util.Arrays;\n+\n+import static brave.internal.Throwables.propagateIfFatal;\n+\n+/** This logs exceptions instead of raising an error, as the supplied listener could have bugs. */\n+public abstract class SafeSpanListener extends SpanListener {\n+  // Array ensures no iterators are created at runtime\n+  public static SpanListener create(SpanListener[] handlers) {\n+    if (handlers.length == 0) return SpanListener.NOOP;\n+    if (handlers.length == 1) return new Single(handlers[0]);\n+    return new Multiple(handlers);\n+  }\n+\n+  @Override\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+    try {\n+      doOnCreate(parent, context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling create {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onAbandon(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnAbandon(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling abandon {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onFlush(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnFlush(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling flush {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onOrphan(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnOrphan(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling orphan {0}\", context, t);\n+    }\n+  }\n+\n+  @Override public void onFinish(TraceContext context, MutableSpan span) {\n+    try {\n+      doOnFinish(context, span);\n+    } catch (Throwable t) {\n+      propagateIfFatal(t);\n+      Platform.get().log(\"error handling finish {0}\", context, t);\n+    }\n+  }\n+\n+  abstract void doOnCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span);\n+\n+  abstract void doOnAbandon(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnFlush(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnOrphan(TraceContext context, MutableSpan span);\n+\n+  abstract void doOnFinish(TraceContext context, MutableSpan span);\n+\n+  static final class Single extends SafeSpanListener {\n+    final SpanListener delegate;\n+\n+    Single(SpanListener delegate) {\n+      this.delegate = delegate;\n+    }\n+\n+    @Override\n+    void doOnCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+      delegate.onCreate(parent, context, span);\n+    }\n+\n+    @Override void doOnAbandon(TraceContext context, MutableSpan span) {\n+      delegate.onAbandon(context, span);\n+    }\n+\n+    @Override void doOnFlush(TraceContext context, MutableSpan span) {\n+      delegate.onFlush(context, span);\n+    }\n+\n+    @Override void doOnOrphan(TraceContext context, MutableSpan span) {\n+      delegate.onOrphan(context, span);\n+    }\n+\n+    @Override void doOnFinish(TraceContext context, MutableSpan span) {\n+      delegate.onFinish(context, span);\n+    }\n+\n+    @Override public String toString() {\n+      return delegate.toString();\n+    }\n+  }\n+\n+  static final class Multiple extends SafeSpanListener {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d265ebb3b6075749f7e45820fcf55550f2b59e2e"}, "originalPosition": 123}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d265ebb3b6075749f7e45820fcf55550f2b59e2e", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/d265ebb3b6075749f7e45820fcf55550f2b59e2e", "committedDate": "2020-04-12T04:07:42Z", "message": "more rationale"}, "afterCommit": {"oid": "dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "committedDate": "2020-04-12T10:17:07Z", "message": "WIP span handler"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/dccb02e4c9849ba8b6f9b5581c1f3a583f7a0eaa", "committedDate": "2020-04-12T10:17:07Z", "message": "WIP span handler"}, "afterCommit": {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/71413431db25b29d5724b7e0abb2e4be4802fc52", "committedDate": "2020-04-12T10:36:47Z", "message": "WIP span listener"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxODQzNzAx", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-391843701", "createdAt": "2020-04-12T10:38:02Z", "commit": {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMDozODowMlrOGEUQwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMlQxMDozODowMlrOGEUQwA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzE3OTQ1Ng==", "bodyText": "note this now uses weak maps", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407179456", "createdAt": "2020-04-12T10:38:02Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/features/handler/FinishedChildrenListener.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanListener;\n+import brave.internal.weaklockfree.WeakConcurrentMap;\n+import brave.propagation.TraceContext;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenListener extends SpanListener {\n+\n+  protected abstract void onFinish(MutableSpan parent, Iterator<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final WeakConcurrentMap<TraceContext, TraceContext> childToParent = new WeakConcurrentMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52"}, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxOTA5MzI5", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-391909329", "createdAt": "2020-04-13T00:37:03Z", "commit": {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwMDozNzowM1rOGEZ9Ew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwMDozODoyMVrOGEZ9xA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3MjcyMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              Throwable caller, error;\n          \n          \n            \n              Throwable error;", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272723", "createdAt": "2020-04-13T00:37:03Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -72,7 +72,7 @@\n   ArrayList<String> tags;\n   /** Also use pair indexing for annotations, but type object to store (startTimestamp, value). */\n   ArrayList<Object> annotations;\n-  Throwable error;\n+  Throwable caller, error;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3Mjg2MQ==", "bodyText": "TODO move these changes to master as they aren't specific to this feature", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272861", "createdAt": "2020-04-13T00:37:57Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/RealSpan.java", "diffHunk": "@@ -140,13 +140,12 @@\n   }\n \n   @Override public void finish() {\n-    finish(clock.currentTimeMicroseconds());\n+    finish(0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzI3MjkwMA==", "bodyText": "TODO move this change to master as it isn't specific to this feature", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407272900", "createdAt": "2020-04-13T00:38:21Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/RealScopedSpan.java", "diffHunk": "@@ -74,8 +74,7 @@\n \n   @Override public void finish() {\n     scope.close();\n-    if (pendingSpans.remove(context) == null) return; // don't double-report\n-    state.finishTimestamp(clock.currentTimeMicroseconds());\n+    if (!pendingSpans.finish(context, 0L)) return; // don't double-report", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "71413431db25b29d5724b7e0abb2e4be4802fc52"}, "originalPosition": 6}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyMzAzNzY2", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-392303766", "createdAt": "2020-04-13T17:37:34Z", "commit": {"oid": "af6728c7e292b72daca379efe317c79e67e3abe8"}, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxNzozNzozNFrOGEudzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxODowNjoyNFrOGEveBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYwODc4Mw==", "bodyText": "nit: iirc this initial comment comes from an initial version where SpanHandler was extending FinishedSpanHandler. Could be updated to match rationale.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n          \n          \n            \n             * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n          \n          \n            \n             * or partitioning of data for backend that needs to see an entire {@linkplain\n          \n          \n            \n             * TraceContext#localRootId() local root}.\n          \n          \n            \n             * This hooks into the span life-cycle covering all state transitions, including\n          \n          \n            \n             * when a span is created, abandoned, finished, or orphan. This is particularly different than \n          \n          \n            \n             * {@link FinishedSpanHandler} that only considers finished spans.\n          \n          \n            \n             * \n          \n          \n            \n             * <p>The purpose of this type is to allow tracking of children,\n          \n          \n            \n             * or partitioning of data for backend that needs to see an entire {@linkplain\n          \n          \n            \n             * TraceContext#localRootId() local root}.", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407608783", "createdAt": "2020-04-13T17:37:34Z", "author": {"login": "jeqo"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af6728c7e292b72daca379efe317c79e67e3abe8"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxMTU4Mg==", "bodyText": "Would make sense to consider onStart as well? Not that I have a use-case in mind, just wondering if having onStart and onFinish could be useful.", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407611582", "createdAt": "2020-04-13T17:42:27Z", "author": {"login": "jeqo"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af6728c7e292b72daca379efe317c79e67e3abe8"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYxNzk5Mw==", "bodyText": "For me is becoming a bit hard to follow the sequence and implications of span state transitions, finished span handler, and now span listeners.\nAdding some docs/diagrams about this could be helpful for users. I can help with this if make sense :)", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407617993", "createdAt": "2020-04-13T17:53:53Z", "author": {"login": "jeqo"}, "path": "brave/src/main/java/brave/handler/SpanListener.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This is like {@link FinishedSpanHandler}, except it can cover all state conditions, including\n+ * when a span is created or abandoned. The purpose of this type is to allow tracking of children,\n+ * or partitioning of data for backend that needs to see an entire {@linkplain\n+ * TraceContext#localRootId() local root}.\n+ *\n+ * <p>As with {@link FinishedSpanHandler}, it is important to do work quickly as callbacks are run\n+ * on the same thread as application code. That said, there are some rules to keep in mind below.\n+ *\n+ * <p>The {@link TraceContext} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks, except {@link #onOrphan}, which has value, but not reference equality.\n+ *\n+ * <p>The {@link MutableSpan} parameter from {@link #onCreate} will be the same reference for\n+ * all callbacks. Do not mutate {@link MutableSpan} between callbacks as it is not thread safe.\n+ *\n+ * <p>If caching the {@link TraceContext} parameter, consider a {@link WeakReference} to avoid\n+ * holding up garbage collection.\n+ */\n+public class SpanListener {\n+  /** Use to avoid comparing against null references */\n+  public static final SpanListener NOOP = new SpanListener() {\n+    @Override public String toString() {\n+      return \"NoopSpanListener{}\";\n+    }\n+  };\n+\n+  protected SpanListener() {\n+  }\n+\n+  /**\n+   * This is called when a span is allocated, but before it is started. An allocation here will\n+   * result in one of:\n+   *\n+   * <ol>\n+   *   <li>{@link #onAbandon} if this was a speculative context</li>\n+   *   <li>{@link #onFlush} if this was intentionally reported incomplete</li>\n+   *   <li>{@link #onOrphan} if this was reported incomplete due to garbage collection</li>\n+   *   <li>{@link #onFinish} if this was reported complete</li>\n+   * </ol>\n+   *\n+   * <p>The {@code parent} can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  public void onCreate(@Nullable TraceContext parent, TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#abandon()}.\n+   *\n+   * <p>This is useful when counting children. Decrement your counter when this occurs as the span\n+   * will not be reported.\n+   *\n+   * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error. Some\n+   * instrumentation speculatively create a span for possible outcomes such as retry.\n+   */\n+  public void onAbandon(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called on {@link Span#flush()}.\n+   *\n+   * <p>Even though the span here will is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+   * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+   */\n+  public void onFlush(TraceContext context, MutableSpan span) {\n+  }\n+\n+  /**\n+   * Called when the trace context was garbage collected prior to completion.\n+   *\n+   * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if {@linkplain", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af6728c7e292b72daca379efe317c79e67e3abe8"}, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyMjMxNw==", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            There are a few reasons why `SpanListener` exists.\n          \n          \n            \n            \n          \n          \n            \n            For example, we need to manipulate Baggage without overriding `PropagationFactory`. For example,\n          \n          \n            \n            some baggage are derived (parsed from other headers). Given a create hook, one can post process\n          \n          \n            \n            baggage before the span is visible to the user.\n          \n          \n            \n            \n          \n          \n            \n            Another example is parent-child relationships. With a create hook someone can do things like count\n          \n          \n            \n            children (needed by [stackdriver model](https://cloud.google.com/trace/docs/reference/v2/rpc/google.devtools.cloudtrace.v2#google.devtools.cloudtrace.v2.Span)).\n          \n          \n            \n            \n          \n          \n            \n            Finally, some services require the entire \"local root\" to be reported at the same time. The only\n          \n          \n            \n            known example of this is [DataDog](https://github.com/DataDog/dd-trace-java/blob/406b324a82b482d7d8ad3faa5f9ccdd307c72308/dd-trace-ot/src/main/java/datadog/trace/common/writer/Writer.java#L20).\n          \n          \n            \n            A create hook can be used track a local root, allowing buffering of all descendants.\n          \n          \n            \n            There are a few reasons why `SpanListener` exists. For example:\n          \n          \n            \n            \n          \n          \n            \n            * We need to manipulate Baggage without overriding `PropagationFactory`, e.g. when\n          \n          \n            \n            some baggage are derived (parsed from other headers): Given a create hook, one can post process\n          \n          \n            \n            baggage before the span is visible to the user.\n          \n          \n            \n            * Another example is parent-child relationships: With a create hook someone can do things like count\n          \n          \n            \n            children (needed by [stackdriver model](https://cloud.google.com/trace/docs/reference/v2/rpc/google.devtools.cloudtrace.v2#google.devtools.cloudtrace.v2.Span)).\n          \n          \n            \n            * Some services require the entire \"local root\" to be reported at the same time. The only\n          \n          \n            \n            known example of this is [DataDog](https://github.com/DataDog/dd-trace-java/blob/406b324a82b482d7d8ad3faa5f9ccdd307c72308/dd-trace-ot/src/main/java/datadog/trace/common/writer/Writer.java#L20): A create hook can be used track a local root, allowing buffering of all descendants.", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407622317", "createdAt": "2020-04-13T18:00:59Z", "author": {"login": "jeqo"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -1,5 +1,32 @@\n # brave rationale\n \n+## SpanListener\n+There are a few reasons why `SpanListener` exists.\n+\n+For example, we need to manipulate Baggage without overriding `PropagationFactory`. For example,\n+some baggage are derived (parsed from other headers). Given a create hook, one can post process\n+baggage before the span is visible to the user.\n+\n+Another example is parent-child relationships. With a create hook someone can do things like count\n+children (needed by [stackdriver model](https://cloud.google.com/trace/docs/reference/v2/rpc/google.devtools.cloudtrace.v2#google.devtools.cloudtrace.v2.Span)).\n+\n+Finally, some services require the entire \"local root\" to be reported at the same time. The only\n+known example of this is [DataDog](https://github.com/DataDog/dd-trace-java/blob/406b324a82b482d7d8ad3faa5f9ccdd307c72308/dd-trace-ot/src/main/java/datadog/trace/common/writer/Writer.java#L20).\n+A create hook can be used track a local root, allowing buffering of all descendants.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af6728c7e292b72daca379efe317c79e67e3abe8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzYyNTIyMA==", "bodyText": "@adriancole would you mind sharing the reasoning behind 0L instead of #currentTimeMicroseconds()", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r407625220", "createdAt": "2020-04-13T18:06:24Z", "author": {"login": "jeqo"}, "path": "brave/src/main/java/brave/RealSpan.java", "diffHunk": "@@ -140,13 +140,12 @@\n   }\n \n   @Override public void finish() {\n-    finish(clock.currentTimeMicroseconds());\n+    finish(0L);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af6728c7e292b72daca379efe317c79e67e3abe8"}, "originalPosition": 5}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c4b7fd74bd1205a0a0e904be9d6ec660f08d8a36", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/c4b7fd74bd1205a0a0e904be9d6ec660f08d8a36", "committedDate": "2020-04-14T01:53:34Z", "message": "Update brave/RATIONALE.md\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>"}, "afterCommit": {"oid": "b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/b87fabd95c2f4fe88ba500ef48c50122dc8c51fc", "committedDate": "2020-04-14T04:44:19Z", "message": "Update brave/RATIONALE.md\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8e9dfaa1fa4b0b4a17a31994b9a3d9a835cb9e21", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/8e9dfaa1fa4b0b4a17a31994b9a3d9a835cb9e21", "committedDate": "2020-04-14T05:54:03Z", "message": "polish"}, "afterCommit": {"oid": "4912b1fca4cbe81528794f19c06290c668b54a57", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/4912b1fca4cbe81528794f19c06290c668b54a57", "committedDate": "2020-04-15T08:02:41Z", "message": "polish"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNjI2ODEx", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-393626811", "createdAt": "2020-04-15T09:56:13Z", "commit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo1NjoxM1rOGFycYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo1NjoxM1rOGFycYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMjUyOQ==", "bodyText": "eventhough nostalgia for SpanCollector SpanHandler may still be better name I admit as we can't move the MutableSpan out of this package without certain chaos...", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408722529", "createdAt": "2020-04-15T09:56:13Z", "author": {"login": "codefromthecrypt"}, "path": "brave-tests/src/test/java/brave/internal/recorder/PendingSpansClassLoaderTest.java", "diffHunk": "@@ -15,6 +15,7 @@\n \n import brave.handler.FinishedSpanHandler;\n import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzNjI3NDg1", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-393627485", "createdAt": "2020-04-15T09:57:09Z", "commit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo1NzowOVrOGFyecw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQwOTo1NzowOVrOGFyecw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODcyMzA1OQ==", "bodyText": "ignore drift here for now as I need to rewrite it anyway but don't want to rewrite it two or three times", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408723059", "createdAt": "2020-04-15T09:57:09Z", "author": {"login": "codefromthecrypt"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -1,5 +1,29 @@\n # brave rationale\n \n+## SpanListener", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "originalPosition": 3}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzODQ3Nzkz", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-393847793", "createdAt": "2020-04-15T14:47:03Z", "commit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0NzowM1rOGF9Tpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0NzowM1rOGF9Tpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMDUxOQ==", "bodyText": "for an enum Cause i would linguistically expect past-tense constants, ABANDONED - FINISHED etc ?", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408900519", "createdAt": "2020-04-15T14:47:03Z", "author": {"login": "jorgheymans"}, "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "originalPosition": 54}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzODQ5MzY0", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-393849364", "createdAt": "2020-04-15T14:48:29Z", "commit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0ODoyOVrOGF9YoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo0ODoyOVrOGF9YoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwMTc5Mg==", "bodyText": "the other constants are named linear to their Span methods, why ORPHAN for gc collected, are there other use cases leading to ORPHAN besides gc ?", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408901792", "createdAt": "2020-04-15T14:48:29Z", "author": {"login": "jorgheymans"}, "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {\n+    /**\n+     * Called on {@link Span#abandon()}.\n+     *\n+     * <p>This is useful when counting children. Decrement your counter when this occurs as the\n+     * span will not be reported.\n+     *\n+     * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error.\n+     * Some instrumentation speculatively create a span for possible outcomes such as retry.\n+     */\n+    ABANDON,\n+    /**\n+     * Called on {@link Span#finish()} and is the simplest cause to reason with. When {@link\n+     * MutableSpan#startTimestamp()} is present, you can assume with high confidence you have all\n+     * recorded data for this span.\n+     */\n+    FINISH,\n+    /**\n+     * Called on {@link Span#flush()}.\n+     *\n+     * <p>Even though the span here is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+     * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+     */\n+    FLUSH,\n+    /**\n+     * Called when the trace context was garbage collected prior to completion.\n+     *\n+     * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if empty.\n+     * Non-empty spans are reported to the tracing system unless a {@link FinishedSpanHandler}\n+     * returns false.\n+     *\n+     * @see FinishedSpanHandler#supportsOrphans()\n+     */\n+    ORPHAN", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "originalPosition": 87}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzODU1Mjcx", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-393855271", "createdAt": "2020-04-15T14:54:22Z", "commit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo1NDoyM1rOGF9rLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNDo1NDoyM1rOGF9rLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkwNjU0Mg==", "bodyText": "does this need to be duplicated from Cause ?\nCalled when data collection completes on its own is enough, and maybe link in the cause parameter to the enum.", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408906542", "createdAt": "2020-04-15T14:54:23Z", "author": {"login": "jorgheymans"}, "path": "brave/src/main/java/brave/handler/SpanCollector.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.handler;\n+\n+import brave.Span;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * This tracks one recording of a {@link TraceContext}. Common implementations include span\n+ * reporting (ex to Zipkin) and data manipulation, such as redaction for security purposes.\n+ *\n+ * <h3>Relationship to Span lifecycle</h3>\n+ * The pair of {@link #begin} and {@link #end} seems the same as the span lifecycle. In\n+ * most cases it will be the same, but you cannot assume this.\n+ *\n+ * <p>A {@link TraceContext} could be recorded twice, for example, if a long operation\n+ * began, called {@link Span#flush()} (recording 1) and later called {@link Span#finish()}\n+ * (recording 2). A {@link TraceContext} could be abrupted by garbage collection resulting in a\n+ * {@link Cause#ABANDON}. A user could even {@linkplain Cause#ABANDON abandon} a span without\n+ * recording anything!\n+ *\n+ * <p>Collectors that process finished spans will need to look at the {link Cause} and {@link\n+ * MutableSpan} collected. For example, {@link Cause#FINISH} is usually a good enough heuristic to\n+ * find complete spans.\n+ *\n+ * <h3>Advanced Notes</h3>\n+ * <p>It is important to do work quickly as callbacks are run on the same thread as application\n+ * code. However, do not mutate {@link MutableSpan} between callbacks, as it is not thread safe.\n+ *\n+ * <p>The {@link TraceContext} and {@link MutableSpan} parameter from {@link #begin} will be\n+ * the same reference for {@link #end}.\n+ *\n+ * <p>If caching the context or span parameters between callbacks, consider a {@link WeakReference}\n+ * to avoid holding up garbage collection.\n+ *\n+ * <p>The {@link #begin} callback primarily supports tracking of children, or partitioning of\n+ * data for backend that needs to see an entire {@linkplain TraceContext#localRootId() local root}.\n+ */\n+public interface SpanCollector {\n+  /** What ended the data collection? */\n+  enum Cause {\n+    /**\n+     * Called on {@link Span#abandon()}.\n+     *\n+     * <p>This is useful when counting children. Decrement your counter when this occurs as the\n+     * span will not be reported.\n+     *\n+     * <p><em>Note:</em>Abandoned spans should be ignored as they aren't indicative of an error.\n+     * Some instrumentation speculatively create a span for possible outcomes such as retry.\n+     */\n+    ABANDON,\n+    /**\n+     * Called on {@link Span#finish()} and is the simplest cause to reason with. When {@link\n+     * MutableSpan#startTimestamp()} is present, you can assume with high confidence you have all\n+     * recorded data for this span.\n+     */\n+    FINISH,\n+    /**\n+     * Called on {@link Span#flush()}.\n+     *\n+     * <p>Even though the span here is incomplete (missing {@link MutableSpan#finishTimestamp()},\n+     * it is reported to the tracing system unless a {@link FinishedSpanHandler} returns false.\n+     */\n+    FLUSH,\n+    /**\n+     * Called when the trace context was garbage collected prior to completion.\n+     *\n+     * <p>Unlike {@link FinishedSpanHandler#supportsOrphans()}, this is called even if empty.\n+     * Non-empty spans are reported to the tracing system unless a {@link FinishedSpanHandler}\n+     * returns false.\n+     *\n+     * @see FinishedSpanHandler#supportsOrphans()\n+     */\n+    ORPHAN\n+  }\n+\n+  /** Use to avoid comparing against null references */\n+  SpanCollector NOOP = new SpanCollector() {\n+    @Override public void begin(TraceContext context, MutableSpan span, TraceContext parent) {\n+    }\n+\n+    @Override public boolean end(TraceContext context, MutableSpan span, Cause cause) {\n+      return true;\n+    }\n+\n+    @Override public String toString() {\n+      return \"NoopSpanCollector{}\";\n+    }\n+  };\n+\n+  /**\n+   * This is called when a span is sampled, but before it is started.\n+   *\n+   * @param context the trace context which is  {@link TraceContext#sampledLocal()}. This includes\n+   * identifiers and potentially {@link TraceContext#extra() extra propagated data} such as baggage\n+   * or extended sampling configuration.\n+   * @param span a mutable object that stores data recorded with span apis. Modifications are\n+   * visible to later collectors.\n+   * @param parent can be {@code null} only when the new context is a {@linkplain\n+   * TraceContext#isLocalRoot() local root}.\n+   */\n+  void begin(TraceContext context, MutableSpan span, @Nullable TraceContext parent);\n+\n+  /**\n+   * Called when data collection completes for one of the following reasons:\n+   *\n+   * <p><ol>\n+   * <li>{@link Cause#ABANDON} if it was a speculative context</li>\n+   * <li>{@link Cause#FINISH} if it was reported complete</li>\n+   * <li>{@link Cause#FLUSH} if it was intentionally reported incomplete</li>\n+   * <li>{@link Cause#ORPHAN} if it was reported incomplete due to garbage collection</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "originalPosition": 124}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzODkxMzQ4", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-393891348", "createdAt": "2020-04-15T15:31:55Z", "commit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTozMTo1NVrOGF_cjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTozMTo1NVrOGF_cjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNTU2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Kick-out if the this was not a normal finish\n          \n          \n            \n                // Kick-out if this was not a normal finish", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408935567", "createdAt": "2020-04-15T15:31:55Z", "author": {"login": "jorgheymans"}, "path": "brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenCollector implements SpanCollector {\n+\n+  protected abstract void onFinish(MutableSpan parent, Iterator<MutableSpan> children);\n+\n+  /** This holds the children of the current parent until the former is finished or abandoned. */\n+  final WeakConcurrentMap<TraceContext, TraceContext> childToParent =\n+    new WeakConcurrentMap<>(false);\n+  final ParentToChildren parentToChildren = new ParentToChildren();\n+\n+  @Override\n+  public void begin(TraceContext context, MutableSpan span, @Nullable TraceContext parent) {\n+    if (!context.isLocalRoot()) { // a child\n+      childToParent.putIfProbablyAbsent(context, parent);\n+      parentToChildren.add(parent, span);\n+    }\n+  }\n+\n+  @Override public boolean end(TraceContext context, MutableSpan span, Cause cause) {\n+    // Kick-out if the this was not a normal finish", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "originalPosition": 45}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzODkyMjMy", "url": "https://github.com/openzipkin/brave/pull/1148#pullrequestreview-393892232", "createdAt": "2020-04-15T15:32:51Z", "commit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTozMjo1MVrOGF_fcQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xNVQxNTozMjo1MVrOGF_fcQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODkzNjMwNQ==", "bodyText": "does this need a type level javadoc ?", "url": "https://github.com/openzipkin/brave/pull/1148#discussion_r408936305", "createdAt": "2020-04-15T15:32:51Z", "author": {"login": "jorgheymans"}, "path": "brave/src/test/java/brave/features/handler/FinishedChildrenCollector.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.handler;\n+\n+import brave.handler.MutableSpan;\n+import brave.handler.SpanCollector;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import com.blogspot.mydailyjava.weaklockfree.WeakConcurrentMap;\n+import java.util.Iterator;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+import static java.util.Collections.emptyIterator;\n+\n+public abstract class FinishedChildrenCollector implements SpanCollector {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ccf2f9f22041ae32a29cde1a8ce0ca8ba736037"}, "originalPosition": 27}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fefe205b56233fdcc9176f4aeb2467004fb4e90a", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/fefe205b56233fdcc9176f4aeb2467004fb4e90a", "committedDate": "2020-04-19T01:55:15Z", "message": "typo"}, "afterCommit": {"oid": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/b4c7609e8fb6e635bd50367cba691e45c25468fc", "committedDate": "2020-04-20T04:37:20Z", "message": "typo"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b4c7609e8fb6e635bd50367cba691e45c25468fc", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/b4c7609e8fb6e635bd50367cba691e45c25468fc", "committedDate": "2020-04-20T04:37:20Z", "message": "typo"}, "afterCommit": {"oid": "777176f8f0fe141126f09ae61876a3f736f19f5b", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/777176f8f0fe141126f09ae61876a3f736f19f5b", "committedDate": "2020-05-08T05:53:19Z", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "777176f8f0fe141126f09ae61876a3f736f19f5b", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/777176f8f0fe141126f09ae61876a3f736f19f5b", "committedDate": "2020-05-08T05:53:19Z", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>"}, "afterCommit": {"oid": "c029d571d2ee44e77d5e7035ab4a93585197a736", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/c029d571d2ee44e77d5e7035ab4a93585197a736", "committedDate": "2020-05-08T08:59:50Z", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c029d571d2ee44e77d5e7035ab4a93585197a736", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/c029d571d2ee44e77d5e7035ab4a93585197a736", "committedDate": "2020-05-08T08:59:50Z", "message": "Adds SpanHandler\n\nCo-Authored-By: Jorge Esteban Quilcate Otoya <quilcate.jorge@gmail.com>\nCo-Authored-By: Jorg Heymans <jorg.heymans@gmail.com>\nCo-Authored-By: Anuraag Agrawal <anuraaga@gmail.com>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c4ce99b43325bf3b330f5f517bb2819684b60308", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/c4ce99b43325bf3b330f5f517bb2819684b60308", "committedDate": "2020-05-08T10:53:27Z", "message": "deprecate and feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "91a49ee9163342cd2d9e5f216e3cf8675db56e56", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/91a49ee9163342cd2d9e5f216e3cf8675db56e56", "committedDate": "2020-05-08T11:14:02Z", "message": "more rationale"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1936, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}