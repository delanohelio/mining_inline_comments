{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyNzQ2NjI5", "number": 1121, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjo1MjoyMFrODqoFVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNToyMjo1M1rODqpZAQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDIzNTEwOnYy", "diffSide": "RIGHT", "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjo1MjoyMFrOF6fTyQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjo1MjoyMFrOF6fTyQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3NDY5Nw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * Blocks until a local span was reported. We define a local span as one with a timestamp and\n          \n          \n            \n               * Blocks until a local span was reported. We define a local span as one with a timestamp and no", "url": "https://github.com/openzipkin/brave/pull/1121#discussion_r396874697", "createdAt": "2020-03-24T02:52:20Z", "author": {"login": "codefromthecrypt"}, "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -239,15 +239,39 @@ private Span doTakeSpan(boolean flushed) throws InterruptedException {\n     }\n   };\n \n+  /**\n+   * Blocks until a local span was reported. We define a local span as one with a timestamp and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a6d195f0eb6dee926076ea11ced7e4db7f97a86"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDIzNjgzOnYy", "diffSide": "LEFT", "path": "instrumentation/jms/src/main/java/brave/jms/TracingCompletionListener.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjo1MzoyMFrOF6fUxA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwMjo1MzoyMFrOF6fUxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Njg3NDk0OA==", "bodyText": "this is just polishing", "url": "https://github.com/openzipkin/brave/pull/1121#discussion_r396874948", "createdAt": "2020-03-24T02:53:20Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/jms/src/main/java/brave/jms/TracingCompletionListener.java", "diffHunk": "@@ -40,23 +40,19 @@ static CompletionListener create(CompletionListener delegate, Span span,\n   }\n \n   @Override public void onCompletion(Message message) {\n-    Scope ws = current.maybeScope(span.context());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "2a6d195f0eb6dee926076ea11ced7e4db7f97a86"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDQyNTQyOnYy", "diffSide": "RIGHT", "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "isResolved": false, "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNTowNjo0MVrOF6hILg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNTo0OTozNlrOF6hxAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwNDQ5NA==", "bodyText": "I wonder if this results in too many permutations. I'm thinking of adding BraveAssertions to allow something like\nassertThat(takeSpan()).isLocal().hasError(\"failed\");\nNot something you have to do :) But wondering what you think of the idea.", "url": "https://github.com/openzipkin/brave/pull/1121#discussion_r396904494", "createdAt": "2020-03-24T05:06:41Z", "author": {"login": "anuraaga"}, "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -239,15 +239,39 @@ private Span doTakeSpan(boolean flushed) throws InterruptedException {\n     }\n   };\n \n+  /**\n+   * Blocks until a local span was reported. We define a local span as one with a timestamp and no\n+   * duration, kind, or remote endpoint. This will fail if there's an \"error\" tag. If you expect a\n+   * failure, use {@link #takeLocalSpanWithError(String)} instead.\n+   */\n   protected Span takeLocalSpan() throws InterruptedException {\n     Span local = takeSpan();\n+    assertLocalSpan(local);\n+    return local;\n+  }\n+\n+  /** Like {@link #takeLocalSpan()} except an error tag must match the given value. */\n+  protected Span takeLocalSpanWithError(String errorTag)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "60b5484d4b901e02dbe3cc51626970514f283e65"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwNjc3MQ==", "bodyText": "right now there are two permutations, local and remote. there can't be any other permutations.\nthe explicit handling of error is really really important because until we made error mandatory we actually had bugs we never noticed.", "url": "https://github.com/openzipkin/brave/pull/1121#discussion_r396906771", "createdAt": "2020-03-24T05:17:06Z", "author": {"login": "codefromthecrypt"}, "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -239,15 +239,39 @@ private Span doTakeSpan(boolean flushed) throws InterruptedException {\n     }\n   };\n \n+  /**\n+   * Blocks until a local span was reported. We define a local span as one with a timestamp and no\n+   * duration, kind, or remote endpoint. This will fail if there's an \"error\" tag. If you expect a\n+   * failure, use {@link #takeLocalSpanWithError(String)} instead.\n+   */\n   protected Span takeLocalSpan() throws InterruptedException {\n     Span local = takeSpan();\n+    assertLocalSpan(local);\n+    return local;\n+  }\n+\n+  /** Like {@link #takeLocalSpan()} except an error tag must match the given value. */\n+  protected Span takeLocalSpanWithError(String errorTag)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwNDQ5NA=="}, "originalCommit": {"oid": "60b5484d4b901e02dbe3cc51626970514f283e65"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwNzg4NQ==", "bodyText": "it could be the case that some of the comparison operators could fit in an assertions class though, ex childOf parentOf etc\nlet's just please not take the base preconditions out, that verify this is or is not a local span and is or is not error. deferring these things would re-introduce the problems the code just only for a day has so far solved.", "url": "https://github.com/openzipkin/brave/pull/1121#discussion_r396907885", "createdAt": "2020-03-24T05:21:48Z", "author": {"login": "codefromthecrypt"}, "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -239,15 +239,39 @@ private Span doTakeSpan(boolean flushed) throws InterruptedException {\n     }\n   };\n \n+  /**\n+   * Blocks until a local span was reported. We define a local span as one with a timestamp and no\n+   * duration, kind, or remote endpoint. This will fail if there's an \"error\" tag. If you expect a\n+   * failure, use {@link #takeLocalSpanWithError(String)} instead.\n+   */\n   protected Span takeLocalSpan() throws InterruptedException {\n     Span local = takeSpan();\n+    assertLocalSpan(local);\n+    return local;\n+  }\n+\n+  /** Like {@link #takeLocalSpan()} except an error tag must match the given value. */\n+  protected Span takeLocalSpanWithError(String errorTag)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwNDQ5NA=="}, "originalCommit": {"oid": "60b5484d4b901e02dbe3cc51626970514f283e65"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwNzk5OQ==", "bodyText": "Ah ok makes sense - remembered that takeSpan verifies there is no error which does seem better.", "url": "https://github.com/openzipkin/brave/pull/1121#discussion_r396907999", "createdAt": "2020-03-24T05:22:20Z", "author": {"login": "anuraaga"}, "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -239,15 +239,39 @@ private Span doTakeSpan(boolean flushed) throws InterruptedException {\n     }\n   };\n \n+  /**\n+   * Blocks until a local span was reported. We define a local span as one with a timestamp and no\n+   * duration, kind, or remote endpoint. This will fail if there's an \"error\" tag. If you expect a\n+   * failure, use {@link #takeLocalSpanWithError(String)} instead.\n+   */\n   protected Span takeLocalSpan() throws InterruptedException {\n     Span local = takeSpan();\n+    assertLocalSpan(local);\n+    return local;\n+  }\n+\n+  /** Like {@link #takeLocalSpan()} except an error tag must match the given value. */\n+  protected Span takeLocalSpanWithError(String errorTag)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwNDQ5NA=="}, "originalCommit": {"oid": "60b5484d4b901e02dbe3cc51626970514f283e65"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkxNDk0Ng==", "bodyText": "the other thing is accidental permutation. we had tests that thought they were acting on a local span when they were acting on a remote one.. I tried to limit most of this by using scopes instead of parent spans", "url": "https://github.com/openzipkin/brave/pull/1121#discussion_r396914946", "createdAt": "2020-03-24T05:49:36Z", "author": {"login": "codefromthecrypt"}, "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -239,15 +239,39 @@ private Span doTakeSpan(boolean flushed) throws InterruptedException {\n     }\n   };\n \n+  /**\n+   * Blocks until a local span was reported. We define a local span as one with a timestamp and no\n+   * duration, kind, or remote endpoint. This will fail if there's an \"error\" tag. If you expect a\n+   * failure, use {@link #takeLocalSpanWithError(String)} instead.\n+   */\n   protected Span takeLocalSpan() throws InterruptedException {\n     Span local = takeSpan();\n+    assertLocalSpan(local);\n+    return local;\n+  }\n+\n+  /** Like {@link #takeLocalSpan()} except an error tag must match the given value. */\n+  protected Span takeLocalSpanWithError(String errorTag)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwNDQ5NA=="}, "originalCommit": {"oid": "60b5484d4b901e02dbe3cc51626970514f283e65"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ2MDQ0OTI5OnYy", "diffSide": "RIGHT", "path": "instrumentation/jms/src/test/java/brave/jms/ITJms_1_1_TracingMessageProducer.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNToyMjo1M1rOF6hWjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNFQwNToyMjo1M1rOF6hWjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjkwODE3Mw==", "bodyText": "@anuraaga for example, the error assertion showed that the earlier tests were bad syntax. the error returned had nothing to do with the session that was closed. it is really important to not undo this as there are still a boatload of hidden bugs to find.", "url": "https://github.com/openzipkin/brave/pull/1121#discussion_r396908173", "createdAt": "2020-03-24T05:22:53Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/jms/src/test/java/brave/jms/ITJms_1_1_TracingMessageProducer.java", "diffHunk": "@@ -191,7 +191,7 @@ void should_record_properties(Map<String, String> producerTags) throws Exception\n \n   @Test public void should_record_error() throws Exception {\n     tracedSession.close();\n-    should_record_error(() -> messageProducer.send(message));\n+    should_record_error(() -> messageProducer.send(jms.destination, message));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c484414d0264edb0cc53d7ad58997788e6ff615d"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1574, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}