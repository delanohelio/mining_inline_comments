{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE0NDg5MjU2", "number": 1193, "title": "Adds EntrySplitter for use in w3c specs and secondary-sampling", "bodyText": "This adds EntrySplitter to help handle complex formats such as W3C\ntrace-context efficiently. For example, this has flexible whitespace\nrules to comply with standards like 'tracestate' which require retaining\nleading whitespace.\nSee #693", "createdAt": "2020-05-07T06:35:48Z", "url": "https://github.com/openzipkin/brave/pull/1193", "merged": true, "mergeCommit": {"oid": "169d93ac71fce759fb872636576d539c6c3b5123"}, "closed": true, "closedAt": "2020-05-08T07:21:49Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 24, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABce3WszgH2gAyNDE0NDg5MjU2OmRjMzVkZDVlMzU3NTBkYWRkNGEzNmRmOTFkZDIxN2QwNzRjM2JhNTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcfMSClAH2gAyNDE0NDg5MjU2OjJjZTBlNDFkYzg3OTZjODM4OGI2ZDUxNWQwZTY1MDFiYzA3MjIwYjM=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "dc35dd5e35750dadd4a36df91dd217d074c3ba56", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/dc35dd5e35750dadd4a36df91dd217d074c3ba56", "committedDate": "2020-05-07T06:33:23Z", "message": "Adds EntrySplitter for use in w3c specs and secondary-sampling\n\nThis adds `EntrySplitter` to help handle complex formats such as W3C\ntrace-context efficiently. For example, this has flexible whitespace\nrules to comply with standards like 'tracestate' which require retaining\nleading whitespace.\n\nSee #693"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f87745c0bde93182927b1d54914eb412cdc150b9", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/f87745c0bde93182927b1d54914eb412cdc150b9", "committedDate": "2020-05-07T06:38:05Z", "message": "EOL before EOF"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1db905a488d02c9864a1dc0fcdeaa1be2932664d", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/1db905a488d02c9864a1dc0fcdeaa1be2932664d", "committedDate": "2020-05-07T13:21:05Z", "message": "fixes edge cases around single characters and OWS"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NDY0Mjc0", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-407464274", "createdAt": "2020-05-07T13:21:31Z", "commit": {"oid": "1db905a488d02c9864a1dc0fcdeaa1be2932664d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoyMTozMVrOGR-NsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxMzoyMTozMVrOGR-NsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ5ODI4OQ==", "bodyText": "@narayaruna look familiar? :)", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421498289", "createdAt": "2020-05-07T13:21:31Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/internal/codec/EntrySplitterTest.java", "diffHunk": "@@ -0,0 +1,279 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.codec.EntrySplitter.Handler;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+public class EntrySplitterTest {\n+  EntrySplitter entrySplitter = EntrySplitter.newBuilder().shouldThrow(true).build();\n+  Map<String, String> map = new LinkedHashMap<>();\n+  Handler<Map<String, String>> parseIntoMap =\n+      (target, input, beginKey, endKey, beginValue, endValue) -> {\n+        String key = input.substring(beginKey, endKey);\n+        String value = input.substring(beginValue, endValue);\n+        target.put(key, value);\n+        return true;\n+      };\n+\n+  @Test public void parse() {\n+    entrySplitter.parse(parseIntoMap, map, \"k1=v1,k2=v2\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k1\", \"v1\"),\n+        entry(\"k2\", \"v2\")\n+    );\n+  }\n+\n+  @Test public void parse_singleChars() {\n+    entrySplitter.parse(parseIntoMap, map, \"k=v,a=b\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k\", \"v\"),\n+        entry(\"a\", \"b\")\n+    );\n+  }\n+\n+  @Test public void parse_valuesAreRequired() {\n+    for (String missingValue : Arrays.asList(\"k1\", \"k1  \", \"k1=v1,k2\", \"k1   ,k2=v1\")) {\n+      assertThatThrownBy(() -> entrySplitter.parse(parseIntoMap, map, missingValue))\n+          .isInstanceOf(IllegalArgumentException.class)\n+          .hasMessage(\"Invalid input: missing key value separator '='\");\n+    }\n+    assertThat(map.isEmpty());\n+  }\n+\n+  @Test public void parse_emptyValuesOk() {\n+    for (String emptyValue : Arrays.asList(\"k1=\", \"k1 =\", \",k1=\", \",k1 =\", \"k1 =,\")) {\n+      entrySplitter.parse(parseIntoMap, map, emptyValue);\n+\n+      assertThat(map).containsExactly(entry(\"k1\", \"\"));\n+      map.clear();\n+    }\n+\n+    entrySplitter.parse(parseIntoMap, map, \"k1=v1,k2=\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k1\", \"v1\"),\n+        entry(\"k2\", \"\")\n+    );\n+  }\n+\n+  @Test public void keyValueSeparatorRequired_false() {\n+    entrySplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    entrySplitter.parse(parseIntoMap, map, \" authcache , gateway \");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"authcache\", \"\"),\n+        entry(\"gateway\", \"\")\n+    );\n+  }\n+\n+  /** Parse Accept header style encoding as used in secondary sampling */\n+  @Test public void parse_onlyFirstKeyValueSeparator() {\n+    entrySplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparator(';')\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    entrySplitter.parse(parseIntoMap, map, \"authcache;ttl=1;spanId=19f84f102048e047,gateway\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"authcache\", \"ttl=1;spanId=19f84f102048e047\"),\n+        entry(\"gateway\", \"\")\n+    );\n+  }\n+\n+  /** This shows you can nest parsers without unnecessary string allocation between stages. */\n+  @Test public void parse_nested() {\n+    EntrySplitter outerSplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparator(';')\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    EntrySplitter innerSplitter = EntrySplitter.newBuilder()\n+        .entrySeparator(';')\n+        .keyValueSeparator('=')\n+        .shouldThrow(true)\n+        .build();\n+\n+    Map<String, Map<String, String>> keyToAttributes = new LinkedHashMap<>();\n+\n+    outerSplitter.parse((target, input, beginKey, endKey, beginValue, endValue) -> {\n+      String key = input.substring(beginKey, endKey);\n+      Map<String, String> attributes = new LinkedHashMap<>();\n+      if (beginValue == endValue) { // no string allocation at all\n+        attributes = Collections.emptyMap();\n+      } else { // no string allocation to pass to the inner parser\n+        attributes = new LinkedHashMap<>();\n+        innerSplitter.parse(parseIntoMap, attributes, input, beginValue, endValue);\n+      }\n+      target.put(key, attributes);\n+      return true;\n+    }, keyToAttributes, \"authcache;ttl=1;spanId=19f84f102048e047,gateway\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1db905a488d02c9864a1dc0fcdeaa1be2932664d"}, "originalPosition": 138}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3NTAzMTY3", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-407503167", "createdAt": "2020-05-07T14:02:45Z", "commit": {"oid": "64a3b61da2d5462936887801532344098b0b7c51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNDowMjo0NVrOGSAFCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QxNDowMjo0NVrOGSAFCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUyODg0Mw==", "bodyText": "added allocation free trace ID example from AWS", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421528843", "createdAt": "2020-05-07T14:02:45Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/internal/codec/EntrySplitterTest.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.codec.EntrySplitter.Handler;\n+import brave.propagation.TraceContext;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+public class EntrySplitterTest {\n+  EntrySplitter entrySplitter = EntrySplitter.newBuilder().shouldThrow(true).build();\n+  Map<String, String> map = new LinkedHashMap<>();\n+  Handler<Map<String, String>> parseIntoMap =\n+      (target, input, beginKey, endKey, beginValue, endValue) -> {\n+        String key = input.substring(beginKey, endKey);\n+        String value = input.substring(beginValue, endValue);\n+        target.put(key, value);\n+        return true;\n+      };\n+\n+  @Test public void parse() {\n+    entrySplitter.parse(parseIntoMap, map, \"k1=v1,k2=v2\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k1\", \"v1\"),\n+        entry(\"k2\", \"v2\")\n+    );\n+  }\n+\n+  @Test public void parse_singleChars() {\n+    entrySplitter.parse(parseIntoMap, map, \"k=v,a=b\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k\", \"v\"),\n+        entry(\"a\", \"b\")\n+    );\n+  }\n+\n+  @Test public void parse_valuesAreRequired() {\n+    for (String missingValue : Arrays.asList(\"k1\", \"k1  \", \"k1=v1,k2\", \"k1   ,k2=v1\")) {\n+      assertThatThrownBy(() -> entrySplitter.parse(parseIntoMap, map, missingValue))\n+          .isInstanceOf(IllegalArgumentException.class)\n+          .hasMessage(\"Invalid input: missing key value separator '='\");\n+    }\n+    assertThat(map.isEmpty());\n+  }\n+\n+  @Test public void parse_emptyValuesOk() {\n+    for (String emptyValue : Arrays.asList(\"k1=\", \"k1 =\", \",k1=\", \",k1 =\", \"k1 =,\")) {\n+      entrySplitter.parse(parseIntoMap, map, emptyValue);\n+\n+      assertThat(map).containsExactly(entry(\"k1\", \"\"));\n+      map.clear();\n+    }\n+\n+    entrySplitter.parse(parseIntoMap, map, \"k1=v1,k2=\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"k1\", \"v1\"),\n+        entry(\"k2\", \"\")\n+    );\n+  }\n+\n+  @Test public void keyValueSeparatorRequired_false() {\n+    entrySplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    entrySplitter.parse(parseIntoMap, map, \" authcache , gateway \");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"authcache\", \"\"),\n+        entry(\"gateway\", \"\")\n+    );\n+  }\n+\n+  /** Parse Accept header style encoding as used in secondary sampling */\n+  @Test public void parse_onlyFirstKeyValueSeparator() {\n+    entrySplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparator(';')\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    entrySplitter.parse(parseIntoMap, map, \"authcache;ttl=1;spanId=19f84f102048e047,gateway\");\n+\n+    assertThat(map).containsExactly(\n+        entry(\"authcache\", \"ttl=1;spanId=19f84f102048e047\"),\n+        entry(\"gateway\", \"\")\n+    );\n+  }\n+\n+  /** This shows you can nest parsers without unnecessary string allocation between stages. */\n+  @Test public void parse_nested() {\n+    EntrySplitter outerSplitter = EntrySplitter.newBuilder()\n+        .keyValueSeparator(';')\n+        .keyValueSeparatorRequired(false)\n+        .shouldThrow(true)\n+        .build();\n+\n+    EntrySplitter innerSplitter = EntrySplitter.newBuilder()\n+        .entrySeparator(';')\n+        .keyValueSeparator('=')\n+        .shouldThrow(true)\n+        .build();\n+\n+    Map<String, Map<String, String>> keyToAttributes = new LinkedHashMap<>();\n+\n+    outerSplitter.parse((target, input, beginKey, endKey, beginValue, endValue) -> {\n+      String key = input.substring(beginKey, endKey);\n+      Map<String, String> attributes = new LinkedHashMap<>();\n+      if (beginValue == endValue) { // no string allocation at all\n+        attributes = Collections.emptyMap();\n+      } else { // no string allocation to pass to the inner parser\n+        attributes = new LinkedHashMap<>();\n+        innerSplitter.parse(parseIntoMap, attributes, input, beginValue, endValue);\n+      }\n+      target.put(key, attributes);\n+      return true;\n+    }, keyToAttributes, \"authcache;ttl=1;spanId=19f84f102048e047,gateway\");\n+\n+    Map<String, String> expectedAttributes = new LinkedHashMap<>();\n+    expectedAttributes.put(\"ttl\", \"1\");\n+    expectedAttributes.put(\"spanId\", \"19f84f102048e047\");\n+    assertThat(keyToAttributes).containsExactly(\n+        entry(\"authcache\", expectedAttributes),\n+        entry(\"gateway\", Collections.emptyMap())\n+    );\n+  }\n+\n+  @Test public void parse_emptyKeysNotOk() {\n+    for (String missingKey : Arrays.asList(\"=\", \"=v1\", \",=\", \",=v2\")) {\n+      assertThatThrownBy(() -> entrySplitter.parse(parseIntoMap, map, missingKey))\n+          .isInstanceOf(IllegalArgumentException.class)\n+          .hasMessage(\"Invalid input: no key before '='\");\n+    }\n+  }\n+\n+  /**\n+   * This is an example of how to parse without allocating strings. This is based on\n+   * https://github.com/openzipkin/zipkin-aws/blob/master/brave-propagation-aws/src/main/java/brave/propagation/aws/AWSPropagation.java\n+   */\n+  @Test public void example_parseAWSTraceId() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64a3b61da2d5462936887801532344098b0b7c51"}, "originalPosition": 162}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "64a3b61da2d5462936887801532344098b0b7c51", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/64a3b61da2d5462936887801532344098b0b7c51", "committedDate": "2020-05-07T14:02:54Z", "message": "added aws example"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTA2MDc5", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-407906079", "createdAt": "2020-05-07T23:35:57Z", "commit": {"oid": "64a3b61da2d5462936887801532344098b0b7c51"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzozNTo1N1rOGST4lQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wN1QyMzozNTo1N1rOGST4lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg1MzMzMw==", "bodyText": "Does it look more sense to use IllegalArgumentException instead of NullPointerException?", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421853333", "createdAt": "2020-05-07T23:35:57Z", "author": {"login": "samukce"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,245 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string trimming optional whitespace (OWS)\n+ * before or after delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new NullPointerException(\"maxEntries == 0\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64a3b61da2d5462936887801532344098b0b7c51"}, "originalPosition": 37}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b322ab53fd32471d1f7a1eb8b36507837714faa5", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/b322ab53fd32471d1f7a1eb8b36507837714faa5", "committedDate": "2020-05-08T02:12:58Z", "message": "now with javadoc on the builder"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTUzOTQ2", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-407953946", "createdAt": "2020-05-08T02:17:20Z", "commit": {"oid": "b322ab53fd32471d1f7a1eb8b36507837714faa5"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMjoxNzoyMFrOGSWoUA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwMjo1NTo0M1rOGSXOMg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTg5ODMyMA==", "bodyText": "More real-world example might be better (or is this one real?)\ncondition=animal=cat", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421898320", "createdAt": "2020-05-08T02:17:20Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new IllegalArgumentException(\"maxEntries == 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, given a string \"k1=v1,k2=v2\", the {@code\n+     * entrySeparator} should be ','. Given a string \"k1=v1;k2=v2\" the {@code entrySeparator} should\n+     * be ';'. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, given a string \"k1=v1,k2=v2\", the\n+     * {@code keyValueSeparator} should be '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the string \"authcache;ttl=1;spanId=19f84f102048e047\", with\n+     * {@code keyValueSeparator=;} parses {@code [(\"authcache\", \"ttl=1;spanId=19f84f102048e047)]}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b322ab53fd32471d1f7a1eb8b36507837714faa5"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNzE0NQ==", "bodyText": "Should we validate the key value separator and entry separator are different chars?", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421907145", "createdAt": "2020-05-08T02:52:14Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new IllegalArgumentException(\"maxEntries == 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, given a string \"k1=v1,k2=v2\", the {@code\n+     * entrySeparator} should be ','. Given a string \"k1=v1;k2=v2\" the {@code entrySeparator} should\n+     * be ';'. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, given a string \"k1=v1,k2=v2\", the\n+     * {@code keyValueSeparator} should be '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the string \"authcache;ttl=1;spanId=19f84f102048e047\", with\n+     * {@code keyValueSeparator=;} parses {@code [(\"authcache\", \"ttl=1;spanId=19f84f102048e047)]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      return new EntrySplitter(this);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b322ab53fd32471d1f7a1eb8b36507837714faa5"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwNzMwNA==", "bodyText": "To confirm my reading, this only happens at the end of the string, i.e., nextIsEnd == true? Because c can't be both the entry separator and key value separator.\nSince we have a comment, we could say // empty value at end of string: ex", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421907304", "createdAt": "2020-05-08T02:52:55Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new IllegalArgumentException(\"maxEntries == 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, given a string \"k1=v1,k2=v2\", the {@code\n+     * entrySeparator} should be ','. Given a string \"k1=v1;k2=v2\" the {@code entrySeparator} should\n+     * be ';'. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, given a string \"k1=v1,k2=v2\", the\n+     * {@code keyValueSeparator} should be '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the string \"authcache;ttl=1;spanId=19f84f102048e047\", with\n+     * {@code keyValueSeparator=;} parses {@code [(\"authcache\", \"ttl=1;spanId=19f84f102048e047)]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      return new EntrySplitter(this);\n+    }\n+  }\n+\n+  /**\n+   * This is a callback on offsets to avoid allocating strings for a malformed input {@code input}.\n+   *\n+   * @param <T> target of parsed entries\n+   */\n+  public interface Handler<T> {\n+    /**\n+     * Called for each valid entry split from the input {@code input}. Return {@code false} after\n+     * logging to stop due to invalid input.\n+     *\n+     * <p>After validating, typically strings will be parsed from the input like so:\n+     * <pre>{@code\n+     * String key = input.substring(beginKey, endKey);\n+     * String value = input.substring(beginValue, endValue);\n+     * }</pre>\n+     *\n+     * @param target receiver of parsed entries\n+     * @param input string including data to parse\n+     * @param beginKey begin index of the entry's key in {@code input}, inclusive\n+     * @param endKey end index of the entry's key in {@code input}, exclusive\n+     * @param beginValue begin index of the entry's value in {@code input}, inclusive\n+     * @param endValue end index of the entry's value in {@code input}, exclusive\n+     * @return true if we reached the {@code endIndex} without failures.\n+     */\n+    boolean onEntry(\n+        T target, String input, int beginKey, int endKey, int beginValue, int endValue);\n+  }\n+\n+  final char keyValueSeparator, entrySeparator;\n+  int maxEntries;\n+  final boolean trimOWSAroundEntrySeparator, trimOWSAroundKeyValueSeparator;\n+  final boolean keyValueSeparatorRequired, shouldThrow;\n+  final String missingKey, missingKeyValueSeparator, overMaxEntries;\n+\n+  EntrySplitter(Builder builder) {\n+    keyValueSeparator = builder.keyValueSeparator;\n+    entrySeparator = builder.entrySeparator;\n+    maxEntries = builder.maxEntries;\n+    trimOWSAroundEntrySeparator = builder.trimOWSAroundEntrySeparator;\n+    trimOWSAroundKeyValueSeparator = builder.trimOWSAroundKeyValueSeparator;\n+    keyValueSeparatorRequired = builder.keyValueSeparatorRequired;\n+    shouldThrow = builder.shouldThrow;\n+    missingKey = \"Invalid input: no key before '\" + keyValueSeparator + \"'\";\n+    missingKeyValueSeparator =\n+        \"Invalid input: missing key value separator '\" + keyValueSeparator + \"'\";\n+    overMaxEntries = \"Invalid input: over \" + maxEntries + \" entries\";\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(Handler<T> handler, T target, String input) {\n+    return parse(handler, target, input, 0, input.length());\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @param beginIndex begin index of the {@code input}, inclusive\n+   * @param endIndex end index of the {@code input}, exclusive\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(\n+      Handler<T> handler, T target, String input, int beginIndex, int endIndex) {\n+    int remainingEntries = maxEntries, beginKey = -1, endKey = -1, beginValue = -1;\n+    for (int i = beginIndex; i < endIndex; i++) {\n+      char c = input.charAt(i);\n+\n+      boolean nextIsEnd = i + 1 == endIndex;\n+      if (c == entrySeparator || nextIsEnd) { // finished an entry\n+        if (c == keyValueSeparator) {\n+          beginValue = i; // empty value: ex \"key=\" \"k1 =\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b322ab53fd32471d1f7a1eb8b36507837714faa5"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkwODAxOA==", "bodyText": "Again adding \"at end of string\" can help", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421908018", "createdAt": "2020-05-08T02:55:43Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries == 0) throw new IllegalArgumentException(\"maxEntries == 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, given a string \"k1=v1,k2=v2\", the {@code\n+     * entrySeparator} should be ','. Given a string \"k1=v1;k2=v2\" the {@code entrySeparator} should\n+     * be ';'. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, given a string \"k1=v1,k2=v2\", the\n+     * {@code keyValueSeparator} should be '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the string \"authcache;ttl=1;spanId=19f84f102048e047\", with\n+     * {@code keyValueSeparator=;} parses {@code [(\"authcache\", \"ttl=1;spanId=19f84f102048e047)]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the string \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      return new EntrySplitter(this);\n+    }\n+  }\n+\n+  /**\n+   * This is a callback on offsets to avoid allocating strings for a malformed input {@code input}.\n+   *\n+   * @param <T> target of parsed entries\n+   */\n+  public interface Handler<T> {\n+    /**\n+     * Called for each valid entry split from the input {@code input}. Return {@code false} after\n+     * logging to stop due to invalid input.\n+     *\n+     * <p>After validating, typically strings will be parsed from the input like so:\n+     * <pre>{@code\n+     * String key = input.substring(beginKey, endKey);\n+     * String value = input.substring(beginValue, endValue);\n+     * }</pre>\n+     *\n+     * @param target receiver of parsed entries\n+     * @param input string including data to parse\n+     * @param beginKey begin index of the entry's key in {@code input}, inclusive\n+     * @param endKey end index of the entry's key in {@code input}, exclusive\n+     * @param beginValue begin index of the entry's value in {@code input}, inclusive\n+     * @param endValue end index of the entry's value in {@code input}, exclusive\n+     * @return true if we reached the {@code endIndex} without failures.\n+     */\n+    boolean onEntry(\n+        T target, String input, int beginKey, int endKey, int beginValue, int endValue);\n+  }\n+\n+  final char keyValueSeparator, entrySeparator;\n+  int maxEntries;\n+  final boolean trimOWSAroundEntrySeparator, trimOWSAroundKeyValueSeparator;\n+  final boolean keyValueSeparatorRequired, shouldThrow;\n+  final String missingKey, missingKeyValueSeparator, overMaxEntries;\n+\n+  EntrySplitter(Builder builder) {\n+    keyValueSeparator = builder.keyValueSeparator;\n+    entrySeparator = builder.entrySeparator;\n+    maxEntries = builder.maxEntries;\n+    trimOWSAroundEntrySeparator = builder.trimOWSAroundEntrySeparator;\n+    trimOWSAroundKeyValueSeparator = builder.trimOWSAroundKeyValueSeparator;\n+    keyValueSeparatorRequired = builder.keyValueSeparatorRequired;\n+    shouldThrow = builder.shouldThrow;\n+    missingKey = \"Invalid input: no key before '\" + keyValueSeparator + \"'\";\n+    missingKeyValueSeparator =\n+        \"Invalid input: missing key value separator '\" + keyValueSeparator + \"'\";\n+    overMaxEntries = \"Invalid input: over \" + maxEntries + \" entries\";\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(Handler<T> handler, T target, String input) {\n+    return parse(handler, target, input, 0, input.length());\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @param beginIndex begin index of the {@code input}, inclusive\n+   * @param endIndex end index of the {@code input}, exclusive\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(\n+      Handler<T> handler, T target, String input, int beginIndex, int endIndex) {\n+    int remainingEntries = maxEntries, beginKey = -1, endKey = -1, beginValue = -1;\n+    for (int i = beginIndex; i < endIndex; i++) {\n+      char c = input.charAt(i);\n+\n+      boolean nextIsEnd = i + 1 == endIndex;\n+      if (c == entrySeparator || nextIsEnd) { // finished an entry\n+        if (c == keyValueSeparator) {\n+          beginValue = i; // empty value: ex \"key=\" \"k1 =\"\n+        }\n+\n+        if (beginKey == -1 && beginValue == -1) {\n+          continue; // ignore empty entries, like \",,\"\n+        } else if (beginKey == -1) {\n+          return logOrThrow(missingKey, shouldThrow); // ex. \"=\" \",=\"\n+        } else if (nextIsEnd && beginValue == -1) { // ex \"k1\" \"k1 \" \"a=b\" \"..=,\"\n+          // We reached the end of a key-only entry, a single character entry or an empty entry", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b322ab53fd32471d1f7a1eb8b36507837714faa5"}, "originalPosition": 223}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "b5a53e9b3ee92883c7d6cf587dcf79087d5800f0", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/b5a53e9b3ee92883c7d6cf587dcf79087d5800f0", "committedDate": "2020-05-08T04:38:26Z", "message": "feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e1465475a426bc7a3292691f82c2cc497785a8e1", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/e1465475a426bc7a3292691f82c2cc497785a8e1", "committedDate": "2020-05-08T04:54:10Z", "message": "feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTk0OTY0", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-407994964", "createdAt": "2020-05-08T04:55:37Z", "commit": {"oid": "e1465475a426bc7a3292691f82c2cc497785a8e1"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNDo1NTozN1rOGSZBUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNDo1NTozN1rOGSZBUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzNzQ4OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * {@code [(\"condition\", \"animal=cat7\")]}\n          \n          \n            \n                 * {@code [(\"condition\", \"animal=cat\")]}", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421937489", "createdAt": "2020-05-08T04:55:37Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries <= 0) throw new IllegalArgumentException(\"maxEntries <= 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, the input \"k1=v1,k2=v2\", should have\n+     * {@code entrySeparator} ','. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      if (entrySeparator == keyValueSeparator) {\n+        throw new IllegalArgumentException(\"entrySeparator == keyValueSeparator\");\n+      }\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, the input \"k1=v1,k2=v2\" should\n+     * have {@code keyValueSeparator} '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the input \"condition=animal=cat\" with {@code keyValueSeparator} '=' parses\n+     * {@code [(\"condition\", \"animal=cat7\")]}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e1465475a426bc7a3292691f82c2cc497785a8e1"}, "originalPosition": 76}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "da26e42e0b6315f8847c1a46da1b5c35b802346f", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/da26e42e0b6315f8847c1a46da1b5c35b802346f", "committedDate": "2020-05-08T04:55:47Z", "message": "fat finger"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTk2Njgx", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-407996681", "createdAt": "2020-05-08T05:01:44Z", "commit": {"oid": "da26e42e0b6315f8847c1a46da1b5c35b802346f"}, "state": "APPROVED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTowMTo0NFrOGSZHqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTowMTo0NFrOGSZHqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTkzOTExNQ==", "bodyText": "Validating in the setter is nicer but I guess it means we should default the values to 0 and replace with the actual defaults in build. Otherwise, it requires hoops to do the horrible, but not inconceivable, using = as entry separator and , as keyvalue separator.", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421939115", "createdAt": "2020-05-08T05:01:44Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries <= 0) throw new IllegalArgumentException(\"maxEntries <= 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, the input \"k1=v1,k2=v2\", should have\n+     * {@code entrySeparator} ','. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      if (entrySeparator == keyValueSeparator) {\n+        throw new IllegalArgumentException(\"entrySeparator == keyValueSeparator\");\n+      }\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, the input \"k1=v1,k2=v2\" should\n+     * have {@code keyValueSeparator} '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the input \"condition=animal=cat\" with {@code keyValueSeparator} '=' parses\n+     * {@code [(\"condition\", \"animal=cat\")]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      if (keyValueSeparator == entrySeparator) {\n+        throw new IllegalArgumentException(\"keyValueSeparator == entrySeparator\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26e42e0b6315f8847c1a46da1b5c35b802346f"}, "originalPosition": 83}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDA3NzYw", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-408007760", "createdAt": "2020-05-08T05:39:42Z", "commit": {"oid": "da26e42e0b6315f8847c1a46da1b5c35b802346f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTozOTo0M1rOGSZvJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTozOTo0M1rOGSZvJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0OTIyMQ==", "bodyText": "Should we also use it as IllegalArgumentException in those argument validations here? When I pass an invalid argument to a method I expect the method raises some validation error about those instead off give feedback about the invalid arguments wrapped in an NPE error.", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421949221", "createdAt": "2020-05-08T05:39:43Z", "author": {"login": "samukce"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries <= 0) throw new IllegalArgumentException(\"maxEntries <= 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, the input \"k1=v1,k2=v2\", should have\n+     * {@code entrySeparator} ','. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      if (entrySeparator == keyValueSeparator) {\n+        throw new IllegalArgumentException(\"entrySeparator == keyValueSeparator\");\n+      }\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, the input \"k1=v1,k2=v2\" should\n+     * have {@code keyValueSeparator} '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the input \"condition=animal=cat\" with {@code keyValueSeparator} '=' parses\n+     * {@code [(\"condition\", \"animal=cat\")]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      if (keyValueSeparator == entrySeparator) {\n+        throw new IllegalArgumentException(\"keyValueSeparator == entrySeparator\");\n+      }\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the input \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the input \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      return new EntrySplitter(this);\n+    }\n+  }\n+\n+  /**\n+   * This is a callback on offsets to avoid allocating strings for a malformed input {@code input}.\n+   *\n+   * @param <T> target of parsed entries\n+   */\n+  public interface Handler<T> {\n+    /**\n+     * Called for each valid entry split from the input {@code input}. Return {@code false} after\n+     * logging to stop due to invalid input.\n+     *\n+     * <p>After validating, typically strings will be parsed from the input like so:\n+     * <pre>{@code\n+     * String key = input.substring(beginKey, endKey);\n+     * String value = input.substring(beginValue, endValue);\n+     * }</pre>\n+     *\n+     * @param target receiver of parsed entries\n+     * @param input string including data to parse\n+     * @param beginKey begin index of the entry's key in {@code input}, inclusive\n+     * @param endKey end index of the entry's key in {@code input}, exclusive\n+     * @param beginValue begin index of the entry's value in {@code input}, inclusive\n+     * @param endValue end index of the entry's value in {@code input}, exclusive\n+     * @return true if we reached the {@code endIndex} without failures.\n+     */\n+    boolean onEntry(\n+        T target, String input, int beginKey, int endKey, int beginValue, int endValue);\n+  }\n+\n+  final char keyValueSeparator, entrySeparator;\n+  int maxEntries;\n+  final boolean trimOWSAroundEntrySeparator, trimOWSAroundKeyValueSeparator;\n+  final boolean keyValueSeparatorRequired, shouldThrow;\n+  final String missingKey, missingKeyValueSeparator, overMaxEntries;\n+\n+  EntrySplitter(Builder builder) {\n+    keyValueSeparator = builder.keyValueSeparator;\n+    entrySeparator = builder.entrySeparator;\n+    maxEntries = builder.maxEntries;\n+    trimOWSAroundEntrySeparator = builder.trimOWSAroundEntrySeparator;\n+    trimOWSAroundKeyValueSeparator = builder.trimOWSAroundKeyValueSeparator;\n+    keyValueSeparatorRequired = builder.keyValueSeparatorRequired;\n+    shouldThrow = builder.shouldThrow;\n+    missingKey = \"Invalid input: no key before '\" + keyValueSeparator + \"'\";\n+    missingKeyValueSeparator =\n+        \"Invalid input: missing key value separator '\" + keyValueSeparator + \"'\";\n+    overMaxEntries = \"Invalid input: over \" + maxEntries + \" entries\";\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(Handler<T> handler, T target, String input) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    return parse(handler, target, input, 0, input.length());\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @param beginIndex begin index of the {@code input}, inclusive\n+   * @param endIndex end index of the {@code input}, exclusive\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(\n+      Handler<T> handler, T target, String input, int beginIndex, int endIndex) {\n+    if (handler == null) throw new NullPointerException(\"handler == null\");\n+    if (target == null) throw new NullPointerException(\"target == null\");\n+    if (input == null) throw new NullPointerException(\"input == null\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26e42e0b6315f8847c1a46da1b5c35b802346f"}, "originalPosition": 216}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDEwMTk1", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-408010195", "createdAt": "2020-05-08T05:47:16Z", "commit": {"oid": "da26e42e0b6315f8847c1a46da1b5c35b802346f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTo0NzoxNlrOGSZ3qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNTo0NzoxNlrOGSZ3qw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk1MTQwMw==", "bodyText": "We are implementing the builder pattern here but those fields are accessible externally in the package. Doing this we could use the builder in the wrong way as this usage for instance EntrySplitter.newBuilder().maxEntries = 0;. Do we have any motivation for this? Otherwise, we could set as private.", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421951403", "createdAt": "2020-05-08T05:47:16Z", "author": {"login": "samukce"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,315 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "da26e42e0b6315f8847c1a46da1b5c35b802346f"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4bd7fc634f7880255017137a709452dd4cdad4b8", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/4bd7fc634f7880255017137a709452dd4cdad4b8", "committedDate": "2020-05-08T06:30:24Z", "message": "rationale"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDI3OTk0", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-408027994", "createdAt": "2020-05-08T06:35:08Z", "commit": {"oid": "4bd7fc634f7880255017137a709452dd4cdad4b8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjozNTowOFrOGSa2lg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjozNTowOFrOGSa2lg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk2NzUxMA==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421967510", "createdAt": "2020-05-08T06:35:08Z", "author": {"login": "samukce"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -18,10 +18,50 @@ thought as it would betray productivity and make this document unreadable.\n Rationale here should be limited to impactful designs, and aspects non-obvious,\n non-conventional or subtle.\n \n-## Public namespace\n+## Java conventions", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4bd7fc634f7880255017137a709452dd4cdad4b8"}, "originalPosition": 5}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dea88a92de3040e63942647814c3c5fdf376fa6c", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/dea88a92de3040e63942647814c3c5fdf376fa6c", "committedDate": "2020-05-08T06:43:15Z", "message": "emphasizes the android"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDMzMTE0", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-408033114", "createdAt": "2020-05-08T06:46:07Z", "commit": {"oid": "dea88a92de3040e63942647814c3c5fdf376fa6c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjo0NjowN1rOGSbIJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjo0NjowN1rOGSbIJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk3MjAwNw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            This means we don not support sharing our packages with third parties, but we\n          \n          \n            \n            This means we do not support sharing our packages with third parties, but we", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421972007", "createdAt": "2020-05-08T06:46:07Z", "author": {"login": "codefromthecrypt"}, "path": "brave/RATIONALE.md", "diffHunk": "@@ -18,10 +18,57 @@ thought as it would betray productivity and make this document unreadable.\n Rationale here should be limited to impactful designs, and aspects non-obvious,\n non-conventional or subtle.\n \n-## Public namespace\n+## Java conventions\n Brave 4's public namespace is more defensive that the past, using a package\n accessor design from [OkHttp](https://github.com/square/okhttp).\n \n+We only expose types public internally or after significant demand. This keeps\n+the api small and easier to manage when charting migration paths. Otherwise,\n+types are always package private.\n+\n+Methods should only be marked public when they are intentional apis or\n+inheritance requires it. This practice prevents accidental dependence on\n+utilities.\n+\n+### Why no private symbols? (methods and fields)\n+Brave is a library with embedded use cases, such as inside Java agents or\n+Android code.\n+\n+For example, Android has a []hard limit on total methods in an application](https://developer.android.com/studio/build/multidex#avoid).\n+Fields marked private imply accessors in order to share state in the same\n+package. We routinely share state, such as sampling flag internals inside a\n+package. If we marked fields private, we'd count against that limit without\n+adding value.\n+\n+Modifiers on fields and methods are distracting to read and increase the size\n+of the bytecode generated during compilation. By recovering the size otherwise\n+spent on private modifiers, we not only avoid hitting limits, but we are also\n+able to add more code with the same jar size.\n+\n+For example, Brave 5.12 remains less than 250KiB, with no dependencies, all\n+features including deprecation bridges, and an embedded json serializer.\n+\n+This means we don not support sharing our packages with third parties, but we", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "dea88a92de3040e63942647814c3c5fdf376fa6c"}, "originalPosition": 35}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e0580c79a16cd5e670dcc7794e9bb1aac95a5d5b", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/e0580c79a16cd5e670dcc7794e9bb1aac95a5d5b", "committedDate": "2020-05-08T06:46:17Z", "message": "no donut"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a6881b5a5ee87cd161a7820b7615a0fa3a51837f", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/a6881b5a5ee87cd161a7820b7615a0fa3a51837f", "committedDate": "2020-05-08T06:53:36Z", "message": "defer on kv-entry splitter"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDM3ODkw", "url": "https://github.com/openzipkin/brave/pull/1193#pullrequestreview-408037890", "createdAt": "2020-05-08T06:56:04Z", "commit": {"oid": "a6881b5a5ee87cd161a7820b7615a0fa3a51837f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjo1NjowNFrOGSbYQg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNjo1NjowNFrOGSbYQg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk3NjEzMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      // \"...,k1\" and input[i] == 'y', we want i + 1, so that the key includes the 'y'\n          \n          \n            \n                      // \"...,k1\"  and input[i] == 'y', we want i + 1, so that the key includes the 'y'", "url": "https://github.com/openzipkin/brave/pull/1193#discussion_r421976130", "createdAt": "2020-05-08T06:56:04Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/codec/EntrySplitter.java", "diffHunk": "@@ -0,0 +1,312 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.codec;\n+\n+import brave.internal.Platform;\n+\n+/**\n+ * Splits a character sequence that's in a delimited string, optionally trimming optional whitespace\n+ * (<a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>) before or after\n+ * delimiters.\n+ *\n+ * <p>This is intended to be initialized as a constant, as doing so per-request will add\n+ * unnecessary overhead.\n+ */\n+public final class EntrySplitter {\n+  public static Builder newBuilder() {\n+    return new Builder();\n+  }\n+\n+  public static final class Builder {\n+    int maxEntries = Integer.MAX_VALUE;\n+    char entrySeparator = ',', keyValueSeparator = '=';\n+    boolean trimOWSAroundEntrySeparator = true, trimOWSAroundKeyValueSeparator = true;\n+    boolean keyValueSeparatorRequired = true, shouldThrow = false;\n+\n+    /**\n+     * When set, {@link Handler} will be called maximum {@code maxEntries} times per parse. After\n+     * that, {@link #parse(Handler, Object, String)} returns false or throws an exception, based on\n+     * {@link #shouldThrow(boolean)}. Default: {@link Integer#MAX_VALUE}.\n+     *\n+     * <p>This is used to implement strict format constraints. For example, above 32 entries is\n+     * malformed. This is separate from any capacity constraints of the {@link Handler}, which may\n+     * be smaller than this amount.\n+     */\n+    public Builder maxEntries(int maxEntries) {\n+      if (maxEntries <= 0) throw new IllegalArgumentException(\"maxEntries <= 0\");\n+      this.maxEntries = maxEntries;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between entries. For example, the input \"k1=v1,k2=v2\", should have\n+     * {@code entrySeparator} ','. Default: ','\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder entrySeparator(char entrySeparator) {\n+      if (entrySeparator == 0) throw new IllegalArgumentException(\"entrySeparator == 0\");\n+      this.entrySeparator = entrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * The separator to use between a key and value. For example, the input \"k1=v1,k2=v2\" should\n+     * have {@code keyValueSeparator} '='. Default: '='\n+     *\n+     * <p><em>Note:</em> Only the first {@code keyValueSeparator} identifies the end of the key\n+     * until the next {@link #entrySeparator(char)}. This means values can include the {@code\n+     * keyValueSeparator} character.\n+     *\n+     * <p>For example, the input \"condition=animal=cat\" with {@code keyValueSeparator} '=' parses\n+     * {@code [(\"condition\", \"animal=cat\")]}\n+     *\n+     * @see #keyValueSeparator(char)\n+     */\n+    public Builder keyValueSeparator(char keyValueSeparator) {\n+      if (keyValueSeparator == 0) throw new IllegalArgumentException(\"keyValueSeparator == 0\");\n+      this.keyValueSeparator = keyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #entrySeparator} and string boundaries. Default: {@code true}\n+     *\n+     * <p>For example, given the input \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"k1   \",\"   v1\"),(\"k2   \", \"   v2\")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundEntrySeparator(boolean trimOWSAroundEntrySeparator) {\n+      this.trimOWSAroundEntrySeparator = trimOWSAroundEntrySeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, optional whitespace (spaces and tabs aka <a href=\"https://httpwg.org/specs/rfc7230.html#rfc.section.3.2\">OWS</a>)\n+     * are removed around the {@link #keyValueSeparator(char)}. Default: {@code true}\n+     *\n+     * <p>For example, given the input \"  k1   =   v1  ,  k2   =   v2  \", this trims around the\n+     * \"=\" character and string boundaries: {@code [(\"  k1\", \"v1  \"),(\"  k2\", \"v2  \")]}.\n+     *\n+     * @see #trimOWSAroundKeyValueSeparator(boolean)\n+     */\n+    public Builder trimOWSAroundKeyValueSeparator(boolean trimOWSAroundKeyValueSeparator) {\n+      this.trimOWSAroundKeyValueSeparator = trimOWSAroundKeyValueSeparator;\n+      return this;\n+    }\n+\n+    /**\n+     * When {@code true}, when a {@link #keyValueSeparator(char)} does not follow a key, {@link\n+     * #parse(Handler, Object, String)} returns false or throws an exception, based on {@link\n+     * #shouldThrow(boolean)}. Default: {@code true}.\n+     *\n+     * <p>Setting this to {@code false} makes \"k1,k2=v2\" interpreted the same as if there was\n+     * a {@link #keyValueSeparator(char)}: \"k1=,k2=v2\". This is used for formats such as HTTP\n+     * queries where separators are optional.\n+     */\n+    public Builder keyValueSeparatorRequired(boolean keyValueSeparatorRequired) {\n+      this.keyValueSeparatorRequired = keyValueSeparatorRequired;\n+      return this;\n+    }\n+\n+    /**\n+     * On validation fail, should this throw an exception or log?. The use case to throw is when\n+     * validating input (ex into a builder), or in unit tests.\n+     */\n+    public Builder shouldThrow(boolean shouldThrow) {\n+      this.shouldThrow = shouldThrow;\n+      return this;\n+    }\n+\n+    public EntrySplitter build() {\n+      if (entrySeparator == keyValueSeparator) {\n+        throw new IllegalArgumentException(\"entrySeparator == keyValueSeparator\");\n+      }\n+      return new EntrySplitter(this);\n+    }\n+  }\n+\n+  /**\n+   * This is a callback on offsets to avoid allocating strings for a malformed input {@code input}.\n+   *\n+   * @param <T> target of parsed entries\n+   */\n+  public interface Handler<T> {\n+    /**\n+     * Called for each valid entry split from the input {@code input}. Return {@code false} after\n+     * logging to stop due to invalid input.\n+     *\n+     * <p>After validating, typically strings will be parsed from the input like so:\n+     * <pre>{@code\n+     * String key = input.substring(beginKey, endKey);\n+     * String value = input.substring(beginValue, endValue);\n+     * }</pre>\n+     *\n+     * @param target receiver of parsed entries\n+     * @param input string including data to parse\n+     * @param beginKey begin index of the entry's key in {@code input}, inclusive\n+     * @param endKey end index of the entry's key in {@code input}, exclusive\n+     * @param beginValue begin index of the entry's value in {@code input}, inclusive\n+     * @param endValue end index of the entry's value in {@code input}, exclusive\n+     * @return true if we reached the {@code endIndex} without failures.\n+     */\n+    boolean onEntry(\n+        T target, String input, int beginKey, int endKey, int beginValue, int endValue);\n+  }\n+\n+  final char keyValueSeparator, entrySeparator;\n+  int maxEntries;\n+  final boolean trimOWSAroundEntrySeparator, trimOWSAroundKeyValueSeparator;\n+  final boolean keyValueSeparatorRequired, shouldThrow;\n+  final String missingKey, missingKeyValueSeparator, overMaxEntries;\n+\n+  EntrySplitter(Builder builder) {\n+    keyValueSeparator = builder.keyValueSeparator;\n+    entrySeparator = builder.entrySeparator;\n+    maxEntries = builder.maxEntries;\n+    trimOWSAroundEntrySeparator = builder.trimOWSAroundEntrySeparator;\n+    trimOWSAroundKeyValueSeparator = builder.trimOWSAroundKeyValueSeparator;\n+    keyValueSeparatorRequired = builder.keyValueSeparatorRequired;\n+    shouldThrow = builder.shouldThrow;\n+    missingKey = \"Invalid input: no key before '\" + keyValueSeparator + \"'\";\n+    missingKeyValueSeparator =\n+        \"Invalid input: missing key value separator '\" + keyValueSeparator + \"'\";\n+    overMaxEntries = \"Invalid input: over \" + maxEntries + \" entries\";\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(Handler<T> handler, T target, String input) {\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    return parse(handler, target, input, 0, input.length());\n+  }\n+\n+  /**\n+   * @param handler parses entries emitted upon success\n+   * @param target receiver of parsed entries\n+   * @param input string including data to parse\n+   * @param beginIndex begin index of the {@code input}, inclusive\n+   * @param endIndex end index of the {@code input}, exclusive\n+   * @return true if we reached the {@code endIndex} without failures.\n+   */\n+  public <T> boolean parse(\n+      Handler<T> handler, T target, String input, int beginIndex, int endIndex) {\n+    if (handler == null) throw new NullPointerException(\"handler == null\");\n+    if (target == null) throw new NullPointerException(\"target == null\");\n+    if (input == null) throw new NullPointerException(\"input == null\");\n+    if (beginIndex < 0) throw new IllegalArgumentException(\"beginIndex < 0\");\n+    if (endIndex > input.length()) throw new IllegalArgumentException(\"endIndex > input.length()\");\n+\n+    int remainingEntries = maxEntries, beginKey = -1, endKey = -1, beginValue = -1;\n+    for (int i = beginIndex; i < endIndex; i++) {\n+      char c = input.charAt(i);\n+\n+      boolean nextIsEnd = i + 1 == endIndex;\n+      if (c == entrySeparator || nextIsEnd) { // finished an entry\n+        if (c == keyValueSeparator) {\n+          beginValue = i; // key separator at end of the input. ex \"key=\" or \"k1 =\", but not \"k1\"\n+        }\n+\n+        if (beginKey == -1 && beginValue == -1) {\n+          continue; // ignore empty entries, like \",,\"\n+        } else if (beginKey == -1) {\n+          return logOrThrow(missingKey, shouldThrow); // ex. \"=\" \",=\"\n+        } else if (nextIsEnd && beginValue == -1) {\n+          // We reached the end of a key-only entry, a single character entry or an empty entry\n+          // at the end of the input. ex \"k1\" \"k1 \" \"a=b\" \"..=,\"\n+          beginValue = c == entrySeparator ? i + 1 : i;\n+        }\n+\n+        int endValue;\n+        if (endKey == -1) {\n+          if (keyValueSeparatorRequired && c != keyValueSeparator) {\n+            return logOrThrow(missingKeyValueSeparator, shouldThrow); // throw on \"k1\" \"k1=v2,k2\"\n+          }\n+\n+          // Even though we have an empty value, we need to handle whitespace and\n+          // boundary conditions.\n+          //\n+          // For example, using entry separator ',' and KV separator '=':\n+          // \"...,k1\" and input[i] == 'y', we want i + 1, so that the key includes the 'y'", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a6881b5a5ee87cd161a7820b7615a0fa3a51837f"}, "originalPosition": 247}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "2ce0e41dc8796c8388b6d515d0e6501bc07220b3", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/2ce0e41dc8796c8388b6d515d0e6501bc07220b3", "committedDate": "2020-05-08T06:56:18Z", "message": "make column pretty"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1728, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}