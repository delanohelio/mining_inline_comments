{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk0MTIwMzE5", "number": 1127, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo1MDoxOFrODrnAJw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNjo0ODowNVrODr8VHQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDU0Mzc1OnYy", "diffSide": "RIGHT", "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo1MDoxOFrOF8DPLg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo1MDoxOFrOF8DPLg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMTkxOA==", "bodyText": "I made a bug somewhere where I called this twice and expected different results :)", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r398511918", "createdAt": "2020-03-26T11:50:18Z", "author": {"login": "codefromthecrypt"}, "path": "brave-tests/src/main/java/brave/test/ITRemote.java", "diffHunk": "@@ -60,19 +60,22 @@\n \n   /** Returns a trace context for use in propagation tests. */\n   protected TraceContext newTraceContext(SamplingFlags flags) {\n+    long id = System.nanoTime(); // Random enough as tests are run serially anyway\n     TraceContext result = TraceContext.newBuilder()\n-      .traceIdHigh(1L).traceId(2L).parentId(3L).spanId(1L)\n+      .traceIdHigh(id).traceId(id + 1).parentId(id + 2).spanId(id + 3)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0914633632f92381a59ac26635acf5825b63a2"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDU0NjY3OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo1MTowMVrOF8DQ4w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo1MTowMVrOF8DQ4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxMjM1NQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @throws AssertionError if any scopes were left unclosed.\n          \n          \n            \n               * @throws IllegalStateException if any scopes were left unclosed.", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r398512355", "createdAt": "2020-03-26T11:51:01Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "diffHunk": "@@ -30,38 +35,66 @@\n  *                  ).build();\n  * }</pre>\n  */\n-public final class StrictScopeDecorator implements ScopeDecorator {\n-  public static ScopeDecorator create() {\n+// Closeable so things like Spring will automatically execute it on shutdown and expose leaks!\n+public final class StrictScopeDecorator implements ScopeDecorator, Closeable {\n+  public static StrictScopeDecorator create() {\n     return new StrictScopeDecorator();\n   }\n \n-  /** Identifies problems by throwing assertion errors when a scope is closed on a different thread. */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    return new StrictScope(scope, new Error(String.format(\"Thread %s opened scope for %s here:\",\n-      Thread.currentThread().getName(), currentSpan)));\n+  final Queue<CallerStackTrace> currentCallers = new ConcurrentLinkedQueue<>();\n+\n+  /**\n+   * Identifies problems by throwing {@link IllegalStateException} when a scope is closed on a\n+   * different thread.\n+   */\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    return new StrictScope(scope, new CallerStackTrace(context), currentCallers);\n+  }\n+\n+  /**\n+   * @throws AssertionError if any scopes were left unclosed.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e0914633632f92381a59ac26635acf5825b63a2"}, "originalPosition": 46}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MDU1ODU3OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo1NDoxOFrOF8DX9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNlQxMTo1NDoxOFrOF8DX9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODUxNDE2Ng==", "bodyText": "This is a neat trick.. Let's say some instrumentation you didn't write might be leaking a scope. If you add a bean of this type to an app with sleuth.. when you ctrl-c it should expose any leak problem automatically.", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r398514166", "createdAt": "2020-03-26T11:54:18Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "diffHunk": "@@ -30,38 +35,66 @@\n  *                  ).build();\n  * }</pre>\n  */\n-public final class StrictScopeDecorator implements ScopeDecorator {\n-  public static ScopeDecorator create() {\n+// Closeable so things like Spring will automatically execute it on shutdown and expose leaks!", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daf53a8425b72457c702ab2096dd683915c6977f"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3MzYzMjY3OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMjo0MDoyMFrOF8hQSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwMzowOTozNVrOF8huCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAwMzcyMg==", "bodyText": "Probably don't care about performance of this but just in case, can consider using a LinkedBlockingDeque to just remove the last element instead of iterating to the end.", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399003722", "createdAt": "2020-03-27T02:40:20Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "diffHunk": "@@ -30,38 +35,66 @@\n  *                  ).build();\n  * }</pre>\n  */\n-public final class StrictScopeDecorator implements ScopeDecorator {\n-  public static ScopeDecorator create() {\n+// Closeable so things like Spring will automatically execute it on shutdown and expose leaks!\n+public final class StrictScopeDecorator implements ScopeDecorator, Closeable {\n+  public static StrictScopeDecorator create() {\n     return new StrictScopeDecorator();\n   }\n \n-  /** Identifies problems by throwing assertion errors when a scope is closed on a different thread. */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    return new StrictScope(scope, new Error(String.format(\"Thread %s opened scope for %s here:\",\n-      Thread.currentThread().getName(), currentSpan)));\n+  final Queue<CallerStackTrace> currentCallers = new ConcurrentLinkedQueue<>();\n+\n+  /**\n+   * Identifies problems by throwing {@link IllegalStateException} when a scope is closed on a\n+   * different thread.\n+   */\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    return new StrictScope(scope, new CallerStackTrace(context), currentCallers);\n+  }\n+\n+  /**\n+   * @throws IllegalStateException if any scopes were left unclosed.\n+   * @since 5.11\n+   */\n+  @Override public void close() {\n+    for (CallerStackTrace caller : currentCallers) {\n+      throw new IllegalStateException(\n+        \"Thread [\" + caller.threadName + \"] opened scope, but never closed it\", caller);\n+    }\n   }\n \n   static final class StrictScope implements Scope {\n     final Scope delegate;\n-    final Throwable caller;\n-    final long threadId = Thread.currentThread().getId();\n+    final Queue<CallerStackTrace> currentCallers;\n+    final CallerStackTrace caller;\n \n-    StrictScope(Scope delegate, Throwable caller) {\n+    StrictScope(Scope delegate, CallerStackTrace caller, Queue<CallerStackTrace> currentCallers) {\n       this.delegate = delegate;\n+      this.currentCallers = currentCallers;\n       this.caller = caller;\n+      this.currentCallers.add(caller);\n     }\n \n     @Override public void close() {\n-      if (Thread.currentThread().getId() != threadId) {\n-        throw new IllegalStateException(\n-          \"scope closed in a different thread: \" + Thread.currentThread().getName(),\n-          caller);\n+      currentCallers.remove(caller);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "daf53a8425b72457c702ab2096dd683915c6977f"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAxMTMzNw==", "bodyText": "I so wanted to, but that's Java 1.7 plus (animal sniffer found this)", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399011337", "createdAt": "2020-03-27T03:09:35Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/StrictScopeDecorator.java", "diffHunk": "@@ -30,38 +35,66 @@\n  *                  ).build();\n  * }</pre>\n  */\n-public final class StrictScopeDecorator implements ScopeDecorator {\n-  public static ScopeDecorator create() {\n+// Closeable so things like Spring will automatically execute it on shutdown and expose leaks!\n+public final class StrictScopeDecorator implements ScopeDecorator, Closeable {\n+  public static StrictScopeDecorator create() {\n     return new StrictScopeDecorator();\n   }\n \n-  /** Identifies problems by throwing assertion errors when a scope is closed on a different thread. */\n-  @Override public Scope decorateScope(@Nullable TraceContext currentSpan, Scope scope) {\n-    return new StrictScope(scope, new Error(String.format(\"Thread %s opened scope for %s here:\",\n-      Thread.currentThread().getName(), currentSpan)));\n+  final Queue<CallerStackTrace> currentCallers = new ConcurrentLinkedQueue<>();\n+\n+  /**\n+   * Identifies problems by throwing {@link IllegalStateException} when a scope is closed on a\n+   * different thread.\n+   */\n+  @Override public Scope decorateScope(@Nullable TraceContext context, Scope scope) {\n+    return new StrictScope(scope, new CallerStackTrace(context), currentCallers);\n+  }\n+\n+  /**\n+   * @throws IllegalStateException if any scopes were left unclosed.\n+   * @since 5.11\n+   */\n+  @Override public void close() {\n+    for (CallerStackTrace caller : currentCallers) {\n+      throw new IllegalStateException(\n+        \"Thread [\" + caller.threadName + \"] opened scope, but never closed it\", caller);\n+    }\n   }\n \n   static final class StrictScope implements Scope {\n     final Scope delegate;\n-    final Throwable caller;\n-    final long threadId = Thread.currentThread().getId();\n+    final Queue<CallerStackTrace> currentCallers;\n+    final CallerStackTrace caller;\n \n-    StrictScope(Scope delegate, Throwable caller) {\n+    StrictScope(Scope delegate, CallerStackTrace caller, Queue<CallerStackTrace> currentCallers) {\n       this.delegate = delegate;\n+      this.currentCallers = currentCallers;\n       this.caller = caller;\n+      this.currentCallers.add(caller);\n     }\n \n     @Override public void close() {\n-      if (Thread.currentThread().getId() != threadId) {\n-        throw new IllegalStateException(\n-          \"scope closed in a different thread: \" + Thread.currentThread().getName(),\n-          caller);\n+      currentCallers.remove(caller);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTAwMzcyMg=="}, "originalCommit": {"oid": "daf53a8425b72457c702ab2096dd683915c6977f"}, "originalPosition": 76}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3NDAzODA1OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNjo0ODowNVrOF8k8kg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yN1QwNjo1MzozN1rOF8lDlA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDIxMA==", "bodyText": "Is it worth adding something like \"This is generally only useful in tests\"?", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399064210", "createdAt": "2020-03-27T06:48:05Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -42,13 +42,27 @@ public static CurrentTraceContext create() {\n     return new Builder().build();\n   }\n \n-  public static CurrentTraceContext.Builder newBuilder() {\n+  public static Builder newBuilder() {\n     return new Builder();\n   }\n \n-  static final class Builder extends CurrentTraceContext.Builder {\n+  /**\n+   * This component is backed by a possibly static shared thread local. Call this to clear the\n+   * reference when you are sure any residual state is due to a leak.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a5fe85a2bafff5209f8a28196e5b7e8383cc8d4f"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDk0Mw==", "bodyText": "sure", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399064943", "createdAt": "2020-03-27T06:50:21Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -42,13 +42,27 @@ public static CurrentTraceContext create() {\n     return new Builder().build();\n   }\n \n-  public static CurrentTraceContext.Builder newBuilder() {\n+  public static Builder newBuilder() {\n     return new Builder();\n   }\n \n-  static final class Builder extends CurrentTraceContext.Builder {\n+  /**\n+   * This component is backed by a possibly static shared thread local. Call this to clear the\n+   * reference when you are sure any residual state is due to a leak.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDIxMA=="}, "originalCommit": {"oid": "a5fe85a2bafff5209f8a28196e5b7e8383cc8d4f"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NTg4MQ==", "bodyText": "well it is being done in a hack way in sleuth...\nhere\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/instrument/web/TraceWebFilter.java#L123-L126\nand also here\nhttps://github.com/spring-cloud/spring-cloud-sleuth/blob/master/spring-cloud-sleuth-core/src/main/java/org/springframework/cloud/sleuth/instrument/scheduling/TraceSchedulingAspect.java#L63-L65\nWhile I can't say either are correct, it might be that some bad instrumentation (ex written by an end user) leaks, and someone wants to correct it.", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399065881", "createdAt": "2020-03-27T06:53:12Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -42,13 +42,27 @@ public static CurrentTraceContext create() {\n     return new Builder().build();\n   }\n \n-  public static CurrentTraceContext.Builder newBuilder() {\n+  public static Builder newBuilder() {\n     return new Builder();\n   }\n \n-  static final class Builder extends CurrentTraceContext.Builder {\n+  /**\n+   * This component is backed by a possibly static shared thread local. Call this to clear the\n+   * reference when you are sure any residual state is due to a leak.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDIxMA=="}, "originalCommit": {"oid": "a5fe85a2bafff5209f8a28196e5b7e8383cc8d4f"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NjAwNA==", "bodyText": "regardless, your statement is correct.. this should (not must) be only used in tests.", "url": "https://github.com/openzipkin/brave/pull/1127#discussion_r399066004", "createdAt": "2020-03-27T06:53:37Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -42,13 +42,27 @@ public static CurrentTraceContext create() {\n     return new Builder().build();\n   }\n \n-  public static CurrentTraceContext.Builder newBuilder() {\n+  public static Builder newBuilder() {\n     return new Builder();\n   }\n \n-  static final class Builder extends CurrentTraceContext.Builder {\n+  /**\n+   * This component is backed by a possibly static shared thread local. Call this to clear the\n+   * reference when you are sure any residual state is due to a leak.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTA2NDIxMA=="}, "originalCommit": {"oid": "a5fe85a2bafff5209f8a28196e5b7e8383cc8d4f"}, "originalPosition": 19}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1587, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}