{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDI1NzM5NzI3", "number": 1224, "reviewThreads": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNDo1MDoyOFrOEBPoag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowODo1OVrOEFbqJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzQwMTM4OnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingResponse.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNDo1MDoyOFrOGc-qmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNTowNzoxN1rOGc-2pA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MDAyNA==", "bodyText": "Curious when this could be set - if the MQ is run in-process?", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r433040024", "createdAt": "2020-06-01T04:50:28Z", "author": {"login": "anuraaga"}, "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingResponse.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.messaging;\n+\n+import brave.Response;\n+import brave.internal.Nullable;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of messaging clients and servers.\n+ *\n+ * @see ProducerResponse\n+ * @see ConsumerResponse\n+ * @since 5.13\n+ */\n+public abstract class MessagingResponse extends Response {\n+  /**\n+   * The request that initiated this messaging response or {@code null} if unknown.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ecbc114033fdc41a29eeaec4e24ac7e6adbf835"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MjAwMg==", "bodyText": "probably not the best sentence. So, for example the messageId field is only readable during the response processing of AWS SQS.\nDifferent than RPC I think here it isn't important that the request is what initiated the response, rather it is simply the request data, available here so you can late process data like message Id", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r433042002", "createdAt": "2020-06-01T05:01:03Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingResponse.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.messaging;\n+\n+import brave.Response;\n+import brave.internal.Nullable;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of messaging clients and servers.\n+ *\n+ * @see ProducerResponse\n+ * @see ConsumerResponse\n+ * @since 5.13\n+ */\n+public abstract class MessagingResponse extends Response {\n+  /**\n+   * The request that initiated this messaging response or {@code null} if unknown.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MDAyNA=="}, "originalCommit": {"oid": "6ecbc114033fdc41a29eeaec4e24ac7e6adbf835"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MzEwOA==", "bodyText": "Ah I think it could be Information about the request that...", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r433043108", "createdAt": "2020-06-01T05:07:17Z", "author": {"login": "anuraaga"}, "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingResponse.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.messaging;\n+\n+import brave.Response;\n+import brave.internal.Nullable;\n+\n+/**\n+ * Abstract response type used for parsing and sampling of messaging clients and servers.\n+ *\n+ * @see ProducerResponse\n+ * @see ConsumerResponse\n+ * @since 5.13\n+ */\n+public abstract class MessagingResponse extends Response {\n+  /**\n+   * The request that initiated this messaging response or {@code null} if unknown.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MDAyNA=="}, "originalCommit": {"oid": "6ecbc114033fdc41a29eeaec4e24ac7e6adbf835"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzQxMTEyOnYy", "diffSide": "LEFT", "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingRequest.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNDo1ODo1M1rOGc-wsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNTowNjo1M1rOGc-2Vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MTU4Ng==", "bodyText": "ps sometime around july last year we decided to replace message.X with messaging.X I don't recall the rationale but it should have been written down. I think it was to do with how the other properties would sound if prefixed \"message\" also to match the abstraction name.\nThe only reason I mention this is that we should decide if the tag name \"messaging.id\" is ok for the message id or we make \"messaging.message_id\" which is also awkward for the same. I don't have a strong feeling either way, but happy to add to the RATIONALE whatever we choose.", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r433041586", "createdAt": "2020-06-01T04:58:53Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingRequest.java", "diffHunk": "@@ -59,13 +57,26 @@\n   /**\n    * Messaging channel name, e.g. \"hooks\" or \"complaints\". {@code null} if unreadable.\n    *\n-   * <p>Conventionally associated with the key \"messaging.channel_name\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ecbc114033fdc41a29eeaec4e24ac7e6adbf835"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MzAzMQ==", "bodyText": "Lean towards messaging.id since when in doubt, shorter seems better", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r433043031", "createdAt": "2020-06-01T05:06:53Z", "author": {"login": "anuraaga"}, "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingRequest.java", "diffHunk": "@@ -59,13 +57,26 @@\n   /**\n    * Messaging channel name, e.g. \"hooks\" or \"complaints\". {@code null} if unreadable.\n    *\n-   * <p>Conventionally associated with the key \"messaging.channel_name\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA0MTU4Ng=="}, "originalCommit": {"oid": "6ecbc114033fdc41a29eeaec4e24ac7e6adbf835"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzcwODgyOnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzo0MToyNFrOGdBikg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzo0MToyNFrOGdBikg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA4NzEyMg==", "bodyText": "+1, chances are very high that the trace or span contains enough contextual information to pinpoint to a specific message anyway if ever needed. Nice wording btw \ud83d\udc4d", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r433087122", "createdAt": "2020-06-01T07:41:24Z", "author": {"login": "jorgheymans"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,19 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Why don't we define a message ID for tools lacking one, such as Kafka?\n+\n+Typical message ID formats encode multiple components such as a broker ID or network address,\n+destination, timestamp or offset. It may be tempting to compose a format to include the dimensions\n+that likely pinpoint a message when there's no format defined by the library. For example, in Kafka,\n+we could compose a format like `topic-partition-offset` to ensure `MessagingRequest.id()` would not\n+be `null`, and people can access not-yet-standard fields such as partition or offset.\n+\n+If we did that, we'd add overhead with the only consumer being tracing itself. It would fail as a\n+correlation field with other libraries as by definition our format would be bespoke. Moreover,\n+higher layers of abstraction which might have a defined message ID format could be confused with\n+ours. Later, if that same tool creates a message ID format, it would likely be different than ours.\n+\n+For reasons including these, if there's no canonical format, we opt out of synthesizing a message ID\n+and just return `null`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740782ef244fdf178f2072d7f6c3b306be06cdd9"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjY5NzcxNjA3OnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingRequest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzo0Mzo0NFrOGdBmvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMVQwNzo0Mzo0NFrOGdBmvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA4ODE4OA==", "bodyText": "Maby add <li>Kakfa - null</li> here once we're decided on this", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r433088188", "createdAt": "2020-06-01T07:43:44Z", "author": {"login": "jorgheymans"}, "path": "instrumentation/messaging/src/main/java/brave/messaging/MessagingRequest.java", "diffHunk": "@@ -66,6 +66,23 @@\n    */\n   @Nullable public abstract String channelName();\n \n+  /**\n+   * The possibly system generated value that uniquely identifies this message. Return {@code null} if\n+   * the ID was unreadable or the transport has no canonical message ID format.\n+   *\n+   * <p>Examples:\n+   * <pre><ul>\n+   *   <li>Amazon SQS - \"MessageId\" response field. ex \"5fea7756-0ea4-451a-a703-a558b933e274\"</li>\n+   *   <li>JMS - \"JMSMessageID\" header. Ex \"ID:10.77.42.209-4280-1477454185311-1:1:1391:1:1\"</li>\n+   *   <li>RabbitMQ - AMQP \"message-id\" (max 256 char)</li>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "740782ef244fdf178f2072d7f6c3b306be06cdd9"}, "originalPosition": 19}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MDQ1OTM3OnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNFQyMTo1MDowNFrOGjflug==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwMDowOToyOFrOGjgRoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg3MDkwNg==", "bodyText": "If we agree with keeping messageId only when this field exists, we should update this line.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For reasons including these, if there's no message ID field, we fall back to a numeric property like\n          \n          \n            \n            offset or sequence, and failing that just return `null`.\n          \n          \n            \n            For reasons including these, if there's no message ID field, and failing that just return `null`.", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r439870906", "createdAt": "2020-06-14T21:50:04Z", "author": {"login": "jeqo"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,134 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Message ID\n+In practice, the message ID is used for deletion, visibility control, retrieval, correlation,\n+duplicate detection or a combination of these. We derive semantics by looking at multiple open\n+source projects and cloud services, as well the special case of JMS.\n+\n+| System      | Kind     | Operation      | Direction | Field                       | Owner  | Scope      | Format\n+|-------------|----------|----------------|-----------|-----------------------------|--------|------------|--------\n+| AMQP        | PRODUCER | publish        | Request   | message-id                  | Local  | Global     | 1-255 characters\n+| AMQP        | CONSUMER | consume        | Request   | message-id                  | Remote | Global     | 1-255 characters\n+| Azure Queue | PRODUCER | PutMessage     | Response  | MessageId                   | Remote | Global     | UUID\n+| Azure Queue | CONSUMER | DeleteMessage  | Response  | MessageId                   | Remote | Global     | UUID\n+| Artemis     | CONSUMER | receive        | Request   | messageId                   | Remote | Global     | random uint64\n+| Kafka       | PRODUCER | send           | Response  | offset                      | Remote | Topic      | uint64\n+| Kafka       | CONSUMER | poll           | Request   | offset                      | Remote | Topic      | uint64\n+| Kinesis     | PRODUCER | Publish        | Response  | SequenceNumber              | Remote | Stream     | 1-128 digits\n+| Kinesis     | CONSUMER | Lambda         | Request   | sequenceNumber              | Remote | Global     | 1-128 digits\n+| SQS         | PRODUCER | SendMessage    | Request   | MessageDeduplicationId      | Local  | Queue      | SHA-256(body)\n+| SQS         | CONSUMER | ReceiveMessage | Request   | MessageDeduplicationId      | Remote | Queue      | SHA-256(body)\n+| SQS         | PRODUCER | SendMessage    | Response  | MessageId                   | Remote | Global     | UUID\n+| SQS         | CONSUMER | ReceiveMessage | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | PRODUCER | Publish        | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | CONSUMER | POST           | Request   | x-amz-sns-message-id        | Remote | Global     | UUID\n+| PubSub      | PRODUCER | Publish        | Response  | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Push           | Request   | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Pull           | Response  | message_id                  | Remote | Topic      | Integer\n+| JMS         | PRODUCER | Send           | Response  | JMSMessageId                | Remote | Global     | ID:opaque string\n+| JMS         | CONSUMER | Receive        | Request   | JMSMessageId                | Remote | Global     | ID:opaque string\n+| MQTT        | PRODUCER | PUBLISH        | Request   | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | PRODUCER | PUBACK/PUBREC  | Response  | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | CONSUMER | PUBLISH        | Request   | Packet Identifier           | Remote | Connection | uint16\n+| MQTT        | CONSUMER | PUBACK/PUBREC  | Response  | Packet Identifier           | Remote | Connection | uint16\n+| Pulsar      | PRODUCER | Send           | Response  | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| Pulsar      | CONSUMER | Receive        | Request   | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| RocketMQ    | PRODUCER | send           | Response  | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| RocketMQ    | CONSUMER | consumeMessage | Request   | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| ServiceBus  | PRODUCER | POST           | Request   | BrokerProperties{MessageId} | Local  | Global     | 1-255 characters\n+| ServiceBus  | CONSUMER | DELETE         | Request   | BrokerProperties{MessageId} | Remote | Global     | 1-255 characters\n+| STOMP       | PRODUCER | SEND           | Request   | receipt Header              | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | RECEIPT/ERROR  | Response  | receipt-id Header           | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | SEND           | Request   | receipt Header              | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | RECEIPT/ERROR  | Response  | receipt-id Header           | Remote | Connection | arbitrary\n+| STOMP       | PRODUCER | MESSAGE        | Request   | message-id Header           | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | ACK/NACK       | Response  | id Header                   | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | MESSAGE        | Request   | message-id Header           | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | ACK/NACK       | Response  | id Header                   | Remote | Connection | arbitrary\n+\n+### Isn't correlation ID the same as a message ID?\n+A correlation ID is a system-wide lookup value that possibly can pass multiple steps. A message ID\n+can have a scope as small as one segment (Ex. flow from producer to broker), and typically an\n+implementation detail. It can bet the case that they are the same, but it is not commonly the case.\n+\n+For example in MQTT, the packet ID is only valid for one segment a message takes. This means for the\n+same message body, the packet ID is overwritten when passing from the producer to the eventual\n+consumer. A more extreme example is Artemis, where there is no api to receive the messageId\n+associated with a published message. In other words, it is only visible in the consumer side, so\n+cannot be used for correlation between the producer and consumer.\n+\n+That said, correlation IDs are sometimes used for single-segment processing. For example, one\n+pattern in JMS is to copy the incoming `JMSMessageID` as the `CorrelationID` in a `JMSReplyTo`\n+response, so that the sender can correlate the two.\n+\n+For the above reasons, we cannot use the message ID and correlation ID concepts interchangeably.\n+\n+### When is a message ID ambiguous?\n+There are many types of features supported by message IDs. Some protocols use a global ID for\n+multiple features. Others use separate ones. In some cases, the choice of which to use for the\n+message ID field borders on arbitrary. Here are some examples to reinforce this.\n+\n+Amazon SQS includes a service-generated `MessageId` that can identify a message later consumed.\n+However, to delete an instance of that message you need one of potentially many `ReceiptHandle`s\n+associated with the `MessageId`. The client can also set certain IDs. For example, a client sets\n+`MessageDeduplicationId` before sending a message to a FIFO queue to suppress redundant sends. In\n+other words there are at least 3 identifiers for a single message, in different formats, depending\n+on the use case.\n+\n+Azure Queue a service-generated `MessageId`, but also a client-generated `x-ms-client-request-id`\n+for correlation. Unlike most services, Azure Queue has delete or update by `MessageId` functions,\n+though a `popreceipt` (akin to subscriber) is also required for these tasks.\n+\n+Azure ServiceBus includes the AMQP `BrokerProperties{MessageId}` field, but it also supports the\n+Kafka protocol, which does not have a message ID. In support of the latter, it also has a\n+`SequenceId` field, which embeds parition information with a logical sequence. Note, when using\n+Kafka protocol an `offset` will also exist, and is not directly related to the `SequenceId`.\n+\n+A Google PubSub Subscriber receives both a `message_id` and an `ack_id` in the `PullResponse`. The\n+`ack_id` has a different format and is scoped to the subscriber.\n+\n+Pulsar has a client-generated `SequenceID`, but the broker controls the `MessageID` (sent in the\n+response). The `MessageID` is not derived from the `SequenceID` and they serve different purposes.\n+`SequenceID` is more about in-flight message tracking; consumer and admin apis use `MessageId` to\n+identify, ack and nack a message.\n+\n+### Why use offset/sequence when there's no message ID?\n+RocketMQ embeds offset in their message ID while Kafka and MQTT don't define a field named message\n+ID. When there isn't a field named message ID, we use the closest stable value, such as a sequence\n+number or offset, as opposed to returning `null` or synthesizing an ID from multiple fields.\n+\n+We use a sequence number or offset with the understanding that this could clarify duplicate sends or\n+trace context breaks in the same way that a message ID could, even if it requires looking at other\n+fields. Plus many message ID formats require looking at other fields anyway. A standard tag is\n+easier to access as it requires no library specific types to parse.\n+\n+Ex. This requires just the messaging jar to express a policy that includes a message ID like field:\n+```java\n+MessagingTags.MESSAGE_ID.tag(req, context, span);\n+```\n+\n+Ex. This requires messaging and Kafka instrumentation jars to tag the same:\n+```java\n+KafkaTags.OFFSET.tag(req, context, span);\n+```\n+\n+Pragmatically, we choose to use a field that serves at least a common purpose as message ID where\n+possible instead of returning `null` for lack of an exact match. Specific to Kafka, we choose the\n+offset.\n+\n+### Why not synthesize a format that includes all needed fields when there's no message ID?\n+Typical message ID formats encode multiple components such as a broker ID or network address,\n+destination, timestamp or offset. It may be tempting to compose a format to include the dimensions\n+that likely pinpoint a message when there's no format defined by the library. For example, in Kafka,\n+we could compose a format like `topic-partition-offset` to ensure `MessagingRequest.id()` would have\n+all identifying information.\n+\n+If we did that, we'd add overhead with the only consumer being tracing itself. It would fail as a\n+correlation field with other libraries as by definition our format would be bespoke. Moreover,\n+higher layers of abstraction which might have a defined message ID format could be confused with\n+ours. Later, if that same tool creates a message ID format, it would likely be different from ours.\n+\n+For reasons including these, if there's no message ID field, we fall back to a numeric property like\n+offset or sequence, and failing that just return `null`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "98e1511d0f929740674c3bfd2b58fa2dbbc7eb61"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg4MjE0NA==", "bodyText": "thanks for the help!", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r439882144", "createdAt": "2020-06-15T00:09:28Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,134 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Message ID\n+In practice, the message ID is used for deletion, visibility control, retrieval, correlation,\n+duplicate detection or a combination of these. We derive semantics by looking at multiple open\n+source projects and cloud services, as well the special case of JMS.\n+\n+| System      | Kind     | Operation      | Direction | Field                       | Owner  | Scope      | Format\n+|-------------|----------|----------------|-----------|-----------------------------|--------|------------|--------\n+| AMQP        | PRODUCER | publish        | Request   | message-id                  | Local  | Global     | 1-255 characters\n+| AMQP        | CONSUMER | consume        | Request   | message-id                  | Remote | Global     | 1-255 characters\n+| Azure Queue | PRODUCER | PutMessage     | Response  | MessageId                   | Remote | Global     | UUID\n+| Azure Queue | CONSUMER | DeleteMessage  | Response  | MessageId                   | Remote | Global     | UUID\n+| Artemis     | CONSUMER | receive        | Request   | messageId                   | Remote | Global     | random uint64\n+| Kafka       | PRODUCER | send           | Response  | offset                      | Remote | Topic      | uint64\n+| Kafka       | CONSUMER | poll           | Request   | offset                      | Remote | Topic      | uint64\n+| Kinesis     | PRODUCER | Publish        | Response  | SequenceNumber              | Remote | Stream     | 1-128 digits\n+| Kinesis     | CONSUMER | Lambda         | Request   | sequenceNumber              | Remote | Global     | 1-128 digits\n+| SQS         | PRODUCER | SendMessage    | Request   | MessageDeduplicationId      | Local  | Queue      | SHA-256(body)\n+| SQS         | CONSUMER | ReceiveMessage | Request   | MessageDeduplicationId      | Remote | Queue      | SHA-256(body)\n+| SQS         | PRODUCER | SendMessage    | Response  | MessageId                   | Remote | Global     | UUID\n+| SQS         | CONSUMER | ReceiveMessage | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | PRODUCER | Publish        | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | CONSUMER | POST           | Request   | x-amz-sns-message-id        | Remote | Global     | UUID\n+| PubSub      | PRODUCER | Publish        | Response  | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Push           | Request   | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Pull           | Response  | message_id                  | Remote | Topic      | Integer\n+| JMS         | PRODUCER | Send           | Response  | JMSMessageId                | Remote | Global     | ID:opaque string\n+| JMS         | CONSUMER | Receive        | Request   | JMSMessageId                | Remote | Global     | ID:opaque string\n+| MQTT        | PRODUCER | PUBLISH        | Request   | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | PRODUCER | PUBACK/PUBREC  | Response  | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | CONSUMER | PUBLISH        | Request   | Packet Identifier           | Remote | Connection | uint16\n+| MQTT        | CONSUMER | PUBACK/PUBREC  | Response  | Packet Identifier           | Remote | Connection | uint16\n+| Pulsar      | PRODUCER | Send           | Response  | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| Pulsar      | CONSUMER | Receive        | Request   | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| RocketMQ    | PRODUCER | send           | Response  | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| RocketMQ    | CONSUMER | consumeMessage | Request   | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| ServiceBus  | PRODUCER | POST           | Request   | BrokerProperties{MessageId} | Local  | Global     | 1-255 characters\n+| ServiceBus  | CONSUMER | DELETE         | Request   | BrokerProperties{MessageId} | Remote | Global     | 1-255 characters\n+| STOMP       | PRODUCER | SEND           | Request   | receipt Header              | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | RECEIPT/ERROR  | Response  | receipt-id Header           | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | SEND           | Request   | receipt Header              | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | RECEIPT/ERROR  | Response  | receipt-id Header           | Remote | Connection | arbitrary\n+| STOMP       | PRODUCER | MESSAGE        | Request   | message-id Header           | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | ACK/NACK       | Response  | id Header                   | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | MESSAGE        | Request   | message-id Header           | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | ACK/NACK       | Response  | id Header                   | Remote | Connection | arbitrary\n+\n+### Isn't correlation ID the same as a message ID?\n+A correlation ID is a system-wide lookup value that possibly can pass multiple steps. A message ID\n+can have a scope as small as one segment (Ex. flow from producer to broker), and typically an\n+implementation detail. It can bet the case that they are the same, but it is not commonly the case.\n+\n+For example in MQTT, the packet ID is only valid for one segment a message takes. This means for the\n+same message body, the packet ID is overwritten when passing from the producer to the eventual\n+consumer. A more extreme example is Artemis, where there is no api to receive the messageId\n+associated with a published message. In other words, it is only visible in the consumer side, so\n+cannot be used for correlation between the producer and consumer.\n+\n+That said, correlation IDs are sometimes used for single-segment processing. For example, one\n+pattern in JMS is to copy the incoming `JMSMessageID` as the `CorrelationID` in a `JMSReplyTo`\n+response, so that the sender can correlate the two.\n+\n+For the above reasons, we cannot use the message ID and correlation ID concepts interchangeably.\n+\n+### When is a message ID ambiguous?\n+There are many types of features supported by message IDs. Some protocols use a global ID for\n+multiple features. Others use separate ones. In some cases, the choice of which to use for the\n+message ID field borders on arbitrary. Here are some examples to reinforce this.\n+\n+Amazon SQS includes a service-generated `MessageId` that can identify a message later consumed.\n+However, to delete an instance of that message you need one of potentially many `ReceiptHandle`s\n+associated with the `MessageId`. The client can also set certain IDs. For example, a client sets\n+`MessageDeduplicationId` before sending a message to a FIFO queue to suppress redundant sends. In\n+other words there are at least 3 identifiers for a single message, in different formats, depending\n+on the use case.\n+\n+Azure Queue a service-generated `MessageId`, but also a client-generated `x-ms-client-request-id`\n+for correlation. Unlike most services, Azure Queue has delete or update by `MessageId` functions,\n+though a `popreceipt` (akin to subscriber) is also required for these tasks.\n+\n+Azure ServiceBus includes the AMQP `BrokerProperties{MessageId}` field, but it also supports the\n+Kafka protocol, which does not have a message ID. In support of the latter, it also has a\n+`SequenceId` field, which embeds parition information with a logical sequence. Note, when using\n+Kafka protocol an `offset` will also exist, and is not directly related to the `SequenceId`.\n+\n+A Google PubSub Subscriber receives both a `message_id` and an `ack_id` in the `PullResponse`. The\n+`ack_id` has a different format and is scoped to the subscriber.\n+\n+Pulsar has a client-generated `SequenceID`, but the broker controls the `MessageID` (sent in the\n+response). The `MessageID` is not derived from the `SequenceID` and they serve different purposes.\n+`SequenceID` is more about in-flight message tracking; consumer and admin apis use `MessageId` to\n+identify, ack and nack a message.\n+\n+### Why use offset/sequence when there's no message ID?\n+RocketMQ embeds offset in their message ID while Kafka and MQTT don't define a field named message\n+ID. When there isn't a field named message ID, we use the closest stable value, such as a sequence\n+number or offset, as opposed to returning `null` or synthesizing an ID from multiple fields.\n+\n+We use a sequence number or offset with the understanding that this could clarify duplicate sends or\n+trace context breaks in the same way that a message ID could, even if it requires looking at other\n+fields. Plus many message ID formats require looking at other fields anyway. A standard tag is\n+easier to access as it requires no library specific types to parse.\n+\n+Ex. This requires just the messaging jar to express a policy that includes a message ID like field:\n+```java\n+MessagingTags.MESSAGE_ID.tag(req, context, span);\n+```\n+\n+Ex. This requires messaging and Kafka instrumentation jars to tag the same:\n+```java\n+KafkaTags.OFFSET.tag(req, context, span);\n+```\n+\n+Pragmatically, we choose to use a field that serves at least a common purpose as message ID where\n+possible instead of returning `null` for lack of an exact match. Specific to Kafka, we choose the\n+offset.\n+\n+### Why not synthesize a format that includes all needed fields when there's no message ID?\n+Typical message ID formats encode multiple components such as a broker ID or network address,\n+destination, timestamp or offset. It may be tempting to compose a format to include the dimensions\n+that likely pinpoint a message when there's no format defined by the library. For example, in Kafka,\n+we could compose a format like `topic-partition-offset` to ensure `MessagingRequest.id()` would have\n+all identifying information.\n+\n+If we did that, we'd add overhead with the only consumer being tracing itself. It would fail as a\n+correlation field with other libraries as by definition our format would be bespoke. Moreover,\n+higher layers of abstraction which might have a defined message ID format could be confused with\n+ours. Later, if that same tool creates a message ID format, it would likely be different from ours.\n+\n+For reasons including these, if there's no message ID field, we fall back to a numeric property like\n+offset or sequence, and failing that just return `null`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTg3MDkwNg=="}, "originalCommit": {"oid": "98e1511d0f929740674c3bfd2b58fa2dbbc7eb61"}, "originalPosition": 134}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTI2OTI5OnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1NTo0MVrOGjnDAA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1NTo0MVrOGjnDAA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5MzA4OA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            We derive semantics by looking at multiple open source projects and cloud services, as well the\n          \n          \n            \n            We derive semantics by looking at multiple open source projects and cloud services, as well as the", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r439993088", "createdAt": "2020-06-15T07:55:41Z", "author": {"login": "jorgheymans"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,155 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Message ID\n+\n+### Why would someone tag message ID?\n+The message ID allows deletion, visibility control, retrieval, correlation, duplicate detection or a\n+combination of these use cases.\n+\n+The purpose of the Message ID, as defined here, is a correlation between one \"send\" event and any\n+number of \"receive\" events. Not all operations can bet tracked in one trace. Some consumers log, but\n+don't trace. Others break traces, or trace in different systems. Moreover, this project doesn't\n+trace all operations. With the message ID, processes curious about an ACK or NACK can find logs\n+related to those operations, even if the logs do not include trace IDs.\n+\n+### What are some examples of message IDs?\n+We derive semantics by looking at multiple open source projects and cloud services, as well the", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40f836fd5b03b4745cc03ef161d4355b33bb465e"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTI3MDQ1OnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1NjowMVrOGjnDwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1NjowMVrOGjnDwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5MzI4MQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            number of \"receive\" events. Not all operations can bet tracked in one trace. Some consumers log, but\n          \n          \n            \n            number of \"receive\" events. Not all operations can be tracked in one trace. Some consumers log, but", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r439993281", "createdAt": "2020-06-15T07:56:01Z", "author": {"login": "jorgheymans"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,155 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Message ID\n+\n+### Why would someone tag message ID?\n+The message ID allows deletion, visibility control, retrieval, correlation, duplicate detection or a\n+combination of these use cases.\n+\n+The purpose of the Message ID, as defined here, is a correlation between one \"send\" event and any\n+number of \"receive\" events. Not all operations can bet tracked in one trace. Some consumers log, but", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40f836fd5b03b4745cc03ef161d4355b33bb465e"}, "originalPosition": 12}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTI3MzkyOnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1Njo1NVrOGjnF6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1Njo1NVrOGjnF6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5MzgzMg==", "bodyText": "second time, you writing this from a hotel room in Vegas ?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            implementation detail. It can bet the case that they are the same, but it is not commonly the case.\n          \n          \n            \n            implementation detail. It can be the case that they are the same, but it is not commonly the case.", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r439993832", "createdAt": "2020-06-15T07:56:55Z", "author": {"login": "jorgheymans"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,155 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Message ID\n+\n+### Why would someone tag message ID?\n+The message ID allows deletion, visibility control, retrieval, correlation, duplicate detection or a\n+combination of these use cases.\n+\n+The purpose of the Message ID, as defined here, is a correlation between one \"send\" event and any\n+number of \"receive\" events. Not all operations can bet tracked in one trace. Some consumers log, but\n+don't trace. Others break traces, or trace in different systems. Moreover, this project doesn't\n+trace all operations. With the message ID, processes curious about an ACK or NACK can find logs\n+related to those operations, even if the logs do not include trace IDs.\n+\n+### What are some examples of message IDs?\n+We derive semantics by looking at multiple open source projects and cloud services, as well the\n+special case of JMS.\n+\n+| System      | Kind     | Operation      | Direction | Field                       | Owner  | Scope      | Format\n+|-------------|----------|----------------|-----------|-----------------------------|--------|------------|--------\n+| AMQP        | PRODUCER | publish        | Request   | message-id                  | Local  | Global     | 1-255 characters\n+| AMQP        | CONSUMER | consume        | Request   | message-id                  | Remote | Global     | 1-255 characters\n+| Azure Queue | PRODUCER | PutMessage     | Response  | MessageId                   | Remote | Global     | UUID\n+| Azure Queue | CONSUMER | DeleteMessage  | Response  | MessageId                   | Remote | Global     | UUID\n+| Artemis     | CONSUMER | receive        | Request   | messageId                   | Remote | Global     | random uint64\n+| Kafka       | PRODUCER | send           | Response  | offset                      | Remote | Topic      | uint64\n+| Kafka       | CONSUMER | poll           | Request   | offset                      | Remote | Topic      | uint64\n+| Kinesis     | PRODUCER | Publish        | Response  | SequenceNumber              | Remote | Stream     | 1-128 digits\n+| Kinesis     | CONSUMER | Lambda         | Request   | sequenceNumber              | Remote | Global     | 1-128 digits\n+| SQS         | PRODUCER | SendMessage    | Request   | MessageDeduplicationId      | Local  | Queue      | SHA-256(body)\n+| SQS         | CONSUMER | ReceiveMessage | Request   | MessageDeduplicationId      | Remote | Queue      | SHA-256(body)\n+| SQS         | PRODUCER | SendMessage    | Response  | MessageId                   | Remote | Global     | UUID\n+| SQS         | CONSUMER | ReceiveMessage | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | PRODUCER | Publish        | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | CONSUMER | POST           | Request   | x-amz-sns-message-id        | Remote | Global     | UUID\n+| PubSub      | PRODUCER | Publish        | Response  | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Push           | Request   | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Pull           | Response  | message_id                  | Remote | Topic      | Integer\n+| JMS         | PRODUCER | Send           | Response  | JMSMessageId                | Remote | Global     | ID:opaque string\n+| JMS         | CONSUMER | Receive        | Request   | JMSMessageId                | Remote | Global     | ID:opaque string\n+| MQTT        | PRODUCER | PUBLISH        | Request   | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | PRODUCER | PUBACK/PUBREC  | Response  | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | CONSUMER | PUBLISH        | Request   | Packet Identifier           | Remote | Connection | uint16\n+| MQTT        | CONSUMER | PUBACK/PUBREC  | Response  | Packet Identifier           | Remote | Connection | uint16\n+| Pulsar      | PRODUCER | Send           | Response  | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| Pulsar      | CONSUMER | Receive        | Request   | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| RocketMQ    | PRODUCER | send           | Response  | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| RocketMQ    | CONSUMER | consumeMessage | Request   | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| ServiceBus  | PRODUCER | POST           | Request   | BrokerProperties{MessageId} | Local  | Global     | 1-255 characters\n+| ServiceBus  | CONSUMER | DELETE         | Request   | BrokerProperties{MessageId} | Remote | Global     | 1-255 characters\n+| STOMP       | PRODUCER | SEND           | Request   | receipt Header              | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | RECEIPT/ERROR  | Response  | receipt-id Header           | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | SEND           | Request   | receipt Header              | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | RECEIPT/ERROR  | Response  | receipt-id Header           | Remote | Connection | arbitrary\n+| STOMP       | PRODUCER | MESSAGE        | Request   | message-id Header           | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | ACK/NACK       | Response  | id Header                   | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | MESSAGE        | Request   | message-id Header           | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | ACK/NACK       | Response  | id Header                   | Remote | Connection | arbitrary\n+\n+### What are some examples of IDs that aren't message IDs?\n+TODO: move some rows above into here\n+\n+### Isn't correlation ID the same as a message ID?\n+A correlation ID is a system-wide lookup value that possibly can pass multiple steps. A message ID\n+can have a scope as small as one segment (Ex. flow from producer to broker), and typically an\n+implementation detail. It can bet the case that they are the same, but it is not commonly the case.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40f836fd5b03b4745cc03ef161d4355b33bb465e"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTI4MzI5OnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1OTozN1rOGjnLzw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwNzo1OTozN1rOGjnLzw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk5NTM0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            Azure Queue a service-generated `MessageId`, but also a client-generated `x-ms-client-request-id`\n          \n          \n            \n            Azure Queue includes a service-generated `MessageId`, but also a client-generated `x-ms-client-request-id`", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r439995343", "createdAt": "2020-06-15T07:59:37Z", "author": {"login": "jorgheymans"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,155 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Message ID\n+\n+### Why would someone tag message ID?\n+The message ID allows deletion, visibility control, retrieval, correlation, duplicate detection or a\n+combination of these use cases.\n+\n+The purpose of the Message ID, as defined here, is a correlation between one \"send\" event and any\n+number of \"receive\" events. Not all operations can bet tracked in one trace. Some consumers log, but\n+don't trace. Others break traces, or trace in different systems. Moreover, this project doesn't\n+trace all operations. With the message ID, processes curious about an ACK or NACK can find logs\n+related to those operations, even if the logs do not include trace IDs.\n+\n+### What are some examples of message IDs?\n+We derive semantics by looking at multiple open source projects and cloud services, as well the\n+special case of JMS.\n+\n+| System      | Kind     | Operation      | Direction | Field                       | Owner  | Scope      | Format\n+|-------------|----------|----------------|-----------|-----------------------------|--------|------------|--------\n+| AMQP        | PRODUCER | publish        | Request   | message-id                  | Local  | Global     | 1-255 characters\n+| AMQP        | CONSUMER | consume        | Request   | message-id                  | Remote | Global     | 1-255 characters\n+| Azure Queue | PRODUCER | PutMessage     | Response  | MessageId                   | Remote | Global     | UUID\n+| Azure Queue | CONSUMER | DeleteMessage  | Response  | MessageId                   | Remote | Global     | UUID\n+| Artemis     | CONSUMER | receive        | Request   | messageId                   | Remote | Global     | random uint64\n+| Kafka       | PRODUCER | send           | Response  | offset                      | Remote | Topic      | uint64\n+| Kafka       | CONSUMER | poll           | Request   | offset                      | Remote | Topic      | uint64\n+| Kinesis     | PRODUCER | Publish        | Response  | SequenceNumber              | Remote | Stream     | 1-128 digits\n+| Kinesis     | CONSUMER | Lambda         | Request   | sequenceNumber              | Remote | Global     | 1-128 digits\n+| SQS         | PRODUCER | SendMessage    | Request   | MessageDeduplicationId      | Local  | Queue      | SHA-256(body)\n+| SQS         | CONSUMER | ReceiveMessage | Request   | MessageDeduplicationId      | Remote | Queue      | SHA-256(body)\n+| SQS         | PRODUCER | SendMessage    | Response  | MessageId                   | Remote | Global     | UUID\n+| SQS         | CONSUMER | ReceiveMessage | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | PRODUCER | Publish        | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | CONSUMER | POST           | Request   | x-amz-sns-message-id        | Remote | Global     | UUID\n+| PubSub      | PRODUCER | Publish        | Response  | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Push           | Request   | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Pull           | Response  | message_id                  | Remote | Topic      | Integer\n+| JMS         | PRODUCER | Send           | Response  | JMSMessageId                | Remote | Global     | ID:opaque string\n+| JMS         | CONSUMER | Receive        | Request   | JMSMessageId                | Remote | Global     | ID:opaque string\n+| MQTT        | PRODUCER | PUBLISH        | Request   | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | PRODUCER | PUBACK/PUBREC  | Response  | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | CONSUMER | PUBLISH        | Request   | Packet Identifier           | Remote | Connection | uint16\n+| MQTT        | CONSUMER | PUBACK/PUBREC  | Response  | Packet Identifier           | Remote | Connection | uint16\n+| Pulsar      | PRODUCER | Send           | Response  | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| Pulsar      | CONSUMER | Receive        | Request   | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| RocketMQ    | PRODUCER | send           | Response  | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| RocketMQ    | CONSUMER | consumeMessage | Request   | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| ServiceBus  | PRODUCER | POST           | Request   | BrokerProperties{MessageId} | Local  | Global     | 1-255 characters\n+| ServiceBus  | CONSUMER | DELETE         | Request   | BrokerProperties{MessageId} | Remote | Global     | 1-255 characters\n+| STOMP       | PRODUCER | SEND           | Request   | receipt Header              | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | RECEIPT/ERROR  | Response  | receipt-id Header           | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | SEND           | Request   | receipt Header              | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | RECEIPT/ERROR  | Response  | receipt-id Header           | Remote | Connection | arbitrary\n+| STOMP       | PRODUCER | MESSAGE        | Request   | message-id Header           | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | ACK/NACK       | Response  | id Header                   | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | MESSAGE        | Request   | message-id Header           | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | ACK/NACK       | Response  | id Header                   | Remote | Connection | arbitrary\n+\n+### What are some examples of IDs that aren't message IDs?\n+TODO: move some rows above into here\n+\n+### Isn't correlation ID the same as a message ID?\n+A correlation ID is a system-wide lookup value that possibly can pass multiple steps. A message ID\n+can have a scope as small as one segment (Ex. flow from producer to broker), and typically an\n+implementation detail. It can bet the case that they are the same, but it is not commonly the case.\n+\n+For example in MQTT, the packet ID is only valid for one segment a message takes. This means for the\n+same message body, the packet ID is overwritten when passing from the producer to the eventual\n+consumer. A more extreme example is Artemis, where there is no api to receive the messageId\n+associated with a published message. In other words, it is only visible in the consumer side, so\n+cannot be used for correlation between the producer and consumer.\n+\n+Another example are cloud services, such as Amazon SQS, Azure Queue and GCP PubSub. The message ID\n+fields there are set by the service and cannot be set by the client. This means that a client cannot\n+propagate the message ID from one part of a pipeline to another. Hence, in these cases a message ID\n+cannot be a correlation ID. The message ID will only be the same between the last producer and its\n+direct consumers.\n+\n+Even though there's no strict relationship, message IDs are sometimes reused as correlation IDs. For\n+example, one pattern in JMS is to copy the incoming `JMSMessageID` as the `CorrelationID` in a\n+`JMSReplyTo` response. In this case, the same ID is used in different fields conventionally even if\n+not defined by the specification.\n+\n+For the above reasons, we cannot use the message ID and correlation ID concepts interchangeably even\n+if there are sometimes overlaps in use cases.\n+\n+### When is a message ID ambiguous?\n+There are many types of features supported by message IDs. Some protocols use a global ID for\n+multiple features. Others use separate ones. In some cases, the choice of which to use for the\n+message ID field borders on arbitrary. Here are some examples to reinforce this.\n+\n+Amazon SQS includes a service-generated `MessageId` that can identify a message later consumed.\n+However, to delete an instance of that message you need one of potentially many `ReceiptHandle`s\n+associated with the `MessageId`. The client can also set certain IDs. For example, a client sets\n+`MessageDeduplicationId` before sending a message to a FIFO queue to suppress redundant sends. In\n+other words there are at least 3 identifiers for a single message, in different formats, depending\n+on the use case.\n+\n+Azure Queue a service-generated `MessageId`, but also a client-generated `x-ms-client-request-id`", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40f836fd5b03b4745cc03ef161d4355b33bb465e"}, "originalPosition": 102}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc0MTMxNDk1OnYy", "diffSide": "RIGHT", "path": "instrumentation/messaging/RATIONALE.md", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNVQwODowODo1OVrOGjnfpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0xNlQwMzo1OToxM1rOGkKaOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMDQyMw==", "bodyText": "\ud83e\udd14  ... ThisSentenceCannotBeGrokkedException\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            For reasons including these, if there's no message ID field, and failing that just return `null`.\n          \n          \n            \n            For reasons including these, if there's no message ID field, and failing that just return `null`.\n          \n      \n    \n    \n  \n\nthe and failing that part confuses me, what do you mean", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r440000423", "createdAt": "2020-06-15T08:08:59Z", "author": {"login": "jorgheymans"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,155 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Message ID\n+\n+### Why would someone tag message ID?\n+The message ID allows deletion, visibility control, retrieval, correlation, duplicate detection or a\n+combination of these use cases.\n+\n+The purpose of the Message ID, as defined here, is a correlation between one \"send\" event and any\n+number of \"receive\" events. Not all operations can bet tracked in one trace. Some consumers log, but\n+don't trace. Others break traces, or trace in different systems. Moreover, this project doesn't\n+trace all operations. With the message ID, processes curious about an ACK or NACK can find logs\n+related to those operations, even if the logs do not include trace IDs.\n+\n+### What are some examples of message IDs?\n+We derive semantics by looking at multiple open source projects and cloud services, as well the\n+special case of JMS.\n+\n+| System      | Kind     | Operation      | Direction | Field                       | Owner  | Scope      | Format\n+|-------------|----------|----------------|-----------|-----------------------------|--------|------------|--------\n+| AMQP        | PRODUCER | publish        | Request   | message-id                  | Local  | Global     | 1-255 characters\n+| AMQP        | CONSUMER | consume        | Request   | message-id                  | Remote | Global     | 1-255 characters\n+| Azure Queue | PRODUCER | PutMessage     | Response  | MessageId                   | Remote | Global     | UUID\n+| Azure Queue | CONSUMER | DeleteMessage  | Response  | MessageId                   | Remote | Global     | UUID\n+| Artemis     | CONSUMER | receive        | Request   | messageId                   | Remote | Global     | random uint64\n+| Kafka       | PRODUCER | send           | Response  | offset                      | Remote | Topic      | uint64\n+| Kafka       | CONSUMER | poll           | Request   | offset                      | Remote | Topic      | uint64\n+| Kinesis     | PRODUCER | Publish        | Response  | SequenceNumber              | Remote | Stream     | 1-128 digits\n+| Kinesis     | CONSUMER | Lambda         | Request   | sequenceNumber              | Remote | Global     | 1-128 digits\n+| SQS         | PRODUCER | SendMessage    | Request   | MessageDeduplicationId      | Local  | Queue      | SHA-256(body)\n+| SQS         | CONSUMER | ReceiveMessage | Request   | MessageDeduplicationId      | Remote | Queue      | SHA-256(body)\n+| SQS         | PRODUCER | SendMessage    | Response  | MessageId                   | Remote | Global     | UUID\n+| SQS         | CONSUMER | ReceiveMessage | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | PRODUCER | Publish        | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | CONSUMER | POST           | Request   | x-amz-sns-message-id        | Remote | Global     | UUID\n+| PubSub      | PRODUCER | Publish        | Response  | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Push           | Request   | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Pull           | Response  | message_id                  | Remote | Topic      | Integer\n+| JMS         | PRODUCER | Send           | Response  | JMSMessageId                | Remote | Global     | ID:opaque string\n+| JMS         | CONSUMER | Receive        | Request   | JMSMessageId                | Remote | Global     | ID:opaque string\n+| MQTT        | PRODUCER | PUBLISH        | Request   | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | PRODUCER | PUBACK/PUBREC  | Response  | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | CONSUMER | PUBLISH        | Request   | Packet Identifier           | Remote | Connection | uint16\n+| MQTT        | CONSUMER | PUBACK/PUBREC  | Response  | Packet Identifier           | Remote | Connection | uint16\n+| Pulsar      | PRODUCER | Send           | Response  | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| Pulsar      | CONSUMER | Receive        | Request   | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| RocketMQ    | PRODUCER | send           | Response  | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| RocketMQ    | CONSUMER | consumeMessage | Request   | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| ServiceBus  | PRODUCER | POST           | Request   | BrokerProperties{MessageId} | Local  | Global     | 1-255 characters\n+| ServiceBus  | CONSUMER | DELETE         | Request   | BrokerProperties{MessageId} | Remote | Global     | 1-255 characters\n+| STOMP       | PRODUCER | SEND           | Request   | receipt Header              | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | RECEIPT/ERROR  | Response  | receipt-id Header           | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | SEND           | Request   | receipt Header              | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | RECEIPT/ERROR  | Response  | receipt-id Header           | Remote | Connection | arbitrary\n+| STOMP       | PRODUCER | MESSAGE        | Request   | message-id Header           | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | ACK/NACK       | Response  | id Header                   | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | MESSAGE        | Request   | message-id Header           | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | ACK/NACK       | Response  | id Header                   | Remote | Connection | arbitrary\n+\n+### What are some examples of IDs that aren't message IDs?\n+TODO: move some rows above into here\n+\n+### Isn't correlation ID the same as a message ID?\n+A correlation ID is a system-wide lookup value that possibly can pass multiple steps. A message ID\n+can have a scope as small as one segment (Ex. flow from producer to broker), and typically an\n+implementation detail. It can bet the case that they are the same, but it is not commonly the case.\n+\n+For example in MQTT, the packet ID is only valid for one segment a message takes. This means for the\n+same message body, the packet ID is overwritten when passing from the producer to the eventual\n+consumer. A more extreme example is Artemis, where there is no api to receive the messageId\n+associated with a published message. In other words, it is only visible in the consumer side, so\n+cannot be used for correlation between the producer and consumer.\n+\n+Another example are cloud services, such as Amazon SQS, Azure Queue and GCP PubSub. The message ID\n+fields there are set by the service and cannot be set by the client. This means that a client cannot\n+propagate the message ID from one part of a pipeline to another. Hence, in these cases a message ID\n+cannot be a correlation ID. The message ID will only be the same between the last producer and its\n+direct consumers.\n+\n+Even though there's no strict relationship, message IDs are sometimes reused as correlation IDs. For\n+example, one pattern in JMS is to copy the incoming `JMSMessageID` as the `CorrelationID` in a\n+`JMSReplyTo` response. In this case, the same ID is used in different fields conventionally even if\n+not defined by the specification.\n+\n+For the above reasons, we cannot use the message ID and correlation ID concepts interchangeably even\n+if there are sometimes overlaps in use cases.\n+\n+### When is a message ID ambiguous?\n+There are many types of features supported by message IDs. Some protocols use a global ID for\n+multiple features. Others use separate ones. In some cases, the choice of which to use for the\n+message ID field borders on arbitrary. Here are some examples to reinforce this.\n+\n+Amazon SQS includes a service-generated `MessageId` that can identify a message later consumed.\n+However, to delete an instance of that message you need one of potentially many `ReceiptHandle`s\n+associated with the `MessageId`. The client can also set certain IDs. For example, a client sets\n+`MessageDeduplicationId` before sending a message to a FIFO queue to suppress redundant sends. In\n+other words there are at least 3 identifiers for a single message, in different formats, depending\n+on the use case.\n+\n+Azure Queue a service-generated `MessageId`, but also a client-generated `x-ms-client-request-id`\n+for correlation. Unlike most services, Azure Queue has delete or update by `MessageId` functions,\n+though a `popreceipt` (akin to subscriber) is also required for these tasks.\n+\n+Azure ServiceBus includes the AMQP `BrokerProperties{MessageId}` field, but it also supports the\n+Kafka protocol, which does not have a message ID. In support of the latter, it also has a\n+`SequenceId` field, which embeds parition information with a logical sequence. Note, when using\n+Kafka protocol an `offset` will also exist, and is not directly related to the `SequenceId`.\n+\n+A Google PubSub Subscriber receives both a `message_id` and an `ack_id` in the `PullResponse`. The\n+`ack_id` has a different format and is scoped to the subscriber.\n+\n+Pulsar has a client-generated `SequenceID`, but the broker controls the `MessageID` (sent in the\n+response). The `MessageID` is not derived from the `SequenceID` and they serve different purposes.\n+`SequenceID` is more about in-flight message tracking; consumer and admin apis use `MessageId` to\n+identify, ack and nack a message.\n+\n+### Why use offset/sequence when there's no message ID?\n+RocketMQ embeds offset in their message ID while Kafka and MQTT don't define a field named message\n+ID. When there isn't a field named message ID, we use the closest stable value, such as a sequence\n+number or offset, as opposed to returning `null` or synthesizing an ID from multiple fields.\n+\n+We use a sequence number or offset with the understanding that this could clarify duplicate sends or\n+trace context breaks in the same way that a message ID could, even if it requires looking at other\n+fields. Plus many message ID formats require looking at other fields anyway. A standard tag is\n+easier to access as it requires no library specific types to parse.\n+\n+Ex. This requires just the messaging jar to express a policy that includes a message ID like field:\n+```java\n+MessagingTags.MESSAGE_ID.tag(req, context, span);\n+```\n+\n+Ex. This requires messaging and Kafka instrumentation jars to tag the same:\n+```java\n+KafkaTags.OFFSET.tag(req, context, span);\n+```\n+\n+Pragmatically, we choose to use a field that serves at least a common purpose as message ID where\n+possible instead of returning `null` for lack of an exact match. Specific to Kafka, we choose the\n+offset.\n+\n+### Why not synthesize a format that includes all needed fields when there's no message ID?\n+Typical message ID formats encode multiple components such as a broker ID or network address,\n+destination, timestamp or offset. It may be tempting to compose a format to include the dimensions\n+that likely pinpoint a message when there's no format defined by the library. For example, in Kafka,\n+we could compose a format like `topic-partition-offset` to ensure `MessagingRequest.id()` would have\n+all identifying information.\n+\n+If we did that, we'd add overhead with the only consumer being tracing itself. It would fail as a\n+correlation field with other libraries as by definition our format would be bespoke. Moreover,\n+higher layers of abstraction which might have a defined message ID format could be confused with\n+ours. Later, if that same tool creates a message ID format, it would likely be different from ours.\n+\n+For reasons including these, if there's no message ID field, and failing that just return `null`.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "40f836fd5b03b4745cc03ef161d4355b33bb465e"}, "originalPosition": 155}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU3MjQ3NQ==", "bodyText": "hopefully fixed", "url": "https://github.com/openzipkin/brave/pull/1224#discussion_r440572475", "createdAt": "2020-06-16T03:59:13Z", "author": {"login": "codefromthecrypt"}, "path": "instrumentation/messaging/RATIONALE.md", "diffHunk": "@@ -78,3 +78,155 @@ continue incoming state.\n Finally, this approach has been in use since late 2017, when we refined our\n only messaging instrumentation, `kafka-clients`, to support message processing.\n By re-using known working practice, we have less risk in abstraction.\n+\n+## Message ID\n+\n+### Why would someone tag message ID?\n+The message ID allows deletion, visibility control, retrieval, correlation, duplicate detection or a\n+combination of these use cases.\n+\n+The purpose of the Message ID, as defined here, is a correlation between one \"send\" event and any\n+number of \"receive\" events. Not all operations can bet tracked in one trace. Some consumers log, but\n+don't trace. Others break traces, or trace in different systems. Moreover, this project doesn't\n+trace all operations. With the message ID, processes curious about an ACK or NACK can find logs\n+related to those operations, even if the logs do not include trace IDs.\n+\n+### What are some examples of message IDs?\n+We derive semantics by looking at multiple open source projects and cloud services, as well the\n+special case of JMS.\n+\n+| System      | Kind     | Operation      | Direction | Field                       | Owner  | Scope      | Format\n+|-------------|----------|----------------|-----------|-----------------------------|--------|------------|--------\n+| AMQP        | PRODUCER | publish        | Request   | message-id                  | Local  | Global     | 1-255 characters\n+| AMQP        | CONSUMER | consume        | Request   | message-id                  | Remote | Global     | 1-255 characters\n+| Azure Queue | PRODUCER | PutMessage     | Response  | MessageId                   | Remote | Global     | UUID\n+| Azure Queue | CONSUMER | DeleteMessage  | Response  | MessageId                   | Remote | Global     | UUID\n+| Artemis     | CONSUMER | receive        | Request   | messageId                   | Remote | Global     | random uint64\n+| Kafka       | PRODUCER | send           | Response  | offset                      | Remote | Topic      | uint64\n+| Kafka       | CONSUMER | poll           | Request   | offset                      | Remote | Topic      | uint64\n+| Kinesis     | PRODUCER | Publish        | Response  | SequenceNumber              | Remote | Stream     | 1-128 digits\n+| Kinesis     | CONSUMER | Lambda         | Request   | sequenceNumber              | Remote | Global     | 1-128 digits\n+| SQS         | PRODUCER | SendMessage    | Request   | MessageDeduplicationId      | Local  | Queue      | SHA-256(body)\n+| SQS         | CONSUMER | ReceiveMessage | Request   | MessageDeduplicationId      | Remote | Queue      | SHA-256(body)\n+| SQS         | PRODUCER | SendMessage    | Response  | MessageId                   | Remote | Global     | UUID\n+| SQS         | CONSUMER | ReceiveMessage | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | PRODUCER | Publish        | Response  | MessageId                   | Remote | Global     | UUID\n+| SNS         | CONSUMER | POST           | Request   | x-amz-sns-message-id        | Remote | Global     | UUID\n+| PubSub      | PRODUCER | Publish        | Response  | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Push           | Request   | message_id                  | Remote | Topic      | Integer\n+| PubSub      | CONSUMER | Pull           | Response  | message_id                  | Remote | Topic      | Integer\n+| JMS         | PRODUCER | Send           | Response  | JMSMessageId                | Remote | Global     | ID:opaque string\n+| JMS         | CONSUMER | Receive        | Request   | JMSMessageId                | Remote | Global     | ID:opaque string\n+| MQTT        | PRODUCER | PUBLISH        | Request   | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | PRODUCER | PUBACK/PUBREC  | Response  | Packet Identifier           | Local  | Connection | uint16\n+| MQTT        | CONSUMER | PUBLISH        | Request   | Packet Identifier           | Remote | Connection | uint16\n+| MQTT        | CONSUMER | PUBACK/PUBREC  | Response  | Packet Identifier           | Remote | Connection | uint16\n+| Pulsar      | PRODUCER | Send           | Response  | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| Pulsar      | CONSUMER | Receive        | Request   | MessageId                   | Remote | Topic      | bytes(ledger|entry|parition)\n+| RocketMQ    | PRODUCER | send           | Response  | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| RocketMQ    | CONSUMER | consumeMessage | Request   | msgId                       | Remote | Topic      | HEX(ip|port|offset)\n+| ServiceBus  | PRODUCER | POST           | Request   | BrokerProperties{MessageId} | Local  | Global     | 1-255 characters\n+| ServiceBus  | CONSUMER | DELETE         | Request   | BrokerProperties{MessageId} | Remote | Global     | 1-255 characters\n+| STOMP       | PRODUCER | SEND           | Request   | receipt Header              | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | RECEIPT/ERROR  | Response  | receipt-id Header           | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | SEND           | Request   | receipt Header              | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | RECEIPT/ERROR  | Response  | receipt-id Header           | Remote | Connection | arbitrary\n+| STOMP       | PRODUCER | MESSAGE        | Request   | message-id Header           | Local  | Connection | arbitrary\n+| STOMP       | PRODUCER | ACK/NACK       | Response  | id Header                   | Local  | Connection | arbitrary\n+| STOMP       | CONSUMER | MESSAGE        | Request   | message-id Header           | Remote | Connection | arbitrary\n+| STOMP       | CONSUMER | ACK/NACK       | Response  | id Header                   | Remote | Connection | arbitrary\n+\n+### What are some examples of IDs that aren't message IDs?\n+TODO: move some rows above into here\n+\n+### Isn't correlation ID the same as a message ID?\n+A correlation ID is a system-wide lookup value that possibly can pass multiple steps. A message ID\n+can have a scope as small as one segment (Ex. flow from producer to broker), and typically an\n+implementation detail. It can bet the case that they are the same, but it is not commonly the case.\n+\n+For example in MQTT, the packet ID is only valid for one segment a message takes. This means for the\n+same message body, the packet ID is overwritten when passing from the producer to the eventual\n+consumer. A more extreme example is Artemis, where there is no api to receive the messageId\n+associated with a published message. In other words, it is only visible in the consumer side, so\n+cannot be used for correlation between the producer and consumer.\n+\n+Another example are cloud services, such as Amazon SQS, Azure Queue and GCP PubSub. The message ID\n+fields there are set by the service and cannot be set by the client. This means that a client cannot\n+propagate the message ID from one part of a pipeline to another. Hence, in these cases a message ID\n+cannot be a correlation ID. The message ID will only be the same between the last producer and its\n+direct consumers.\n+\n+Even though there's no strict relationship, message IDs are sometimes reused as correlation IDs. For\n+example, one pattern in JMS is to copy the incoming `JMSMessageID` as the `CorrelationID` in a\n+`JMSReplyTo` response. In this case, the same ID is used in different fields conventionally even if\n+not defined by the specification.\n+\n+For the above reasons, we cannot use the message ID and correlation ID concepts interchangeably even\n+if there are sometimes overlaps in use cases.\n+\n+### When is a message ID ambiguous?\n+There are many types of features supported by message IDs. Some protocols use a global ID for\n+multiple features. Others use separate ones. In some cases, the choice of which to use for the\n+message ID field borders on arbitrary. Here are some examples to reinforce this.\n+\n+Amazon SQS includes a service-generated `MessageId` that can identify a message later consumed.\n+However, to delete an instance of that message you need one of potentially many `ReceiptHandle`s\n+associated with the `MessageId`. The client can also set certain IDs. For example, a client sets\n+`MessageDeduplicationId` before sending a message to a FIFO queue to suppress redundant sends. In\n+other words there are at least 3 identifiers for a single message, in different formats, depending\n+on the use case.\n+\n+Azure Queue a service-generated `MessageId`, but also a client-generated `x-ms-client-request-id`\n+for correlation. Unlike most services, Azure Queue has delete or update by `MessageId` functions,\n+though a `popreceipt` (akin to subscriber) is also required for these tasks.\n+\n+Azure ServiceBus includes the AMQP `BrokerProperties{MessageId}` field, but it also supports the\n+Kafka protocol, which does not have a message ID. In support of the latter, it also has a\n+`SequenceId` field, which embeds parition information with a logical sequence. Note, when using\n+Kafka protocol an `offset` will also exist, and is not directly related to the `SequenceId`.\n+\n+A Google PubSub Subscriber receives both a `message_id` and an `ack_id` in the `PullResponse`. The\n+`ack_id` has a different format and is scoped to the subscriber.\n+\n+Pulsar has a client-generated `SequenceID`, but the broker controls the `MessageID` (sent in the\n+response). The `MessageID` is not derived from the `SequenceID` and they serve different purposes.\n+`SequenceID` is more about in-flight message tracking; consumer and admin apis use `MessageId` to\n+identify, ack and nack a message.\n+\n+### Why use offset/sequence when there's no message ID?\n+RocketMQ embeds offset in their message ID while Kafka and MQTT don't define a field named message\n+ID. When there isn't a field named message ID, we use the closest stable value, such as a sequence\n+number or offset, as opposed to returning `null` or synthesizing an ID from multiple fields.\n+\n+We use a sequence number or offset with the understanding that this could clarify duplicate sends or\n+trace context breaks in the same way that a message ID could, even if it requires looking at other\n+fields. Plus many message ID formats require looking at other fields anyway. A standard tag is\n+easier to access as it requires no library specific types to parse.\n+\n+Ex. This requires just the messaging jar to express a policy that includes a message ID like field:\n+```java\n+MessagingTags.MESSAGE_ID.tag(req, context, span);\n+```\n+\n+Ex. This requires messaging and Kafka instrumentation jars to tag the same:\n+```java\n+KafkaTags.OFFSET.tag(req, context, span);\n+```\n+\n+Pragmatically, we choose to use a field that serves at least a common purpose as message ID where\n+possible instead of returning `null` for lack of an exact match. Specific to Kafka, we choose the\n+offset.\n+\n+### Why not synthesize a format that includes all needed fields when there's no message ID?\n+Typical message ID formats encode multiple components such as a broker ID or network address,\n+destination, timestamp or offset. It may be tempting to compose a format to include the dimensions\n+that likely pinpoint a message when there's no format defined by the library. For example, in Kafka,\n+we could compose a format like `topic-partition-offset` to ensure `MessagingRequest.id()` would have\n+all identifying information.\n+\n+If we did that, we'd add overhead with the only consumer being tracing itself. It would fail as a\n+correlation field with other libraries as by definition our format would be bespoke. Moreover,\n+higher layers of abstraction which might have a defined message ID format could be confused with\n+ours. Later, if that same tool creates a message ID format, it would likely be different from ours.\n+\n+For reasons including these, if there's no message ID field, and failing that just return `null`.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDAwMDQyMw=="}, "originalCommit": {"oid": "40f836fd5b03b4745cc03ef161d4355b33bb465e"}, "originalPosition": 155}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1471, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}