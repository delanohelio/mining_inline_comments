{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAxODAxODEx", "number": 1147, "title": "Reverts defensiveness in generic params and shares a buffer", "bodyText": "it was a relic of an older JDK, or complete fantasy. This reverts it.\nThis also fixes where we accidentally didn't share a buffer.\nThanks @felixbarny for mentioning this..", "createdAt": "2020-04-10T07:54:10Z", "url": "https://github.com/openzipkin/brave/pull/1147", "merged": true, "mergeCommit": {"oid": "d27005ed2a573a06f26983990ded9c31c91d209e"}, "closed": true, "closedAt": "2020-04-10T08:50:24Z", "author": {"login": "codefromthecrypt"}, "timelineItems": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcWMRO7AH2gAyNDAxODAxODExOmJkYjEzNThjMzNhY2I0YjNhMjAxMDhhMTlkZGQ0ZDM1ZTgxNTUwZjU=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcWM71fAFqTM5MTMzMzYyNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/bdb1358c33acb4b3a20108a19ddd4d35e81550f5", "committedDate": "2020-04-10T07:50:06Z", "message": "Reverts defensiveness in generic params and shares a buffer\n\nit was a relic of an older JDK, or complete fantasy. This reverts it.\n\nThis also fixes where we accidentally didn't share a buffer."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzE3MzEw", "url": "https://github.com/openzipkin/brave/pull/1147#pullrequestreview-391317310", "createdAt": "2020-04-10T07:56:13Z", "commit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1NjoxM1rOGDz4lA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1NjoxM1rOGDz4lA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0ODk4MA==", "bodyText": "note this is not really much different than before.. I can revert it.. I was just playing around.", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406648980", "createdAt": "2020-04-10T07:56:13Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -92,12 +92,21 @@ public void clear() {\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    class ThreadLocalScope implements Scope {\n-      @Override public void close() {\n-        local.set(previous);\n-      }\n-    }\n-    Scope result = new ThreadLocalScope();\n+    Scope result = new ThreadLocalScope(local, previous);\n     return decorateScope(currentSpan, result);\n   }\n+\n+  static final class ThreadLocalScope implements Scope {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzE3NDAz", "url": "https://github.com/openzipkin/brave/pull/1147#pullrequestreview-391317403", "createdAt": "2020-04-10T07:56:27Z", "commit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "state": "APPROVED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1NjoyN1rOGDz42Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwNzo1ODoxMlrOGDz7PQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTA0OQ==", "bodyText": "Agree - the JVM has no idea what's in these brackets anyways without reflection", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406649049", "createdAt": "2020-04-10T07:56:27Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracing.java", "diffHunk": "@@ -49,8 +49,7 @@\n  * for example via spring or when mocking.\n  */\n public abstract class Tracing implements Closeable {\n-  // AtomicReference<Object> instead of AtomicReference<Tracing> to ensure unloadable\n-  static final AtomicReference<Object> CURRENT = new AtomicReference<>();\n+  static final AtomicReference<Tracing> CURRENT = new AtomicReference<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY0OTY2MQ==", "bodyText": "This seems nice - seems like it could fix something?", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406649661", "createdAt": "2020-04-10T07:58:12Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/propagation/ThreadLocalCurrentTraceContext.java", "diffHunk": "@@ -92,12 +92,21 @@ public void clear() {\n   @Override public Scope newScope(@Nullable TraceContext currentSpan) {\n     final TraceContext previous = local.get();\n     local.set(currentSpan);\n-    class ThreadLocalScope implements Scope {\n-      @Override public void close() {\n-        local.set(previous);\n-      }\n-    }\n-    Scope result = new ThreadLocalScope();\n+    Scope result = new ThreadLocalScope(local, previous);\n     return decorateScope(currentSpan, result);\n   }\n+\n+  static final class ThreadLocalScope implements Scope {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bdb1358c33acb4b3a20108a19ddd4d35e81550f5"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "51aec8fc2ed3573d610c23ee2c31395080d9dcce", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/51aec8fc2ed3573d610c23ee2c31395080d9dcce", "committedDate": "2020-04-10T08:07:09Z", "message": "special case null"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzIyOTgz", "url": "https://github.com/openzipkin/brave/pull/1147#pullrequestreview-391322983", "createdAt": "2020-04-10T08:10:36Z", "commit": {"oid": "51aec8fc2ed3573d610c23ee2c31395080d9dcce"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "34bac2e6595dbe13352efed93bebd032000e2eeb", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/34bac2e6595dbe13352efed93bebd032000e2eeb", "committedDate": "2020-04-10T08:17:29Z", "message": "leaked scopes that revert to null are unloadable"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d984a69aeec9d0687a6fd5de9f00abd91cd69b3d", "author": {"user": null}, "url": "https://github.com/openzipkin/brave/commit/d984a69aeec9d0687a6fd5de9f00abd91cd69b3d", "committedDate": "2020-04-10T08:28:21Z", "message": "clarifies TODO"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkxMzMzNjI0", "url": "https://github.com/openzipkin/brave/pull/1147#pullrequestreview-391333624", "createdAt": "2020-04-10T08:36:38Z", "commit": {"oid": "d984a69aeec9d0687a6fd5de9f00abd91cd69b3d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODozNjozOFrOGD0umQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMFQwODozNjozOFrOGD0umQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjY2MjgwOQ==", "bodyText": "Doesn't block this PR at all, just to record my thought and maybe @felixbarny has some ideas too.\nI haven't worked with unloading scenarios much but wonder whether this is so odd - since most things get cleaned up when GC happens, it seems natural to me for unloaded classes to also wait until GC to be cleaned up.", "url": "https://github.com/openzipkin/brave/pull/1147#discussion_r406662809", "createdAt": "2020-04-10T08:36:38Z", "author": {"login": "anuraaga"}, "path": "brave-tests/src/test/java/brave/propagation/ThreadLocalCurrentTraceContextClassLoaderTest.java", "diffHunk": "@@ -43,9 +43,24 @@\n     }\n   }\n \n+  @Test public void leakedNullScope() {\n+    assertRunIsUnloadable(LeakedNullScope.class, getClass().getClassLoader());\n+  }\n+\n+  static class LeakedNullScope implements Runnable {\n+    @Override public void run() {\n+      CurrentTraceContext current = ThreadLocalCurrentTraceContext.newBuilder().build();\n+      current.newScope(null);\n+    }\n+  }\n+\n   /**\n-   * TODO: While it is an instrumentation bug to leak a scope, we should be tolerant, for example\n-   * considering weak references or similar.\n+   * TODO: While it is an instrumentation bug to leak a scope, we should be tolerant.\n+   *\n+   * <p>The current design problem is we don't know a reference type we can use that clears when\n+   * the classloader is unloaded, regardless of GC. For example, having {@link Scope} extend {@link\n+   * java.lang.ref.WeakReference} to hold the value to revert. This would only help if GC happened", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d984a69aeec9d0687a6fd5de9f00abd91cd69b3d"}, "originalPosition": 29}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1930, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}