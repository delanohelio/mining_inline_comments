{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyMTM2MTk1", "number": 1149, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNDowNjoyOVrODw6JEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNzowMTowN1rODw62wg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjEwODM0OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tracer.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNDowNjoyOVrOGEKLUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNzowODo0NFrOGELDXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAxNDIyNw==", "bodyText": "this one is very hard to grok, but basically if the input context is the same ids as the one garbage collected, but a different instance, it is effectively resurrection from the POV of the user (as they wouldn't know about ref swapping anyway). I can remove this or revise this comment if confusing", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407014227", "createdAt": "2020-04-11T04:06:29Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "cdb9635603615134033eb8fbd7498124285484fb"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzU2MQ==", "bodyText": "IIUC Recreated would be more intuitive - not sure what it means to resurrect an object in Java", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027561", "createdAt": "2020-04-11T06:56:53Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAxNDIyNw=="}, "originalCommit": {"oid": "cdb9635603615134033eb8fbd7498124285484fb"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyODU3NA==", "bodyText": "sgtm thanks", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407028574", "createdAt": "2020-04-11T07:08:44Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAxNDIyNw=="}, "originalCommit": {"oid": "cdb9635603615134033eb8fbd7498124285484fb"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjIyMTM5OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/NoopSpan.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNjo1NToyMFrOGEK-9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNzoxNTowN1rOGELFwg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzQ0NA==", "bodyText": "maybe a one liner why not comparing to real span?", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027444", "createdAt": "2020-04-11T06:55:20Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/NoopSpan.java", "diffHunk": "@@ -92,10 +92,22 @@\n     return \"NoopSpan(\" + context + \")\";\n   }\n \n+  /**\n+   * This also matches equals against a lazy span. The rationale is least surprise to the user, as\n+   * code should not act differently given an instance of lazy or {@link NoopSpan}.\n+   */\n   @Override public boolean equals(Object o) {\n     if (o == this) return true;\n-    if (!(o instanceof NoopSpan)) return false;\n-    return context.equals(((NoopSpan) o).context);\n+    return isEqualToNoopOrLazySpan(context, o);\n+  }\n+\n+  static boolean isEqualToNoopOrLazySpan(TraceContext context, Object o) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyOTE4Ng==", "bodyText": "added this for the two places it applies (here and over in real)\n  // We don't compare a RealSpan vs a NoopSpan as they can never equal each other.\n  // RealSpan's are always locally sampled and Noop ones are always not.", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407029186", "createdAt": "2020-04-11T07:15:07Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/NoopSpan.java", "diffHunk": "@@ -92,10 +92,22 @@\n     return \"NoopSpan(\" + context + \")\";\n   }\n \n+  /**\n+   * This also matches equals against a lazy span. The rationale is least surprise to the user, as\n+   * code should not act differently given an instance of lazy or {@link NoopSpan}.\n+   */\n   @Override public boolean equals(Object o) {\n     if (o == this) return true;\n-    if (!(o instanceof NoopSpan)) return false;\n-    return context.equals(((NoopSpan) o).context);\n+    return isEqualToNoopOrLazySpan(context, o);\n+  }\n+\n+  static boolean isEqualToNoopOrLazySpan(TraceContext context, Object o) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzQ0NA=="}, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjIyMjQ5OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/Tracer.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNjo1NzoxMlrOGEK_dA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNjo1NzoxMlrOGEK_dA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzU3Mg==", "bodyText": "each other", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027572", "createdAt": "2020-04-11T06:57:12Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/Tracer.java", "diffHunk": "@@ -369,27 +365,48 @@ public Span nextSpan(TraceContextOrSamplingFlags extracted) {\n     return _toSpan(decorateContext(flags, traceIdHigh, traceId, localRootId, spanId, 0L, extra));\n   }\n \n-  /** Converts the context to a Span object after decorating it for propagation */\n+  /**\n+   * Converts the context to a Span object after decorating it for propagation.\n+   *\n+   * <p>This api is not advised for routine use. It is better to hold a reference to a span created\n+   * elsewhere vs rely on implicit lookups.\n+   */\n   public Span toSpan(TraceContext context) {\n-    if (context == null) throw new NullPointerException(\"context == null\");\n-    if (isDecorated(context)) return _toSpan(context);\n-\n-    return _toSpan(decorateContext(\n+    // Re-use a pending context if present: This ensures reference consistency on Span.context()\n+    TraceContext pendingContext = swapForPendingContext(context);\n+    if (pendingContext != null) return _toSpan(pendingContext);\n+\n+    // There are a few known scenarios for the context to be absent from the pending map:\n+    // * Created by a separate tracer (localRootId set)\n+    // * Resurrected span from a garbage collection (localRootId set)\n+    // * Ad-hoc usage of TraceContext.Builder (localRootId not set, as only settable internally)\n+    //\n+    // The first two scenarios are currently indistinguishable from eachother. If we had a way to", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyNjIyNTMwOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/internal/recorder/PendingSpan.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNzowMTowN1rOGELA0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xMVQwNzoxODo1OVrOGELHCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA==", "bodyText": "I don't think this type is exposed to users and can be leaked by them. Can't we use a normal reference?", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407027920", "createdAt": "2020-04-11T07:01:07Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/recorder/PendingSpan.java", "diffHunk": "@@ -15,17 +15,32 @@\n \n import brave.Clock;\n import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n \n-public final class PendingSpan {\n+/**\n+ * This includes a weak reference of the trace context, which allows externalized forms of the trace\n+ * context to be swapped for the one in use.\n+ *\n+ * <p>This is a weak reference to ensure that {@link PendingSpans} can clean up on GC.\n+ */\n+public final class PendingSpan extends WeakReference<TraceContext> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyODgxOA==", "bodyText": "if we use a hard reference, it breaks PendingSpans. The keys used in PendingSpans include a weak reference to the trace context, if the value of the same entry has a hard reference, the weak keys are made useless as they can never be collected. Is there a good way to rephrase this?", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407028818", "createdAt": "2020-04-11T07:10:56Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/recorder/PendingSpan.java", "diffHunk": "@@ -15,17 +15,32 @@\n \n import brave.Clock;\n import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n \n-public final class PendingSpan {\n+/**\n+ * This includes a weak reference of the trace context, which allows externalized forms of the trace\n+ * context to be swapped for the one in use.\n+ *\n+ * <p>This is a weak reference to ensure that {@link PendingSpans} can clean up on GC.\n+ */\n+public final class PendingSpan extends WeakReference<TraceContext> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA=="}, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyOTI5NA==", "bodyText": "I'll rephrase as it isn't clear that this type is a map entry value anyway..", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407029294", "createdAt": "2020-04-11T07:16:39Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/recorder/PendingSpan.java", "diffHunk": "@@ -15,17 +15,32 @@\n \n import brave.Clock;\n import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n \n-public final class PendingSpan {\n+/**\n+ * This includes a weak reference of the trace context, which allows externalized forms of the trace\n+ * context to be swapped for the one in use.\n+ *\n+ * <p>This is a weak reference to ensure that {@link PendingSpans} can clean up on GC.\n+ */\n+public final class PendingSpan extends WeakReference<TraceContext> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA=="}, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyOTUxNA==", "bodyText": "PTAL! thanks", "url": "https://github.com/openzipkin/brave/pull/1149#discussion_r407029514", "createdAt": "2020-04-11T07:18:59Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/recorder/PendingSpan.java", "diffHunk": "@@ -15,17 +15,32 @@\n \n import brave.Clock;\n import brave.handler.MutableSpan;\n+import brave.internal.Nullable;\n+import brave.propagation.TraceContext;\n+import java.lang.ref.WeakReference;\n \n-public final class PendingSpan {\n+/**\n+ * This includes a weak reference of the trace context, which allows externalized forms of the trace\n+ * context to be swapped for the one in use.\n+ *\n+ * <p>This is a weak reference to ensure that {@link PendingSpans} can clean up on GC.\n+ */\n+public final class PendingSpan extends WeakReference<TraceContext> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzAyNzkyMA=="}, "originalCommit": {"oid": "0b7b426b114b46307fa8ae3bb1dd49ca5bcb326d"}, "originalPosition": 22}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1639, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}