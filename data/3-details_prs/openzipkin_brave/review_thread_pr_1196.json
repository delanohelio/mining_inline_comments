{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1NTY3MTY5", "number": 1196, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxMjoxNToyNFrOD625HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNTo0NDo0NFrOD63_ig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDQzMzU3OnYy", "diffSide": "LEFT", "path": "brave/src/test/java/brave/features/handler/RedactingSpanHandlerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxMjoxNToyNFrOGS6qJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxMjoxNToyNFrOGS6qJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4ODYxMw==", "bodyText": "I switched only one test to show decoupling from zipkin types", "url": "https://github.com/openzipkin/brave/pull/1196#discussion_r422488613", "createdAt": "2020-05-09T12:15:24Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/features/handler/RedactingSpanHandlerTest.java", "diffHunk": "@@ -28,9 +28,8 @@\n import java.util.regex.Pattern;\n import org.junit.After;\n import org.junit.Test;\n-import zipkin2.Annotation;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aaff718c86306f51a21a194c0785ab5376262c5"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDQzNjAyOnYy", "diffSide": "LEFT", "path": "brave/src/test/java/brave/handler/MutableSpanTest.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxMjoxODo0MVrOGS6rUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxMjoxODo0MVrOGS6rUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ4ODkxNQ==", "bodyText": "in hindsight maybe it is worth putting these back.. they are allocation free ways to get the count..", "url": "https://github.com/openzipkin/brave/pull/1196#discussion_r422488915", "createdAt": "2020-05-09T12:18:41Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/handler/MutableSpanTest.java", "diffHunk": "@@ -91,7 +89,7 @@\n     // When exporting into a list, a lambda would usually need to close over the list, which results\n     // in a new instance per invocation. Since there's a target type parameter, the lambda for this\n     // style of conversion can be constant, reducing overhead.\n-    List<Tag> listTarget = new ArrayList<>(span.tagCount());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6aaff718c86306f51a21a194c0785ab5376262c5"}, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDUxODg5OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/handler/MutableSpan.java", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxMzo1ODowOVrOGS7S7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNToxODo0NlrOGS7zdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5OTA1NA==", "bodyText": "Just to confirm it's ok for this to not be volatile. I guess an ArrayList would have already had issues when resizing though if there is a problem, but I'm not sure that memory is synced if users allowed to mutate without the lock.", "url": "https://github.com/openzipkin/brave/pull/1196#discussion_r422499054", "createdAt": "2020-05-09T13:58:09Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -81,9 +85,9 @@\n   int localPort, remotePort;\n \n   /** To reduce the amount of allocation use a pair-indexed list for tag (key, value). */\n-  ArrayList<String> tags;\n-  /** Also use pair indexing for annotations, but type object to store (startTimestamp, value). */\n-  ArrayList<Object> annotations;\n+  Object[] tags = EMPTY_ARRAY;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "62ad1ec7ffdf11fb2607ba43d3419d53e7a96fe3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDQ4MA==", "bodyText": "yeah this type isn't thread safe it is externally synchronized. the only reason doing copy-on-write is for the map views, to avoid having issues with people sharing them. I'll make a note", "url": "https://github.com/openzipkin/brave/pull/1196#discussion_r422504480", "createdAt": "2020-05-09T14:50:45Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -81,9 +85,9 @@\n   int localPort, remotePort;\n \n   /** To reduce the amount of allocation use a pair-indexed list for tag (key, value). */\n-  ArrayList<String> tags;\n-  /** Also use pair indexing for annotations, but type object to store (startTimestamp, value). */\n-  ArrayList<Object> annotations;\n+  Object[] tags = EMPTY_ARRAY;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5OTA1NA=="}, "originalCommit": {"oid": "62ad1ec7ffdf11fb2607ba43d3419d53e7a96fe3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNDUxOA==", "bodyText": "copy-on-write for update I mean", "url": "https://github.com/openzipkin/brave/pull/1196#discussion_r422504518", "createdAt": "2020-05-09T14:51:10Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -81,9 +85,9 @@\n   int localPort, remotePort;\n \n   /** To reduce the amount of allocation use a pair-indexed list for tag (key, value). */\n-  ArrayList<String> tags;\n-  /** Also use pair indexing for annotations, but type object to store (startTimestamp, value). */\n-  ArrayList<Object> annotations;\n+  Object[] tags = EMPTY_ARRAY;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5OTA1NA=="}, "originalCommit": {"oid": "62ad1ec7ffdf11fb2607ba43d3419d53e7a96fe3"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUwNzM4Mg==", "bodyText": "I think I added confusion by even saying copy-on-write.. my bad. PTAL at latest!", "url": "https://github.com/openzipkin/brave/pull/1196#discussion_r422507382", "createdAt": "2020-05-09T15:18:46Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -81,9 +85,9 @@\n   int localPort, remotePort;\n \n   /** To reduce the amount of allocation use a pair-indexed list for tag (key, value). */\n-  ArrayList<String> tags;\n-  /** Also use pair indexing for annotations, but type object to store (startTimestamp, value). */\n-  ArrayList<Object> annotations;\n+  Object[] tags = EMPTY_ARRAY;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQ5OTA1NA=="}, "originalCommit": {"oid": "62ad1ec7ffdf11fb2607ba43d3419d53e7a96fe3"}, "originalPosition": 29}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYzMDYxMzg2OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/handler/MutableSpan.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNTo0NDo0NFrOGS8AXg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQxNTo0NDo0NFrOGS8AXg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjUxMDY4Ng==", "bodyText": "oops we don't need to do this.. all we need to do is shift and set null. Otherwise dropping all but one tag (like skeletal spans do) will thrash. will fix", "url": "https://github.com/openzipkin/brave/pull/1196#discussion_r422510686", "createdAt": "2020-05-09T15:44:44Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/handler/MutableSpan.java", "diffHunk": "@@ -883,6 +928,32 @@ static void writeEndpoint(StringBuilder b,\n     b.append('}');\n   }\n \n+  static Object[] add(Object[] input, Object key, Object value) {\n+    int newIndex = input.length;\n+    Object[] result = Arrays.copyOf(input, input.length + 2); // copy-on-write\n+    result[newIndex] = key;\n+    result[newIndex + 1] = value;\n+    return result;\n+  }\n+\n+  // this is externally synchronized, so we can edit it directly\n+  static Object[] update(Object[] input, int i, Object value) {\n+    if (value.equals(input[i + 1])) return input;\n+    input[i + 1] = value;\n+    return input;\n+  }\n+\n+  static Object[] copy(Object[] input) {\n+    return input.length > 0 ? Arrays.copyOf(input, input.length) : EMPTY_ARRAY;\n+  }\n+\n+  static Object[] remove(Object[] input, int i) {\n+    if (input.length == 2 && i == 0) return EMPTY_ARRAY;\n+    Object[] result = Arrays.copyOf(input, input.length - 2);\n+    System.arraycopy(input, i + 2, result, i, input.length - i - 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8877e7bc4e42f57c0c2d1b706e244df4393109cc"}, "originalPosition": 501}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1426, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}