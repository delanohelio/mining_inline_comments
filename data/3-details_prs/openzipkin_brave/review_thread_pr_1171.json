{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA4MzU1MTYy", "number": 1171, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjoyODoyNlrOD1nUrA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjozODo1M1rOD1nhpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTQ1Mzg4OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjoyODoyNlrOGLIgoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjozNDo0OFrOGLIrbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNjk0NA==", "bodyText": "It might be a tiny bit more performant to presize instead of precopy\nList<String> result = new ArrayList<>(propagation.keys().size()+ baggageKeyNames.size());\nresult.addAll(propataion.keys();\nresult.addAll(baggageKeyNames);\nreturn unmodifiable(result);", "url": "https://github.com/openzipkin/brave/pull/1171#discussion_r414326944", "createdAt": "2020-04-24T06:28:26Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "diffHunk": "@@ -259,6 +240,45 @@ public FactoryBuilder add(BaggagePropagationConfig config) {\n     return delegate.keys();\n   }\n \n+  /**\n+   * Returns the key names used for propagation, including those used for the {@linkplain #keys()\n+   * trace context} and {@linkplain SingleBaggageField#keyNames() baggage}. The result can be cached\n+   * in the same scope as the propagation instance.\n+   *\n+   * <p>This is here for the remote propagation use cases:\n+   * <ul>\n+   *   <li>To generate constants for all key names. ex. gRPC Metadata.Key</li>\n+   *   <li>To iterate fields when missing a get field by name function. ex. OpenTracing TextMap</li>\n+   *   <li>To clear fields on re-usable requests. ex. JMS message</li>\n+   * </ul>\n+   *\n+   * <h3>Details</h3>\n+   * The {@code propagation} parameter is required because there may be multiple tracers with\n+   * different baggage configuration. Also, {@link Propagation} instances can be wrapped, so you\n+   * cannot use {@code instanceof} to identify if baggage is internally supported. For example,\n+   * {@link ExtraFieldPropagation} internally wraps {@link BaggagePropagation}.\n+   *\n+   * <p>This is different than {@link BaggageField#getAll(TraceContext)}, as propagation keys may be\n+   * different than {@link BaggageField#name() baggage field names}.\n+   *\n+   * @param propagation used to extract configuration\n+   * @return a list of remote propagation key names used for trace context and baggage.\n+   * @since 5.12\n+   */\n+  // On OpenTracing TextMap: https://github.com/opentracing/opentracing-java/issues/305\n+  public static List<String> allKeyNames(Propagation<String> propagation) {\n+    if (propagation == null) throw new NullPointerException(\"propagation == null\");\n+    // When baggage or similar is in use, the result != TraceContextOrSamplingFlags.EMPTY\n+    TraceContextOrSamplingFlags emptyExtraction =\n+      propagation.extractor((c, k) -> null).extract(Boolean.TRUE);\n+    List<String> baggageKeyNames = ExtraBaggageContext.getAllKeyNames(emptyExtraction);\n+    if (baggageKeyNames.isEmpty()) return propagation.keys();\n+\n+    List<String> result = new ArrayList<>(propagation.keys());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a71b3c5bb583b7a5e9e537f14536af0f421e9788"}, "originalPosition": 228}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyOTcwOA==", "bodyText": "sure thing", "url": "https://github.com/openzipkin/brave/pull/1171#discussion_r414329708", "createdAt": "2020-04-24T06:34:48Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "diffHunk": "@@ -259,6 +240,45 @@ public FactoryBuilder add(BaggagePropagationConfig config) {\n     return delegate.keys();\n   }\n \n+  /**\n+   * Returns the key names used for propagation, including those used for the {@linkplain #keys()\n+   * trace context} and {@linkplain SingleBaggageField#keyNames() baggage}. The result can be cached\n+   * in the same scope as the propagation instance.\n+   *\n+   * <p>This is here for the remote propagation use cases:\n+   * <ul>\n+   *   <li>To generate constants for all key names. ex. gRPC Metadata.Key</li>\n+   *   <li>To iterate fields when missing a get field by name function. ex. OpenTracing TextMap</li>\n+   *   <li>To clear fields on re-usable requests. ex. JMS message</li>\n+   * </ul>\n+   *\n+   * <h3>Details</h3>\n+   * The {@code propagation} parameter is required because there may be multiple tracers with\n+   * different baggage configuration. Also, {@link Propagation} instances can be wrapped, so you\n+   * cannot use {@code instanceof} to identify if baggage is internally supported. For example,\n+   * {@link ExtraFieldPropagation} internally wraps {@link BaggagePropagation}.\n+   *\n+   * <p>This is different than {@link BaggageField#getAll(TraceContext)}, as propagation keys may be\n+   * different than {@link BaggageField#name() baggage field names}.\n+   *\n+   * @param propagation used to extract configuration\n+   * @return a list of remote propagation key names used for trace context and baggage.\n+   * @since 5.12\n+   */\n+  // On OpenTracing TextMap: https://github.com/opentracing/opentracing-java/issues/305\n+  public static List<String> allKeyNames(Propagation<String> propagation) {\n+    if (propagation == null) throw new NullPointerException(\"propagation == null\");\n+    // When baggage or similar is in use, the result != TraceContextOrSamplingFlags.EMPTY\n+    TraceContextOrSamplingFlags emptyExtraction =\n+      propagation.extractor((c, k) -> null).extract(Boolean.TRUE);\n+    List<String> baggageKeyNames = ExtraBaggageContext.getAllKeyNames(emptyExtraction);\n+    if (baggageKeyNames.isEmpty()) return propagation.keys();\n+\n+    List<String> result = new ArrayList<>(propagation.keys());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMyNjk0NA=="}, "originalCommit": {"oid": "a71b3c5bb583b7a5e9e537f14536af0f421e9788"}, "originalPosition": 228}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTQ4NDIyOnYy", "diffSide": "LEFT", "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjozODowMFrOGLIw8g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjozODowMFrOGLIw8g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzMTEyMg==", "bodyText": "ps this was redundant as config keyNames are by definition lc", "url": "https://github.com/openzipkin/brave/pull/1171#discussion_r414331122", "createdAt": "2020-04-24T06:38:00Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "diffHunk": "@@ -138,92 +139,72 @@ public FactoryBuilder add(BaggagePropagationConfig config) {\n         throw new UnsupportedOperationException(\"dynamic fields not yet supported\");\n       }\n       SingleBaggageField field = (SingleBaggageField) config;\n-      if (fieldToKeyNames.containsKey(field.field)) {\n+      if (fieldToHandler.containsKey(field.field)) {\n         throw new IllegalArgumentException(field.field.name + \" already added\");\n       }\n       configs.add(field);\n-      Set<String> lcKeyNames = new LinkedHashSet<>();\n+      if (field.keyNames().isEmpty()) {\n+        fieldToHandler.put(field.field, BaggageHandlers.string(field.field));\n+        return this;\n+      }\n+\n       for (String keyName : field.keyNames) {\n-        String lcName = validateName(keyName).toLowerCase(Locale.ROOT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed0aa9d359be54ba7797393859a444cf90c12f4"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU3NTQ4NzEwOnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjozODo1M1rOGLIyjw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQwNjozODo1M1rOGLIyjw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDMzMTUzNQ==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * different than {@link BaggageField#name() baggage field names}.\n          \n          \n            \n               * different than {@linkplain BaggageField#name() baggage field names}.", "url": "https://github.com/openzipkin/brave/pull/1171#discussion_r414331535", "createdAt": "2020-04-24T06:38:53Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/baggage/BaggagePropagation.java", "diffHunk": "@@ -259,6 +240,46 @@ public FactoryBuilder add(BaggagePropagationConfig config) {\n     return delegate.keys();\n   }\n \n+  /**\n+   * Returns the key names used for propagation, including those used for the {@linkplain #keys()\n+   * trace context} and {@linkplain SingleBaggageField#keyNames() baggage}. The result can be cached\n+   * in the same scope as the propagation instance.\n+   *\n+   * <p>This is here for the remote propagation use cases:\n+   * <ul>\n+   *   <li>To generate constants for all key names. ex. gRPC Metadata.Key</li>\n+   *   <li>To iterate fields when missing a get field by name function. ex. OpenTracing TextMap</li>\n+   *   <li>To clear fields on re-usable requests. ex. JMS message</li>\n+   * </ul>\n+   *\n+   * <h3>Details</h3>\n+   * The {@code propagation} parameter is required because there may be multiple tracers with\n+   * different baggage configuration. Also, {@link Propagation} instances can be wrapped, so you\n+   * cannot use {@code instanceof} to identify if baggage is internally supported. For example,\n+   * {@link ExtraFieldPropagation} internally wraps {@link BaggagePropagation}.\n+   *\n+   * <p>This is different than {@link BaggageField#getAll(TraceContext)}, as propagation keys may be\n+   * different than {@link BaggageField#name() baggage field names}.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bed0aa9d359be54ba7797393859a444cf90c12f4"}, "originalPosition": 213}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1376, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}