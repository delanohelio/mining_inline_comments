{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEwODAxMTEy", "number": 1182, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1NDoxN1rOD3sStQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNDo1NDowMFrOD344ew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzIzOTU3OnYy", "diffSide": "RIGHT", "path": "brave/src/test/java/brave/features/baggage/BaggageInSingleHeaderTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1NDoxN1rOGOFnOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1NDoxN1rOGOFnOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTIxMA==", "bodyText": "neat file 1:", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417425210", "createdAt": "2020-04-29T15:54:17Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/features/baggage/BaggageInSingleHeaderTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.baggage.BaggagePropagationConfig.SingleBaggageField;\n+import brave.internal.InternalBaggage;\n+import brave.propagation.B3Propagation;\n+import brave.propagation.Propagation;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import org.junit.Test;\n+\n+import static brave.baggage.BaggagePropagation.newFactoryBuilder;\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.entry;\n+\n+/** This is an internal feature until we settle on an encoding format. */\n+public class BaggageInSingleHeaderTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NzI0MDU2OnYy", "diffSide": "RIGHT", "path": "brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1NDoyOFrOGOFnzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQxNTo1NDoyOFrOGOFnzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzQyNTM1Nw==", "bodyText": "neat file 2:", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417425357", "createdAt": "2020-04-29T15:54:28Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/test/java/brave/features/baggage/SingleHeaderCodec.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.features.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.baggage.BaggagePropagationConfig;\n+import brave.internal.baggage.BaggageCodec;\n+import brave.internal.baggage.ExtraBaggageFields;\n+import brave.propagation.Propagation;\n+import brave.propagation.TraceContext;\n+import java.util.Collections;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * This is a non-complete codec for the w3c (soon to be renamed to \"baggage\") header.\n+ *\n+ * <p>See https://github.com/w3c/correlation-context/blob/master/correlation_context/HTTP_HEADER_FORMAT.md\n+ */\n+final class SingleHeaderCodec implements BaggageCodec {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248"}, "originalPosition": 32}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTI5MjU0OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/internal/baggage/BaggageCodec.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNDo0ODoyOFrOGOZgqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNToyNToxMVrOGOaFHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MTIwOQ==", "bodyText": "If we have a type parameter I think we need it on the BaggageCodec<R>. I checked out the branch and tried implementing this interface but the ony thing allowed when inherting instead of R is Object since anything else is outside the type's bounds.", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417751209", "createdAt": "2020-04-30T04:48:28Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/BaggageCodec.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.internal.Nullable;\n+import brave.propagation.Propagation.Getter;\n+import brave.propagation.Propagation.Setter;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public interface BaggageCodec {\n+  /**\n+   * Use this when configuration results in no codec needed.\n+   */\n+  BaggageCodec NOOP = new BaggageCodec() {\n+    @Override public List<String> extractKeyNames() {\n+      return Collections.emptyList();\n+    }\n+\n+    @Override public List<String> injectKeyNames() {\n+      return Collections.emptyList();\n+    }\n+\n+    @Override public <R> boolean decode(ExtraBaggageFields extra, R request, String value) {\n+      return false;\n+    }\n+\n+    @Override public <R> String encode(ExtraBaggageFields extra, TraceContext context, R request) {\n+      return null;\n+    }\n+\n+    @Override public String toString() {\n+      return \"NoopBaggageCodec\";\n+    }\n+  };\n+\n+  /**\n+   * Ordered list of key names used during {@link Extractor#extract(Object)} with {@link\n+   * Getter#get(Object, Object)}.\n+   *\n+   * <p>{@link Getter#get(Object, Object)} will be called against these in order until a\n+   * non-{@code null} value result or there are no more keys.\n+   *\n+   * @since 5.12\n+   */\n+  List<String> extractKeyNames();\n+\n+  /**\n+   * Ordered list of key names used during {@link Injector#inject(TraceContext, Object)} with {@link\n+   * Setter#put(Object, Object, String)}.\n+   *\n+   * @since 5.12\n+   */\n+  List<String> injectKeyNames();\n+\n+  /**\n+   * Called on the first non-{@code null} value from an {@link #extractKeyNames() extract key}.\n+   * Decodes any field state from an extracted value or returns {@code null} if there were none.\n+   *\n+   * <p>Ex. When the state is a simple string, this will just use the request value directly.\n+   * {@linkplain ExtraBaggageFields#isDynamic() dynamic values} will need to perform some decoding,\n+   * such as splitting on comma and equals.\n+   *\n+   * @param <R> the type parameter of {@link Extractor#<R>}\n+   * @param extra holds {@link BaggageField} state.\n+   * @param request the parameter of {@link Extractor#extract(Object)}\n+   * @param value a non-{@code null} result of {@link Getter#get(Object, Object)}\n+   * @see #extractKeyNames()\n+   */\n+  <R> boolean decode(ExtraBaggageFields extra, R request, String value);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248"}, "originalPosition": 85}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc2MDU0MA==", "bodyText": "agreed. this  drifted and isn't currently useful. I had one version that was passing the setter..", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417760540", "createdAt": "2020-04-30T05:25:11Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/baggage/BaggageCodec.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import brave.internal.Nullable;\n+import brave.propagation.Propagation.Getter;\n+import brave.propagation.Propagation.Setter;\n+import brave.propagation.TraceContext;\n+import brave.propagation.TraceContext.Extractor;\n+import brave.propagation.TraceContext.Injector;\n+import java.util.Collections;\n+import java.util.List;\n+\n+public interface BaggageCodec {\n+  /**\n+   * Use this when configuration results in no codec needed.\n+   */\n+  BaggageCodec NOOP = new BaggageCodec() {\n+    @Override public List<String> extractKeyNames() {\n+      return Collections.emptyList();\n+    }\n+\n+    @Override public List<String> injectKeyNames() {\n+      return Collections.emptyList();\n+    }\n+\n+    @Override public <R> boolean decode(ExtraBaggageFields extra, R request, String value) {\n+      return false;\n+    }\n+\n+    @Override public <R> String encode(ExtraBaggageFields extra, TraceContext context, R request) {\n+      return null;\n+    }\n+\n+    @Override public String toString() {\n+      return \"NoopBaggageCodec\";\n+    }\n+  };\n+\n+  /**\n+   * Ordered list of key names used during {@link Extractor#extract(Object)} with {@link\n+   * Getter#get(Object, Object)}.\n+   *\n+   * <p>{@link Getter#get(Object, Object)} will be called against these in order until a\n+   * non-{@code null} value result or there are no more keys.\n+   *\n+   * @since 5.12\n+   */\n+  List<String> extractKeyNames();\n+\n+  /**\n+   * Ordered list of key names used during {@link Injector#inject(TraceContext, Object)} with {@link\n+   * Setter#put(Object, Object, String)}.\n+   *\n+   * @since 5.12\n+   */\n+  List<String> injectKeyNames();\n+\n+  /**\n+   * Called on the first non-{@code null} value from an {@link #extractKeyNames() extract key}.\n+   * Decodes any field state from an extracted value or returns {@code null} if there were none.\n+   *\n+   * <p>Ex. When the state is a simple string, this will just use the request value directly.\n+   * {@linkplain ExtraBaggageFields#isDynamic() dynamic values} will need to perform some decoding,\n+   * such as splitting on comma and equals.\n+   *\n+   * @param <R> the type parameter of {@link Extractor#<R>}\n+   * @param extra holds {@link BaggageField} state.\n+   * @param request the parameter of {@link Extractor#extract(Object)}\n+   * @param value a non-{@code null} result of {@link Getter#get(Object, Object)}\n+   * @see #extractKeyNames()\n+   */\n+  <R> boolean decode(ExtraBaggageFields extra, R request, String value);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MTIwOQ=="}, "originalCommit": {"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248"}, "originalPosition": 85}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTI5OTI3OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/internal/baggage/DynamicBaggageState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNDo1MjoxNFrOGOZkZg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNToyNjoxN1rOGOaGKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjE2Ng==", "bodyText": "Formatting in a couplle files", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417752166", "createdAt": "2020-04-30T04:52:14Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/DynamicBaggageState.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static brave.internal.baggage.ExtraBaggageFields.equal;\n+\n+/** Handles {@link BaggageField} value storage with a map. */\n+final class DynamicBaggageState extends ExtraBaggageFields.State<Map<BaggageField, String>> {\n+  DynamicBaggageState(DynamicBaggageFieldsFactory factory, Map<BaggageField, String> parentState) {\n+    super(factory, parentState);\n+  }\n+\n+  @Override public boolean isDynamic() {\n+    return true;\n+  }\n+\n+  /** The list of fields present, regardless of value. */\n+  @Override public List<BaggageField> getAllFields() {\n+    return Collections.unmodifiableList(new ArrayList<>(state.keySet()));\n+  }\n+\n+  @Override public String getValue(BaggageField field) {\n+    return state.get(field);\n+  }\n+\n+  @Override public boolean updateValue(BaggageField field, String value) {\n+    synchronized (this) {\n+      Map<BaggageField, String> state = this.state;\n+      if (equal(value, state.get(field))) return false;\n+\n+      // We replace an existing value with null instead of deleting it. This way we know there was\n+      // a field value at some point (ex for reverting state).\n+      LinkedHashMap<BaggageField, String> mergedState = new LinkedHashMap<>(state);\n+      mergedState.put(field, value);\n+      this.state = mergedState;\n+    }\n+    return true;\n+  }\n+\n+  @Override void putAllIfAbsent(ExtraBaggageFields parent) {\n+    Map<BaggageField, String> parentState = ((DynamicBaggageState) parent.internal).state;\n+\n+    for (BaggageField field : parentState.keySet()) {\n+      String thisValue = state.get(field);\n+      if (thisValue != null) continue; // extracted wins vs parent\n+      state.put(field, parentState.get(field));\n+    }\n+  }\n+\n+  // Implemented for equals when no baggage was extracted\n+  @Override public boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof DynamicBaggageState)) return false;\n+    return state.equals(((DynamicBaggageState) o).state);\n+  }\n+\n+  @Override public int hashCode() {\n+    return state.hashCode();\n+  }\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc2MDgxMA==", "bodyText": "np. My formatter is actually correct now (I caused a lot of format problems when updating to an unknown version of intellij). regardless, I'll sweep for fuzz.. was a bit tired and didn't catch all of it last night.", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417760810", "createdAt": "2020-04-30T05:26:17Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/baggage/DynamicBaggageState.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static brave.internal.baggage.ExtraBaggageFields.equal;\n+\n+/** Handles {@link BaggageField} value storage with a map. */\n+final class DynamicBaggageState extends ExtraBaggageFields.State<Map<BaggageField, String>> {\n+  DynamicBaggageState(DynamicBaggageFieldsFactory factory, Map<BaggageField, String> parentState) {\n+    super(factory, parentState);\n+  }\n+\n+  @Override public boolean isDynamic() {\n+    return true;\n+  }\n+\n+  /** The list of fields present, regardless of value. */\n+  @Override public List<BaggageField> getAllFields() {\n+    return Collections.unmodifiableList(new ArrayList<>(state.keySet()));\n+  }\n+\n+  @Override public String getValue(BaggageField field) {\n+    return state.get(field);\n+  }\n+\n+  @Override public boolean updateValue(BaggageField field, String value) {\n+    synchronized (this) {\n+      Map<BaggageField, String> state = this.state;\n+      if (equal(value, state.get(field))) return false;\n+\n+      // We replace an existing value with null instead of deleting it. This way we know there was\n+      // a field value at some point (ex for reverting state).\n+      LinkedHashMap<BaggageField, String> mergedState = new LinkedHashMap<>(state);\n+      mergedState.put(field, value);\n+      this.state = mergedState;\n+    }\n+    return true;\n+  }\n+\n+  @Override void putAllIfAbsent(ExtraBaggageFields parent) {\n+    Map<BaggageField, String> parentState = ((DynamicBaggageState) parent.internal).state;\n+\n+    for (BaggageField field : parentState.keySet()) {\n+      String thisValue = state.get(field);\n+      if (thisValue != null) continue; // extracted wins vs parent\n+      state.put(field, parentState.get(field));\n+    }\n+  }\n+\n+  // Implemented for equals when no baggage was extracted\n+  @Override public boolean equals(Object o) {\n+    if (o == this) return true;\n+    if (!(o instanceof DynamicBaggageState)) return false;\n+    return state.equals(((DynamicBaggageState) o).state);\n+  }\n+\n+  @Override public int hashCode() {\n+    return state.hashCode();\n+  }\n+}", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjE2Ng=="}, "originalCommit": {"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5OTMwMjM1OnYy", "diffSide": "RIGHT", "path": "brave/src/main/java/brave/internal/baggage/DynamicBaggageState.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNDo1NDowMFrOGOZmEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQwNjoyNToxNFrOGObWLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjU5Mg==", "bodyText": "Is there any implicit guarantee this is mutable (not Collections.emptyMap())? There might be but it's not so clear.", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417752592", "createdAt": "2020-04-30T04:54:00Z", "author": {"login": "anuraaga"}, "path": "brave/src/main/java/brave/internal/baggage/DynamicBaggageState.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static brave.internal.baggage.ExtraBaggageFields.equal;\n+\n+/** Handles {@link BaggageField} value storage with a map. */\n+final class DynamicBaggageState extends ExtraBaggageFields.State<Map<BaggageField, String>> {\n+  DynamicBaggageState(DynamicBaggageFieldsFactory factory, Map<BaggageField, String> parentState) {\n+    super(factory, parentState);\n+  }\n+\n+  @Override public boolean isDynamic() {\n+    return true;\n+  }\n+\n+  /** The list of fields present, regardless of value. */\n+  @Override public List<BaggageField> getAllFields() {\n+    return Collections.unmodifiableList(new ArrayList<>(state.keySet()));\n+  }\n+\n+  @Override public String getValue(BaggageField field) {\n+    return state.get(field);\n+  }\n+\n+  @Override public boolean updateValue(BaggageField field, String value) {\n+    synchronized (this) {\n+      Map<BaggageField, String> state = this.state;\n+      if (equal(value, state.get(field))) return false;\n+\n+      // We replace an existing value with null instead of deleting it. This way we know there was\n+      // a field value at some point (ex for reverting state).\n+      LinkedHashMap<BaggageField, String> mergedState = new LinkedHashMap<>(state);\n+      mergedState.put(field, value);\n+      this.state = mergedState;\n+    }\n+    return true;\n+  }\n+\n+  @Override void putAllIfAbsent(ExtraBaggageFields parent) {\n+    Map<BaggageField, String> parentState = ((DynamicBaggageState) parent.internal).state;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc4MTI5Mg==", "bodyText": "you found a bug thanks!", "url": "https://github.com/openzipkin/brave/pull/1182#discussion_r417781292", "createdAt": "2020-04-30T06:25:14Z", "author": {"login": "codefromthecrypt"}, "path": "brave/src/main/java/brave/internal/baggage/DynamicBaggageState.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2013-2020 The OpenZipkin Authors\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except\n+ * in compliance with the License. You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software distributed under the License\n+ * is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express\n+ * or implied. See the License for the specific language governing permissions and limitations under\n+ * the License.\n+ */\n+package brave.internal.baggage;\n+\n+import brave.baggage.BaggageField;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static brave.internal.baggage.ExtraBaggageFields.equal;\n+\n+/** Handles {@link BaggageField} value storage with a map. */\n+final class DynamicBaggageState extends ExtraBaggageFields.State<Map<BaggageField, String>> {\n+  DynamicBaggageState(DynamicBaggageFieldsFactory factory, Map<BaggageField, String> parentState) {\n+    super(factory, parentState);\n+  }\n+\n+  @Override public boolean isDynamic() {\n+    return true;\n+  }\n+\n+  /** The list of fields present, regardless of value. */\n+  @Override public List<BaggageField> getAllFields() {\n+    return Collections.unmodifiableList(new ArrayList<>(state.keySet()));\n+  }\n+\n+  @Override public String getValue(BaggageField field) {\n+    return state.get(field);\n+  }\n+\n+  @Override public boolean updateValue(BaggageField field, String value) {\n+    synchronized (this) {\n+      Map<BaggageField, String> state = this.state;\n+      if (equal(value, state.get(field))) return false;\n+\n+      // We replace an existing value with null instead of deleting it. This way we know there was\n+      // a field value at some point (ex for reverting state).\n+      LinkedHashMap<BaggageField, String> mergedState = new LinkedHashMap<>(state);\n+      mergedState.put(field, value);\n+      this.state = mergedState;\n+    }\n+    return true;\n+  }\n+\n+  @Override void putAllIfAbsent(ExtraBaggageFields parent) {\n+    Map<BaggageField, String> parentState = ((DynamicBaggageState) parent.internal).state;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzc1MjU5Mg=="}, "originalCommit": {"oid": "870f1c84f6b9632d23905e4b02a3d901489a8248"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1396, "cost": 1, "resetAt": "2021-11-13T12:10:21Z"}}}