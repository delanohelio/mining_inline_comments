{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDEyODcyODUy", "number": 1470, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNjo0Mzo1OFrOD5Rd3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNjo0Mzo1OFrOD5Rd3g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYxMzgxNTk4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "isResolved": false, "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQwNjo0Mzo1OFrOGQcWyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wNVQxNDo0MToyMFrOGQstxA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw==", "bodyText": "Given that ConcurrentHashMap does not allow null-keys or null-values, it may also be ok to use Collections.synchronizedMap here, since I don't expect a lot of pressure on the lookup of an ExecutorService.\nget(String key) should be rewritten to use computeIfAbsent(..).", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r419894987", "createdAt": "2020-05-05T06:43:58Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "diffHunk": "@@ -24,17 +24,18 @@\n  * Provider for executor services. By calling {@link #dispose()} all created executor services are shut down.\n  * <p>\n  * In some situations it is necessary to use multiple instances of executor services in order to avoid deadlocks. That\n- * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key.\n+ * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key. </p>\n  */\n @Singleton\n public class ExecutorServiceProvider implements Provider<ExecutorService>, IDisposable {\n+\t\n+\tprivate final Map<String, ExecutorService> instanceCache = new ConcurrentHashMap<>(3);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76f94d1e01fdcc4196fb0390863da46253502a36"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NTI2OA==", "bodyText": "dispose must sync on the map, too.", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r419895268", "createdAt": "2020-05-05T06:44:43Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "diffHunk": "@@ -24,17 +24,18 @@\n  * Provider for executor services. By calling {@link #dispose()} all created executor services are shut down.\n  * <p>\n  * In some situations it is necessary to use multiple instances of executor services in order to avoid deadlocks. That\n- * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key.\n+ * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key. </p>\n  */\n @Singleton\n public class ExecutorServiceProvider implements Provider<ExecutorService>, IDisposable {\n+\t\n+\tprivate final Map<String, ExecutorService> instanceCache = new ConcurrentHashMap<>(3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, "originalCommit": {"oid": "76f94d1e01fdcc4196fb0390863da46253502a36"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2MDQ2NQ==", "bodyText": "get(String key) should be rewritten to use computeIfAbsent(..).\n\nI can think of two ways; however, I am not convinced by either. In the first one, calling  computeIfAbsent(...) inside the if (result == null) doesn't make much sense. We already know that the value is null before calling computeIfAbsent(...). The second one would block threads even if the map has a non-null value for the key requested by the second thread.\n@szarnekow Please suggest if there is any other way to rewrite this method.\nExecutorService result = instanceCache.get(key);                            \nif (result == null) {                                                       \n\tsynchronized (instanceCache) {                                          \n\t\tresult = instanceCache.computeIfAbsent(key, k -> createInstance(k));\n\t}                                                                       \n}                                                                           \nreturn result; \n\nsynchronized (instanceCache) {                                         \n\treturn instanceCache.computeIfAbsent(key, k -> createInstance(k)); \n}", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420060465", "createdAt": "2020-05-05T12:11:14Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "diffHunk": "@@ -24,17 +24,18 @@\n  * Provider for executor services. By calling {@link #dispose()} all created executor services are shut down.\n  * <p>\n  * In some situations it is necessary to use multiple instances of executor services in order to avoid deadlocks. That\n- * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key.\n+ * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key. </p>\n  */\n @Singleton\n public class ExecutorServiceProvider implements Provider<ExecutorService>, IDisposable {\n+\t\n+\tprivate final Map<String, ExecutorService> instanceCache = new ConcurrentHashMap<>(3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, "originalCommit": {"oid": "76f94d1e01fdcc4196fb0390863da46253502a36"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDA2NTczMQ==", "bodyText": "Steps:\n\nUse a Collections.synchronizedMap(new HashMap<>()) for the field initializer\nRewrite and simplify get(String) towards public ExecutorService get(String key) { return instanceCache.computeIfAbsent(key, this::createInstance)); }\nfix dispose to sync on the instanceCache, too: public void dipose() { synchronized(instanceCache) { .. } }", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420065731", "createdAt": "2020-05-05T12:20:57Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "diffHunk": "@@ -24,17 +24,18 @@\n  * Provider for executor services. By calling {@link #dispose()} all created executor services are shut down.\n  * <p>\n  * In some situations it is necessary to use multiple instances of executor services in order to avoid deadlocks. That\n- * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key.\n+ * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key. </p>\n  */\n @Singleton\n public class ExecutorServiceProvider implements Provider<ExecutorService>, IDisposable {\n+\t\n+\tprivate final Map<String, ExecutorService> instanceCache = new ConcurrentHashMap<>(3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, "originalCommit": {"oid": "76f94d1e01fdcc4196fb0390863da46253502a36"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE0NTgyMw==", "bodyText": "@szarnekow computeIfAbsent(...) is not atomic. Don't we have to sync on the map?", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420145823", "createdAt": "2020-05-05T14:18:49Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "diffHunk": "@@ -24,17 +24,18 @@\n  * Provider for executor services. By calling {@link #dispose()} all created executor services are shut down.\n  * <p>\n  * In some situations it is necessary to use multiple instances of executor services in order to avoid deadlocks. That\n- * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key.\n+ * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key. </p>\n  */\n @Singleton\n public class ExecutorServiceProvider implements Provider<ExecutorService>, IDisposable {\n+\t\n+\tprivate final Map<String, ExecutorService> instanceCache = new ConcurrentHashMap<>(3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, "originalCommit": {"oid": "76f94d1e01fdcc4196fb0390863da46253502a36"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE1NDU3OA==", "bodyText": "SynchronizedMap.computeIfAbsent(K, Function<? super K, ? extends V>) is safe.", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420154578", "createdAt": "2020-05-05T14:30:03Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "diffHunk": "@@ -24,17 +24,18 @@\n  * Provider for executor services. By calling {@link #dispose()} all created executor services are shut down.\n  * <p>\n  * In some situations it is necessary to use multiple instances of executor services in order to avoid deadlocks. That\n- * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key.\n+ * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key. </p>\n  */\n @Singleton\n public class ExecutorServiceProvider implements Provider<ExecutorService>, IDisposable {\n+\t\n+\tprivate final Map<String, ExecutorService> instanceCache = new ConcurrentHashMap<>(3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, "originalCommit": {"oid": "76f94d1e01fdcc4196fb0390863da46253502a36"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDE2MzAxMg==", "bodyText": "ok, tx for clarification.", "url": "https://github.com/eclipse/xtext-core/pull/1470#discussion_r420163012", "createdAt": "2020-05-05T14:41:20Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/ExecutorServiceProvider.java", "diffHunk": "@@ -24,17 +24,18 @@\n  * Provider for executor services. By calling {@link #dispose()} all created executor services are shut down.\n  * <p>\n  * In some situations it is necessary to use multiple instances of executor services in order to avoid deadlocks. That\n- * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key.\n+ * can be achieved with the {@link #get(String)}\ufffdmethod, which will return a different instance for each key. </p>\n  */\n @Singleton\n public class ExecutorServiceProvider implements Provider<ExecutorService>, IDisposable {\n+\t\n+\tprivate final Map<String, ExecutorService> instanceCache = new ConcurrentHashMap<>(3);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxOTg5NDk4Nw=="}, "originalCommit": {"oid": "76f94d1e01fdcc4196fb0390863da46253502a36"}, "originalPosition": 25}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1110, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}