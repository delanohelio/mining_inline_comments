{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzg0NjcxMTM1", "number": 1417, "title": "Refactor more xtend to java", "bodyText": "", "createdAt": "2020-03-06T07:19:56Z", "url": "https://github.com/eclipse/xtext-core/pull/1417", "merged": true, "mergeCommit": {"oid": "e94ed3bba662d297b5f0ddc8ee9d6e33ebb668c3"}, "closed": true, "closedAt": "2020-03-13T08:18:24Z", "author": {"login": "ArneDeutsch"}, "timelineItems": {"totalCount": 17, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcK7MQvgFqTM3MDEzMTAxMQ==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcNLb83gBqjMxMjU3MTE3OTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTMxMDEx", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-370131011", "createdAt": "2020-03-06T07:43:07Z", "commit": {"oid": "160bdb1022650cb315717906b182eb5812c4cd12"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0MzowN1rOFyvmPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwNzo0MzowN1rOFyvmPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODc1Mjk1OQ==", "bodyText": "you should remove final from all parameters", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388752959", "createdAt": "2020-03-06T07:43:07Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(final IResourceServiceProvider.Registry resourceServiceProviderRegistry,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "160bdb1022650cb315717906b182eb5812c4cd12"}, "originalPosition": 40}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "160bdb1022650cb315717906b182eb5812c4cd12", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/160bdb1022650cb315717906b182eb5812c4cd12", "committedDate": "2020-03-03T10:47:26Z", "message": "[eclipse/xtext#1679] Refactor AbstractTraceRegionToString from Xtend to\njava.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}, "afterCommit": {"oid": "67ab803d8b2e316e47273e4b16ff6caa5c471045", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/67ab803d8b2e316e47273e4b16ff6caa5c471045", "committedDate": "2020-03-06T09:29:21Z", "message": "[eclipse/xtext#1679] Refactor ReferenceAcceptor from Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "67ab803d8b2e316e47273e4b16ff6caa5c471045", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/67ab803d8b2e316e47273e4b16ff6caa5c471045", "committedDate": "2020-03-06T09:29:21Z", "message": "[eclipse/xtext#1679] Refactor ReferenceAcceptor from Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}, "afterCommit": {"oid": "716c6eb69f58840bc816e2731e3690b7de20f841", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/716c6eb69f58840bc816e2731e3690b7de20f841", "committedDate": "2020-03-06T09:36:02Z", "message": "[eclipse/xtext#1679] Refactor ReferenceAcceptor from Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "716c6eb69f58840bc816e2731e3690b7de20f841", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/716c6eb69f58840bc816e2731e3690b7de20f841", "committedDate": "2020-03-06T09:36:02Z", "message": "[eclipse/xtext#1679] Refactor ReferenceAcceptor from Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}, "afterCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "committedDate": "2020-03-06T09:44:08Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMTk4OTg4", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-370198988", "createdAt": "2020-03-06T09:50:14Z", "commit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 68, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQwOTo1MDoxNFrOFyy4_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMDoxNjowM1rOFyztKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwNjkwOA==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388806908", "createdAt": "2020-03-06T09:50:14Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwNzM3Nw==", "bodyText": "I don't really like this new HashMap<>() works as well", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388807377", "createdAt": "2020-03-06T09:51:03Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODMzOA==", "bodyText": "Collections.emptyMap()", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808338", "createdAt": "2020-03-06T09:52:50Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODU4OQ==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808589", "createdAt": "2020-03-06T09:53:21Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();\n+\t\t}\n+\t}\n+\n+\tprotected URI findExportedContainer(EObject obj) {\n+\t\tif (exportedContainersInCurrentResource.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEObject source = obj;\n+\t\tURI result = exportedContainersInCurrentResource.get(source);\n+\t\twhile ((result == null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwODY3OA==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388808678", "createdAt": "2020-03-06T09:53:29Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index,\n+\t\t\tEObject targetOrProxy, URI targetURI) {\n+\t\tif ((currentResource == null) || (source.eResource() != currentResource)) {\n+\t\t\tcomputeExportedObjectsMap(source);\n+\t\t\tcurrentResource = source.eResource();\n+\t\t}\n+\t\taccept(createReferenceDescription(EcoreUtil2.getFragmentPathURI(source), targetURI, eReference, index,\n+\t\t\t\tfindExportedContainer(source)));\n+\t}\n+\n+\t@Override\n+\tpublic void accept(IReferenceDescription description) {\n+\t\tdelegate.accept(description);\n+\t}\n+\n+\tprotected void computeExportedObjectsMap(EObject source) {\n+\t\tResource resource = source.eResource();\n+\t\tIResourceServiceProvider resourceServiceProvider = resourceServiceProviderRegistry\n+\t\t\t\t.getResourceServiceProvider(resource.getURI());\n+\t\tif (resourceServiceProvider != null) {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>newHashMap();\n+\t\t\tIterable<IEObjectDescription> exportedObjects = resourceServiceProvider.getResourceDescriptionManager()\n+\t\t\t\t\t.getResourceDescription(resource).getExportedObjects();\n+\t\t\tfor (IEObjectDescription description : exportedObjects) {\n+\t\t\t\tEObject instance = description.getEObjectOrProxy();\n+\t\t\t\tif (instance.eIsProxy()) {\n+\t\t\t\t\tinstance = resource.getEObject(description.getEObjectURI().fragment());\n+\t\t\t\t}\n+\t\t\t\texportedContainersInCurrentResource.put(instance, description.getEObjectURI());\n+\t\t\t}\n+\t\t} else {\n+\t\t\texportedContainersInCurrentResource = CollectionLiterals.<EObject, URI>emptyMap();\n+\t\t}\n+\t}\n+\n+\tprotected URI findExportedContainer(EObject obj) {\n+\t\tif (exportedContainersInCurrentResource.isEmpty()) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tEObject source = obj;\n+\t\tURI result = exportedContainersInCurrentResource.get(source);\n+\t\twhile ((result == null)) {\n+\t\t\tif (exportedContainersInCurrentResource.containsKey(source)) {\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t\tsource = source.eContainer();\n+\t\t\tif ((source == null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTIwMw==", "bodyText": "@szarnekow We prefer not to have there in the java code right?", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809203", "createdAt": "2020-03-06T09:54:29Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof InterruptedException) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTM1Ng==", "bodyText": "@cdietrich We're 2.21 one now, is this still beta?", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809356", "createdAt": "2020-03-06T09:54:49Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof InterruptedException) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @since 2.14\n+\t */\n+\t@Beta", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTU2Mw==", "bodyText": "We really don't want these ;)", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809563", "createdAt": "2020-03-06T09:55:14Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+@SuppressWarnings(\"all\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTY3Mw==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809673", "createdAt": "2020-03-06T09:55:26Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+@SuppressWarnings(\"all\")\n+public class FileSystemAccessRequest implements Runnable {\n+\tprivate final URI uri;\n+\n+\tprivate final Runnable runMe;\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic FileSystemAccessRequest(final URI uri, final Runnable runMe) {\n+\t\tthis.uri = uri;\n+\t\tthis.runMe = runMe;\n+\t}\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 35}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTc4OQ==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388809789", "createdAt": "2020-03-06T09:55:39Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/GeneratorContext.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @since 2.9\n+ */\n+public class GeneratorContext implements IGeneratorContext {\n+\tprivate CancelIndicator cancelIndicator;\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDAwNw==", "bodyText": "@cdietrich Is this still beta? It's been so long", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388810007", "createdAt": "2020-03-06T09:55:56Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 33}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMDI2OA==", "bodyText": "s/whether/Whether/", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388810268", "createdAt": "2020-03-06T09:56:28Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+@ImplementedBy(IShouldGenerate.OnlyWithoutErrors.class)\n+public interface IShouldGenerate {\n+\t@Beta\n+\t@Singleton\n+\tclass OnlyWithoutErrors implements IShouldGenerate {\n+\t\t@Inject\n+\t\tprivate IResourceValidator resourceValidator;\n+\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tif (!resource.getErrors().isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<Issue> issues = resourceValidator.validate(resource, CheckMode.NORMAL_AND_FAST, cancelIndicator);\n+\t\t\treturn !exists(issues, (Issue issue) -> Objects.equal(issue.getSeverity(), Severity.ERROR));\n+\t\t}\n+\t}\n+\n+\t@Beta\n+\t@Singleton\n+\tclass Always implements IShouldGenerate {\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\treturn true;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * whether code should be generated for this resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 62}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjI4OQ==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812289", "createdAt": "2020-03-06T10:00:25Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjM4OQ==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812389", "createdAt": "2020-03-06T10:00:34Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjQ0NA==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812444", "createdAt": "2020-03-06T10:00:39Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic String toString() {\n+\t\treturn new ToStringBuilder(this).addAllFields().toString();\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMjQ3Mg==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388812472", "createdAt": "2020-03-06T10:00:42Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,69 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\t@Pure\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzQ5Mg==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813492", "createdAt": "2020-03-06T10:02:50Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzY5Mg==", "bodyText": "API typos make me sad :(", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813692", "createdAt": "2020-03-06T10:03:11Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzkyNg==", "bodyText": "Sneaky throw", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813926", "createdAt": "2020-03-06T10:03:36Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 115}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzk5Ng==", "bodyText": "Sneaky throw", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388813996", "createdAt": "2020-03-06T10:03:44Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 120}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDExMg==", "bodyText": "Sneaky", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814112", "createdAt": "2020-03-06T10:03:56Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 132}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDE4NQ==", "bodyText": "sneaky", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814185", "createdAt": "2020-03-06T10:04:04Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDI2NA==", "bodyText": "Sneaky", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814264", "createdAt": "2020-03-06T10:04:12Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 146}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDMwOQ==", "bodyText": "Double try?", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814309", "createdAt": "2020-03-06T10:04:18Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 138}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDM4Mg==", "bodyText": "Sneaky", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814382", "createdAt": "2020-03-06T10:04:26Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDQ0Mw==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814443", "createdAt": "2020-03-06T10:04:35Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 164}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDQ4NA==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814484", "createdAt": "2020-03-06T10:04:40Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 173}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDUxMA==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814510", "createdAt": "2020-03-06T10:04:45Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDU0NA==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814544", "createdAt": "2020-03-06T10:04:50Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 191}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDU5Mg==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814592", "createdAt": "2020-03-06T10:04:55Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 200}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDY0MQ==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814641", "createdAt": "2020-03-06T10:05:01Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeDelete getBeforeDelete() {\n+\t\treturn beforeDelete;\n+\t}\n+\n+\tpublic void setBeforeDelete(URIBasedFileSystemAccess.BeforeDelete beforeDelete) {\n+\t\tthis.beforeDelete = beforeDelete;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeWrite getBeforeWrite() {\n+\t\treturn beforeWrite;\n+\t}\n+\n+\tpublic void setBeforeWrite(URIBasedFileSystemAccess.BeforeWrite beforeWrite) {\n+\t\tthis.beforeWrite = beforeWrite;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 236}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDY3OQ==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814679", "createdAt": "2020-03-06T10:05:05Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic URIBasedFileSystemAccess.BeforeDelete getBeforeDelete() {\n+\t\treturn beforeDelete;\n+\t}\n+\n+\tpublic void setBeforeDelete(URIBasedFileSystemAccess.BeforeDelete beforeDelete) {\n+\t\tthis.beforeDelete = beforeDelete;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDcxOA==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814718", "createdAt": "2020-03-06T10:05:10Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceFileNameProvider getTraceFileNameProvider() {\n+\t\treturn traceFileNameProvider;\n+\t}\n+\n+\tpublic void setTraceFileNameProvider(TraceFileNameProvider traceFileNameProvider) {\n+\t\tthis.traceFileNameProvider = traceFileNameProvider;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNDc1OA==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388814758", "createdAt": "2020-03-06T10:05:14Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {\n+\t\t\t\tByteStreams.copy(beforeWrite.beforeWrite(uri, outputCfgName, content), out);\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic InputStream readBinaryFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\ttry {\n+\t\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\t\treturn beforeRead.beforeRead(uri, converter.createInputStream(uri));\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\tif (t instanceof FileNotFoundException) {\n+\t\t\t\t\tthrow new RuntimeIOException(t);\n+\t\t\t\t} else {\n+\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic CharSequence readTextFile(String fileName, String outputCfgName) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\treturn CharStreams.toString(new InputStreamReader(readBinaryFile(fileName, outputCfgName),\n+\t\t\t\t\tgetEncoding(getURI(fileName, outputCfgName))));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Pure\n+\tpublic URIConverter getConverter() {\n+\t\treturn converter;\n+\t}\n+\n+\tpublic void setConverter(URIConverter converter) {\n+\t\tthis.converter = converter;\n+\t}\n+\n+\t@Pure\n+\tpublic URI getBaseDir() {\n+\t\treturn baseDir;\n+\t}\n+\n+\tpublic void setBaseDir(URI baseDir) {\n+\t\tthis.baseDir = baseDir;\n+\t}\n+\n+\t@Pure\n+\tpublic boolean isGenerateTraces() {\n+\t\treturn generateTraces;\n+\t}\n+\n+\tpublic void setGenerateTraces(boolean generateTraces) {\n+\t\tthis.generateTraces = generateTraces;\n+\t}\n+\n+\t@Pure\n+\tpublic IEncodingProvider getEncodingProvider() {\n+\t\treturn encodingProvider;\n+\t}\n+\n+\tpublic void setEncodingProvider(IEncodingProvider encodingProvider) {\n+\t\tthis.encodingProvider = encodingProvider;\n+\t}\n+\n+\t@Pure\n+\tpublic TraceRegionSerializer getTraceRegionSerializer() {\n+\t\treturn traceRegionSerializer;\n+\t}\n+\n+\tpublic void setTraceRegionSerializer(TraceRegionSerializer traceRegionSerializer) {\n+\t\tthis.traceRegionSerializer = traceRegionSerializer;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 209}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTEwMA==", "bodyText": "absoluteURI.toUri()", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815100", "createdAt": "2020-03-06T10:05:52Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTI0Mw==", "bodyText": "Sneaky", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815243", "createdAt": "2020-03-06T10:06:05Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof IllegalArgumentException) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Base URI was \" + getURI(), t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTYyMQ==", "bodyText": "obj.toString()", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815621", "createdAt": "2020-03-06T10:06:54Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(absoluteURI));\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof IllegalArgumentException) {\n+\t\t\t\tthrow new IllegalArgumentException(\"Base URI was \" + getURI(), t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(ISourceFolder sourceFolder) {\n+\t\treturn deresolve(sourceFolder.getPath());\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(IProjectConfig projectConfig) {\n+\t\tISourceFolder sourceFolder = projectConfig.findSourceFolderContaining(getURI());\n+\t\treturn sourceFolder != null ? deresolve(sourceFolder) : null;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj != null && !Objects.equal(obj.getClass(), AbsoluteURI.class)) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(obj) + \" instanceof \" + obj.getClass().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 59}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTg1NA==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815854", "createdAt": "2020-03-06T10:07:21Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 71}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTg4Nw==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815887", "createdAt": "2020-03-06T10:07:25Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTkxNQ==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815915", "createdAt": "2020-03-06T10:07:28Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNTk3Ng==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388815976", "createdAt": "2020-03-06T10:07:36Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjA0Nw==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816047", "createdAt": "2020-03-06T10:07:45Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 98}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjA4MQ==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816081", "createdAt": "2020-03-06T10:07:48Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 93}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjEyNw==", "bodyText": "Not needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816127", "createdAt": "2020-03-06T10:07:55Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjI0Ng==", "bodyText": "new ArrayList<>();", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816246", "createdAt": "2020-03-06T10:08:07Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 80}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjM3NQ==", "bodyText": "new ArrayList<>()", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816375", "createdAt": "2020-03-06T10:08:20Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjQ5MQ==", "bodyText": "new ArrayList<>();", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816491", "createdAt": "2020-03-06T10:08:36Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjU1NQ==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816555", "createdAt": "2020-03-06T10:08:43Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 111}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNjgyMA==", "bodyText": "Just remove every @Pure in this file", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388816820", "createdAt": "2020-03-06T10:09:14Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 118}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzYyMw==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817623", "createdAt": "2020-03-06T10:10:55Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzg1Nw==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817857", "createdAt": "2020-03-06T10:11:24Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzkxNA==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388817914", "createdAt": "2020-03-06T10:11:32Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODEzNg==", "bodyText": "sneaky", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818136", "createdAt": "2020-03-06T10:11:57Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 287}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM1Nw==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818357", "createdAt": "2020-03-06T10:12:22Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM4OQ==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818389", "createdAt": "2020-03-06T10:12:26Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODQ3Nw==", "bodyText": "CollectionLiterals", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818477", "createdAt": "2020-03-06T10:12:36Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 299}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODcwNQ==", "bodyText": "Unneeded parentheses", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818705", "createdAt": "2020-03-06T10:13:01Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 333}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODc5NQ==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818795", "createdAt": "2020-03-06T10:13:12Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 337}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODg1NA==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818854", "createdAt": "2020-03-06T10:13:19Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 335}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODk2Mg==", "bodyText": "CollectionLiterals", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388818962", "createdAt": "2020-03-06T10:13:31Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 343}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTEzMA==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819130", "createdAt": "2020-03-06T10:13:43Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 344}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTM3Nw==", "bodyText": "Is the Integer.valueOf really needed?", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819377", "createdAt": "2020-03-06T10:14:15Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTUwMQ==", "bodyText": "same, also it_1 is a pretty bad name", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819501", "createdAt": "2020-03-06T10:14:33Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTc5OA==", "bodyText": "Conversions.unwrapArray this really isnt needed", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819798", "createdAt": "2020-03-06T10:15:10Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 367}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTk2Mw==", "bodyText": "Bad naming", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388819963", "createdAt": "2020-03-06T10:15:30Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 395}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDAzNw==", "bodyText": "More sneaky", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820037", "createdAt": "2020-03-06T10:15:39Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;\n+\t\ttry {\n+\t\t\treturn render();\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof Exception) {\n+\t\t\t\t_xtrycatchfinallyexpression = Throwables.getStackTraceAsString(t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 402}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDEyNQ==", "bodyText": "more pure", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820125", "createdAt": "2020-03-06T10:15:47Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = CollectionLiterals.newArrayList();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; ((i < ((Object[]) Conversions.unwrapArray(left, Object.class)).length)\n+\t\t\t\t|| (i < ((Object[]) Conversions.unwrapArray(right, Object.class)).length)); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tString _xtrycatchfinallyexpression = null;\n+\t\ttry {\n+\t\t\treturn render();\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof Exception) {\n+\t\t\t\t_xtrycatchfinallyexpression = Throwables.getStackTraceAsString(t);\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t\treturn _xtrycatchfinallyexpression;\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 408}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgyMDI2Ng==", "bodyText": "More pure", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388820266", "createdAt": "2020-03-06T10:16:03Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractURIWrapper.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+/**\n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public abstract class AbstractURIWrapper {\n+\tprivate final URI uri;\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn uri.toString();\n+\t}\n+\n+\tpublic AbstractURIWrapper(URI uri) {\n+\t\tthis.uri = uri;\n+\t}\n+\n+\t@Override\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 30}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjE3Mjcw", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-370217270", "createdAt": "2020-03-06T10:19:25Z", "commit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjQ3Njky", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-370247692", "createdAt": "2020-03-06T11:11:29Z", "commit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxMTozMFrOFy1Ppw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxMTozMFrOFy1Ppw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NTQ3OQ==", "bodyText": "sneaky", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388845479", "createdAt": "2020-03-06T11:11:30Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 99}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjQ3OTM5", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-370247939", "createdAt": "2020-03-06T11:11:56Z", "commit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxMTo1NlrOFy1QeQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxMTo1NlrOFy1QeQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NTY4OQ==", "bodyText": "Not sure if out should better be buffered if it isn't already.", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388845689", "createdAt": "2020-03-06T11:11:56Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t(\"A slot with name \\'\" + outputConfiguration) + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tString encoding = getEncoding(uri);\n+\t\t\tCharSequence postProcessed = postProcess(fileName, outputCfgName, contents, encoding);\n+\t\t\tgenerateTrace(fileName, outputCfgName, postProcessed);\n+\t\t\tgenerateFile(fileName, outputCfgName,\n+\t\t\t\t\tnew ByteArrayInputStream(postProcessed.toString().getBytes(encoding)));\n+\t\t} catch (Throwable e) {\n+\t\t\tthrow Exceptions.sneakyThrow(e);\n+\t\t}\n+\t}\n+\n+\tprotected void generateTrace(String generatedFile, String outputConfigName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tif (isGenerateTraces() && contents instanceof ITraceRegionProvider) {\n+\t\t\t\ttry {\n+\t\t\t\t\tByteArrayOutputStream out = new ByteArrayOutputStream();\n+\t\t\t\t\ttraceRegionSerializer.writeTraceRegionTo(((ITraceRegionProvider) contents).getTraceRegion(), out);\n+\t\t\t\t\tgenerateFile(traceFileNameProvider.getTraceFromJava(generatedFile), outputConfigName,\n+\t\t\t\t\t\t\tnew ByteArrayInputStream(out.toByteArray()));\n+\t\t\t\t} catch (Throwable t) {\n+\t\t\t\t\tif (t instanceof TraceNotFoundException) {\n+\t\t\t\t\t\t// do not re-throw\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, InputStream content) throws RuntimeIOException {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\ttry (OutputStream out = converter.createOutputStream(uri)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMjQ4OTM0", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-370248934", "createdAt": "2020-03-06T11:13:51Z", "commit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxMzo1MVrOFy1Thg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxMToxMzo1MVrOFy1Thg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODg0NjQ3MA==", "bodyText": "obj.toString", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388846470", "createdAt": "2020-03-06T11:13:51Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/SourceRelativeURI.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * A source relative URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class SourceRelativeURI extends AbstractURIWrapper {\n+\tpublic static SourceRelativeURI fromAbsolute(URI uri) {\n+\t\tif (uri.isRelative()) {\n+\t\t\tthrow new IllegalArgumentException(uri.toString());\n+\t\t}\n+\t\treturn new SourceRelativeURI(uri.path().substring(1));\n+\t}\n+\n+\tpublic SourceRelativeURI(URI sourceRelativeURI) {\n+\t\tsuper(sourceRelativeURI);\n+\t\tif (!sourceRelativeURI.isRelative() || sourceRelativeURI.path().startsWith(\"/\")) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(sourceRelativeURI));\n+\t\t}\n+\t}\n+\n+\tpublic SourceRelativeURI(String relativeURI) {\n+\t\tthis(URI.createURI(relativeURI));\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (obj != null && !Objects.equal(obj.getClass(), SourceRelativeURI.class)) {\n+\t\t\tthrow new IllegalArgumentException(String.valueOf(obj) + \" instanceof \" + obj.getClass().getName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 42}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/c6b3b012ed9f78d817c7ace144e8e0a39537e2c5", "committedDate": "2020-03-06T09:44:08Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}, "afterCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/1822521ec3c6e302f6b864c091a9449b16ead439", "committedDate": "2020-03-06T13:57:44Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzUwMTUw", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-370350150", "createdAt": "2020-03-06T14:14:20Z", "commit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNDoxNDoyMFrOFy6FFA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNDozMDo1M1rOFy6qZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY5Mg==", "bodyText": "Sure this should be an identity check?", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388924692", "createdAt": "2020-03-06T14:14:20Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index, EObject targetOrProxy,\n+\t\t\tURI targetURI) {\n+\t\tif (currentResource == null || source.eResource() != currentResource) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNTQwNg==", "bodyText": "Collections.emptyMap", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388925406", "createdAt": "2020-03-06T14:15:24Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);\n+\t\tif (outlet == null) {\n+\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\"A slot with name \\'\" + outputConfiguration + \"\\' has not been configured.\");\n+\t\t}\n+\t\tURI uri = URI.createFileURI(outlet + File.separator + path);\n+\t\treturn baseDir != null ? uri.resolve(baseDir) : uri;\n+\t}\n+\n+\tpublic String getEncoding(URI uri) {\n+\t\treturn encodingProvider.getEncoding(uri);\n+\t}\n+\n+\t@Override\n+\tpublic void generateFile(String fileName, String outputCfgName, CharSequence contents) {\n+\t\ttry {\n+\t\t\tURI uri = getURI(fileName, outputCfgName);\n+\t\t\tif (!getOutputConfig(outputCfgName).isOverrideExistingResources()\n+\t\t\t\t\t&& converter.exists(uri, CollectionLiterals.emptyMap())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 89}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjIxNA==", "bodyText": "I'd move this three lines lower", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926214", "createdAt": "2020-03-06T14:16:39Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjUxNg==", "bodyText": "This used to be an InterruptedException", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926516", "createdAt": "2020-03-06T14:17:17Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNjc2Ng==", "bodyText": "Redundant finals", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388926766", "createdAt": "2020-03-06T14:17:43Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessRequest implements Runnable {\n+\tprivate final URI uri;\n+\n+\tprivate final Runnable runMe;\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic FileSystemAccessRequest(final URI uri, final Runnable runMe) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNzU5Ng==", "bodyText": "Nope, sadly you can't do anything about this", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388927596", "createdAt": "2020-03-06T14:19:10Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,244 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);\n+\t}\n+\n+\tpublic interface BeforeRead {\n+\t\tInputStream beforeRead(URI changed, InputStream in);\n+\t}\n+\n+\tprivate URIConverter converter;\n+\tprivate URI baseDir;\n+\tprivate boolean generateTraces = false;\n+\tprivate IEncodingProvider encodingProvider = new IEncodingProvider.Runtime();\n+\tprivate TraceRegionSerializer traceRegionSerializer;\n+\tprivate TraceFileNameProvider traceFileNameProvider;\n+\tprivate URIBasedFileSystemAccess.BeforeDelete beforeDelete = (uri) -> true;\n+\tprivate URIBasedFileSystemAccess.BeforeWrite beforeWrite = (uri, string, stream) -> stream;\n+\tprivate URIBasedFileSystemAccess.BeforeRead beforeRead = (uri, stream) -> stream;\n+\n+\t@Override\n+\tpublic void setPostProcessor(IFilePostProcessor filePostProcessor) {\n+\t\tsuper.setPostProcessor(filePostProcessor);\n+\t}\n+\n+\t@Override\n+\tpublic URI getURI(String path, String outputConfiguration) {\n+\t\tString outlet = getPathes().get(outputConfiguration);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxMzY5Mg=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 72}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDM3OA==", "bodyText": "@ArneDeutsch Missed this one", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930378", "createdAt": "2020-03-06T14:24:09Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzYyMw=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 253}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDQzMg==", "bodyText": "@ArneDeutsch Missed this one", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930432", "createdAt": "2020-03-06T14:24:14Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzg1Nw=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 261}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDQ4Mw==", "bodyText": "@ArneDeutsch Missed this one", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930483", "createdAt": "2020-03-06T14:24:20Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxNzkxNA=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 262}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDUyNw==", "bodyText": "@ArneDeutsch Missed this one", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930527", "createdAt": "2020-03-06T14:24:26Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM4OQ=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 294}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDU0Mg==", "bodyText": "@ArneDeutsch Missed this one", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930542", "createdAt": "2020-03-06T14:24:29Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxODM1Nw=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 293}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDg5NQ==", "bodyText": "@ArneDeutsch Missed this one", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930895", "createdAt": "2020-03-06T14:25:07Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTM3Nw=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 351}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMDkyOQ==", "bodyText": "@ArneDeutsch Missed this one", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388930929", "createdAt": "2020-03-06T14:25:11Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,434 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<String> lines = CollectionLiterals.newArrayList();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = CollectionLiterals.newArrayList();\n+\n+\t\tprivate final List<RegionHandle> children = CollectionLiterals.newArrayList();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\t@Pure\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (Throwable t) {\n+\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, CollectionLiterals.newLinkedHashSet());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = CollectionLiterals.newLinkedHashMap();\n+\t\tList<RegionHandle> roothandles = CollectionLiterals.newArrayList();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgxOTUwMQ=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 354}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTE1OQ==", "bodyText": "file_1?", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388931159", "createdAt": "2020-03-06T14:25:35Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 342}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMTUzMg==", "bodyText": "Another it_1", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388931532", "createdAt": "2020-03-06T14:26:10Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 363}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzMjMwMg==", "bodyText": "No need for Integer.valueOf", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388932302", "createdAt": "2020-03-06T14:27:28Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 365}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNDE1OQ==", "bodyText": "Static import this if there is no name collision", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388934159", "createdAt": "2020-03-06T14:30:46Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))\n+\t\t\t\t\t.length();\n+\t\t\tfor (RegionHandle handle : roothandles) {\n+\t\t\t\trender(handle, idwidth, offsetWidth, lengthWidth, 1, result);\n+\t\t\t}\n+\t\t}\n+\t\treturn join(result, org.eclipse.xtext.util.Strings.newLine());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 374}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNDI0NA==", "bodyText": "Same", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388934244", "createdAt": "2020-03-06T14:30:53Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbstractTraceRegionToString.java", "diffHunk": "@@ -0,0 +1,409 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import static com.google.common.collect.Iterables.*;\n+import static com.google.common.collect.Multimaps.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.filter;\n+\n+import java.io.IOException;\n+import java.io.StringReader;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.xtext.util.ITextRegion;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xbase.lib.Functions.Function1;\n+\n+import com.google.common.base.Strings;\n+import com.google.common.base.Throwables;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Moritz Eysholdt - Initial contribution and API\n+ */\n+public abstract class AbstractTraceRegionToString {\n+\tprotected static class Insert {\n+\t\tprivate final int offset;\n+\n+\t\tprivate final boolean open;\n+\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final LocationHandle location;\n+\n+\t\tpublic Insert(int offset, boolean open, RegionHandle region, LocationHandle location) {\n+\t\t\tthis.offset = offset;\n+\t\t\tthis.open = open;\n+\t\t\tthis.region = region;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic int getOffset() {\n+\t\t\treturn offset;\n+\t\t}\n+\n+\t\tpublic boolean isOpen() {\n+\t\t\treturn open;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic LocationHandle getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprotected static class File {\n+\t\tprivate final SourceRelativeURI uri;\n+\n+\t\tprivate final List<Insert> inserts = new ArrayList<>();\n+\n+\t\tprivate final List<String> lines = new ArrayList<>();\n+\n+\t\tpublic File(SourceRelativeURI uri) {\n+\t\t\tthis.uri = uri;\n+\t\t}\n+\n+\t\tpublic SourceRelativeURI getUri() {\n+\t\t\treturn uri;\n+\t\t}\n+\n+\t\tpublic List<Insert> getInserts() {\n+\t\t\treturn inserts;\n+\t\t}\n+\n+\t\tpublic List<String> getLines() {\n+\t\t\treturn lines;\n+\t\t}\n+\t}\n+\n+\tprotected static class RegionHandle {\n+\t\tprivate final int id;\n+\n+\t\tprivate final AbstractTraceRegion region;\n+\n+\t\tprivate final List<LocationHandle> locations = new ArrayList<>();\n+\n+\t\tprivate final List<RegionHandle> children = new ArrayList<>();\n+\n+\t\tpublic RegionHandle(int id, AbstractTraceRegion region) {\n+\t\t\tthis.id = id;\n+\t\t\tthis.region = region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic AbstractTraceRegion getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic List<LocationHandle> getLocations() {\n+\t\t\treturn locations;\n+\t\t}\n+\n+\t\tpublic List<RegionHandle> getChildren() {\n+\t\t\treturn children;\n+\t\t}\n+\t}\n+\n+\tprotected static class LocationHandle {\n+\t\tprivate final RegionHandle region;\n+\n+\t\tprivate final int id;\n+\n+\t\tprivate final ILocationData location;\n+\n+\t\tpublic LocationHandle(RegionHandle region, int id, ILocationData location) {\n+\t\t\tthis.region = region;\n+\t\t\tthis.id = id;\n+\t\t\tthis.location = location;\n+\t\t}\n+\n+\t\tpublic RegionHandle getRegion() {\n+\t\t\treturn region;\n+\t\t}\n+\n+\t\tpublic int getId() {\n+\t\t\treturn id;\n+\t\t}\n+\n+\t\tpublic ILocationData getLocation() {\n+\t\t\treturn location;\n+\t\t}\n+\t}\n+\n+\tprivate int radix = 10;\n+\tprivate boolean showTree = true;\n+\tprivate boolean showLegend = true;\n+\n+\tprotected abstract String getRemoteText(SourceRelativeURI uri);\n+\n+\tprotected abstract String getLocalText();\n+\n+\tprotected abstract AbstractTraceRegion getTrace();\n+\n+\tprotected ITextRegion getLocalFrame() {\n+\t\treturn null;\n+\t}\n+\n+\tprotected ITextRegion getRemoteFrame(SourceRelativeURI uri) {\n+\t\treturn null;\n+\t}\n+\n+\tprotected String getLocalTitle() {\n+\t\treturn \"generated.java\";\n+\t}\n+\n+\tprotected String getRemoteTitle(SourceRelativeURI uri) {\n+\t\treturn uri.getURI().toString();\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region) {\n+\t\tITextRegion frame = getLocalFrame();\n+\t\treturn frame == null ? true : frame.contains(region.getMyRegion());\n+\t}\n+\n+\tprotected boolean shouldInclude(AbstractTraceRegion region, ILocationData location) {\n+\t\tSourceRelativeURI srcRelativePath = location.getSrcRelativePath();\n+\t\tITextRegion frame = getRemoteFrame(\n+\t\t\t\tsrcRelativePath == null ? region.getAssociatedSrcRelativePath() : srcRelativePath);\n+\t\treturn frame == null ? true : frame.contains(location);\n+\t}\n+\n+\tprotected void add(Map<SourceRelativeURI, File> files, SourceRelativeURI uri, ITextRegion it, RegionHandle region,\n+\t\t\tLocationHandle location) {\n+\t\tFile file = files.get(uri);\n+\t\tif (file == null) {\n+\t\t\tfile = new File(uri);\n+\t\t\tfiles.put(uri, file);\n+\t\t}\n+\t\tadd(file, it, region, location);\n+\t}\n+\n+\tprotected void add(File file, ITextRegion it, RegionHandle region, LocationHandle location) {\n+\t\tfile.inserts.add(new Insert(it.getOffset(), true, region, location));\n+\t\tfile.inserts.add(new Insert(it.getOffset() + it.getLength(), false, region, location));\n+\t}\n+\n+\tprotected int collect(AbstractTraceRegion reg, int nextID, File lFile, Map<SourceRelativeURI, File> rFiles,\n+\t\t\tList<RegionHandle> result) {\n+\t\tint i = nextID;\n+\t\tList<RegionHandle> childResult = result;\n+\t\tif (shouldInclude(reg)) {\n+\t\t\tRegionHandle regHandle = new RegionHandle(i++, reg);\n+\t\t\tresult.add(regHandle);\n+\t\t\tchildResult = regHandle.children;\n+\t\t\tadd(lFile, reg.getMyRegion(), regHandle, null);\n+\t\t\tList<ILocationData> locs = toList(filter(reg.getAssociatedLocations(), loc -> shouldInclude(reg, loc)));\n+\t\t\tfor (int j = 0; j < locs.size(); j++) {\n+\t\t\t\tILocationData loc = locs.get(j);\n+\t\t\t\tLocationHandle locHandle = new LocationHandle(regHandle, locs.size() > 1 ? (j + 1) : -1, loc);\n+\t\t\t\tregHandle.locations.add(locHandle);\n+\t\t\t\tSourceRelativeURI srcRelativePath = loc.getSrcRelativePath();\n+\t\t\t\tSourceRelativeURI path = srcRelativePath == null ? reg.getAssociatedSrcRelativePath() : srcRelativePath;\n+\t\t\t\tadd(rFiles, path, loc, regHandle, locHandle);\n+\t\t\t}\n+\t\t}\n+\t\tfor (AbstractTraceRegion child : reg.getNestedRegions()) {\n+\t\t\ti = collect(child, i, lFile, rFiles, childResult);\n+\t\t}\n+\t\treturn i;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.Insert it, int width) {\n+\t\tString first = Strings.padStart(Integer.toString(it.region.id, this.radix), width, '0');\n+\t\treturn it.location != null && it.location.id >= 0 ? first + \"_\" + Integer.toString(it.location.id, this.radix)\n+\t\t\t\t: first;\n+\t}\n+\n+\tprotected int sortKey(AbstractTraceRegionToString.Insert it) {\n+\t\tint base = (it.region.id * Short.MAX_VALUE);\n+\t\treturn it.location != null && it.location.id >= 0 ? base + it.location.id : base;\n+\t}\n+\n+\tprotected String render(Collection<AbstractTraceRegionToString.Insert> inserts, int width) {\n+\t\tString opens = join(map(sortBy(filter(inserts, i -> i.open), i -> sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString closes = join(map(sortBy(filter(inserts, i -> !i.open), i -> -sortKey(i)), i -> render(i, width)), \",\");\n+\t\tString s1 = opens.isEmpty() ? \"\" : (\"[\" + opens + \"[\");\n+\t\tString s2 = closes.isEmpty() ? \"\" : ((\"]\" + closes) + \"]\");\n+\t\treturn (s2 + s1);\n+\t}\n+\n+\tprotected List<String> render(AbstractTraceRegionToString.File file, int width) {\n+\t\ttry {\n+\t\t\tString text = file.uri == null ? this.getLocalText() : this.getRemoteText(file.uri);\n+\t\t\tITextRegion localOrRemoteFrame = file.uri == null ? getLocalFrame() : getRemoteFrame(file.uri);\n+\t\t\tITextRegion frame = localOrRemoteFrame == null ? new TextRegion(0, text.length()) : localOrRemoteFrame;\n+\t\t\tint last = frame.getOffset();\n+\t\t\tStringBuilder result = new StringBuilder();\n+\t\t\tfor (Map.Entry<Integer, Collection<Insert>> e : sortBy(toList(index(\n+\t\t\t\t\tfilter(file.inserts,\n+\t\t\t\t\t\t\ti -> i.offset >= frame.getOffset() && i.offset <= (frame.getOffset() + frame.getLength())),\n+\t\t\t\t\ti -> i.offset).asMap().entrySet()), i -> i.getKey())) {\n+\t\t\t\tint offset = e.getKey().intValue();\n+\t\t\t\tresult.append(text.substring(last, offset));\n+\t\t\t\tresult.append(render(e.getValue(), width));\n+\t\t\t\tlast = offset;\n+\t\t\t}\n+\t\t\tint end = frame.getOffset() + frame.getLength();\n+\t\t\tif (last < end) {\n+\t\t\t\tresult.append(text.substring(last, end));\n+\t\t\t}\n+\t\t\treturn CharStreams.readLines(new StringReader(result.toString()));\n+\t\t} catch (IOException t) {\n+\t\t\tthrow new RuntimeIOException(t);\n+\t\t}\n+\t}\n+\n+\tprotected String title(SourceRelativeURI uri, int width) {\n+\t\tString s = \" \" + (uri == null ? getLocalTitle() : getRemoteTitle(uri)) + \" \";\n+\t\tString left = Strings.repeat(\"-\", (width - s.length()) / 2);\n+\t\tString right = Strings.repeat(\"-\", (width - (s.length() + left.length())));\n+\t\treturn left + s + right;\n+\t}\n+\n+\tprotected <T extends Object> Set<T> collect(T start, Function1<? super T, ? extends Iterable<T>> reachable) {\n+\t\treturn collect(start, reachable, new LinkedHashSet<>());\n+\t}\n+\n+\tprotected <R extends Collection<? super T>, T extends Object> R collect(T start,\n+\t\t\tFunction1<? super T, ? extends Iterable<T>> reachable, R collector) {\n+\t\tif (collector.add(start)) {\n+\t\t\tfor (T r : reachable.apply(start)) {\n+\t\t\t\tcollect(r, reachable, collector);\n+\t\t\t}\n+\t\t}\n+\t\treturn collector;\n+\t}\n+\n+\tprotected String render(AbstractTraceRegionToString.LocationHandle loc) {\n+\t\tString prefix = loc.id >= 0 ? Integer.toString(loc.id, this.radix) + \": \" : \"\";\n+\t\tString name = loc.location.getClass().getSimpleName();\n+\t\tString path = loc.location.getSrcRelativePath() == null ? \"\" : (\",\" + loc.location.getSrcRelativePath());\n+\t\treturn prefix + name + \"[\" + loc.location.getOffset() + \",\" + loc.location.getLength() + path + \"]\";\n+\t}\n+\n+\tprotected void render(AbstractTraceRegionToString.RegionHandle region, int idW, int offsetW, int lengthW,\n+\t\t\tint indent, List<String> result) {\n+\t\tString id = Strings.padStart(Integer.toString(region.id, this.radix), idW, '0');\n+\t\tString debug = region.region.isUseForDebugging() ? \"D\" : \" \";\n+\t\tString offset = Strings.padStart(Integer.toString(region.region.getMyOffset()), offsetW, '0');\n+\t\tString length = Strings.padStart(Integer.toString(region.region.getMyLength()), lengthW, '0');\n+\t\tString space = Strings.repeat(\" \", indent);\n+\t\tString name = region.region.getClass().getSimpleName();\n+\t\tString locations = join(map(region.locations, it -> render(it)), \", \");\n+\t\tString loc = debug + \" \" + offset + \"-\" + length + space;\n+\t\tString header = id + \": \" + loc + name + \" -> \" + locations;\n+\t\tif (region.children.isEmpty()) {\n+\t\t\tresult.add(header);\n+\t\t} else {\n+\t\t\tresult.add((header + \" {\"));\n+\t\t\tfor (RegionHandle child : region.children) {\n+\t\t\t\trender(child, idW, offsetW, lengthW, (indent + 2), result);\n+\t\t\t}\n+\t\t\tresult.add((id + \": \" + Strings.repeat(\" \", loc.length())) + \"}\");\n+\t\t}\n+\t}\n+\n+\tprotected String render() {\n+\t\tFile localFile = new File(null);\n+\t\tLinkedHashMap<SourceRelativeURI, File> remoteFiles = new LinkedHashMap<>();\n+\t\tList<RegionHandle> roothandles = new ArrayList<>();\n+\t\tint maxid = collect(getTrace(), 1, localFile, remoteFiles, roothandles);\n+\t\tint idwidth = Integer.toString(maxid, radix).length();\n+\t\taddAll(localFile.lines, render(localFile, idwidth));\n+\t\tfor (File file : remoteFiles.values()) {\n+\t\t\taddAll(file.lines, render(file, idwidth));\n+\t\t}\n+\t\tint localWidth = Math.max(max(map(localFile.lines, (String it) -> Integer.valueOf(it.length()))),\n+\t\t\t\tgetLocalTitle().length() + 2);\n+\t\tint remoteWidth = max(map(remoteFiles.values(),\n+\t\t\t\t(File it) -> Math.max(max(map(it.lines, (String it_1) -> Integer.valueOf(it_1.length()))),\n+\t\t\t\t\t\tgetRemoteTitle(it.uri).length() + 2)));\n+\t\tlocalFile.lines.add(0, title(null, localWidth));\n+\t\tfor (File file_1 : remoteFiles.values()) {\n+\t\t\tfile_1.lines.add(0, title(file_1.uri, remoteWidth));\n+\t\t}\n+\t\tList<String> left = localFile.lines;\n+\t\tList<String> right = toList(concat(map(remoteFiles.values(), it -> it.lines)));\n+\t\tArrayList<String> result = new ArrayList<>();\n+\t\tif (showLegend) {\n+\t\t\tresult.add(\n+\t\t\t\t\t\"Regions are surrounded by [N[ ... ]N]. Regions on the left and right with the same N are associated.\");\n+\t\t}\n+\t\tfor (int i = 0; i < left.size() || i < right.size(); i++) {\n+\t\t\tString l = Strings.padEnd(i < left.size() ? left.get(i) : \"\", localWidth, ' ');\n+\t\t\tString r = i < right.size() ? right.get(i) : \"\";\n+\t\t\tresult.add(l + \" | \" + r);\n+\t\t}\n+\t\tif (showTree) {\n+\t\t\tresult.add(Strings.repeat(\"-\", localWidth + remoteWidth + 3));\n+\t\t\tif (showLegend) {\n+\t\t\t\tresult.add(\n+\t\t\t\t\t\t\"<N>: <isDebug> <offset>-<length> <RegionJavaClass> -> <LocationJavaClass>[<offset>,<length>,<uri>]\");\n+\t\t\t}\n+\t\t\tIterable<RegionHandle> allhandles = concat(map(roothandles, it -> collect(it, it_1 -> it_1.children)));\n+\t\t\tint offsetWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyOffset()))))\n+\t\t\t\t\t.length();\n+\t\t\tint lengthWidth = String\n+\t\t\t\t\t.valueOf(max(map(allhandles, (RegionHandle it) -> Integer.valueOf(it.region.getMyLength()))))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 368}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwMzY0MDMw", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-370364030", "createdAt": "2020-03-06T14:33:11Z", "commit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNDozMzoxMlrOFy6vlw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wNlQxNDozMzoxMlrOFy6vlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkzNTU3NQ==", "bodyText": "This used to be IllegalArgumentException", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r388935575", "createdAt": "2020-03-06T14:33:12Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/AbsoluteURI.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/**\n+ * Copyright (c) 2015-2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator.trace;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.workspace.IProjectConfig;\n+import org.eclipse.xtext.workspace.ISourceFolder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * An absolute URI that allows to obtain a resource in a {@link IProjectConfig project}.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ */\n+public class AbsoluteURI extends AbstractURIWrapper {\n+\tpublic AbsoluteURI(URI absoluteURI) {\n+\t\tsuper(absoluteURI);\n+\t\tif (absoluteURI.isRelative() || !absoluteURI.isHierarchical()) {\n+\t\t\tthrow new IllegalArgumentException(absoluteURI.toString());\n+\t\t}\n+\t}\n+\n+\tpublic AbsoluteURI(String absoluteURI) {\n+\t\tthis(URI.createURI(absoluteURI));\n+\t}\n+\n+\tpublic SourceRelativeURI deresolve(URI sourceFolderURI) {\n+\t\ttry {\n+\t\t\treturn new SourceRelativeURI(getURI().deresolve(sourceFolderURI));\n+\t\t} catch (Throwable t) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/1822521ec3c6e302f6b864c091a9449b16ead439", "committedDate": "2020-03-06T13:57:44Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}, "afterCommit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/d2e39ad150fae434a096c502225e051ce459a4da", "committedDate": "2020-03-09T11:05:29Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxMzEyODA0", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-371312804", "createdAt": "2020-03-09T16:00:55Z", "commit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da"}, "state": "APPROVED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNjowMDo1NVrOFzu1nQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQxNzowNjo0MlrOFzxa5A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc4OTA4NQ==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389789085", "createdAt": "2020-03-09T16:00:55Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/findReferences/ReferenceAcceptor.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.findReferences;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.EcoreUtil2;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceServiceProvider;\n+import org.eclipse.xtext.resource.impl.DefaultReferenceDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+\n+/**\n+ * For local references, populates an {@link IReferenceDescription} that knows its exported container URI.\n+ * \n+ * @author Sebastian Zarnekow - Initial contribution and API\n+ * @author kosyakov - Pulled up to the runtime project\n+ */\n+public class ReferenceAcceptor implements IReferenceFinder.Acceptor {\n+\tprivate final IResourceServiceProvider.Registry resourceServiceProviderRegistry;\n+\n+\tprivate final IAcceptor<IReferenceDescription> delegate;\n+\n+\tprivate Resource currentResource;\n+\n+\tprivate Map<EObject, URI> exportedContainersInCurrentResource;\n+\n+\tpublic ReferenceAcceptor(IResourceServiceProvider.Registry resourceServiceProviderRegistry,\n+\t\t\tIAcceptor<IReferenceDescription> delegate) {\n+\t\tthis.resourceServiceProviderRegistry = resourceServiceProviderRegistry;\n+\t\tthis.delegate = delegate;\n+\t}\n+\n+\t@Override\n+\tpublic void accept(EObject source, URI sourceURI, EReference eReference, int index, EObject targetOrProxy,\n+\t\t\tURI targetURI) {\n+\t\tif (currentResource == null || source.eResource() != currentResource) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODkyNDY5Mg=="}, "originalCommit": {"oid": "1822521ec3c6e302f6b864c091a9449b16ead439"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NjI1OQ==", "bodyText": "I'd like to keep this @Beta - the code tickles me. I've doubts that it is really safe to to do it like this.", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389796259", "createdAt": "2020-03-09T16:12:02Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessQueue.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import java.util.concurrent.BlockingQueue;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.core.runtime.OperationCanceledException;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.xbase.lib.Exceptions;\n+\n+import com.google.common.annotations.Beta;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessQueue extends AdapterImpl {\n+\tprivate final BlockingQueue<FileSystemAccessRequest> requestQueue;\n+\n+\tprivate final IProgressMonitor monitor;\n+\n+\t/**\n+\t * @since 2.8\n+\t */\n+\tpublic FileSystemAccessQueue(BlockingQueue<FileSystemAccessRequest> requestQueue, IProgressMonitor monitor) {\n+\t\tthis.requestQueue = requestQueue;\n+\t\tthis.monitor = monitor;\n+\t}\n+\n+\t/**\n+\t * @since 2.9\n+\t */\n+\tpublic void sendAsync(URI uri, Runnable runMe) {\n+\t\tsend(new FileSystemAccessRequest(uri, runMe));\n+\t}\n+\n+\tprotected FileSystemAccessRequest send(FileSystemAccessRequest request) {\n+\t\ttry {\n+\t\t\tif (monitor.isCanceled()) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t}\n+\t\t\trequestQueue.put(request);\n+\t\t\treturn request;\n+\t\t} catch (Throwable t) {\n+\t\t\tif (t instanceof InterruptedException) {\n+\t\t\t\tthrow new OperationCanceledException();\n+\t\t\t} else {\n+\t\t\t\tthrow Exceptions.sneakyThrow(t);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @since 2.14\n+\t */\n+\t@Beta", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODgwOTM1Ng=="}, "originalCommit": {"oid": "c6b3b012ed9f78d817c7ace144e8e0a39537e2c5"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NjQ3OQ==", "bodyText": "A toString would be awesome.", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389796479", "createdAt": "2020-03-09T16:12:23Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/FileSystemAccessRequest.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*******************************************************************************\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ *\n+ * SPDX-License-Identifier: EPL-2.0\n+ *******************************************************************************/\n+package org.eclipse.xtext.generator;\n+\n+import org.eclipse.emf.common.util.URI;\n+\n+/**\n+ * @author Anton Kosyakov\n+ * @since 2.7\n+ */\n+public class FileSystemAccessRequest implements Runnable {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTc5NzA0OQ==", "bodyText": "Cosmetics: Can be simplified to OutputConfigurationAdapter.class.equals(type)", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389797049", "createdAt": "2020-03-09T16:13:19Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgwMjAwMA==", "bodyText": "Could be come Preconditions.checkNotNull(..) and the subsequent hashCode and equals implementation could be simplified.", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389802000", "createdAt": "2020-03-09T16:20:37Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMDY1NQ==", "bodyText": "It would be really useful if these would declare throws IOException", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389830655", "createdAt": "2020-03-09T17:05:30Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/URIBasedFileSystemAccess.java", "diffHunk": "@@ -0,0 +1,222 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.OutputStream;\n+import java.io.UnsupportedEncodingException;\n+import java.util.Collections;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.URIConverter;\n+import org.eclipse.xtext.generator.trace.ITraceRegionProvider;\n+import org.eclipse.xtext.generator.trace.TraceFileNameProvider;\n+import org.eclipse.xtext.generator.trace.TraceNotFoundException;\n+import org.eclipse.xtext.generator.trace.TraceRegionSerializer;\n+import org.eclipse.xtext.parser.IEncodingProvider;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+\n+import com.google.common.io.ByteStreams;\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * A file system access implementation that is based on EMF URIs and URIConverter\n+ * \n+ * @since 2.9\n+ */\n+public class URIBasedFileSystemAccess extends AbstractFileSystemAccess2 {\n+\tpublic interface BeforeDelete {\n+\t\t/**\n+\t\t * @return <code>true</code> if the file can be deleted, false otherwise\n+\t\t */\n+\t\tboolean beforeDelete(URI changed);\n+\t}\n+\n+\tpublic interface BeforeWrite {\n+\t\tInputStream beforeWrite(URI changed, String outputCfgName, InputStream in);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMTA0Ng==", "bodyText": "There is only a single field. We could try to avoid the ToStringBuilder", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389831046", "createdAt": "2020-03-09T17:06:09Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/OutputConfigurationAdapter.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+import com.google.common.base.Objects;\n+\n+/**\n+ * @noreference\n+ */\n+public class OutputConfigurationAdapter extends AdapterImpl {\n+\tprivate final Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage;\n+\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn Objects.equal(type, OutputConfigurationAdapter.class);\n+\t}\n+\n+\tpublic OutputConfigurationAdapter(Map<String, Set<OutputConfiguration>> outputConfigurationsPerLanguage) {\n+\t\tthis.outputConfigurationsPerLanguage = outputConfigurationsPerLanguage;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn 31 * 1 + ((outputConfigurationsPerLanguage == null) ? 0 : outputConfigurationsPerLanguage.hashCode());\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tOutputConfigurationAdapter other = (OutputConfigurationAdapter) obj;\n+\t\tif (outputConfigurationsPerLanguage == null) {\n+\t\t\tif (other.outputConfigurationsPerLanguage != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!outputConfigurationsPerLanguage.equals(other.outputConfigurationsPerLanguage))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn new ToStringBuilder(this).addAllFields().toString();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTgzMTM5Ng==", "bodyText": "Severity is an enum - identity comparison could be used here.", "url": "https://github.com/eclipse/xtext-core/pull/1417#discussion_r389831396", "createdAt": "2020-03-09T17:06:42Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/IShouldGenerate.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/**\n+ * Copyright (c) 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.generator;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.xtext.diagnostics.Severity;\n+import org.eclipse.xtext.util.CancelIndicator;\n+import org.eclipse.xtext.validation.CheckMode;\n+import org.eclipse.xtext.validation.IResourceValidator;\n+import org.eclipse.xtext.validation.Issue;\n+\n+import com.google.common.annotations.Beta;\n+import com.google.common.base.Objects;\n+import com.google.inject.ImplementedBy;\n+import com.google.inject.Inject;\n+import com.google.inject.Singleton;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.9\n+ */\n+@Beta\n+@ImplementedBy(IShouldGenerate.OnlyWithoutErrors.class)\n+public interface IShouldGenerate {\n+\t@Beta\n+\t@Singleton\n+\tclass OnlyWithoutErrors implements IShouldGenerate {\n+\t\t@Inject\n+\t\tprivate IResourceValidator resourceValidator;\n+\n+\t\t@Override\n+\t\tpublic boolean shouldGenerate(Resource resource, CancelIndicator cancelIndicator) {\n+\t\t\tif (!resource.getErrors().isEmpty()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tList<Issue> issues = resourceValidator.validate(resource, CheckMode.NORMAL_AND_FAST, cancelIndicator);\n+\t\t\treturn !exists(issues, (Issue issue) -> Objects.equal(issue.getSeverity(), Severity.ERROR));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxOTM3MzQw", "url": "https://github.com/eclipse/xtext-core/pull/1417#pullrequestreview-371937340", "createdAt": "2020-03-10T13:14:14Z", "commit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/9f4bf0fb16a8d36a8252a316db7602d7387a2697", "committedDate": "2020-03-13T07:46:15Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d2e39ad150fae434a096c502225e051ce459a4da", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/d2e39ad150fae434a096c502225e051ce459a4da", "committedDate": "2020-03-09T11:05:29Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}, "afterCommit": {"oid": "9f4bf0fb16a8d36a8252a316db7602d7387a2697", "author": {"user": {"login": "ArneDeutsch", "name": "Arne Deutsch"}}, "url": "https://github.com/eclipse/xtext-core/commit/9f4bf0fb16a8d36a8252a316db7602d7387a2697", "committedDate": "2020-03-13T07:46:15Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to java.\n\nSigned-off-by: Arne Deutsch <Arne.Deutsch@itemis.de>"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4726, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}