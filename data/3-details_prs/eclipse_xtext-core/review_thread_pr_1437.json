{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk4MDQwNjEy", "number": 1437, "reviewThreads": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1NTo1NVrODuSPRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozNjo1MVrODuZ6RA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODU5OTA4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1NTo1NVrOGAMSHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1NTo1NVrOGAMSHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NDQzMQ==", "bodyText": "This was already Java on master. Let's see if we do have any semantic changes :)", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402854431", "createdAt": "2020-04-03T08:55:55Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -155,20 +83,19 @@ public boolean isPortableURIFragment(String uriFragment) {\n \t * @return the EObject for the given portableURIFragment\n \t */\n \tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n-\t\tPortableURIs.PortableFragmentDescription desc = fromFragmentString(portableFragment);\n+\t\tPortableFragmentDescription desc = fromFragmentString(portableFragment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 121}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYwNzYxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1NzoxNFrOGAMWog==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1NzoxNFrOGAMWog==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NTU4Ng==", "bodyText": "this reverts the fixed comment", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402855586", "createdAt": "2020-04-03T08:57:14Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -155,20 +83,19 @@ public boolean isPortableURIFragment(String uriFragment) {\n \t * @return the EObject for the given portableURIFragment\n \t */\n \tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n-\t\tPortableURIs.PortableFragmentDescription desc = fromFragmentString(portableFragment);\n+\t\tPortableFragmentDescription desc = fromFragmentString(portableFragment);\n \t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n \t\tmock.setEType(desc.descriptionEClass);\n-\t\tIScope scope = globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n-\t\tOptional<IEObjectDescription> description = Streams.stream( //\n-\t\t\t\tscope.getElements(desc.descriptionQualifiedName)).findFirst();\n-\t\treturn description.map(d -> {\n-\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n-\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n-\t\t}).orElse(null);\n+\t\tIScope scope = globalScopeProvider.getScope(resource, mock, alwaysTrue());\n+\t\tIEObjectDescription description = head(scope.getElements(desc.descriptionQualifiedName));\n+\t\tif (description == null)\n+\t\t\treturn null;\n+\t\tEObject container = EcoreUtil.resolve(description.getEObjectOrProxy(), resource);\n+\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n \t}\n \n \t/**\n-\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> if no\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 141}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYxMDM0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1Nzo0MlrOGAMYRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1Nzo0MlrOGAMYRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NjAwNA==", "bodyText": "Version on master appears to be cleaner and has the original source comment.", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402856004", "createdAt": "2020-04-03T08:57:42Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -180,16 +107,15 @@ public EObject resolve(StorageAwareResource resource, String portableFragment) {\n \t * @return a portable URI or <code>null</code>\n \t */\n \tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n-\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n-\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n-\t\tif (object == null || object.eResource().getResourceSet() != null) {\n-\t\t\treturn toPortableURI(sourceResource, object);\n-\t\t}\n+\t\tResource resource = sourceResource.getResourceSet().getResource(targetURI.trimFragment(), false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 154}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYxMjk1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1ODowNVrOGAMZqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1ODowNVrOGAMZqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NjM2MQ==", "bodyText": "I prefer the curly braces on master", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402856361", "createdAt": "2020-04-03T08:58:05Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -200,13 +126,11 @@ public URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n \t * @return a portable URI or <code>null</code>\n \t */\n \tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n-\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\tif (targetObject == null || targetObject.eIsProxy())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 172}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYxOTUzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1OTowN1rOGAMdVw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1OTowN1rOGAMdVw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1NzMwMw==", "bodyText": "isAncestor does this check already", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402857303", "createdAt": "2020-04-03T08:59:07Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 200}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYyMzI2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1OTo0NVrOGAMffw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwODo1OTo0NVrOGAMffw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1Nzg1NQ==", "bodyText": "Not sure if I like IterableExtensions being used here given that this class was already reviewed and ported to Java a few days ago", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402857855", "createdAt": "2020-04-03T08:59:45Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -8,9 +8,12 @@\n  */\n package org.eclipse.xtext.resource.persistence;\n \n+import static com.google.common.base.Predicates.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYyNjYyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMDoxOVrOGAMhUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMDoxOVrOGAMhUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODMyMw==", "bodyText": "I prefer the version on master.", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858323", "createdAt": "2020-04-03T09:00:19Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t});\n+\t\tif (containerDesc != null)\n+\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n+\t\treturn null;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n-\t\t\tEObject target) {\n+\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n-\t\t\t\tfragmentToTarget);\n+\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n-\t\tif (desc.descriptionRelativeFragment != null) {\n+\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n+\t\tif (desc.descriptionRelativeFragment != null)\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n-\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 232}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYyODM1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMDozM1rOGAMiMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMDozM1rOGAMiMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODU0NQ==", "bodyText": "Could use the short class name for the inner type, though.", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858545", "createdAt": "2020-04-03T09:00:33Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -217,52 +141,44 @@ public URI toPortableURI(StorageAwareResource sourceResource, EObject targetObje\n \tprotected String getPortableURIFragment(EObject obj) {\n \t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n \t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n-\t\tif (desc == null) {\n+\t\tif (desc == null)\n \t\t\treturn null;\n-\t\t}\n-\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n-\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n-\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n-\t\t}).map(containerDesc -> {\n-\t\t\tPortableFragmentDescription fragmentDescription = createPortableFragmentDescription(containerDesc, obj);\n-\t\t\treturn toFragmentString(fragmentDescription);\n-\t\t}).findFirst().orElse(null);\n+\t\tIEObjectDescription containerDesc = findFirst(desc.getExportedObjects(), it -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(it.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn obj.equals(possibleContainer) || EcoreUtil.isAncestor(obj, possibleContainer);\n+\t\t});\n+\t\tif (containerDesc != null)\n+\t\t\treturn toFragmentString(createPortableFragmentDescription(containerDesc, obj));\n+\t\treturn null;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc,\n-\t\t\tEObject target) {\n+\tprotected PortableFragmentDescription createPortableFragmentDescription(IEObjectDescription desc, EObject target) {\n \t\tEObject possibleContainer = EcoreUtil.resolve(desc.getEObjectOrProxy(), target);\n \t\tString fragmentToTarget = getFragment(target, possibleContainer);\n-\t\treturn new PortableURIs.PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(),\n-\t\t\t\tfragmentToTarget);\n+\t\treturn new PortableFragmentDescription(desc.getEClass(), desc.getQualifiedName(), fragmentToTarget);\n \t}\n \n-\tprotected String toFragmentString(PortableURIs.PortableFragmentDescription desc) {\n+\tprotected String toFragmentString(PortableFragmentDescription desc) {\n \t\tString eclassUriAsString = URI.encodeFragment(EcoreUtil.getURI(desc.descriptionEClass).toString(), false);\n \t\tList<String> segments = desc.descriptionQualifiedName.getSegments();\n \t\tString uriFragment = PortableURIs.PORTABLE_SCHEME + \"#\" + eclassUriAsString + \"#\"\n-\t\t\t\t+ URI.encodeFragment(Joiner.on(':').join(segments), false);\n-\t\tif (desc.descriptionRelativeFragment != null) {\n+\t\t\t\t+ URI.encodeFragment(join(segments, \":\"), false);\n+\t\tif (desc.descriptionRelativeFragment != null)\n \t\t\turiFragment += \"#\" + URI.encodeFragment(desc.descriptionRelativeFragment, false);\n-\t\t}\n \t\treturn uriFragment;\n \t}\n \n-\tprotected PortableURIs.PortableFragmentDescription fromFragmentString(String fragmentString) {\n+\tprotected PortableFragmentDescription fromFragmentString(String fragmentString) {\n \t\tIterator<String> segments = Splitter.on(\"#\").split(fragmentString).iterator();\n-\t\tsegments.next(); // skip first\n+\t\tsegments.next();\n \t\tURI eClassURI = URI.createURI(URI.decode(segments.next()));\n-\t\tEPackage ePackage = this.packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n-\t\tEClass eClass = EcorePackage.Literals.EOBJECT;\n-\t\tif (ePackage != null) {\n-\t\t\tResource resource = ePackage.eResource();\n-\t\t\tif (resource != null) {\n-\t\t\t\teClass = (EClass) resource.getEObject(eClassURI.fragment());\n-\t\t\t}\n-\t\t}\n-\t\tQualifiedName qname = QualifiedName.create(Splitter.on(\":\").splitToList(URI.decode(segments.next())));\n+\t\tEPackage ePackage = packageRegistry.getEPackage(eClassURI.trimFragment().toString());\n+\t\tResource eResource = ePackage == null ? null : ePackage.eResource();\n+\t\tEClass eClass = (EClass) (eResource == null ? null : eResource.getEObject(eClassURI.fragment()));\n+\t\tQualifiedName qname = QualifiedName.create(toList(Splitter.on(\":\").split(URI.decode(segments.next()))));\n \t\tString fragment = segments.hasNext() ? URI.decode(segments.next()) : null;\n-\t\treturn new PortableURIs.PortableFragmentDescription(eClass, qname, fragment);\n+\t\treturn new PortableFragmentDescription(eClass == null ? EcorePackage.Literals.EOBJECT : eClass, qname,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 252}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYzMDM2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMDo1MFrOGAMjPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMDo1MFrOGAMjPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg1ODgxMg==", "bodyText": "This reverts the cleanup that is present on master.", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402858812", "createdAt": "2020-04-03T09:00:50Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -276,10 +192,21 @@ protected String toFragmentString(PortableURIs.PortableFragmentDescription desc)\n \t * @return a fragment path from the given container to the child, or <code>null</null> is fromContainer == toChild\n \t * \n \t * @see #getEObject(EObject,String)\n-\t * @throws IllegalArgumentException if the child is not a child of the given container.\n \t */\n-\tpublic String getFragment(EObject fromContainer, EObject toChild) throws IllegalArgumentException {\n-\t\treturn Strings.emptyToNull(EcoreUtil.getRelativeURIFragmentPath(fromContainer, toChild));\n+\tpublic String getFragment(EObject fromContainer, EObject toChild) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 265}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODYzOTQwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMjoyMFrOGAMn4Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMjoyMFrOGAMn4Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDAwMQ==", "bodyText": "IterableExtensions are still being used here. Can this be simplified, e.g. by using FluentIterable or streams?", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860001", "createdAt": "2020-04-03T09:02:20Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY0NDgxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMzoxM1rOGAMqpw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMzoxM1rOGAMqpw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDcxMQ==", "bodyText": "@Pure can be removed", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860711", "createdAt": "2020-04-03T09:03:13Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);\n+\t\t\treturn;\n+\t\t}\n+\t\tfsa.generateFile(computeOutputPath(resource), new ByteArrayInputStream(bout.toByteArray(), 0, bout.length()));\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageLoadable createResourceStorageLoadable(InputStream in) {\n+\t\treturn new ResourceStorageLoadable(in, isStoreNodeModel());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageWritable createResourceStorageWritable(OutputStream out) {\n+\t\treturn new ResourceStorageWritable(out, isStoreNodeModel());\n+\t}\n+\n+\t/**\n+\t * @return whether a stored resource state exists for the given resource\n+\t */\n+\tprotected boolean doesStorageExist(StorageAwareResource resource) {\n+\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\tif (stateProvider != null && stateProvider.getResourceStorageLoadable(resource) != null)\n+\t\t\treturn true;\n+\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\tCollections.emptyMap()))\n+\t\t\treturn true;\n+\t\tif (resource.getURI().isArchive())\n+\t\t\treturn false;\n+\t\tURI uri = getFileSystemAccess(resource).getURI(computeOutputPath(resource));\n+\t\treturn uri != null && resource.getResourceSet().getURIConverter().exists(uri, null);\n+\t}\n+\n+\tprotected AbstractFileSystemAccess2 getFileSystemAccess(StorageAwareResource resource) {\n+\t\tAbstractFileSystemAccess2 fsa = fileSystemAccessProvider.get();\n+\t\tfsa.setContext(resource);\n+\t\tfsa.setOutputConfigurations(\n+\t\t\t\ttoMap(outputConfigurationProvider.getOutputConfigurations(resource), it -> it.getName()));\n+\t\treturn fsa;\n+\t}\n+\n+\tprotected String computeOutputPath(StorageAwareResource resource) {\n+\t\treturn getBinaryStorageURI(resource.getURI()).deresolve(getSourceContainerURI(resource), false, false, true)\n+\t\t\t\t.path();\n+\t}\n+\n+\tprotected URI getSourceContainerURI(StorageAwareResource resource) {\n+\t\treturn resource.getURI().trimSegments(1).appendSegment(\"\");\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasStorageFor(URI uri) {\n+\t\treturn new ExtensibleURIConverterImpl().exists(getBinaryStorageURI(uri), Collections.emptyMap());\n+\t}\n+\n+\tprotected URI getBinaryStorageURI(URI sourceURI) {\n+\t\treturn sourceURI.trimSegments(1).appendSegment(\".\" + sourceURI.lastSegment() + \"bin\");\n+\t}\n+\n+\t@Pure", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 152}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY0NjI0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMzoyNVrOGAMraw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMzoyNVrOGAMraw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MDkwNw==", "bodyText": "@Accessors can be removed", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402860907", "createdAt": "2020-04-03T09:03:25Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY0OTE2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMzo1NFrOGAMtLw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowMzo1NFrOGAMtLw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MTM1OQ==", "bodyText": "EcoreUtil.getAdapter?", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402861359", "createdAt": "2020-04-03T09:03:54Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);\n+\t\t\treturn;\n+\t\t}\n+\t\tfsa.generateFile(computeOutputPath(resource), new ByteArrayInputStream(bout.toByteArray(), 0, bout.length()));\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageLoadable createResourceStorageLoadable(InputStream in) {\n+\t\treturn new ResourceStorageLoadable(in, isStoreNodeModel());\n+\t}\n+\n+\t@Override\n+\tpublic ResourceStorageWritable createResourceStorageWritable(OutputStream out) {\n+\t\treturn new ResourceStorageWritable(out, isStoreNodeModel());\n+\t}\n+\n+\t/**\n+\t * @return whether a stored resource state exists for the given resource\n+\t */\n+\tprotected boolean doesStorageExist(StorageAwareResource resource) {\n+\t\tResourceStorageProviderAdapter stateProvider = head(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 113}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY1MzA0OnYy", "diffSide": "LEFT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.xtend", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowNDozMFrOGAMvTA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowNDozMFrOGAMvTA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MTkwMA==", "bodyText": "Comment got lost", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402861900", "createdAt": "2020-04-03T09:04:30Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.xtend", "diffHunk": "@@ -1,151 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0.\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- *******************************************************************************/\n-package org.eclipse.xtext.resource.persistence\n-\n-import com.google.inject.Inject\n-import com.google.inject.Provider\n-import java.io.ByteArrayInputStream\n-import java.io.ByteArrayOutputStream\n-import java.io.InputStream\n-import java.io.OutputStream\n-import org.eclipse.emf.common.util.URI\n-import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl\n-import org.eclipse.xtext.generator.AbstractFileSystemAccess2\n-import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider\n-import org.eclipse.xtext.generator.IFileSystemAccessExtension3\n-import org.eclipse.xtend.lib.annotations.Accessors\n-import java.io.IOException\n-import org.apache.log4j.Logger\n-\n-/**\n- * @author Sven Efftinge - Initial contribution and API\n- */\n-class ResourceStorageFacade implements IResourceStorageFacade {\n-\t\n-\tstatic val Logger LOG = Logger.getLogger(ResourceStorageFacade)\n-\t\n-\t@Inject IContextualOutputConfigurationProvider outputConfigurationProvider\n-\t@Inject Provider<AbstractFileSystemAccess2> fileSystemAccessProvider\n-\t\n-\t@Accessors boolean storeNodeModel = false\n-\t\n-\t/**\n-\t * @return whether the given resource should be loaded from stored resource state\n-\t */\n-\toverride boolean shouldLoadFromStorage(StorageAwareResource resource) {\n-\t\tval adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.resourceSet)\n-\t\tif (adapter === null) {\n-\t\t\treturn false;\n-\t\t} else {\n-\t\t\tif (adapter.sourceLevelURIs.contains(resource.URI))\n-\t\t\t\treturn false;\n-\t\t}\n-\t\treturn doesStorageExist(resource)\n-\t}\n-\t\n-\t/**\n-\t * Finds or creates a ResourceStorageLoadable for the given resource.\n-\t * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-\t * of the given resource.\n-\t * \n-\t * @return an IResourceStorageLoadable\n-\t */\n-\toverride ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n-\t\tval stateProvider = resource.resourceSet.eAdapters.filter(ResourceStorageProviderAdapter).head\n-\t\tif (stateProvider !== null) {\n-\t\t\tval inputStream = stateProvider.getResourceStorageLoadable(resource)\n-\t\t\tif (inputStream !== null)\n-\t\t\t\treturn inputStream\n-\t\t}\n-\t\tval inputStream = if (resource.resourceSet.URIConverter.exists(resource.URI.getBinaryStorageURI, emptyMap)) {\n-\t\t\t\tresource.resourceSet.URIConverter.createInputStream(resource.URI.getBinaryStorageURI)\n-\t\t\t} else {\n-\t\t\t\tval fsa = getFileSystemAccess(resource);\n-\t\t\t\tval outputRelativePath = computeOutputPath(resource)\n-\t\t\t\tfsa.readBinaryFile(outputRelativePath)\n-\t\t\t}\n-\t\treturn createResourceStorageLoadable(inputStream)\n-\t}\n-\t\n-\toverride void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n-\t\tval path = computeOutputPath(resource)\n-\t\tval bout = new MyByteArrayOutputStream()\n-\t\tval outStream = createResourceStorageWritable(bout)\n-\t\ttry {\n-\t\t\toutStream.writeResource(resource)\n-\t\t} catch(IOException e) {\n-\t\t\t// something went wrong when writing the resource - stream's content is bogus and not written to disk", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 83}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY1NDAwOnYy", "diffSide": "LEFT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.xtend", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowNDozOFrOGAMvyA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOTowNDozOFrOGAMvyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2MjAyNA==", "bodyText": "Comments got lost", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402862024", "createdAt": "2020-04-03T09:04:38Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.xtend", "diffHunk": "@@ -1,151 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0.\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- *******************************************************************************/\n-package org.eclipse.xtext.resource.persistence\n-\n-import com.google.inject.Inject\n-import com.google.inject.Provider\n-import java.io.ByteArrayInputStream\n-import java.io.ByteArrayOutputStream\n-import java.io.InputStream\n-import java.io.OutputStream\n-import org.eclipse.emf.common.util.URI\n-import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl\n-import org.eclipse.xtext.generator.AbstractFileSystemAccess2\n-import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider\n-import org.eclipse.xtext.generator.IFileSystemAccessExtension3\n-import org.eclipse.xtend.lib.annotations.Accessors\n-import java.io.IOException\n-import org.apache.log4j.Logger\n-\n-/**\n- * @author Sven Efftinge - Initial contribution and API\n- */\n-class ResourceStorageFacade implements IResourceStorageFacade {\n-\t\n-\tstatic val Logger LOG = Logger.getLogger(ResourceStorageFacade)\n-\t\n-\t@Inject IContextualOutputConfigurationProvider outputConfigurationProvider\n-\t@Inject Provider<AbstractFileSystemAccess2> fileSystemAccessProvider\n-\t\n-\t@Accessors boolean storeNodeModel = false\n-\t\n-\t/**\n-\t * @return whether the given resource should be loaded from stored resource state\n-\t */\n-\toverride boolean shouldLoadFromStorage(StorageAwareResource resource) {\n-\t\tval adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.resourceSet)\n-\t\tif (adapter === null) {\n-\t\t\treturn false;\n-\t\t} else {\n-\t\t\tif (adapter.sourceLevelURIs.contains(resource.URI))\n-\t\t\t\treturn false;\n-\t\t}\n-\t\treturn doesStorageExist(resource)\n-\t}\n-\t\n-\t/**\n-\t * Finds or creates a ResourceStorageLoadable for the given resource.\n-\t * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-\t * of the given resource.\n-\t * \n-\t * @return an IResourceStorageLoadable\n-\t */\n-\toverride ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n-\t\tval stateProvider = resource.resourceSet.eAdapters.filter(ResourceStorageProviderAdapter).head\n-\t\tif (stateProvider !== null) {\n-\t\t\tval inputStream = stateProvider.getResourceStorageLoadable(resource)\n-\t\t\tif (inputStream !== null)\n-\t\t\t\treturn inputStream\n-\t\t}\n-\t\tval inputStream = if (resource.resourceSet.URIConverter.exists(resource.URI.getBinaryStorageURI, emptyMap)) {\n-\t\t\t\tresource.resourceSet.URIConverter.createInputStream(resource.URI.getBinaryStorageURI)\n-\t\t\t} else {\n-\t\t\t\tval fsa = getFileSystemAccess(resource);\n-\t\t\t\tval outputRelativePath = computeOutputPath(resource)\n-\t\t\t\tfsa.readBinaryFile(outputRelativePath)\n-\t\t\t}\n-\t\treturn createResourceStorageLoadable(inputStream)\n-\t}\n-\t\n-\toverride void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n-\t\tval path = computeOutputPath(resource)\n-\t\tval bout = new MyByteArrayOutputStream()\n-\t\tval outStream = createResourceStorageWritable(bout)\n-\t\ttry {\n-\t\t\toutStream.writeResource(resource)\n-\t\t} catch(IOException e) {\n-\t\t\t// something went wrong when writing the resource - stream's content is bogus and not written to disk\n-\t\t\tLOG.warn(\"Cannot write storage for \" + resource.URI, e)\n-\t\t\treturn;\n-\t\t}\n-\t\tfsa.generateFile(path, new ByteArrayInputStream(bout.toByteArray, 0, bout.length))\n-\t}\n-\t\n-\toverride ResourceStorageLoadable createResourceStorageLoadable(InputStream in) {\n-\t\treturn new ResourceStorageLoadable(in, isStoreNodeModel)\n-\t}\n-\t\n-\toverride ResourceStorageWritable createResourceStorageWritable(OutputStream out) {\n-\t\treturn new ResourceStorageWritable(out, isStoreNodeModel)\n-\t}\n-\t\n-\t/**\n-\t * @return whether a stored resource state exists for the given resource\n-\t */\n-\tprotected def doesStorageExist(StorageAwareResource resource) {\n-\t\tval stateProvider = resource.resourceSet.eAdapters.filter(ResourceStorageProviderAdapter).head\n-\t\tif (stateProvider !== null && stateProvider.getResourceStorageLoadable(resource) !== null)\n-\t\t\treturn true;\n-\t\t// check for next to original location, i.e. jars", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY5Njg5OnYy", "diffSide": "LEFT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.xtend", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMjozOVrOGANIvw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMjozOVrOGANIvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2ODQxNQ==", "bodyText": "Comment got lost", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402868415", "createdAt": "2020-04-03T09:12:39Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.xtend", "diffHunk": "@@ -1,113 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0.\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- *******************************************************************************/\n-package org.eclipse.xtext.resource.persistence\n-\n-import com.google.common.io.CharStreams\n-import java.io.BufferedInputStream\n-import java.io.DataInputStream\n-import java.io.IOException\n-import java.io.InputStream\n-import java.io.InputStreamReader\n-import java.io.ObjectInputStream\n-import java.util.zip.ZipInputStream\n-import org.apache.log4j.Logger\n-import org.eclipse.emf.ecore.InternalEObject\n-import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl\n-import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl.EObjectInputStream\n-import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor\n-import org.eclipse.xtext.nodemodel.impl.SerializableNodeModel\n-import org.eclipse.xtext.nodemodel.serialization.DeserializationConversionContext\n-import org.eclipse.xtext.parser.ParseResult\n-\n-/**\n- * @author Sven Efftinge - Initial contribution and API\n- */\n-@FinalFieldsConstructor class ResourceStorageLoadable {\n-\t\n-\tstatic val LOG = Logger.getLogger(ResourceStorageLoadable)\n-\t\n-\tval InputStream in\n-\tval boolean storeNodeModel\n-\t\n-\tprotected def void loadIntoResource(StorageAwareResource resource) throws IOException {\n-\t\tif (!resource.isLoadedFromStorage) {\n-\t\t\tthrow new IllegalStateException(\"Please use StorageAwareResource#load(ResourceStorageLoadable).\");\n-\t\t}\n-\t\tval zin = new ZipInputStream(in)\n-\t\ttry {\n-\t\t\tloadEntries(resource, zin)\n-\t\t} finally {\n-\t\t\tzin.close\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Load entries from the storage.\n-\t * Overriding methods should first delegate to super before adding their own entries.\n-\t */\n-\tprotected def void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n-\t\tzipIn.nextEntry\n-\t\treadContents(resource, new BufferedInputStream(zipIn))\n-\n-\t\tzipIn.nextEntry\n-\t\treadResourceDescription(resource, new BufferedInputStream(zipIn))\n-\n-\t\tif (storeNodeModel) {\n-\t\t\tzipIn.nextEntry\n-\t\t\treadNodeModel(resource, new BufferedInputStream(zipIn))\n-\t\t}\n-\t}\n-\t\n-\tprotected def void readContents(StorageAwareResource resource, InputStream inputStream) throws IOException {\n-\t\tval in = new BinaryResourceImpl.EObjectInputStream(inputStream, emptyMap) {\n-\t\t\t\n-\t\t\toverride readCompressedInt() throws IOException {\n-\t\t\t\t//HACK! null resource set, to avoid usage of resourceSet's package registry", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 71}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY5NzU3OnYy", "diffSide": "LEFT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.xtend", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMjo1MFrOGANJMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMjo1MFrOGANJMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2ODUyOQ==", "bodyText": "Comment got lost", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402868529", "createdAt": "2020-04-03T09:12:50Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.xtend", "diffHunk": "@@ -1,113 +0,0 @@\n-/*******************************************************************************\n- * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n- * This program and the accompanying materials are made available under the\n- * terms of the Eclipse Public License 2.0 which is available at\n- * http://www.eclipse.org/legal/epl-2.0.\n- *\n- * SPDX-License-Identifier: EPL-2.0\n- *******************************************************************************/\n-package org.eclipse.xtext.resource.persistence\n-\n-import com.google.common.io.CharStreams\n-import java.io.BufferedInputStream\n-import java.io.DataInputStream\n-import java.io.IOException\n-import java.io.InputStream\n-import java.io.InputStreamReader\n-import java.io.ObjectInputStream\n-import java.util.zip.ZipInputStream\n-import org.apache.log4j.Logger\n-import org.eclipse.emf.ecore.InternalEObject\n-import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl\n-import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl.EObjectInputStream\n-import org.eclipse.xtend.lib.annotations.FinalFieldsConstructor\n-import org.eclipse.xtext.nodemodel.impl.SerializableNodeModel\n-import org.eclipse.xtext.nodemodel.serialization.DeserializationConversionContext\n-import org.eclipse.xtext.parser.ParseResult\n-\n-/**\n- * @author Sven Efftinge - Initial contribution and API\n- */\n-@FinalFieldsConstructor class ResourceStorageLoadable {\n-\t\n-\tstatic val LOG = Logger.getLogger(ResourceStorageLoadable)\n-\t\n-\tval InputStream in\n-\tval boolean storeNodeModel\n-\t\n-\tprotected def void loadIntoResource(StorageAwareResource resource) throws IOException {\n-\t\tif (!resource.isLoadedFromStorage) {\n-\t\t\tthrow new IllegalStateException(\"Please use StorageAwareResource#load(ResourceStorageLoadable).\");\n-\t\t}\n-\t\tval zin = new ZipInputStream(in)\n-\t\ttry {\n-\t\t\tloadEntries(resource, zin)\n-\t\t} finally {\n-\t\t\tzin.close\n-\t\t}\n-\t}\n-\t\n-\t/**\n-\t * Load entries from the storage.\n-\t * Overriding methods should first delegate to super before adding their own entries.\n-\t */\n-\tprotected def void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n-\t\tzipIn.nextEntry\n-\t\treadContents(resource, new BufferedInputStream(zipIn))\n-\n-\t\tzipIn.nextEntry\n-\t\treadResourceDescription(resource, new BufferedInputStream(zipIn))\n-\n-\t\tif (storeNodeModel) {\n-\t\t\tzipIn.nextEntry\n-\t\t\treadNodeModel(resource, new BufferedInputStream(zipIn))\n-\t\t}\n-\t}\n-\t\n-\tprotected def void readContents(StorageAwareResource resource, InputStream inputStream) throws IOException {\n-\t\tval in = new BinaryResourceImpl.EObjectInputStream(inputStream, emptyMap) {\n-\t\t\t\n-\t\t\toverride readCompressedInt() throws IOException {\n-\t\t\t\t//HACK! null resource set, to avoid usage of resourceSet's package registry\n-\t\t\t\tresourceSet = null\n-\t\t\t\tsuper.readCompressedInt()\n-\t\t\t}\n-\t\t\t\n-\t\t\toverride loadEObject() throws IOException {\n-\t\t\t\tval result = super.loadEObject()\n-\t\t\t\thandleLoadEObject(result, this)\n-\t\t\t\treturn result\n-\t\t\t}\n-\t\n-\t\t\t\n-\t\t}\n-\t\tin.loadResource(resource)\n-\t}\n-\t\n-\tprotected def handleLoadEObject(InternalEObject loaded, EObjectInputStream input) throws IOException {\n-\t}\n-\t\n-\tprotected def void readResourceDescription(StorageAwareResource resource, InputStream inputStream) throws IOException {\n-\t\tval objectIn = new ObjectInputStream(inputStream)\n-\t\tval description = objectIn.readObject as SerializableResourceDescription\n-\t\tdescription.updateResourceURI(resource.URI)\n-\t\tresource.resourceDescription = description\n-\t}\n-\t\n-\tprotected def void readNodeModel(StorageAwareResource resource, InputStream inputStream) throws IOException {\n-\t\tval serializableNodeModel = new SerializableNodeModel(resource)\n-\t\t// if this is a synthetic resource (i.e. tests or so, don't load the node model)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 99}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODY5OTI0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageProviderAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMzoxNVrOGANKNg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxMzoxNVrOGANKNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg2ODc5MA==", "bodyText": "I prefer equals", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402868790", "createdAt": "2020-04-03T09:13:15Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageProviderAdapter.java", "diffHunk": "@@ -19,7 +19,7 @@\n public class ResourceStorageProviderAdapter extends AdapterImpl {\n \t@Override\n \tpublic boolean isAdapterForType(Object type) {\n-\t\treturn ResourceStorageProviderAdapter.class.equals(type);\n+\t\treturn type == ResourceStorageProviderAdapter.class;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODcwNzMzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxNTozNlrOGANPiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxNTozNlrOGANPiQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDE1Mw==", "bodyText": "fieldname should be uri", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402870153", "createdAt": "2020-04-03T09:15:36Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 45}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODcwODQ2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxNTo1OVrOGANQOg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxNTo1OVrOGANQOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MDMzMA==", "bodyText": "parametername should be uri", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402870330", "createdAt": "2020-04-03T09:15:59Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODcxMzE0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxNzoyMFrOGANTGw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxNzoyMFrOGANTGw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTA2Nw==", "bodyText": "I prefer the version on master", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871067", "createdAt": "2020-04-03T09:17:20Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java", "diffHunk": "@@ -8,11 +8,12 @@\n  */\n package org.eclipse.xtext.resource.persistence;\n \n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODcxNDI3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxNzo0MVrOGANT3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxNzo0MVrOGANT3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTI2MA==", "bodyText": "I prefer the version on master", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871260", "createdAt": "2020-04-03T09:17:41Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -46,27 +45,25 @@\n \tpublic void load(Map<?, ?> options) throws IOException {\n \t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n \t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n-\t\t\tLOG.debug(\"Loading \" + getURI() + \" from storage.\");\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5ODcxNTY5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResourceDescriptionManager.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxODowM1rOGANUtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QwOToxODowM1rOGANUtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjg3MTQ3Ng==", "bodyText": "I prefer the version on matser", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r402871476", "createdAt": "2020-04-03T09:18:03Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResourceDescriptionManager.java", "diffHunk": "@@ -21,10 +21,9 @@\n \t@Override\n \tpublic IResourceDescription getResourceDescription(Resource resource) {\n \t\tif (resource instanceof StorageAwareResource) {\n-\t\t\tIResourceDescription result = ((StorageAwareResource) resource).getResourceDescription();\n-\t\t\tif (result != null) {\n-\t\t\t\treturn result;\n-\t\t\t}\n+\t\t\tIResourceDescription resourceDescription = ((StorageAwareResource) resource).getResourceDescription();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3e015dd2843a6894f4e2b2e41d0d3cb6ce83938a"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTc4OTA0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyMTo0NlrOGAXo4g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyMTo0NlrOGAXo4g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MDQ4Mg==", "bodyText": "{@link #shouldLoadFromStorage}", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403040482", "createdAt": "2020-04-03T14:21:46Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTc5MTM0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyMjoyMlrOGAXqZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyMjoyMlrOGAXqZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MDg3MQ==", "bodyText": "Doesn't agree with the actual return type, and it's a useless comment", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403040871", "createdAt": "2020-04-03T14:22:22Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTc5MzgyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyMjo1MFrOGAXr5w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyMjo1MFrOGAXr5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MTI1NQ==", "bodyText": "@link these types please", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403041255", "createdAt": "2020-04-03T14:22:50Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\tResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n+\n+\t/**\n+\t * Saves the resource using the given file system access.\n+\t */\n+\tvoid saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageWritable wrapping the given OutputStream", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 61}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTc5NDE0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyMjo1NFrOGAXsHA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyMjo1NFrOGAXsHA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MTMwOA==", "bodyText": "@link these types please", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403041308", "createdAt": "2020-04-03T14:22:54Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/IResourceStorageFacade.java", "diffHunk": "@@ -22,37 +22,36 @@\n  * @since 2.8\n  */\n public interface IResourceStorageFacade {\n-  /**\n-   * @return whether the given resource should and can be loaded from stored resource state\n-   */\n-  boolean shouldLoadFromStorage(StorageAwareResource resource);\n-  \n-  /**\n-   * @return whether storage data exists for the given URI\n-   */\n-  boolean hasStorageFor(URI uri);\n-  \n-  /**\n-   * Finds or creates a ResourceStorageLoadable for the given resource.\n-   * Clients should first call shouldLoadFromStorage to check whether there exists a storage version\n-   * of the given resource.\n-   * \n-   * @return an IResourceStorageLoadable\n-   */\n-  ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n-  \n-  /**\n-   * Saves the resource using the given file system access.\n-   */\n-  void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n-   */\n-  ResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n-  \n-  /**\n-   * Creates a fresh ResourceStorageLoadable wrapping the given InputStream\n-   */\n-  ResourceStorageLoadable createResourceStorageLoadable(InputStream inputStream);\n+\t/**\n+\t * @return whether the given resource should and can be loaded from stored resource state\n+\t */\n+\tboolean shouldLoadFromStorage(StorageAwareResource resource);\n+\n+\t/**\n+\t * @return whether storage data exists for the given URI\n+\t */\n+\tboolean hasStorageFor(URI uri);\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\tResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource);\n+\n+\t/**\n+\t * Saves the resource using the given file system access.\n+\t */\n+\tvoid saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageWritable wrapping the given OutputStream\n+\t */\n+\tResourceStorageWritable createResourceStorageWritable(OutputStream outputStream);\n+\n+\t/**\n+\t * Creates a fresh ResourceStorageLoadable wrapping the given InputStream", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 66}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTgwMDAzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyNDoxOVrOGAXv4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyNDoxOVrOGAXv4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MjI3Mg==", "bodyText": "Doesn't agree with actual type and is a pretty useless comment", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403042272", "createdAt": "2020-04-03T14:24:19Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 63}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTgwNTk0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyNTozMVrOGAXzcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyNTozMVrOGAXzcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MzE4NA==", "bodyText": "s/ResourceStorageFacade.LOG/LOG/", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403043184", "createdAt": "2020-04-03T14:25:31Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call\n+\t * shouldLoadFromStorage to check whether there exists a storage version of the given resource.\n+\t * \n+\t * @return an IResourceStorageLoadable\n+\t */\n+\t@Override\n+\tpublic ResourceStorageLoadable getOrCreateResourceStorageLoadable(StorageAwareResource resource) {\n+\t\ttry {\n+\t\t\tResourceStorageProviderAdapter stateProvider = head(\n+\t\t\t\t\tfilter(resource.getResourceSet().eAdapters(), ResourceStorageProviderAdapter.class));\n+\t\t\tif (stateProvider != null) {\n+\t\t\t\tResourceStorageLoadable loadable = stateProvider.getResourceStorageLoadable(resource);\n+\t\t\t\tif (loadable != null)\n+\t\t\t\t\treturn loadable;\n+\t\t\t}\n+\t\t\tif (resource.getResourceSet().getURIConverter().exists(getBinaryStorageURI(resource.getURI()),\n+\t\t\t\t\tCollections.emptyMap())) {\n+\t\t\t\treturn createResourceStorageLoadable(resource.getResourceSet().getURIConverter()\n+\t\t\t\t\t\t.createInputStream(getBinaryStorageURI(resource.getURI())));\n+\t\t\t}\n+\t\t\treturn createResourceStorageLoadable(\n+\t\t\t\t\tgetFileSystemAccess(resource).readBinaryFile(computeOutputPath(resource)));\n+\t\t} catch (IOException e) {\n+\t\t\tthrow new RuntimeIOException(e);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic void saveResource(StorageAwareResource resource, IFileSystemAccessExtension3 fsa) {\n+\t\tMyByteArrayOutputStream bout = new MyByteArrayOutputStream();\n+\t\ttry {\n+\t\t\tcreateResourceStorageWritable(bout).writeResource(resource);\n+\t\t} catch (IOException e) {\n+\t\t\tResourceStorageFacade.LOG.warn(\"Cannot write storage for \" + resource.getURI(), e);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 93}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTgwODM0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyNjowN1rOGAX06g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyNjowN1rOGAX06g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0MzU2Mg==", "bodyText": "@link on this and the next line please", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403043562", "createdAt": "2020-04-03T14:26:07Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageFacade.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.util.Collections;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.impl.ExtensibleURIConverterImpl;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.generator.AbstractFileSystemAccess2;\n+import org.eclipse.xtext.generator.IContextualOutputConfigurationProvider;\n+import org.eclipse.xtext.generator.IFileSystemAccessExtension3;\n+import org.eclipse.xtext.util.RuntimeIOException;\n+import org.eclipse.xtext.xbase.lib.Pure;\n+\n+import com.google.inject.Inject;\n+import com.google.inject.Provider;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageFacade implements IResourceStorageFacade {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageFacade.class);\n+\n+\t@Inject\n+\tprivate IContextualOutputConfigurationProvider outputConfigurationProvider;\n+\n+\t@Inject\n+\tprivate Provider<AbstractFileSystemAccess2> fileSystemAccessProvider;\n+\n+\t@Accessors\n+\tprivate boolean storeNodeModel = false;\n+\n+\t/**\n+\t * @return whether the given resource should be loaded from stored resource state\n+\t */\n+\t@Override\n+\tpublic boolean shouldLoadFromStorage(StorageAwareResource resource) {\n+\t\tSourceLevelURIsAdapter adapter = SourceLevelURIsAdapter.findInstalledAdapter(resource.getResourceSet());\n+\t\tif (adapter == null || adapter.getSourceLevelURIs().contains(resource.getURI()))\n+\t\t\treturn false;\n+\t\treturn doesStorageExist(resource);\n+\t}\n+\n+\t/**\n+\t * Finds or creates a ResourceStorageLoadable for the given resource. Clients should first call", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 60}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTgxNDUwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyNzoyMlrOGAX4tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDoyNzoyMlrOGAX4tA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0NDUzMg==", "bodyText": "s/ResourceStorageLoadable.LOG/LOG/", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403044532", "createdAt": "2020-04-03T14:27:22Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageLoadable.java", "diffHunk": "@@ -0,0 +1,118 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.BufferedInputStream;\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.ObjectInputStream;\n+import java.util.Collections;\n+import java.util.zip.ZipInputStream;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.resource.impl.BinaryResourceImpl;\n+import org.eclipse.xtext.nodemodel.impl.SerializableNodeModel;\n+import org.eclipse.xtext.nodemodel.serialization.DeserializationConversionContext;\n+import org.eclipse.xtext.parser.ParseResult;\n+\n+import com.google.common.io.CharStreams;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageLoadable {\n+\tprivate static final Logger LOG = Logger.getLogger(ResourceStorageLoadable.class);\n+\n+\tprivate final InputStream in;\n+\n+\tprivate final boolean storeNodeModel;\n+\n+\tpublic ResourceStorageLoadable(InputStream in, boolean storeNodeModel) {\n+\t\tthis.in = in;\n+\t\tthis.storeNodeModel = storeNodeModel;\n+\t}\n+\n+\tprotected void loadIntoResource(StorageAwareResource resource) throws IOException {\n+\t\tif (!resource.isLoadedFromStorage())\n+\t\t\tthrow new IllegalStateException(\"Please use StorageAwareResource#load(ResourceStorageLoadable).\");\n+\t\ttry (ZipInputStream zin = new ZipInputStream(in)) {\n+\t\t\tloadEntries(resource, zin);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Load entries from the storage. Overriding methods should first delegate to super before adding their own entries.\n+\t */\n+\tprotected void loadEntries(StorageAwareResource resource, ZipInputStream zipIn) throws IOException {\n+\t\tzipIn.getNextEntry();\n+\t\treadContents(resource, new BufferedInputStream(zipIn));\n+\t\tzipIn.getNextEntry();\n+\t\treadResourceDescription(resource, new BufferedInputStream(zipIn));\n+\t\tif (storeNodeModel) {\n+\t\t\tzipIn.getNextEntry();\n+\t\t\treadNodeModel(resource, new BufferedInputStream(zipIn));\n+\t\t}\n+\t}\n+\n+\tprotected void readContents(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\tnew BinaryResourceImpl.EObjectInputStream(inputStream, Collections.emptyMap()) {\n+\t\t\t@Override\n+\t\t\tpublic int readCompressedInt() throws IOException {\n+\t\t\t\tresourceSet = null;\n+\t\t\t\treturn super.readCompressedInt();\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic InternalEObject loadEObject() throws IOException {\n+\t\t\t\tInternalEObject result = super.loadEObject();\n+\t\t\t\thandleLoadEObject(result, this);\n+\t\t\t\treturn result;\n+\t\t\t}\n+\t\t}.loadResource(resource);\n+\t}\n+\n+\tprotected Object handleLoadEObject(InternalEObject loaded, BinaryResourceImpl.EObjectInputStream input)\n+\t\t\tthrows IOException {\n+\t\treturn null;\n+\t}\n+\n+\tprotected void readResourceDescription(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\ttry {\n+\t\t\tSerializableResourceDescription description = (SerializableResourceDescription) new ObjectInputStream(\n+\t\t\t\t\tinputStream).readObject();\n+\t\t\tdescription.updateResourceURI(resource.getURI());\n+\t\t\tresource.setResourceDescription(description);\n+\t\t} catch (ClassNotFoundException e) {\n+\t\t\tthrow new RuntimeException(e);\n+\t\t}\n+\t}\n+\n+\tprotected void readNodeModel(StorageAwareResource resource, InputStream inputStream) throws IOException {\n+\t\tSerializableNodeModel serializableNodeModel = new SerializableNodeModel(resource);\n+\t\tif (!resource.getResourceSet().getURIConverter().exists(resource.getURI(),\n+\t\t\t\tresource.getResourceSet().getLoadOptions())) {\n+\t\t\tResourceStorageLoadable.LOG.info(\"Skipping loading node model for synthetic resource \" + resource.getURI());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 105}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTgzOTU1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableEObjectDescription.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozMjo1OVrOGAYIVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozMjo1OVrOGAYIVg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0ODUzNA==", "bodyText": "You could use userData.keySet().stream().toArray(String[]::new)", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403048534", "createdAt": "2020-04-03T14:32:59Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableEObjectDescription.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.HashMap;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.InternalEObject;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.xbase.lib.Conversions;\n+\n+/**\n+ * @since 2.8\n+ */\n+public class SerializableEObjectDescription\n+\t\timplements IEObjectDescription, Externalizable, SerializableEObjectDescriptionProvider {\n+\tprotected URI eObjectURI;\n+\n+\tprotected EClass eClass;\n+\n+\tprotected QualifiedName qualifiedName;\n+\n+\tprotected HashMap<String, String> userData;\n+\n+\tprotected transient EObject eObjectOrProxy;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\teObjectURI = uri.appendFragment(eObjectURI.fragment());\n+\t}\n+\n+\t@Override\n+\tpublic EObject getEObjectOrProxy() {\n+\t\tif (eObjectOrProxy == null) {\n+\t\t\tEObject proxy = EcoreUtil.create(eClass);\n+\t\t\t((InternalEObject) proxy).eSetProxyURI(eObjectURI);\n+\t\t\teObjectOrProxy = proxy;\n+\t\t}\n+\t\treturn eObjectOrProxy;\n+\t}\n+\n+\t@Override\n+\tpublic QualifiedName getName() {\n+\t\treturn qualifiedName;\n+\t}\n+\n+\t@Override\n+\tpublic String getUserData(String key) {\n+\t\treturn userData.get(key);\n+\t}\n+\n+\t@Override\n+\tpublic String[] getUserDataKeys() {\n+\t\treturn (String[]) Conversions.unwrapArray(userData.keySet(), String.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 69}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTg0Mzg4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableReferenceDescription.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozNDowMFrOGAYLBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozNDowMFrOGAYLBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA0OTIyMA==", "bodyText": "Update copyright", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403049220", "createdAt": "2020-04-03T14:34:00Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableReferenceDescription.java", "diffHunk": "@@ -0,0 +1,99 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 2}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTg1MTk3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozNTo1NlrOGAYQMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMlQxMzo0MzoyMlrOGJ3LOg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MDU0Nw==", "bodyText": "I don't immediately say why the casts are needed? Isn't SerializableEObjectDescription instanceof IEObjectDescription", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403050547", "createdAt": "2020-04-03T14:35:56Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5NDM2Mg==", "bodyText": "True. But a List< SerializableEObjectDescription> is not a List<IEObjectDescription>.", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r412994362", "createdAt": "2020-04-22T13:43:22Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MDU0Nw=="}, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 58}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTg1NTcxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozNjo0NlrOGAYSgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozNjo0NlrOGAYSgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MTEzOQ==", "bodyText": "SerializableResourceDescription::createCopy", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403051139", "createdAt": "2020-04-03T14:36:46Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {\n+\t\tthis.uRI = uRI;\n+\t}\n+\n+\tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n+\t\tSerializableResourceDescription description = new SerializableResourceDescription();\n+\t\tdescription.setURI(desc.getURI());\n+\t\tdescription.descriptions = toList(\n+\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 135}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ5OTg1NjA0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozNjo1MVrOGAYStw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wM1QxNDozNjo1MVrOGAYStw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzA1MTE5MQ==", "bodyText": "SerializableResourceDescription::createCopy", "url": "https://github.com/eclipse/xtext-core/pull/1437#discussion_r403051191", "createdAt": "2020-04-03T14:36:51Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SerializableResourceDescription.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import static org.eclipse.xtext.resource.persistence.SerializationExtensions.*;\n+import static org.eclipse.xtext.xbase.lib.IterableExtensions.*;\n+\n+import java.io.Externalizable;\n+import java.io.IOException;\n+import java.io.ObjectInput;\n+import java.io.ObjectOutput;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.impl.AbstractResourceDescription;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SerializableResourceDescription extends AbstractResourceDescription implements Externalizable {\n+\n+\tprivate List<SerializableEObjectDescription> descriptions = Collections.emptyList();\n+\n+\tprivate List<SerializableReferenceDescription> references = Collections.emptyList();\n+\n+\tprivate List<QualifiedName> importedNames = Collections.emptyList();\n+\n+\tprivate URI uRI;\n+\n+\tpublic void updateResourceURI(URI uri) {\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tref.updateResourceURI(uri, uRI);\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tdesc.updateResourceURI(uri);\n+\t\tuRI = uri;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected List<IEObjectDescription> computeExportedObjects() {\n+\t\treturn ((List<IEObjectDescription>) ((List<?>) this.descriptions));\n+\t}\n+\n+\t@Override\n+\tpublic Iterable<QualifiedName> getImportedNames() {\n+\t\treturn importedNames;\n+\t}\n+\n+\t@Override\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic Iterable<IReferenceDescription> getReferenceDescriptions() {\n+\t\treturn ((Iterable<IReferenceDescription>) ((Iterable<?>) references));\n+\t}\n+\n+\t@Override\n+\tpublic void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {\n+\t\tsetURI(readURI(in));\n+\t\tint descriptionsSize = in.readInt();\n+\t\tdescriptions = new ArrayList<>(descriptionsSize);\n+\t\tfor (int i = 0; i < descriptionsSize; i++)\n+\t\t\tdescriptions.add(readCastedObject(in));\n+\t\tint referencesSize = in.readInt();\n+\t\treferences = new ArrayList<>(referencesSize);\n+\t\tfor (int i = 0; i < referencesSize; i++)\n+\t\t\treferences.add(readCastedObject(in));\n+\t\tint importedNamesSize = in.readInt();\n+\t\timportedNames = new ArrayList<>(importedNamesSize);\n+\t\tfor (int i = 0; i < importedNamesSize; i++)\n+\t\t\timportedNames.add(readQualifiedName(in));\n+\t}\n+\n+\t@Override\n+\tpublic void writeExternal(ObjectOutput out) throws IOException {\n+\t\twriteURI(out, uRI);\n+\t\tout.writeInt(descriptions.size());\n+\t\tfor (SerializableEObjectDescription desc : descriptions)\n+\t\t\tout.writeObject(desc);\n+\t\tout.writeInt(references.size());\n+\t\tfor (SerializableReferenceDescription ref : references)\n+\t\t\tout.writeObject(ref);\n+\t\tout.writeInt(importedNames.size());\n+\t\tfor (QualifiedName name : this.importedNames)\n+\t\t\tSerializationExtensions.writeQualifiedName(out, name);\n+\t}\n+\n+\tpublic List<SerializableEObjectDescription> getDescriptions() {\n+\t\treturn descriptions;\n+\t}\n+\n+\tpublic void setDescriptions(List<SerializableEObjectDescription> descriptions) {\n+\t\tthis.descriptions = descriptions;\n+\t}\n+\n+\tpublic List<SerializableReferenceDescription> getReferences() {\n+\t\treturn references;\n+\t}\n+\n+\tpublic void setReferences(List<SerializableReferenceDescription> references) {\n+\t\tthis.references = references;\n+\t}\n+\n+\tpublic void setImportedNames(List<QualifiedName> importedNames) {\n+\t\tthis.importedNames = importedNames;\n+\t}\n+\n+\tpublic URI getURI() {\n+\t\treturn uRI;\n+\t}\n+\n+\tpublic void setURI(URI uRI) {\n+\t\tthis.uRI = uRI;\n+\t}\n+\n+\tpublic static SerializableResourceDescription createCopy(IResourceDescription desc) {\n+\t\tSerializableResourceDescription description = new SerializableResourceDescription();\n+\t\tdescription.setURI(desc.getURI());\n+\t\tdescription.descriptions = toList(\n+\t\t\t\tmap(desc.getExportedObjects(), it -> SerializableResourceDescription.createCopy(it)));\n+\t\tdescription.references = toList(\n+\t\t\t\tmap(desc.getReferenceDescriptions(), it -> SerializableResourceDescription.createCopy(it)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6ae39b4db197bb2ac5dc5fc4114e5a41db55bdfb"}, "originalPosition": 137}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1070, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}