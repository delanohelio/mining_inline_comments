{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTEwMDAyOTcy", "number": 1600, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0NjozMlrOEx4mKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0OTowN1rOEx4pqg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzQyOTU1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0NjozMlrOHoN3sw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo1NDoyNlrOHoOJhQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMjMzOQ==", "bodyText": "Not static final on these fields?", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511932339", "createdAt": "2020-10-26T12:46:32Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 409}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMjUxNg==", "bodyText": "Also, can't you just use \\R here?", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511932516", "createdAt": "2020-10-26T12:46:51Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMjMzOQ=="}, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 409}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzNjkwMQ==", "bodyText": "finals change was unintended", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511936901", "createdAt": "2020-10-26T12:54:26Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMjMzOQ=="}, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 409}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzQyOTU2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/node/TracedAccessorsProcessor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0NjozMlrOHoN3tQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0NzoxN1rOHoN5Mg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMjM0MQ==", "bodyText": "Java11 -> Set.of(..)?", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511932341", "createdAt": "2020-10-26T12:46:32Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/node/TracedAccessorsProcessor.java", "diffHunk": "@@ -26,19 +26,19 @@\n import org.eclipse.xtend.lib.macro.declaration.TypeReference;\n import org.eclipse.xtend2.lib.StringConcatenationClient;\n import org.eclipse.xtext.generator.trace.ILocationData;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Extension;\n import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.ListExtensions;\n import org.eclipse.xtext.xbase.lib.StringExtensions;\n \n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n \n public class TracedAccessorsProcessor extends AbstractClassProcessor {\n \n \tprivate static final Set<String> TYPES_WITH_GOOD_TO_STRING = Collections", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMjcyMg==", "bodyText": "no java 11 yet", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511932722", "createdAt": "2020-10-26T12:47:17Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/generator/trace/node/TracedAccessorsProcessor.java", "diffHunk": "@@ -26,19 +26,19 @@\n import org.eclipse.xtend.lib.macro.declaration.TypeReference;\n import org.eclipse.xtend2.lib.StringConcatenationClient;\n import org.eclipse.xtext.generator.trace.ILocationData;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Extension;\n import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.ListExtensions;\n import org.eclipse.xtext.xbase.lib.StringExtensions;\n \n import com.google.common.collect.FluentIterable;\n import com.google.common.collect.Iterables;\n+import com.google.common.collect.Sets;\n \n public class TracedAccessorsProcessor extends AbstractClassProcessor {\n \n \tprivate static final Set<String> TYPES_WITH_GOOD_TO_STRING = Collections", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMjM0MQ=="}, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzQzMDM4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext/src/org/eclipse/xtext/tasks/PreferenceTaskTagProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0Njo0NlrOHoN4Nw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0Njo0NlrOHoN4Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMjQ3MQ==", "bodyText": "List.of", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511932471", "createdAt": "2020-10-26T12:46:46Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/tasks/PreferenceTaskTagProvider.java", "diffHunk": "@@ -36,7 +36,7 @@\n \tpublic static final PreferenceKey CASE_SENSITIVE_KEY = new PreferenceKey(\"task.caseSensitive\", \"true\");\n \n \tpublic static final List<PreferenceKey> KEYS = Collections.<PreferenceKey>unmodifiableList(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 21}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzQzNDUzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0Nzo1OVrOHoN66Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0Nzo1OVrOHoN66Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMzE2MQ==", "bodyText": "Hmm, underscore in names is very weird imo, maybe cont is better?", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511933161", "createdAt": "2020-10-26T12:47:59Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n+\n+\tprivate static String WS = \"( |\\\\t)+\";\n+\n+\tprivate static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n+\n+\tprivate static String ML_COMMENT = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\treturn \"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\";\n+\t\t}\n+\t}.apply();\n+\n+\tprivate Pattern p_slComment = Pattern.compile(SL_COMMENT);\n+\n+\tprivate Pattern p_mlComment = Pattern.compile(ML_COMMENT);\n+\n+\tprivate Pattern p_token = Pattern.compile(TOKEN);\n+\n+\tprivate Pattern p_newline = Pattern.compile(NEWLINE);\n+\n+\tprivate Pattern p_ws = Pattern.compile(WS);\n+\n+\tprivate Pattern compoundPattern = new Function0<Pattern>() {\n+\t\tpublic Pattern apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(\"(\");\n+\t\t\tbuilder.append(SL_COMMENT, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(ML_COMMENT, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(TOKEN, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(NEWLINE, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(WS, \"\");\n+\t\t\tbuilder.append(\")\");\n+\t\t\treturn Pattern.compile(builder.toString(), Pattern.MULTILINE);\n+\t\t}\n+\t}.apply();\n+\n+\tprivate ErrorContext errorContext;\n+\n+\t/**\n+\t * Performs the actual comparison of given and expected grammar.\n+\t * \n+\t * @return {@link Pair} containing the number of lines of the tested grammar\n+\t * (key) and the referenced grammar (value) for logging purposes\n+\t */\n+\tpublic ErrorContext compareGrammars(CharSequence grammar, CharSequence grammarReference,\n+\t\t\tString absoluteGrammarFileName, String absoluteGrammarFileNameReference, IErrorHandler errorHandler) {\n+\t\terrorContext = new ErrorContext();\n+\t\terrorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n+\t\terrorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n+\t\treturn compareGrammars(grammar, grammarReference, errorHandler);\n+\t}\n+\n+\t/**\n+\t * Performs the actual comparison of given and expected grammar.\n+\t * \n+\t * @return {@link Pair} containing the number of lines of the tested grammar\n+\t * (key) and the referenced grammar (value) for logging purposes\n+\t */\n+\tpublic ErrorContext compareGrammars(CharSequence grammar, CharSequence grammarReference,\n+\t\t\tIErrorHandler errorHandler) {\n+\t\tif (errorContext == null) {\n+\t\t\terrorContext = new ErrorContext();\n+\t\t}\n+\t\tMatcher compoundMatcher = compoundPattern.matcher(grammar);\n+\t\tMatcher compoundMatcherReference = compoundPattern.matcher(grammarReference);\n+\t\tboolean continue_ = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 478}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzQzNjAyOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0ODoyNlrOHoN71g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0ODoyNlrOHoN71g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMzM5OA==", "bodyText": "s/continue/Continue/", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511933398", "createdAt": "2020-10-26T12:48:26Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n+\n+\tprivate static String WS = \"( |\\\\t)+\";\n+\n+\tprivate static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n+\n+\tprivate static String ML_COMMENT = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\treturn \"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\";\n+\t\t}\n+\t}.apply();\n+\n+\tprivate Pattern p_slComment = Pattern.compile(SL_COMMENT);\n+\n+\tprivate Pattern p_mlComment = Pattern.compile(ML_COMMENT);\n+\n+\tprivate Pattern p_token = Pattern.compile(TOKEN);\n+\n+\tprivate Pattern p_newline = Pattern.compile(NEWLINE);\n+\n+\tprivate Pattern p_ws = Pattern.compile(WS);\n+\n+\tprivate Pattern compoundPattern = new Function0<Pattern>() {\n+\t\tpublic Pattern apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(\"(\");\n+\t\t\tbuilder.append(SL_COMMENT, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(ML_COMMENT, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(TOKEN, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(NEWLINE, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(WS, \"\");\n+\t\t\tbuilder.append(\")\");\n+\t\t\treturn Pattern.compile(builder.toString(), Pattern.MULTILINE);\n+\t\t}\n+\t}.apply();\n+\n+\tprivate ErrorContext errorContext;\n+\n+\t/**\n+\t * Performs the actual comparison of given and expected grammar.\n+\t * \n+\t * @return {@link Pair} containing the number of lines of the tested grammar\n+\t * (key) and the referenced grammar (value) for logging purposes\n+\t */\n+\tpublic ErrorContext compareGrammars(CharSequence grammar, CharSequence grammarReference,\n+\t\t\tString absoluteGrammarFileName, String absoluteGrammarFileNameReference, IErrorHandler errorHandler) {\n+\t\terrorContext = new ErrorContext();\n+\t\terrorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n+\t\terrorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n+\t\treturn compareGrammars(grammar, grammarReference, errorHandler);\n+\t}\n+\n+\t/**\n+\t * Performs the actual comparison of given and expected grammar.\n+\t * \n+\t * @return {@link Pair} containing the number of lines of the tested grammar\n+\t * (key) and the referenced grammar (value) for logging purposes\n+\t */\n+\tpublic ErrorContext compareGrammars(CharSequence grammar, CharSequence grammarReference,\n+\t\t\tIErrorHandler errorHandler) {\n+\t\tif (errorContext == null) {\n+\t\t\terrorContext = new ErrorContext();\n+\t\t}\n+\t\tMatcher compoundMatcher = compoundPattern.matcher(grammar);\n+\t\tMatcher compoundMatcherReference = compoundPattern.matcher(grammarReference);\n+\t\tboolean continue_ = true;\n+\t\tboolean continueReference = true;\n+\t\twhile (continue_ || continueReference) {\n+\t\t\tif (continue_) {\n+\t\t\t\tcontinue_ = nextToken(compoundMatcher, errorContext.testedGrammar, errorHandler);\n+\t\t\t}\n+\t\t\tString match = null;\n+\t\t\tif (continue_) {\n+\t\t\t\tmatch = compoundMatcher.group();\n+\t\t\t} else {\n+\t\t\t\tmatch = \"\ufffd\ufffdeof\ufffd\ufffd\";\n+\t\t\t}\n+\t\t\tif (continueReference) {\n+\t\t\t\tcontinueReference = nextToken(compoundMatcherReference, errorContext.referenceGrammar, errorHandler);\n+\t\t\t}\n+\t\t\tString matchReference = null;\n+\t\t\tif (continueReference) {\n+\t\t\t\tmatchReference = compoundMatcherReference.group();\n+\t\t\t} else {\n+\t\t\t\tmatchReference = \"\ufffd\ufffdeof\ufffd\ufffd\";\n+\t\t\t}\n+\t\t\tif (!Objects.equal(matchReference, match)) {\n+\t\t\t\terrorHandler.handleMismatch(match, matchReference, errorContext);\n+\t\t\t}\n+\t\t}\n+\t\treturn errorContext;\n+\t}\n+\n+\t/**\n+\t * continue matching until the next token is found, count newlines while", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 507}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzQzNzExOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0ODo0NVrOHoN8fg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMzowODo1M1rOHoOqMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMzU2Ng==", "bodyText": "Not .equals?", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511933566", "createdAt": "2020-10-26T12:48:45Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n+\n+\tprivate static String WS = \"( |\\\\t)+\";\n+\n+\tprivate static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n+\n+\tprivate static String ML_COMMENT = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\treturn \"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\";\n+\t\t}\n+\t}.apply();\n+\n+\tprivate Pattern p_slComment = Pattern.compile(SL_COMMENT);\n+\n+\tprivate Pattern p_mlComment = Pattern.compile(ML_COMMENT);\n+\n+\tprivate Pattern p_token = Pattern.compile(TOKEN);\n+\n+\tprivate Pattern p_newline = Pattern.compile(NEWLINE);\n+\n+\tprivate Pattern p_ws = Pattern.compile(WS);\n+\n+\tprivate Pattern compoundPattern = new Function0<Pattern>() {\n+\t\tpublic Pattern apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(\"(\");\n+\t\t\tbuilder.append(SL_COMMENT, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(ML_COMMENT, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(TOKEN, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(NEWLINE, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(WS, \"\");\n+\t\t\tbuilder.append(\")\");\n+\t\t\treturn Pattern.compile(builder.toString(), Pattern.MULTILINE);\n+\t\t}\n+\t}.apply();\n+\n+\tprivate ErrorContext errorContext;\n+\n+\t/**\n+\t * Performs the actual comparison of given and expected grammar.\n+\t * \n+\t * @return {@link Pair} containing the number of lines of the tested grammar\n+\t * (key) and the referenced grammar (value) for logging purposes\n+\t */\n+\tpublic ErrorContext compareGrammars(CharSequence grammar, CharSequence grammarReference,\n+\t\t\tString absoluteGrammarFileName, String absoluteGrammarFileNameReference, IErrorHandler errorHandler) {\n+\t\terrorContext = new ErrorContext();\n+\t\terrorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n+\t\terrorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n+\t\treturn compareGrammars(grammar, grammarReference, errorHandler);\n+\t}\n+\n+\t/**\n+\t * Performs the actual comparison of given and expected grammar.\n+\t * \n+\t * @return {@link Pair} containing the number of lines of the tested grammar\n+\t * (key) and the referenced grammar (value) for logging purposes\n+\t */\n+\tpublic ErrorContext compareGrammars(CharSequence grammar, CharSequence grammarReference,\n+\t\t\tIErrorHandler errorHandler) {\n+\t\tif (errorContext == null) {\n+\t\t\terrorContext = new ErrorContext();\n+\t\t}\n+\t\tMatcher compoundMatcher = compoundPattern.matcher(grammar);\n+\t\tMatcher compoundMatcherReference = compoundPattern.matcher(grammarReference);\n+\t\tboolean continue_ = true;\n+\t\tboolean continueReference = true;\n+\t\twhile (continue_ || continueReference) {\n+\t\t\tif (continue_) {\n+\t\t\t\tcontinue_ = nextToken(compoundMatcher, errorContext.testedGrammar, errorHandler);\n+\t\t\t}\n+\t\t\tString match = null;\n+\t\t\tif (continue_) {\n+\t\t\t\tmatch = compoundMatcher.group();\n+\t\t\t} else {\n+\t\t\t\tmatch = \"\ufffd\ufffdeof\ufffd\ufffd\";\n+\t\t\t}\n+\t\t\tif (continueReference) {\n+\t\t\t\tcontinueReference = nextToken(compoundMatcherReference, errorContext.referenceGrammar, errorHandler);\n+\t\t\t}\n+\t\t\tString matchReference = null;\n+\t\t\tif (continueReference) {\n+\t\t\t\tmatchReference = compoundMatcherReference.group();\n+\t\t\t} else {\n+\t\t\t\tmatchReference = \"\ufffd\ufffdeof\ufffd\ufffd\";\n+\t\t\t}\n+\t\t\tif (!Objects.equal(matchReference, match)) {\n+\t\t\t\terrorHandler.handleMismatch(match, matchReference, errorContext);\n+\t\t\t}\n+\t\t}\n+\t\treturn errorContext;\n+\t}\n+\n+\t/**\n+\t * continue matching until the next token is found, count newlines while\n+\t * doing so.\n+\t * \n+\t * @return the number of newlines passed while searching\n+\t */\n+\tprivate boolean nextToken(Matcher matcher, MatchState state, IErrorHandler errorHandler) {\n+\t\twhile (matcher.find()) {\n+\t\t\tstate.currentToken = matcher.group();\n+\t\t\tif (matcher.start() != state.position) {\n+\t\t\t\thandleInvalidGrammarFile(errorHandler, state);\n+\t\t\t}\n+\t\t\tString match = matcher.group();\n+\t\t\tstate.previousToken = match;\n+\t\t\tstate.position = matcher.end();\n+\t\t\tif (p_newline.matcher(match).matches()) {\n+\t\t\t\tstate.lineNumber++;\n+\t\t\t} else {\n+\t\t\t\tif (p_slComment.matcher(match).matches() || p_ws.matcher(match).matches()) {\n+\t\t\t\t} else {\n+\t\t\t\t\tif (p_mlComment.matcher(match).matches()) {\n+\t\t\t\t\t\tMatcher newlines = p_newline.matcher(match);\n+\t\t\t\t\t\twhile (newlines.find()) {\n+\t\t\t\t\t\t\tstate.lineNumber++;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (p_token.matcher(match).matches()) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate void handleInvalidGrammarFile(IErrorHandler errorHandler, MatchState state) {\n+\t\tif (state == errorContext.testedGrammar) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 543}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0NTI2NQ==", "bodyText": "didnt want to change any semantics", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511945265", "createdAt": "2020-10-26T13:08:53Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n+\n+\tprivate static String WS = \"( |\\\\t)+\";\n+\n+\tprivate static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n+\n+\tprivate static String ML_COMMENT = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\treturn \"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\";\n+\t\t}\n+\t}.apply();\n+\n+\tprivate Pattern p_slComment = Pattern.compile(SL_COMMENT);\n+\n+\tprivate Pattern p_mlComment = Pattern.compile(ML_COMMENT);\n+\n+\tprivate Pattern p_token = Pattern.compile(TOKEN);\n+\n+\tprivate Pattern p_newline = Pattern.compile(NEWLINE);\n+\n+\tprivate Pattern p_ws = Pattern.compile(WS);\n+\n+\tprivate Pattern compoundPattern = new Function0<Pattern>() {\n+\t\tpublic Pattern apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(\"(\");\n+\t\t\tbuilder.append(SL_COMMENT, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(ML_COMMENT, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(TOKEN, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(NEWLINE, \"\");\n+\t\t\tbuilder.append(\")|(\");\n+\t\t\tbuilder.append(WS, \"\");\n+\t\t\tbuilder.append(\")\");\n+\t\t\treturn Pattern.compile(builder.toString(), Pattern.MULTILINE);\n+\t\t}\n+\t}.apply();\n+\n+\tprivate ErrorContext errorContext;\n+\n+\t/**\n+\t * Performs the actual comparison of given and expected grammar.\n+\t * \n+\t * @return {@link Pair} containing the number of lines of the tested grammar\n+\t * (key) and the referenced grammar (value) for logging purposes\n+\t */\n+\tpublic ErrorContext compareGrammars(CharSequence grammar, CharSequence grammarReference,\n+\t\t\tString absoluteGrammarFileName, String absoluteGrammarFileNameReference, IErrorHandler errorHandler) {\n+\t\terrorContext = new ErrorContext();\n+\t\terrorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n+\t\terrorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n+\t\treturn compareGrammars(grammar, grammarReference, errorHandler);\n+\t}\n+\n+\t/**\n+\t * Performs the actual comparison of given and expected grammar.\n+\t * \n+\t * @return {@link Pair} containing the number of lines of the tested grammar\n+\t * (key) and the referenced grammar (value) for logging purposes\n+\t */\n+\tpublic ErrorContext compareGrammars(CharSequence grammar, CharSequence grammarReference,\n+\t\t\tIErrorHandler errorHandler) {\n+\t\tif (errorContext == null) {\n+\t\t\terrorContext = new ErrorContext();\n+\t\t}\n+\t\tMatcher compoundMatcher = compoundPattern.matcher(grammar);\n+\t\tMatcher compoundMatcherReference = compoundPattern.matcher(grammarReference);\n+\t\tboolean continue_ = true;\n+\t\tboolean continueReference = true;\n+\t\twhile (continue_ || continueReference) {\n+\t\t\tif (continue_) {\n+\t\t\t\tcontinue_ = nextToken(compoundMatcher, errorContext.testedGrammar, errorHandler);\n+\t\t\t}\n+\t\t\tString match = null;\n+\t\t\tif (continue_) {\n+\t\t\t\tmatch = compoundMatcher.group();\n+\t\t\t} else {\n+\t\t\t\tmatch = \"\ufffd\ufffdeof\ufffd\ufffd\";\n+\t\t\t}\n+\t\t\tif (continueReference) {\n+\t\t\t\tcontinueReference = nextToken(compoundMatcherReference, errorContext.referenceGrammar, errorHandler);\n+\t\t\t}\n+\t\t\tString matchReference = null;\n+\t\t\tif (continueReference) {\n+\t\t\t\tmatchReference = compoundMatcherReference.group();\n+\t\t\t} else {\n+\t\t\t\tmatchReference = \"\ufffd\ufffdeof\ufffd\ufffd\";\n+\t\t\t}\n+\t\t\tif (!Objects.equal(matchReference, match)) {\n+\t\t\t\terrorHandler.handleMismatch(match, matchReference, errorContext);\n+\t\t\t}\n+\t\t}\n+\t\treturn errorContext;\n+\t}\n+\n+\t/**\n+\t * continue matching until the next token is found, count newlines while\n+\t * doing so.\n+\t * \n+\t * @return the number of newlines passed while searching\n+\t */\n+\tprivate boolean nextToken(Matcher matcher, MatchState state, IErrorHandler errorHandler) {\n+\t\twhile (matcher.find()) {\n+\t\t\tstate.currentToken = matcher.group();\n+\t\t\tif (matcher.start() != state.position) {\n+\t\t\t\thandleInvalidGrammarFile(errorHandler, state);\n+\t\t\t}\n+\t\t\tString match = matcher.group();\n+\t\t\tstate.previousToken = match;\n+\t\t\tstate.position = matcher.end();\n+\t\t\tif (p_newline.matcher(match).matches()) {\n+\t\t\t\tstate.lineNumber++;\n+\t\t\t} else {\n+\t\t\t\tif (p_slComment.matcher(match).matches() || p_ws.matcher(match).matches()) {\n+\t\t\t\t} else {\n+\t\t\t\t\tif (p_mlComment.matcher(match).matches()) {\n+\t\t\t\t\t\tMatcher newlines = p_newline.matcher(match);\n+\t\t\t\t\t\twhile (newlines.find()) {\n+\t\t\t\t\t\t\tstate.lineNumber++;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tif (p_token.matcher(match).matches()) {\n+\t\t\t\t\t\t\treturn true;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\tprivate void handleInvalidGrammarFile(IErrorHandler errorHandler, MatchState state) {\n+\t\tif (state == errorContext.testedGrammar) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMzU2Ng=="}, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 543}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIwNzQzODUwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo0OTowN1rOHoN9Qw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yNlQxMjo1NDowOVrOHoOIxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMzc2Mw==", "bodyText": "Why no camelcase on these vars?", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511933763", "createdAt": "2020-10-26T12:49:07Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n+\n+\tprivate static String WS = \"( |\\\\t)+\";\n+\n+\tprivate static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n+\n+\tprivate static String ML_COMMENT = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\treturn \"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\";\n+\t\t}\n+\t}.apply();\n+\n+\tprivate Pattern p_slComment = Pattern.compile(SL_COMMENT);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 421}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzNjcwOQ==", "bodyText": "didnt want to change these or var names", "url": "https://github.com/eclipse/xtext-core/pull/1600#discussion_r511936709", "createdAt": "2020-10-26T12:54:09Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/generator/parser/AntlrGrammarComparator.java", "diffHunk": "@@ -8,299 +8,263 @@\n  */\n package org.eclipse.xtext.generator.parser;\n \n-import java.util.Collections;\n import java.util.List;\n import java.util.regex.Matcher;\n import java.util.regex.Pattern;\n \n import org.eclipse.xtend2.lib.StringConcatenation;\n-import org.eclipse.xtext.xbase.lib.CollectionLiterals;\n import org.eclipse.xtext.xbase.lib.Functions.Function0;\n-import org.eclipse.xtext.xbase.lib.IterableExtensions;\n import org.eclipse.xtext.xbase.lib.Pair;\n-import org.eclipse.xtext.xbase.lib.Pure;\n \n+import com.google.common.base.Joiner;\n import com.google.common.base.Objects;\n+import com.google.common.collect.Lists;\n \n /**\n- * Compares two charSequences of ANTLR grammars token by token.\n- * Ignores differences in white space, and counts line breaks for usable error diagnosis.\n+ * Compares two charSequences of ANTLR grammars token by token. Ignores\n+ * differences in white space, and counts line breaks for usable error\n+ * diagnosis.\n  * \n  * @author Christian Schneider - Initial contribution and API\n  * @noreference\n  */\n-@SuppressWarnings(\"all\")\n public class AntlrGrammarComparator {\n-  public interface IErrorHandler {\n-    public abstract void handleInvalidGeneratedGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleInvalidReferenceGrammarFile(final AntlrGrammarComparator.ErrorContext context);\n-    \n-    public abstract void handleMismatch(final String matched, final String expected, final AntlrGrammarComparator.ErrorContext context);\n-  }\n-  \n-  public static final class ErrorContext {\n-    private AntlrGrammarComparator.MatchState testedGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    private AntlrGrammarComparator.MatchState referenceGrammar = new AntlrGrammarComparator.MatchState();\n-    \n-    public AntlrGrammarComparator.MatchState reset() {\n-      AntlrGrammarComparator.MatchState _xblockexpression = null;\n-      {\n-        AntlrGrammarComparator.MatchState _matchState = new AntlrGrammarComparator.MatchState();\n-        this.testedGrammar = _matchState;\n-        AntlrGrammarComparator.MatchState _matchState_1 = new AntlrGrammarComparator.MatchState();\n-        _xblockexpression = this.referenceGrammar = _matchState_1;\n-      }\n-      return _xblockexpression;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getTestedGrammar() {\n-      return this.testedGrammar;\n-    }\n-    \n-    public void setTestedGrammar(final AntlrGrammarComparator.MatchState testedGrammar) {\n-      this.testedGrammar = testedGrammar;\n-    }\n-    \n-    @Pure\n-    public AntlrGrammarComparator.MatchState getReferenceGrammar() {\n-      return this.referenceGrammar;\n-    }\n-    \n-    public void setReferenceGrammar(final AntlrGrammarComparator.MatchState referenceGrammar) {\n-      this.referenceGrammar = referenceGrammar;\n-    }\n-  }\n-  \n-  public static final class MatchState {\n-    private String absoluteFileName;\n-    \n-    private int lineNumber = 1;\n-    \n-    private int position = 0;\n-    \n-    private String previousToken;\n-    \n-    private String currentToken;\n-    \n-    @Pure\n-    public String getAbsoluteFileName() {\n-      return this.absoluteFileName;\n-    }\n-    \n-    public void setAbsoluteFileName(final String absoluteFileName) {\n-      this.absoluteFileName = absoluteFileName;\n-    }\n-    \n-    @Pure\n-    public int getLineNumber() {\n-      return this.lineNumber;\n-    }\n-    \n-    public void setLineNumber(final int lineNumber) {\n-      this.lineNumber = lineNumber;\n-    }\n-    \n-    @Pure\n-    public String getPreviousToken() {\n-      return this.previousToken;\n-    }\n-    \n-    public void setPreviousToken(final String previousToken) {\n-      this.previousToken = previousToken;\n-    }\n-    \n-    @Pure\n-    public String getCurrentToken() {\n-      return this.currentToken;\n-    }\n-    \n-    public void setCurrentToken(final String currentToken) {\n-      this.currentToken = currentToken;\n-    }\n-  }\n-  \n-  private final static List<String> SINGLE_CHAR_TOKENS = Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\", \"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\"));\n-  \n-  private final static String QUOTED_TOKENS = IterableExtensions.join(Collections.<String>unmodifiableList(CollectionLiterals.<String>newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\")), \"|\");\n-  \n-  private final static String TOKEN = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      String _join = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS, \"|\");\n-      _builder.append(_join, \"\");\n-      _builder.append(\"|\");\n-      _builder.append(AntlrGrammarComparator.QUOTED_TOKENS, \"\");\n-      _builder.append(\"|[^\\\\s\\'\\\"\");\n-      String _join_1 = IterableExtensions.join(AntlrGrammarComparator.SINGLE_CHAR_TOKENS);\n-      _builder.append(_join_1, \"\");\n-      _builder.append(\"]+\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n-  \n-  private final static String WS = \"( |\\\\t)+\";\n-  \n-  private final static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n-  \n-  private final static String ML_COMMENT = new Function0<String>() {\n-    public String apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\");\n-      return _builder.toString();\n-    }\n-  }.apply();\n-  \n-  private final Pattern p_slComment = Pattern.compile(AntlrGrammarComparator.SL_COMMENT);\n-  \n-  private final Pattern p_mlComment = Pattern.compile(AntlrGrammarComparator.ML_COMMENT);\n-  \n-  private final Pattern p_token = Pattern.compile(AntlrGrammarComparator.TOKEN);\n-  \n-  private final Pattern p_newline = Pattern.compile(AntlrGrammarComparator.NEWLINE);\n-  \n-  private final Pattern p_ws = Pattern.compile(AntlrGrammarComparator.WS);\n-  \n-  private final Pattern compoundPattern = new Function0<Pattern>() {\n-    public Pattern apply() {\n-      StringConcatenation _builder = new StringConcatenation();\n-      _builder.append(\"(\");\n-      _builder.append(AntlrGrammarComparator.SL_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.ML_COMMENT, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.TOKEN, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.NEWLINE, \"\");\n-      _builder.append(\")|(\");\n-      _builder.append(AntlrGrammarComparator.WS, \"\");\n-      _builder.append(\")\");\n-      Pattern _compile = Pattern.compile(_builder.toString(), Pattern.MULTILINE);\n-      return _compile;\n-    }\n-  }.apply();\n-  \n-  private AntlrGrammarComparator.ErrorContext errorContext;\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final String absoluteGrammarFileName, final String absoluteGrammarFileNameReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-    this.errorContext = _errorContext;\n-    this.errorContext.testedGrammar.absoluteFileName = absoluteGrammarFileName;\n-    this.errorContext.referenceGrammar.absoluteFileName = absoluteGrammarFileNameReference;\n-    return this.compareGrammars(grammar, grammarReference, errorHandler);\n-  }\n-  \n-  /**\n-   * Performs the actual comparison of given and expected grammar.\n-   * \n-   * @return {@link Pair} containing the number of lines of the tested grammar (key)\n-   * \t\t\tand the referenced grammar (value) for logging purposes\n-   */\n-  public AntlrGrammarComparator.ErrorContext compareGrammars(final CharSequence grammar, final CharSequence grammarReference, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    boolean _equals = Objects.equal(this.errorContext, null);\n-    if (_equals) {\n-      AntlrGrammarComparator.ErrorContext _errorContext = new AntlrGrammarComparator.ErrorContext();\n-      this.errorContext = _errorContext;\n-    }\n-    final Matcher compoundMatcher = this.compoundPattern.matcher(grammar);\n-    final Matcher compoundMatcherReference = this.compoundPattern.matcher(grammarReference);\n-    boolean continue_ = true;\n-    boolean continueReference = true;\n-    while ((continue_ || continueReference)) {\n-      {\n-        if (continue_) {\n-          boolean _nextToken = this.nextToken(compoundMatcher, this.errorContext.testedGrammar, errorHandler);\n-          continue_ = _nextToken;\n-        }\n-        String _xifexpression = null;\n-        if (continue_) {\n-          _xifexpression = compoundMatcher.group();\n-        } else {\n-          _xifexpression = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String match = _xifexpression;\n-        if (continueReference) {\n-          boolean _nextToken_1 = this.nextToken(compoundMatcherReference, this.errorContext.referenceGrammar, errorHandler);\n-          continueReference = _nextToken_1;\n-        }\n-        String _xifexpression_1 = null;\n-        if (continueReference) {\n-          _xifexpression_1 = compoundMatcherReference.group();\n-        } else {\n-          _xifexpression_1 = \"\ufffd\ufffdeof\ufffd\ufffd\";\n-        }\n-        final String matchReference = _xifexpression_1;\n-        boolean _notEquals = (!Objects.equal(matchReference, match));\n-        if (_notEquals) {\n-          errorHandler.handleMismatch(match, matchReference, this.errorContext);\n-        }\n-      }\n-    }\n-    return this.errorContext;\n-  }\n-  \n-  /**\n-   * continue matching until the next token is found, count newlines while doing so.\n-   * \n-   * @return the number of newlines passed while searching\n-   */\n-  private boolean nextToken(final Matcher matcher, final AntlrGrammarComparator.MatchState state, final AntlrGrammarComparator.IErrorHandler errorHandler) {\n-    while (matcher.find()) {\n-      {\n-        String _group = matcher.group();\n-        state.currentToken = _group;\n-        int _start = matcher.start();\n-        boolean _notEquals = (_start != state.position);\n-        if (_notEquals) {\n-          this.handleInvalidGrammarFile(errorHandler, state);\n-        }\n-        final String match = matcher.group();\n-        state.previousToken = match;\n-        int _end = matcher.end();\n-        state.position = _end;\n-        Matcher _matcher = this.p_newline.matcher(match);\n-        boolean _matches = _matcher.matches();\n-        if (_matches) {\n-          state.lineNumber++;\n-        } else {\n-          if ((this.p_slComment.matcher(match).matches() || this.p_ws.matcher(match).matches())) {\n-          } else {\n-            Matcher _matcher_1 = this.p_mlComment.matcher(match);\n-            boolean _matches_1 = _matcher_1.matches();\n-            if (_matches_1) {\n-              final Matcher newlines = this.p_newline.matcher(match);\n-              while (newlines.find()) {\n-                state.lineNumber++;\n-              }\n-            } else {\n-              Matcher _matcher_2 = this.p_token.matcher(match);\n-              boolean _matches_2 = _matcher_2.matches();\n-              if (_matches_2) {\n-                return true;\n-              }\n-            }\n-          }\n-        }\n-      }\n-    }\n-    return false;\n-  }\n-  \n-  private void handleInvalidGrammarFile(final AntlrGrammarComparator.IErrorHandler errorHandler, final AntlrGrammarComparator.MatchState state) {\n-    if ((state == this.errorContext.testedGrammar)) {\n-      errorHandler.handleInvalidGeneratedGrammarFile(this.errorContext);\n-    } else {\n-      errorHandler.handleInvalidReferenceGrammarFile(this.errorContext);\n-    }\n-  }\n+\tpublic interface IErrorHandler {\n+\t\tpublic abstract void handleInvalidGeneratedGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleInvalidReferenceGrammarFile(ErrorContext context);\n+\n+\t\tpublic abstract void handleMismatch(String matched, String expected, ErrorContext context);\n+\t}\n+\n+\tpublic static class ErrorContext {\n+\t\tprivate MatchState testedGrammar = new MatchState();\n+\n+\t\tprivate MatchState referenceGrammar = new MatchState();\n+\n+\t\tpublic MatchState reset() {\n+\t\t\ttestedGrammar = new MatchState();\n+\t\t\treturn referenceGrammar = new MatchState();\n+\t\t}\n+\n+\t\tpublic MatchState getTestedGrammar() {\n+\t\t\treturn testedGrammar;\n+\t\t}\n+\n+\t\tpublic void setTestedGrammar(MatchState testedGrammar) {\n+\t\t\tthis.testedGrammar = testedGrammar;\n+\t\t}\n+\n+\t\tpublic MatchState getReferenceGrammar() {\n+\t\t\treturn referenceGrammar;\n+\t\t}\n+\n+\t\tpublic void setReferenceGrammar(MatchState referenceGrammar) {\n+\t\t\tthis.referenceGrammar = referenceGrammar;\n+\t\t}\n+\t}\n+\n+\tpublic static class MatchState {\n+\t\tprivate String absoluteFileName;\n+\n+\t\tprivate int lineNumber = 1;\n+\n+\t\tprivate int position = 0;\n+\n+\t\tprivate String previousToken;\n+\n+\t\tprivate String currentToken;\n+\n+\t\tpublic String getAbsoluteFileName() {\n+\t\t\treturn absoluteFileName;\n+\t\t}\n+\n+\t\tpublic void setAbsoluteFileName(String absoluteFileName) {\n+\t\t\tthis.absoluteFileName = absoluteFileName;\n+\t\t}\n+\n+\t\tpublic int getLineNumber() {\n+\t\t\treturn lineNumber;\n+\t\t}\n+\n+\t\tpublic void setLineNumber(int lineNumber) {\n+\t\t\tthis.lineNumber = lineNumber;\n+\t\t}\n+\n+\t\tpublic String getPreviousToken() {\n+\t\t\treturn previousToken;\n+\t\t}\n+\n+\t\tpublic void setPreviousToken(String previousToken) {\n+\t\t\tthis.previousToken = previousToken;\n+\t\t}\n+\n+\t\tpublic String getCurrentToken() {\n+\t\t\treturn currentToken;\n+\t\t}\n+\n+\t\tpublic void setCurrentToken(String currentToken) {\n+\t\t\tthis.currentToken = currentToken;\n+\t\t}\n+\t}\n+\n+\tprivate static List<String> SINGLE_CHAR_TOKENS = Lists.newArrayList(\"\\\\(\", \"\\\\)\", \"\\\\[\", \"\\\\]\", \"\\\\{\", \"\\\\}\", \"\\\\|\",\n+\t\t\t\"=\", \"\\\\?\", \"\\\\*\", \"\\\\+\", \":\", \";\");\n+\n+\tprivate static String QUOTED_TOKENS = Joiner.on(\"|\")\n+\t\t\t.join(Lists.newArrayList(\"\\'(\\\\\\\\\\')+\\'\", \"(\\'[^\\']*\\')\", \"(\\\"[^\\\"]*\\\")\"));\n+\n+\tprivate static String TOKEN = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\tStringConcatenation builder = new StringConcatenation();\n+\t\t\tbuilder.append(Joiner.on(\"|\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"|\");\n+\t\t\tbuilder.append(QUOTED_TOKENS, \"\");\n+\t\t\tbuilder.append(\"|[^\\\\s\\'\\\"\");\n+\t\t\tbuilder.append(Joiner.on(\"\").join(SINGLE_CHAR_TOKENS), \"\");\n+\t\t\tbuilder.append(\"]+\");\n+\t\t\treturn builder.toString();\n+\t\t}\n+\t}.apply();\n+\n+\tprivate static String NEWLINE = \"\\\\r?\\\\n|\\\\r\";\n+\n+\tprivate static String WS = \"( |\\\\t)+\";\n+\n+\tprivate static String SL_COMMENT = \"//[^\\\\r\\\\n]*\";\n+\n+\tprivate static String ML_COMMENT = new Function0<String>() {\n+\t\tpublic String apply() {\n+\t\t\treturn \"/\\\\*(\\\\*[^/]|[^\\\\*])*\\\\*/\";\n+\t\t}\n+\t}.apply();\n+\n+\tprivate Pattern p_slComment = Pattern.compile(SL_COMMENT);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzMzc2Mw=="}, "originalCommit": {"oid": "9fa5a964c8533255d800bfe84d68ecc78c26f25a"}, "originalPosition": 421}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 992, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}