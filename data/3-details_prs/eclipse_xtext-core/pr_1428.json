{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkyMDQxMjQ5", "number": 1428, "title": "[eclipse/xtext#1679] Refactor more Xtend to Java", "bodyText": "[eclipse/xtext#1679] Refactor more Xtend to Java", "createdAt": "2020-03-22T17:24:04Z", "url": "https://github.com/eclipse/xtext-core/pull/1428", "merged": true, "mergeCommit": {"oid": "12a21c9114d7600dae5029d38149e204d87f885b"}, "closed": true, "closedAt": "2020-03-26T15:54:05Z", "author": {"login": "szarnekow"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcQNStGAFqTM3OTAyOTEzNw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcRI7ZpgBqjMxNjQzOTE3NDk=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDI5MTM3", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379029137", "createdAt": "2020-03-22T17:38:03Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzozODowNFrOF5xRjQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzozODowNFrOF5xRjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMDQ2MQ==", "bodyText": "Year 2018, 2020", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396120461", "createdAt": "2020-03-22T17:38:04Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/naming/DefaultCopyQualifiedNameService.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/**\n+ * Copyright (c) 2018 itemis AG (http://www.itemis.eu) and others.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDI5NDY0", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379029464", "createdAt": "2020-03-22T17:41:15Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo0MToxNlrOF5xS1A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo0MToxNlrOF5xS1A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMDc4OA==", "bodyText": "Please remove this. from the lines - 73, 77, 81, 159, 162.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396120788", "createdAt": "2020-03-22T17:41:16Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 73}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDI5ODgw", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379029880", "createdAt": "2020-03-22T17:45:53Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo0NTo1M1rOF5xUqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo0NTo1M1rOF5xUqQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTI1Nw==", "bodyText": "Please format code.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396121257", "createdAt": "2020-03-22T17:45:53Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 164}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMwMzc2", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379030376", "createdAt": "2020-03-22T17:51:33Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1MTozM1rOF5xW9A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1MTozM1rOF5xW9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTg0NA==", "bodyText": "Returns null if no portable URI can be constructed...", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396121844", "createdAt": "2020-03-22T17:51:33Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 171}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMwNDY5", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379030469", "createdAt": "2020-03-22T17:52:45Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1Mjo0NVrOF5xXYw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1Mjo0NVrOF5xXYw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMTk1NQ==", "bodyText": "PS comments above.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396121955", "createdAt": "2020-03-22T17:52:45Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 192}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMwNTk1", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379030595", "createdAt": "2020-03-22T17:53:58Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1Mzo1OVrOF5xYBg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1Mzo1OVrOF5xYBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjExOA==", "bodyText": "Excessive ((", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122118", "createdAt": "2020-03-22T17:53:59Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be\n+\t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetObject\n+\t *            the target object that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n+\t\tString portableFragment = getPortableURIFragment(targetObject);\n+\t\tif ((portableFragment != null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 207}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMwNzIz", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379030723", "createdAt": "2020-03-22T17:55:14Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1NToxNFrOF5xYnw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1NToxNFrOF5xYnw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjI3MQ==", "bodyText": "Excessive ((", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122271", "createdAt": "2020-03-22T17:55:14Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be\n+\t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetObject\n+\t *            the target object that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n+\t\tString portableFragment = getPortableURIFragment(targetObject);\n+\t\tif ((portableFragment != null)) {\n+\t\t\treturn sourceResource.getURI().appendFragment(portableFragment);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @return a portable URI fragment, or <code>null</code> if the give EObject isn't itself or is not contained in an\n+\t *         exported EObjectDescription\n+\t */\n+\tprotected String getPortableURIFragment(EObject obj) {\n+\t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n+\t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n+\t\tif ((desc == null)) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 220}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMwOTcx", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379030971", "createdAt": "2020-03-22T17:57:55Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1Nzo1NVrOF5xZoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxNzo1Nzo1NVrOF5xZoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjUyOA==", "bodyText": "Did you purposefully use FluentIterable here?", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122528", "createdAt": "2020-03-22T17:57:55Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.FluentIterable;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn this.descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn this.descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn this.descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream(scope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d->{\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> is no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> is no portable URI can be\n+\t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetObject\n+\t *            the target object that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n+\t\tString portableFragment = getPortableURIFragment(targetObject);\n+\t\tif ((portableFragment != null)) {\n+\t\t\treturn sourceResource.getURI().appendFragment(portableFragment);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @return a portable URI fragment, or <code>null</code> if the give EObject isn't itself or is not contained in an\n+\t *         exported EObjectDescription\n+\t */\n+\tprotected String getPortableURIFragment(EObject obj) {\n+\t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n+\t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n+\t\tif ((desc == null)) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn FluentIterable.from(desc.getExportedObjects()).filter(description->{", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 223}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMxMjAz", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379031203", "createdAt": "2020-03-22T18:00:24Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowMDoyNFrOF5xacw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowMDoyNFrOF5xacw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjczOQ==", "bodyText": "NL", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122739", "createdAt": "2020-03-22T18:00:24Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/ResourceStorageProviderAdapter.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+\n+/**\n+ * An adapter that can be installed into a SerializableResource, to provide resource state. It is used with dirty\n+ * editors providing the dirty non persisted state to other editors.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class ResourceStorageProviderAdapter extends AdapterImpl {\n+\t@Override\n+\tpublic boolean isAdapterForType(Object type) {\n+\t\treturn ResourceStorageProviderAdapter.class.equals(type);\n+\t}\n+\n+\tpublic ResourceStorageLoadable getResourceStorageLoadable(StorageAwareResource resource) {\n+\t\treturn null;\n+\t}\n+}", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 28}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMxMjcx", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379031271", "createdAt": "2020-03-22T18:00:53Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowMDo1M1rOF5xavg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowMDo1M1rOF5xavg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjgxNA==", "bodyText": "2014, 2020", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122814", "createdAt": "2020-03-22T18:00:53Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2014 itemis AG (http://www.itemis.eu) and others.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMxNDE4", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379031418", "createdAt": "2020-03-22T18:02:02Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowMjowM1rOF5xbJg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowMjowM1rOF5xbJg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMjkxOA==", "bodyText": "this. not needed.\nreturn Collections.unmodifiableSet(this.sourceLevelURIs) -> return sourceLevelURIs", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396122918", "createdAt": "2020-03-22T18:02:03Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/SourceLevelURIsAdapter.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) 2014 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import org.eclipse.emf.common.notify.Adapter;\n+import org.eclipse.emf.common.notify.impl.AdapterImpl;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.resource.ResourceSet;\n+\n+import com.google.common.collect.ImmutableSet;\n+\n+/**\n+ * An adapter to be installed into a ResourceSet.\n+ * \n+ * It's used as a protocol to tell whether a StorageAwareResource should load from source or could load from serialized\n+ * data.\n+ * \n+ * @see ResourceStorageProviderAdapter\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class SourceLevelURIsAdapter extends AdapterImpl {\n+\t\n+\tpublic static void setSourceLevelUris(ResourceSet resourceSet, Collection<URI> uris) {\n+\t\tSourceLevelURIsAdapter adapter = findOrCreateAdapter(resourceSet);\n+\t\tadapter.sourceLevelURIs = ImmutableSet.copyOf(uris);\n+\t}\n+\n+\tprotected static SourceLevelURIsAdapter findOrCreateAdapter(ResourceSet resourceSet) {\n+\t\tSourceLevelURIsAdapter adapter = findInstalledAdapter(resourceSet);\n+\t\tif (adapter != null) {\n+\t\t\treturn adapter;\n+\t\t}\n+\t\tadapter = new SourceLevelURIsAdapter();\n+\t\tresourceSet.eAdapters().add(adapter);\n+\t\treturn adapter;\n+\t}\n+\n+\t/**\n+\t * Installs the given set of URIs as the source level URIs. Does not copy the given set but uses it directly.\n+\t */\n+\tpublic static void setSourceLevelUrisWithoutCopy(ResourceSet resourceSet, Set<URI> uris) {\n+\t\tSourceLevelURIsAdapter adapter = findOrCreateAdapter(resourceSet);\n+\t\tadapter.sourceLevelURIs = uris;\n+\t}\n+\n+\tpublic static SourceLevelURIsAdapter findInstalledAdapter(ResourceSet resourceSet) {\n+\t\tfor (Adapter adapter : resourceSet.eAdapters()) {\n+\t\t\tif (adapter instanceof SourceLevelURIsAdapter) {\n+\t\t\t\treturn (SourceLevelURIsAdapter) adapter;\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\t\n+\tprivate Set<URI> sourceLevelURIs;\n+\n+\tpublic Set<URI> getSourceLevelURIs() {\n+\t\treturn Collections.unmodifiableSet(this.sourceLevelURIs);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMxNjIw", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379031620", "createdAt": "2020-03-22T18:03:52Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowMzo1MlrOF5xb9w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowMzo1MlrOF5xb9w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMzEyNw==", "bodyText": "2014, 2020", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396123127", "createdAt": "2020-03-22T18:03:52Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 2}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMxNjk5", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379031699", "createdAt": "2020-03-22T18:04:39Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowNDozOVrOF5xcMQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowNDozOVrOF5xcMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMzE4NQ==", "bodyText": "Please remove if there are no warnings in the code.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396123185", "createdAt": "2020-03-22T18:04:39Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.linking.lazy.LazyLinkingResource;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.util.internal.Stopwatches;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * A resource implementation that can load itself from ResourceStorage.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+@SuppressWarnings(\"all\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 29}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzc5MDMxNzc5", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-379031779", "createdAt": "2020-03-22T18:05:41Z", "commit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowNTo0MVrOF5xcpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQxODowNTo0MVrOF5xcpQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjEyMzMwMQ==", "bodyText": "The Code inside the catch block looks incorrectly formatted.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r396123301", "createdAt": "2020-03-22T18:05:41Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,137 @@\n+/**\n+ * Copyright (c) 2014, 2017 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.linking.lazy.LazyLinkingResource;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.util.internal.Stopwatches;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * A resource implementation that can load itself from ResourceStorage.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+@SuppressWarnings(\"all\")\n+public class StorageAwareResource extends LazyLinkingResource {\n+\tpublic static final String UNRESOLVABLE_FRAGMENT = \"UNRESOLVABLE\";\n+\n+\tprivate static final Logger LOG = Logger.getLogger(StorageAwareResource.class);\n+\n+\t@Inject(optional = true)\n+\tprivate IResourceStorageFacade resourceStorageFacade;\n+\n+\t@Inject\n+\tprivate PortableURIs portableURIs;\n+\n+\tprivate boolean isLoadedFromStorage = false;\n+\n+\tprivate IResourceDescription resourceDescription = null;\n+\n+\t@Override\n+\tpublic void load(Map<?, ?> options) throws IOException {\n+\t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n+\t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled()) {\n+\t\t\t\tLOG.debug(\"Loading \" + getURI() + \" from storage.\");\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tResourceStorageLoadable in = resourceStorageFacade.getOrCreateResourceStorageLoadable(this);\n+\t\t\t\tloadFromStorage(in);\n+\t\t\t\treturn;\n+\t\t\t} catch (IOException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7"}, "originalPosition": 56}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "79e6a92b696d1d52b30ee0865794ba1c0163713f", "author": {"user": {"login": "szarnekow", "name": "Sebastian Zarnekow"}}, "url": "https://github.com/eclipse/xtext-core/commit/79e6a92b696d1d52b30ee0865794ba1c0163713f", "committedDate": "2020-03-23T07:41:02Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to Java"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "author": {"user": {"login": "szarnekow", "name": "Sebastian Zarnekow"}}, "url": "https://github.com/eclipse/xtext-core/commit/8716bdbf956aacc5deb59123dc29d1e9c02f7ab7", "committedDate": "2020-03-22T17:23:14Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to Java"}, "afterCommit": {"oid": "79e6a92b696d1d52b30ee0865794ba1c0163713f", "author": {"user": {"login": "szarnekow", "name": "Sebastian Zarnekow"}}, "url": "https://github.com/eclipse/xtext-core/commit/79e6a92b696d1d52b30ee0865794ba1c0163713f", "committedDate": "2020-03-23T07:41:02Z", "message": "[eclipse/xtext#1679] Refactor more Xtend to Java"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "author": {"user": {"login": "szarnekow", "name": "Sebastian Zarnekow"}}, "url": "https://github.com/eclipse/xtext-core/commit/a203c616f7dc8b4c2f26d8a87bf91a1557c1c628", "committedDate": "2020-03-23T07:45:18Z", "message": "Fix tests, added JavaDoc"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMTEwMzgx", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-381110381", "createdAt": "2020-03-25T12:43:37Z", "commit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo0MzozN1rOF7ZPgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo0MzozN1rOF7ZPgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyMzg3Mg==", "bodyText": "You might like to change the detailed message to the parameter 'storageInputStream' must not be null or something better.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397823872", "createdAt": "2020-03-25T12:43:37Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.linking.lazy.LazyLinkingResource;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.util.internal.Stopwatches;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * A resource implementation that can load itself from ResourceStorage.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class StorageAwareResource extends LazyLinkingResource {\n+\tpublic static final String UNRESOLVABLE_FRAGMENT = \"UNRESOLVABLE\";\n+\n+\tprivate static final Logger LOG = Logger.getLogger(StorageAwareResource.class);\n+\n+\t@Inject(optional = true)\n+\tprivate IResourceStorageFacade resourceStorageFacade;\n+\n+\t@Inject\n+\tprivate PortableURIs portableURIs;\n+\n+\tprivate boolean isLoadedFromStorage = false;\n+\n+\tprivate IResourceDescription resourceDescription = null;\n+\n+\t@Override\n+\tpublic void load(Map<?, ?> options) throws IOException {\n+\t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n+\t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled()) {\n+\t\t\t\tLOG.debug(\"Loading \" + getURI() + \" from storage.\");\n+\t\t\t}\n+\t\t\ttry {\n+\t\t\t\tResourceStorageLoadable in = resourceStorageFacade.getOrCreateResourceStorageLoadable(this);\n+\t\t\t\tloadFromStorage(in);\n+\t\t\t\treturn;\n+\t\t\t} catch (IOException e) {\n+\t\t\t\tif (contents != null) {\n+\t\t\t\t\tcontents.clear();\n+\t\t\t\t}\n+\t\t\t\tif (eAdapters != null) {\n+\t\t\t\t\teAdapters.clear();\n+\t\t\t\t}\n+\t\t\t\tunload();\n+\t\t\t}\n+\t\t}\n+\t\tsuper.load(options);\n+\t}\n+\n+\tpublic void loadFromStorage(ResourceStorageLoadable storageInputStream) throws IOException {\n+\t\tif (storageInputStream == null) {\n+\t\t\tthrow new NullPointerException(\"storageInputStream\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMTExNzkx", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-381111791", "createdAt": "2020-03-25T12:45:42Z", "commit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo0NTo0M1rOF7ZUEg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo0NTo0M1rOF7ZUEg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNTA0Mg==", "bodyText": "Please remove line.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397825042", "createdAt": "2020-03-25T12:45:43Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);\n+\t\tEReference mock = EcoreFactory.eINSTANCE.createEReference();\n+\t\tmock.setEType(desc.descriptionEClass);\n+\t\tIScope scope = this.globalScopeProvider.getScope(resource, mock, Predicates.<IEObjectDescription>alwaysTrue());\n+\t\tOptional<IEObjectDescription> description = Streams.stream( //\n+\t\t\t\tscope.getElements(desc.descriptionQualifiedName)).findFirst();\n+\t\treturn description.map(d -> {\n+\t\t\tEObject container = EcoreUtil.resolve(d.getEObjectOrProxy(), resource);\n+\t\t\treturn getEObject(container, desc.descriptionRelativeFragment);\n+\t\t}).orElse(null);\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the given resource to the targetURI. Returns <code>null</code> if no\n+\t * portable URI can be constructed, which is the case if the targetObject is not itself exported or is a child of an\n+\t * exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetURI\n+\t *            the target URI that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, URI targetURI) {\n+\t\tEObject object = sourceResource.getResourceSet().getEObject(targetURI, false);\n+\t\t// if it points to some registered ecore, there's no resourceSet and the result is not portable\n+\t\tif (object == null || object.eResource().getResourceSet() != null) {\n+\t\t\treturn toPortableURI(sourceResource, object);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Creates and returns a portable URI from the global scope. Returns <code>null</code> if no portable URI can be\n+\t * constructed, which is the case if the targetObject is not itself exported or is a child of an exported EObject.\n+\t * \n+\t * @param sourceResource\n+\t *            the resource from which the EObject should later be resolved\n+\t * @param targetObject\n+\t *            the target object that should be resolvable by the created portable URI\n+\t * \n+\t * @return a portable URI or <code>null</code>\n+\t */\n+\tpublic URI toPortableURI(StorageAwareResource sourceResource, EObject targetObject) {\n+\t\tif (targetObject == null || targetObject.eIsProxy()) {\n+\t\t\treturn sourceResource.getURI().appendFragment(StorageAwareResource.UNRESOLVABLE_FRAGMENT);\n+\t\t}\n+\t\tString portableFragment = getPortableURIFragment(targetObject);\n+\t\tif (portableFragment != null) {\n+\t\t\treturn sourceResource.getURI().appendFragment(portableFragment);\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * @return a portable URI fragment, or <code>null</code> if the give EObject isn't itself or is not contained in an\n+\t *         exported EObjectDescription\n+\t */\n+\tprotected String getPortableURIFragment(EObject obj) {\n+\t\tIResourceDescriptions descriptions = resourceDescriptionsProvider.getResourceDescriptions(obj.eResource());\n+\t\tIResourceDescription desc = descriptions.getResourceDescription(obj.eResource().getURI());\n+\t\tif (desc == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn Streams.stream(desc.getExportedObjects()).filter(description -> {\n+\t\t\tEObject possibleContainer = EcoreUtil.resolve(description.getEObjectOrProxy(), obj.eResource());\n+\t\t\treturn EcoreUtil.isAncestor(obj, possibleContainer);\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "originalPosition": 226}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMTEzMzE5", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-381113319", "createdAt": "2020-03-25T12:47:54Z", "commit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo0Nzo1NFrOF7ZZOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo0Nzo1NFrOF7ZZOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNjM2MQ==", "bodyText": "Please remove this on lines 158, and 161.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397826361", "createdAt": "2020-03-25T12:47:54Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/PortableURIs.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Optional;\n+\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EPackage;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.EcoreFactory;\n+import org.eclipse.emf.ecore.EcorePackage;\n+import org.eclipse.emf.ecore.resource.Resource;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.naming.QualifiedName;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.resource.IResourceDescriptions;\n+import org.eclipse.xtext.resource.impl.ResourceDescriptionsProvider;\n+import org.eclipse.xtext.scoping.IGlobalScopeProvider;\n+import org.eclipse.xtext.scoping.IScope;\n+\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Predicates;\n+import com.google.common.base.Splitter;\n+import com.google.common.base.Strings;\n+import com.google.common.collect.Streams;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Portable URIs are based on names and therefore are independent of the concrete file pathes and fuile names the of\n+ * resources.\n+ * \n+ * A portable URI is really a resource URI to the client URI and a fragment that contains the information to retrieve\n+ * the referenced element using the global scoping. That is it contains\n+ * <ul>\n+ * <li>the qualified name of a container of the target element\n+ * <li>the type of that container\n+ * <li>the path from that container to the actual target element\n+ * </ul>\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ * \n+ * @since 2.8\n+ */\n+public class PortableURIs {\n+\n+\tpublic static class PortableFragmentDescription {\n+\t\tprivate final EClass descriptionEClass;\n+\n+\t\tprivate final QualifiedName descriptionQualifiedName;\n+\n+\t\tprivate final String descriptionRelativeFragment;\n+\n+\t\tpublic PortableFragmentDescription(EClass descriptionEClass, QualifiedName descriptionQualifiedName,\n+\t\t\t\tString descriptionRelativeFragment) {\n+\t\t\tthis.descriptionEClass = descriptionEClass;\n+\t\t\tthis.descriptionQualifiedName = descriptionQualifiedName;\n+\t\t\tthis.descriptionRelativeFragment = descriptionRelativeFragment;\n+\t\t}\n+\n+\t\tpublic EClass getDescriptionEClass() {\n+\t\t\treturn descriptionEClass;\n+\t\t}\n+\n+\t\tpublic QualifiedName getDescriptionQualifiedName() {\n+\t\t\treturn descriptionQualifiedName;\n+\t\t}\n+\n+\t\tpublic String getDescriptionRelativeFragment() {\n+\t\t\treturn descriptionRelativeFragment;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\tfinal int prime = 31;\n+\t\t\tint result = 1;\n+\t\t\tresult = prime * result + ((descriptionEClass == null) ? 0 : descriptionEClass.hashCode());\n+\t\t\tresult = prime * result + ((descriptionQualifiedName == null) ? 0 : descriptionQualifiedName.hashCode());\n+\t\t\tresult = prime * result\n+\t\t\t\t\t+ ((descriptionRelativeFragment == null) ? 0 : descriptionRelativeFragment.hashCode());\n+\t\t\treturn result;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object obj) {\n+\t\t\tif (this == obj)\n+\t\t\t\treturn true;\n+\t\t\tif (obj == null)\n+\t\t\t\treturn false;\n+\t\t\tif (getClass() != obj.getClass())\n+\t\t\t\treturn false;\n+\t\t\tPortableFragmentDescription other = (PortableFragmentDescription) obj;\n+\t\t\tif (descriptionEClass == null) {\n+\t\t\t\tif (other.descriptionEClass != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionEClass.equals(other.descriptionEClass))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionQualifiedName == null) {\n+\t\t\t\tif (other.descriptionQualifiedName != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionQualifiedName.equals(other.descriptionQualifiedName))\n+\t\t\t\treturn false;\n+\t\t\tif (descriptionRelativeFragment == null) {\n+\t\t\t\tif (other.descriptionRelativeFragment != null)\n+\t\t\t\t\treturn false;\n+\t\t\t} else if (!descriptionRelativeFragment.equals(other.descriptionRelativeFragment))\n+\t\t\t\treturn false;\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn \"PortableFragmentDescription [descriptionEClass=\" + descriptionEClass + \", descriptionQualifiedName=\"\n+\t\t\t\t\t+ descriptionQualifiedName + \", descriptionRelativeFragment=\" + descriptionRelativeFragment + \"]\";\n+\t\t}\n+\n+\t}\n+\n+\tpublic static final String PORTABLE_SCHEME = \"portable\";\n+\n+\t@Inject\n+\tprivate IGlobalScopeProvider globalScopeProvider;\n+\n+\t@Inject\n+\tprivate EPackage.Registry packageRegistry;\n+\n+\t@Inject\n+\tprivate ResourceDescriptionsProvider resourceDescriptionsProvider;\n+\n+\t/**\n+\t * @return whether the given string is a portable URI fragment\n+\t */\n+\tpublic boolean isPortableURIFragment(String uriFragment) {\n+\t\treturn uriFragment.startsWith(PortableURIs.PORTABLE_SCHEME);\n+\t}\n+\n+\t/**\n+\t * Resolves a given portable URI fragment against the given resource.\n+\t * \n+\t * @param resource\n+\t *            the resource from which global scope to look up the EObject\n+\t * @param portableFragment\n+\t *            the portable fragment pointing to the to be resolved EObject\n+\t * \n+\t * @return the EObject for the given portableURIFragment\n+\t */\n+\tpublic EObject resolve(StorageAwareResource resource, String portableFragment) {\n+\t\tPortableURIs.PortableFragmentDescription desc = this.fromFragmentString(portableFragment);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "originalPosition": 158}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMTE0NTQ1", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-381114545", "createdAt": "2020-03-25T12:49:37Z", "commit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo0OTozOFrOF7ZdCg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo0OTozOFrOF7ZdCg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNzMzOA==", "bodyText": "Please add 2020 to the Copyright if you think its required.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397827338", "createdAt": "2020-03-25T12:49:38Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.tests/xtend-gen/org/eclipse/xtext/resource/persistence/PortableURIsTest.java", "diffHunk": "@@ -22,6 +22,7 @@\n import org.eclipse.xtext.linking.langATestLanguage.Type;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMTE0ODQ5", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-381114849", "createdAt": "2020-03-25T12:50:03Z", "commit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo1MDowM1rOF7Zd-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMjo1MDowM1rOF7Zd-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NzgyNzU3OA==", "bodyText": "Please add 2020 to the Copyright if you think its required.", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397827578", "createdAt": "2020-03-25T12:50:03Z", "author": {"login": "nbhusare"}, "path": "org.eclipse.xtext.tests/src/org/eclipse/xtext/resource/persistence/PortableURIsTest.xtend", "diffHunk": "@@ -84,7 +84,7 @@ class PortableURIsTest extends AbstractXtextTests {\n \t\ttry {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxMTU5NTQ0", "url": "https://github.com/eclipse/xtext-core/pull/1428#pullrequestreview-381159544", "createdAt": "2020-03-25T13:45:04Z", "commit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzo0NTowNVrOF7bsfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yNVQxMzo0NTowNVrOF7bsfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5Nzg2NDA2Mg==", "bodyText": "Isn't this just done in LOG.debug?", "url": "https://github.com/eclipse/xtext-core/pull/1428#discussion_r397864062", "createdAt": "2020-03-25T13:45:05Z", "author": {"login": "tivervac"}, "path": "org.eclipse.xtext/src/org/eclipse/xtext/resource/persistence/StorageAwareResource.java", "diffHunk": "@@ -0,0 +1,136 @@\n+/**\n+ * Copyright (c) 2014, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.resource.persistence;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import org.apache.log4j.Logger;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.xtext.linking.lazy.LazyLinkingResource;\n+import org.eclipse.xtext.resource.IResourceDescription;\n+import org.eclipse.xtext.util.internal.Stopwatches;\n+\n+import com.google.inject.Inject;\n+\n+/**\n+ * A resource implementation that can load itself from ResourceStorage.\n+ * \n+ * @author Sven Efftinge - Initial contribution and API\n+ */\n+public class StorageAwareResource extends LazyLinkingResource {\n+\tpublic static final String UNRESOLVABLE_FRAGMENT = \"UNRESOLVABLE\";\n+\n+\tprivate static final Logger LOG = Logger.getLogger(StorageAwareResource.class);\n+\n+\t@Inject(optional = true)\n+\tprivate IResourceStorageFacade resourceStorageFacade;\n+\n+\t@Inject\n+\tprivate PortableURIs portableURIs;\n+\n+\tprivate boolean isLoadedFromStorage = false;\n+\n+\tprivate IResourceDescription resourceDescription = null;\n+\n+\t@Override\n+\tpublic void load(Map<?, ?> options) throws IOException {\n+\t\tif (!isLoaded && !isLoading && resourceStorageFacade != null\n+\t\t\t\t&& resourceStorageFacade.shouldLoadFromStorage(this)) {\n+\t\t\tif (StorageAwareResource.LOG.isDebugEnabled()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a203c616f7dc8b4c2f26d8a87bf91a1557c1c628"}, "originalPosition": 48}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d2383316e9447994b015ecba1d883c308442043a", "author": {"user": {"login": "szarnekow", "name": "Sebastian Zarnekow"}}, "url": "https://github.com/eclipse/xtext-core/commit/d2383316e9447994b015ecba1d883c308442043a", "committedDate": "2020-03-25T15:06:42Z", "message": "Incorporated review feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8c4f462569ba5150ff50f55cb81721a22d729b42", "author": {"user": {"login": "szarnekow", "name": "Sebastian Zarnekow"}}, "url": "https://github.com/eclipse/xtext-core/commit/8c4f462569ba5150ff50f55cb81721a22d729b42", "committedDate": "2020-03-25T15:05:30Z", "message": "Incorporated review feedback"}, "afterCommit": {"oid": "d2383316e9447994b015ecba1d883c308442043a", "author": {"user": {"login": "szarnekow", "name": "Sebastian Zarnekow"}}, "url": "https://github.com/eclipse/xtext-core/commit/d2383316e9447994b015ecba1d883c308442043a", "committedDate": "2020-03-25T15:06:42Z", "message": "Incorporated review feedback"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4735, "cost": 1, "resetAt": "2021-11-01T14:20:25Z"}}}