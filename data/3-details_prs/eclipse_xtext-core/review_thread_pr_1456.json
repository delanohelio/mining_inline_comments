{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA5MTEzNjIy", "number": 1456, "reviewThreads": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNzowNDoyMlrOD3gCaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozODo1MVrOD3h7WQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTIzMTc5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/TopologicalSorter.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwNzowNDoyMlrOGNyIxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozNTo0OVrOGN0_Fw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwNjExNw==", "bodyText": "needed", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417106117", "createdAt": "2020-04-29T07:04:22Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/TopologicalSorter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+\n+/**\n+ * @author Jan Koehnlein - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class TopologicalSorter {\n+\tprotected static class Entry {\n+\t\tprivate final ProjectDescription description;\n+\n+\t\tprivate boolean marked;\n+\n+\t\tprivate boolean cyclic;\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn description.getName();\n+\t\t}\n+\n+\t\tpublic Entry(ProjectDescription description) {\n+\t\t\tthis.description = description;\n+\t\t}\n+\t}\n+\n+\tprivate LinkedHashSet<ProjectDescription> result;\n+\n+\tprivate Map<String, TopologicalSorter.Entry> name2entry;\n+\n+\tprivate IAcceptor<ProjectDescription> cyclicAcceptor;\n+\n+\tpublic List<ProjectDescription> sortByDependencies(Iterable<ProjectDescription> descriptions,\n+\t\t\tProcedure1<? super ProjectDescription> cyclicAcceptor) {\n+\t\tthis.cyclicAcceptor = new IAcceptor<ProjectDescription>() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "229aaed0c13b8e60f7c54de4ca972eff6738bb0d"}, "originalPosition": 51}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1Mjc5MQ==", "bodyText": "this.cyclicAcceptor = cyclicAcceptor::apply", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417152791", "createdAt": "2020-04-29T08:35:49Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/TopologicalSorter.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.eclipse.xtext.resource.impl.ProjectDescription;\n+import org.eclipse.xtext.util.IAcceptor;\n+import org.eclipse.xtext.xbase.lib.IterableExtensions;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure1;\n+\n+/**\n+ * @author Jan Koehnlein - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class TopologicalSorter {\n+\tprotected static class Entry {\n+\t\tprivate final ProjectDescription description;\n+\n+\t\tprivate boolean marked;\n+\n+\t\tprivate boolean cyclic;\n+\n+\t\t@Override\n+\t\tpublic String toString() {\n+\t\t\treturn description.getName();\n+\t\t}\n+\n+\t\tpublic Entry(ProjectDescription description) {\n+\t\t\tthis.description = description;\n+\t\t}\n+\t}\n+\n+\tprivate LinkedHashSet<ProjectDescription> result;\n+\n+\tprivate Map<String, TopologicalSorter.Entry> name2entry;\n+\n+\tprivate IAcceptor<ProjectDescription> cyclicAcceptor;\n+\n+\tpublic List<ProjectDescription> sortByDependencies(Iterable<ProjectDescription> descriptions,\n+\t\t\tProcedure1<? super ProjectDescription> cyclicAcceptor) {\n+\t\tthis.cyclicAcceptor = new IAcceptor<ProjectDescription>() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzEwNjExNw=="}, "originalCommit": {"oid": "229aaed0c13b8e60f7c54de4ca972eff6738bb0d"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTQ5NDY2OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNTo0N1rOGN0pFw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODo1NzowNFrOGN1wAw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzE1OQ==", "bodyText": "return true means include keyword?", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417147159", "createdAt": "2020-04-29T08:25:47Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.contentassist;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EClassifier;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Keyword;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.scoping.IScope;\n+import org.eclipse.xtext.scoping.IScopeProvider;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xtext.CurrentTypeFinder;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Generic content proposal provider for use in different IDE contexts. This provider is <em>not</em> used by the\n+ * Eclipse integration, which has its own abstraction for content assist proposals.\n+ * \n+ * @noreference\n+ */\n+public class IdeContentProposalProvider {\n+\t@Inject\n+\tprivate IScopeProvider scopeProvider;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IdeCrossrefProposalProvider crossrefProposalProvider;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate CurrentTypeFinder currentTypeFinder;\n+\n+\t/**\n+\t * Create content assist proposals and pass them to the given acceptor.\n+\t */\n+\tpublic void createProposals(Collection<ContentAssistContext> contexts, IIdeContentProposalAcceptor acceptor) {\n+\t\tfor (ContentAssistContext context : getFilteredContexts(contexts)) {\n+\t\t\tfor (AbstractElement element : context.getFirstSetGrammarElements()) {\n+\t\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcreateProposals(element, context, acceptor);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ContentAssistContext> getFilteredContexts(Collection<ContentAssistContext> contexts) {\n+\t\treturn contexts;\n+\t}\n+\n+\tprotected void _createProposals(AbstractElement element, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t}\n+\n+\tprotected void _createProposals(Assignment assignment, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tAbstractElement terminal = assignment.getTerminal();\n+\t\tif (terminal instanceof CrossReference) {\n+\t\t\tcreateProposals(terminal, context, acceptor);\n+\t\t} else {\n+\t\t\tif (terminal instanceof RuleCall) {\n+\t\t\t\tAbstractRule rule = ((RuleCall) terminal).getRule();\n+\t\t\t\tif (rule instanceof TerminalRule && context.getPrefix().isEmpty()) {\n+\t\t\t\t\tfinal String proposal;\n+\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\tproposal = \"\\\"\" + assignment.getFeature() + \"\\\"\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tproposal = assignment.getFeature();\n+\t\t\t\t\t}\n+\t\t\t\t\tContentAssistEntry entry = proposalCreator.createProposal(proposal, context,\n+\t\t\t\t\t\t\t(ContentAssistEntry it) -> {\n+\t\t\t\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions()\n+\t\t\t\t\t\t\t\t\t\t\t.add(new TextRegion(context.getOffset() + 1, proposal.length() - 2));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_TEXT);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions().add(new TextRegion(context.getOffset(), proposal.length()));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_VALUE);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tit.setDescription(rule.getName());\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\tacceptor.accept(entry, proposalPriorities.getDefaultPriority(entry));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void _createProposals(Keyword keyword, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tif (filterKeyword(keyword, context)) {\n+\t\t\tContentAssistEntry entry = proposalCreator.createProposal(keyword.getValue(), context,\n+\t\t\t\t\tContentAssistEntry.KIND_KEYWORD, null);\n+\t\t\tif (entry != null) {\n+\t\t\t\tacceptor.accept(entry, proposalPriorities.getKeywordPriority(keyword.getValue(), entry));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean filterKeyword(Keyword keyword, ContentAssistContext context) {\n+\t\treturn true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE2NTMxNQ==", "bodyText": "yes, api from hell.", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417165315", "createdAt": "2020-04-29T08:57:04Z", "author": {"login": "cdietrich"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.contentassist;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EClassifier;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Keyword;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.scoping.IScope;\n+import org.eclipse.xtext.scoping.IScopeProvider;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xtext.CurrentTypeFinder;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Generic content proposal provider for use in different IDE contexts. This provider is <em>not</em> used by the\n+ * Eclipse integration, which has its own abstraction for content assist proposals.\n+ * \n+ * @noreference\n+ */\n+public class IdeContentProposalProvider {\n+\t@Inject\n+\tprivate IScopeProvider scopeProvider;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IdeCrossrefProposalProvider crossrefProposalProvider;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate CurrentTypeFinder currentTypeFinder;\n+\n+\t/**\n+\t * Create content assist proposals and pass them to the given acceptor.\n+\t */\n+\tpublic void createProposals(Collection<ContentAssistContext> contexts, IIdeContentProposalAcceptor acceptor) {\n+\t\tfor (ContentAssistContext context : getFilteredContexts(contexts)) {\n+\t\t\tfor (AbstractElement element : context.getFirstSetGrammarElements()) {\n+\t\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcreateProposals(element, context, acceptor);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ContentAssistContext> getFilteredContexts(Collection<ContentAssistContext> contexts) {\n+\t\treturn contexts;\n+\t}\n+\n+\tprotected void _createProposals(AbstractElement element, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t}\n+\n+\tprotected void _createProposals(Assignment assignment, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tAbstractElement terminal = assignment.getTerminal();\n+\t\tif (terminal instanceof CrossReference) {\n+\t\t\tcreateProposals(terminal, context, acceptor);\n+\t\t} else {\n+\t\t\tif (terminal instanceof RuleCall) {\n+\t\t\t\tAbstractRule rule = ((RuleCall) terminal).getRule();\n+\t\t\t\tif (rule instanceof TerminalRule && context.getPrefix().isEmpty()) {\n+\t\t\t\t\tfinal String proposal;\n+\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\tproposal = \"\\\"\" + assignment.getFeature() + \"\\\"\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tproposal = assignment.getFeature();\n+\t\t\t\t\t}\n+\t\t\t\t\tContentAssistEntry entry = proposalCreator.createProposal(proposal, context,\n+\t\t\t\t\t\t\t(ContentAssistEntry it) -> {\n+\t\t\t\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions()\n+\t\t\t\t\t\t\t\t\t\t\t.add(new TextRegion(context.getOffset() + 1, proposal.length() - 2));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_TEXT);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions().add(new TextRegion(context.getOffset(), proposal.length()));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_VALUE);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tit.setDescription(rule.getName());\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\tacceptor.accept(entry, proposalPriorities.getDefaultPriority(entry));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void _createProposals(Keyword keyword, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tif (filterKeyword(keyword, context)) {\n+\t\t\tContentAssistEntry entry = proposalCreator.createProposal(keyword.getValue(), context,\n+\t\t\t\t\tContentAssistEntry.KIND_KEYWORD, null);\n+\t\t\tif (entry != null) {\n+\t\t\t\tacceptor.accept(entry, proposalPriorities.getKeywordPriority(keyword.getValue(), entry));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean filterKeyword(Keyword keyword, ContentAssistContext context) {\n+\t\treturn true;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzE1OQ=="}, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 129}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTQ5NjA0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNjoxMFrOGN0p7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNjoxMFrOGN0p7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzM3NQ==", "bodyText": "s/ereference/eReference", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417147375", "createdAt": "2020-04-29T08:26:10Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/contentassist/IdeContentProposalProvider.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.contentassist;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.emf.ecore.EClassifier;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.xtext.AbstractElement;\n+import org.eclipse.xtext.AbstractRule;\n+import org.eclipse.xtext.Assignment;\n+import org.eclipse.xtext.CrossReference;\n+import org.eclipse.xtext.GrammarUtil;\n+import org.eclipse.xtext.Keyword;\n+import org.eclipse.xtext.RuleCall;\n+import org.eclipse.xtext.TerminalRule;\n+import org.eclipse.xtext.naming.IQualifiedNameConverter;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.scoping.IScope;\n+import org.eclipse.xtext.scoping.IScopeProvider;\n+import org.eclipse.xtext.util.TextRegion;\n+import org.eclipse.xtext.xtext.CurrentTypeFinder;\n+\n+import com.google.common.base.Predicate;\n+import com.google.common.base.Predicates;\n+import com.google.inject.Inject;\n+\n+/**\n+ * Generic content proposal provider for use in different IDE contexts. This provider is <em>not</em> used by the\n+ * Eclipse integration, which has its own abstraction for content assist proposals.\n+ * \n+ * @noreference\n+ */\n+public class IdeContentProposalProvider {\n+\t@Inject\n+\tprivate IScopeProvider scopeProvider;\n+\n+\t@Inject\n+\tprivate IQualifiedNameConverter qualifiedNameConverter;\n+\n+\t@Inject\n+\tprivate IdeCrossrefProposalProvider crossrefProposalProvider;\n+\n+\t@Inject\n+\tprivate IdeContentProposalCreator proposalCreator;\n+\n+\t@Inject\n+\tprivate IdeContentProposalPriorities proposalPriorities;\n+\n+\t@Inject\n+\tprivate CurrentTypeFinder currentTypeFinder;\n+\n+\t/**\n+\t * Create content assist proposals and pass them to the given acceptor.\n+\t */\n+\tpublic void createProposals(Collection<ContentAssistContext> contexts, IIdeContentProposalAcceptor acceptor) {\n+\t\tfor (ContentAssistContext context : getFilteredContexts(contexts)) {\n+\t\t\tfor (AbstractElement element : context.getFirstSetGrammarElements()) {\n+\t\t\t\tif (!acceptor.canAcceptMoreProposals()) {\n+\t\t\t\t\treturn;\n+\t\t\t\t}\n+\t\t\t\tcreateProposals(element, context, acceptor);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected Iterable<ContentAssistContext> getFilteredContexts(Collection<ContentAssistContext> contexts) {\n+\t\treturn contexts;\n+\t}\n+\n+\tprotected void _createProposals(AbstractElement element, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t}\n+\n+\tprotected void _createProposals(Assignment assignment, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tAbstractElement terminal = assignment.getTerminal();\n+\t\tif (terminal instanceof CrossReference) {\n+\t\t\tcreateProposals(terminal, context, acceptor);\n+\t\t} else {\n+\t\t\tif (terminal instanceof RuleCall) {\n+\t\t\t\tAbstractRule rule = ((RuleCall) terminal).getRule();\n+\t\t\t\tif (rule instanceof TerminalRule && context.getPrefix().isEmpty()) {\n+\t\t\t\t\tfinal String proposal;\n+\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\tproposal = \"\\\"\" + assignment.getFeature() + \"\\\"\";\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\tproposal = assignment.getFeature();\n+\t\t\t\t\t}\n+\t\t\t\t\tContentAssistEntry entry = proposalCreator.createProposal(proposal, context,\n+\t\t\t\t\t\t\t(ContentAssistEntry it) -> {\n+\t\t\t\t\t\t\t\tif (\"STRING\".equals(rule.getName())) {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions()\n+\t\t\t\t\t\t\t\t\t\t\t.add(new TextRegion(context.getOffset() + 1, proposal.length() - 2));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_TEXT);\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tit.getEditPositions().add(new TextRegion(context.getOffset(), proposal.length()));\n+\t\t\t\t\t\t\t\t\tit.setKind(ContentAssistEntry.KIND_VALUE);\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tit.setDescription(rule.getName());\n+\t\t\t\t\t\t\t});\n+\t\t\t\t\tacceptor.accept(entry, proposalPriorities.getDefaultPriority(entry));\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected void _createProposals(Keyword keyword, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tif (filterKeyword(keyword, context)) {\n+\t\t\tContentAssistEntry entry = proposalCreator.createProposal(keyword.getValue(), context,\n+\t\t\t\t\tContentAssistEntry.KIND_KEYWORD, null);\n+\t\t\tif (entry != null) {\n+\t\t\t\tacceptor.accept(entry, proposalPriorities.getKeywordPriority(keyword.getValue(), entry));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprotected boolean filterKeyword(Keyword keyword, ContentAssistContext context) {\n+\t\treturn true;\n+\t}\n+\n+\tprotected void _createProposals(RuleCall ruleCall, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t}\n+\n+\tprotected void _createProposals(CrossReference reference, ContentAssistContext context,\n+\t\t\tIIdeContentProposalAcceptor acceptor) {\n+\t\tEClassifier type = currentTypeFinder.findCurrentTypeAfter(reference);\n+\t\tif (type instanceof EClass) {\n+\t\t\tEReference ereference = GrammarUtil.getReference(reference, ((EClass) type));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 140}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTQ5ODA5OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNjo0NFrOGN0rRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNjo0NFrOGN0rRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzcxNw==", "bodyText": "ICallHierarchyBuilder.CallHierarchyType -> CallHierarchyType", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417147717", "createdAt": "2020-04-29T08:26:44Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTQ5ODg4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNjo1NVrOGN0rsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNjo1NVrOGN0rsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0NzgyNQ==", "bodyText": "Unnecessary types", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417147825", "createdAt": "2020-04-29T08:26:55Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 59}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUwMDAxOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNzoxM1rOGN0sag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNzoxM1rOGN0sag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODAxMA==", "bodyText": "unnecessary type", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148010", "createdAt": "2020-04-29T08:27:13Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,\n+\t\t\t\t\t\tIReferenceDescription reference) -> {\n+\t\t\t\t\tIHierarchyNode childNode = createChild(children, declaration, parent);\n+\t\t\t\t\tif (childNode != null) {\n+\t\t\t\t\t\tIHierarchyNodeReference nodeReference = createNodeReference(reference);\n+\t\t\t\t\t\tif (nodeReference != null) {\n+\t\t\t\t\t\t\tchildNode.getReferences().add(nodeReference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\treturn children.values();\n+\t}\n+\n+\tprotected void findDeclarations(IHierarchyNode parent, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tif (hierarchyType != null) {\n+\t\t\tswitch (hierarchyType) {\n+\t\t\tcase CALLEE:\n+\t\t\t\tfindTargetDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t}\n+\t}\n+\n+\tprotected void findTargetDeclarations(URI sourceDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\treadOnly(sourceDeclarationURI, (EObject sourceDeclaration) -> {\n+\t\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t\t(IReferenceDescription reference) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 92}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUwMDUzOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNzoyMFrOGN0svQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNzoyMFrOGN0svQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODA5Mw==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148093", "createdAt": "2020-04-29T08:27:20Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,\n+\t\t\t\t\t\tIReferenceDescription reference) -> {\n+\t\t\t\t\tIHierarchyNode childNode = createChild(children, declaration, parent);\n+\t\t\t\t\tif (childNode != null) {\n+\t\t\t\t\t\tIHierarchyNodeReference nodeReference = createNodeReference(reference);\n+\t\t\t\t\t\tif (nodeReference != null) {\n+\t\t\t\t\t\t\tchildNode.getReferences().add(nodeReference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\treturn children.values();\n+\t}\n+\n+\tprotected void findDeclarations(IHierarchyNode parent, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tif (hierarchyType != null) {\n+\t\t\tswitch (hierarchyType) {\n+\t\t\tcase CALLEE:\n+\t\t\t\tfindTargetDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t}\n+\t}\n+\n+\tprotected void findTargetDeclarations(URI sourceDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\treadOnly(sourceDeclarationURI, (EObject sourceDeclaration) -> {\n+\t\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\t\tIEObjectDescription targetDeclaration = null;\n+\t\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\t\ttargetDeclaration = findTargetDeclaration(reference);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tacceptor.apply(targetDeclaration, reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\tgetReferenceFinder().findAllReferences(sourceDeclaration, referenceAcceptor, monitor);\n+\t\t\treturn null;\n+\t\t});\n+\t}\n+\n+\tprotected void findSourceDeclarations(URI targetDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tTargetURIs targetURIs = collectTargetURIs(targetDeclarationURI);\n+\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t(IReferenceDescription reference) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 110}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUwMTE4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNzoyOVrOGN0tFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNzoyOVrOGN0tFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODE4Mg==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148182", "createdAt": "2020-04-29T08:27:29Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,\n+\t\t\t\t\t\tIReferenceDescription reference) -> {\n+\t\t\t\t\tIHierarchyNode childNode = createChild(children, declaration, parent);\n+\t\t\t\t\tif (childNode != null) {\n+\t\t\t\t\t\tIHierarchyNodeReference nodeReference = createNodeReference(reference);\n+\t\t\t\t\t\tif (nodeReference != null) {\n+\t\t\t\t\t\t\tchildNode.getReferences().add(nodeReference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\treturn children.values();\n+\t}\n+\n+\tprotected void findDeclarations(IHierarchyNode parent, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tif (hierarchyType != null) {\n+\t\t\tswitch (hierarchyType) {\n+\t\t\tcase CALLEE:\n+\t\t\t\tfindTargetDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t}\n+\t}\n+\n+\tprotected void findTargetDeclarations(URI sourceDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\treadOnly(sourceDeclarationURI, (EObject sourceDeclaration) -> {\n+\t\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\t\tIEObjectDescription targetDeclaration = null;\n+\t\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\t\ttargetDeclaration = findTargetDeclaration(reference);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tacceptor.apply(targetDeclaration, reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\tgetReferenceFinder().findAllReferences(sourceDeclaration, referenceAcceptor, monitor);\n+\t\t\treturn null;\n+\t\t});\n+\t}\n+\n+\tprotected void findSourceDeclarations(URI targetDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tTargetURIs targetURIs = collectTargetURIs(targetDeclarationURI);\n+\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\tIEObjectDescription sourceDeclaration = null;\n+\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\tsourceDeclaration = findSourceDeclaration(reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tacceptor.apply(sourceDeclaration, reference);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\tgetReferenceFinder().findAllReferences(targetURIs, getResourceAccess(), getIndexData(), referenceAcceptor, monitor);\n+\t}\n+\n+\tprotected TargetURIs collectTargetURIs(URI targetURI) {\n+\t\tTargetURIs targetURIs = getTargetURIProvider().get();\n+\t\tif (targetURI == null) {\n+\t\t\treturn targetURIs;\n+\t\t}\n+\t\treadOnly(targetURI, (EObject targetObject) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUwMTc4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNzo0MFrOGN0tfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyNzo0MFrOGN0tfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODI4Nw==", "bodyText": "same", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148287", "createdAt": "2020-04-29T08:27:40Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/editor/hierarchy/DefaultCallHierarchyBuilder.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.editor.hierarchy;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+import org.eclipse.core.runtime.IProgressMonitor;\n+import org.eclipse.emf.common.util.URI;\n+import org.eclipse.emf.ecore.EObject;\n+import org.eclipse.emf.ecore.EReference;\n+import org.eclipse.emf.ecore.util.EcoreUtil;\n+import org.eclipse.xtext.findReferences.ReferenceAcceptor;\n+import org.eclipse.xtext.findReferences.TargetURIs;\n+import org.eclipse.xtext.nodemodel.ICompositeNode;\n+import org.eclipse.xtext.nodemodel.util.NodeModelUtils;\n+import org.eclipse.xtext.resource.IEObjectDescription;\n+import org.eclipse.xtext.resource.IReferenceDescription;\n+import org.eclipse.xtext.util.ITextRegionWithLineInformation;\n+import org.eclipse.xtext.xbase.lib.Procedures.Procedure2;\n+\n+import com.google.common.collect.Lists;\n+\n+/**\n+ * <p>\n+ * Default implementation of a call hierarchy builder.\n+ * </p>\n+ * \n+ * @author kosyakov - Initial contribution and API\n+ * @since 2.10\n+ */\n+public class DefaultCallHierarchyBuilder extends AbstractHierarchyBuilder implements ICallHierarchyBuilder {\n+\tprivate ICallHierarchyBuilder.CallHierarchyType hierarchyType = ICallHierarchyBuilder.CallHierarchyType.CALLER;\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildRoots(URI rootURI, IProgressMonitor monitor) {\n+\t\tIEObjectDescription rootDeclaration = findDeclaration(rootURI);\n+\t\tif (rootDeclaration == null) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\treturn Lists.newArrayList(createRoot(rootDeclaration));\n+\t}\n+\n+\t@Override\n+\tpublic Collection<IHierarchyNode> buildChildren(IHierarchyNode parent, IProgressMonitor monitor) {\n+\t\tif (!parent.mayHaveChildren()) {\n+\t\t\treturn Collections.emptyList();\n+\t\t}\n+\t\tMap<URI, IHierarchyNode> children = new LinkedHashMap<>();\n+\t\tfindDeclarations(parent, monitor,\n+\t\t\t\t(Procedure2<IEObjectDescription, IReferenceDescription>) (IEObjectDescription declaration,\n+\t\t\t\t\t\tIReferenceDescription reference) -> {\n+\t\t\t\t\tIHierarchyNode childNode = createChild(children, declaration, parent);\n+\t\t\t\t\tif (childNode != null) {\n+\t\t\t\t\t\tIHierarchyNodeReference nodeReference = createNodeReference(reference);\n+\t\t\t\t\t\tif (nodeReference != null) {\n+\t\t\t\t\t\t\tchildNode.getReferences().add(nodeReference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\treturn children.values();\n+\t}\n+\n+\tprotected void findDeclarations(IHierarchyNode parent, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tif (hierarchyType != null) {\n+\t\t\tswitch (hierarchyType) {\n+\t\t\tcase CALLEE:\n+\t\t\t\tfindTargetDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t} else {\n+\t\t\tfindSourceDeclarations(parent.getElement().getEObjectURI(), monitor, acceptor);\n+\t\t}\n+\t}\n+\n+\tprotected void findTargetDeclarations(URI sourceDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\treadOnly(sourceDeclarationURI, (EObject sourceDeclaration) -> {\n+\t\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\t\tIEObjectDescription targetDeclaration = null;\n+\t\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\t\ttargetDeclaration = findTargetDeclaration(reference);\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tacceptor.apply(targetDeclaration, reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t});\n+\t\t\tgetReferenceFinder().findAllReferences(sourceDeclaration, referenceAcceptor, monitor);\n+\t\t\treturn null;\n+\t\t});\n+\t}\n+\n+\tprotected void findSourceDeclarations(URI targetDeclarationURI, IProgressMonitor monitor,\n+\t\t\tProcedure2<? super IEObjectDescription, ? super IReferenceDescription> acceptor) {\n+\t\tTargetURIs targetURIs = collectTargetURIs(targetDeclarationURI);\n+\t\tReferenceAcceptor referenceAcceptor = new ReferenceAcceptor(getResourceServiceProviderRegistry(),\n+\t\t\t\t(IReferenceDescription reference) -> {\n+\t\t\t\t\tif (filterReference(reference)) {\n+\t\t\t\t\t\tIEObjectDescription sourceDeclaration = null;\n+\t\t\t\t\t\tif (reference != null) {\n+\t\t\t\t\t\t\tsourceDeclaration = findSourceDeclaration(reference);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tacceptor.apply(sourceDeclaration, reference);\n+\t\t\t\t\t}\n+\t\t\t\t});\n+\t\tgetReferenceFinder().findAllReferences(targetURIs, getResourceAccess(), getIndexData(), referenceAcceptor, monitor);\n+\t}\n+\n+\tprotected TargetURIs collectTargetURIs(URI targetURI) {\n+\t\tTargetURIs targetURIs = getTargetURIProvider().get();\n+\t\tif (targetURI == null) {\n+\t\t\treturn targetURIs;\n+\t\t}\n+\t\treadOnly(targetURI, (EObject targetObject) -> {\n+\t\t\tif (targetObject != null) {\n+\t\t\t\tgetTargetURICollector().add(targetObject, targetURIs);\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t});\n+\t\treturn targetURIs;\n+\t}\n+\n+\tprotected boolean filterReference(IReferenceDescription reference) {\n+\t\treturn reference != null;\n+\t}\n+\n+\tprotected IEObjectDescription findDeclaration(URI objectURI) {\n+\t\treturn getDescription(objectURI);\n+\t}\n+\n+\tprotected IEObjectDescription findTargetDeclaration(IReferenceDescription reference) {\n+\t\treturn findDeclaration(reference.getTargetEObjectUri());\n+\t}\n+\n+\tprotected IEObjectDescription findSourceDeclaration(IReferenceDescription reference) {\n+\t\treturn findDeclaration(reference.getContainerEObjectURI());\n+\t}\n+\n+\t/**\n+\t * @return a root hierarchy node for the given declaration; cannot be <code>null</code>\n+\t */\n+\tprotected IHierarchyNode createRoot(IEObjectDescription declaration) {\n+\t\tDefaultHierarchyNode node = new DefaultHierarchyNode();\n+\t\tnode.setElement(declaration);\n+\t\tnode.setMayHaveChildren(true);\n+\t\treturn node;\n+\t}\n+\n+\t/**\n+\t * @return a child node for the given declaration and the parent node; cannot be <code>null</code>\n+\t */\n+\tprotected IHierarchyNode createChild(IEObjectDescription declaration, IHierarchyNode parent) {\n+\t\tDefaultHierarchyNode node = new DefaultHierarchyNode();\n+\t\tnode.setParent(parent);\n+\t\tnode.setElement(declaration);\n+\t\tnode.setMayHaveChildren(!node.isRecursive());\n+\t\treturn node;\n+\t}\n+\n+\tprotected IHierarchyNode createChild(Map<URI, IHierarchyNode> children, IEObjectDescription declaration,\n+\t\t\tIHierarchyNode parent) {\n+\t\tif (declaration == null) {\n+\t\t\treturn null;\n+\t\t}\n+\t\tIHierarchyNode childNode = children.get(declaration.getEObjectURI());\n+\t\tif (childNode == null) {\n+\t\t\tchildNode = createChild(declaration, parent);\n+\t\t\tchildren.put(declaration.getEObjectURI(), childNode);\n+\t\t}\n+\t\treturn childNode;\n+\t}\n+\n+\t/**\n+\t * @return a hierarchy node reference for the given reference; cannot be <code>null</code>\n+\t */\n+\tprotected IHierarchyNodeReference createNodeReference(IReferenceDescription reference) {\n+\t\treturn readOnly(reference.getSourceEObjectUri(), (EObject sourceObject) -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 190}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUwNDg4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyODozOVrOGN0vkg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODoyODozOVrOGN0vkg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE0ODgxOA==", "bodyText": "Integer.valueOf not necessary", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417148818", "createdAt": "2020-04-29T08:28:39Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tchar LF = '\\r';\n+\t\tint l = contents.length();\n+\t\tStringBuilder lineContent = new StringBuilder();\n+\t\tint line = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tif (line > lineNumber) {\n+\t\t\t\treturn lineContent.toString();\n+\t\t\t}\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (line == lineNumber && ch != NL && ch != LF) {\n+\t\t\t\tlineContent.append(ch);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t}\n+\t\t}\n+\t\tif (line < lineNumber) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 131}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUxMzA1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMDo1MlrOGN00iA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMDo1MlrOGN00iA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MDA4OA==", "bodyText": "can be inlined", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417150088", "createdAt": "2020-04-29T08:30:52Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\tchar NL = '\\n';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 109}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUxMzUwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMTowMFrOGN00xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMTowMFrOGN00xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MDE1MQ==", "bodyText": "Integer.valueOf", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417150151", "createdAt": "2020-04-29T08:31:00Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 107}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUxNDIwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMToxMlrOGN01Ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMToxMlrOGN01Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MDI2Mg==", "bodyText": "inline", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417150262", "createdAt": "2020-04-29T08:31:12Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 78}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUyMTE4OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMzoxM1rOGN05eQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMzoxM1rOGN05eQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MTM1Mw==", "bodyText": "Hmm should contents be part of toString if printSourceOnError is false?", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417151353", "createdAt": "2020-04-29T08:33:13Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tchar LF = '\\r';\n+\t\tint l = contents.length();\n+\t\tStringBuilder lineContent = new StringBuilder();\n+\t\tint line = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tif (line > lineNumber) {\n+\t\t\t\treturn lineContent.toString();\n+\t\t\t}\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (line == lineNumber && ch != NL && ch != LF) {\n+\t\t\t\tlineContent.append(ch);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t}\n+\t\t}\n+\t\tif (line < lineNumber) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\treturn lineContent.toString();\n+\t}\n+\n+\t/**\n+\t * Get the number of lines in the document. Empty document has line count: {@code 1}.\n+\t */\n+\tpublic int getLineCount() {\n+\t\treturn getPosition(contents.length()).getLine() + 1;\n+\t}\n+\n+\tpublic String getSubstring(Range range) {\n+\t\tint start = getOffSet(range.getStart());\n+\t\tint end = getOffSet(range.getEnd());\n+\t\treturn contents.substring(start, end);\n+\t}\n+\n+\t/**\n+\t * As opposed to {@link TextEdit}[] the positions in the edits of a {@link DidChangeTextDocumentParams} refer to the\n+\t * state after applying the preceding edits. See\n+\t * https://microsoft.github.io/language-server-protocol/specification#textedit-1 and\n+\t * https://github.com/microsoft/vscode/issues/23173#issuecomment-289378160 for details.\n+\t * \n+\t * @return a new document with an incremented version and the text document changes applied.\n+\t * @since 2.18\n+\t */\n+\tpublic Document applyTextDocumentChanges(Iterable<? extends TextDocumentContentChangeEvent> changes) {\n+\t\tDocument currentDocument = this;\n+\t\tInteger newVersion = null;\n+\t\tif (currentDocument.version != null) {\n+\t\t\tnewVersion = Integer.valueOf(currentDocument.version.intValue() + 1);\n+\t\t}\n+\t\tfor (TextDocumentContentChangeEvent change : changes) {\n+\t\t\tfinal String newContent;\n+\t\t\tif (change.getRange() == null) {\n+\t\t\t\tnewContent = change.getText();\n+\t\t\t} else {\n+\t\t\t\tint start = currentDocument.getOffSet(change.getRange().getStart());\n+\t\t\t\tint end = currentDocument.getOffSet(change.getRange().getEnd());\n+\t\t\t\tnewContent = currentDocument.contents.substring(0, start) + change.getText()\n+\t\t\t\t\t\t+ currentDocument.contents.substring(end);\n+\t\t\t}\n+\t\t\tcurrentDocument = new Document(newVersion, newContent, printSourceOnError);\n+\t\t}\n+\t\treturn currentDocument;\n+\t}\n+\n+\t/**\n+\t * Only use for testing.\n+\t * \n+\t * All positions in the {@link TextEdit}s refer to the same original document (this).\n+\t */\n+\tpublic Document applyChanges(Iterable<? extends TextEdit> changes) {\n+\t\tString newContent = contents;\n+\t\tfor (TextEdit change : changes) {\n+\t\t\tif (change.getRange() == null) {\n+\t\t\t\tnewContent = change.getNewText();\n+\t\t\t} else {\n+\t\t\t\tint start = getOffSet(change.getRange().getStart());\n+\t\t\t\tint end = getOffSet(change.getRange().getEnd());\n+\t\t\t\tnewContent = newContent.substring(0, start) + change.getNewText() + newContent.substring(end);\n+\t\t\t}\n+\t\t}\n+\t\tInteger newVersion = null;\n+\t\tif (version != null) {\n+\t\t\tnewVersion = Integer.valueOf(version.intValue() + 1);\n+\t\t}\n+\t\treturn new Document(newVersion, newContent);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic boolean isPrintSourceOnError() {\n+\t\treturn printSourceOnError;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\tfinal int prime = 31;\n+\t\tint result = 1;\n+\t\tresult = prime * result + ((contents == null) ? 0 : contents.hashCode());\n+\t\tresult = prime * result + (printSourceOnError ? 1231 : 1237);\n+\t\tresult = prime * result + ((version == null) ? 0 : version.hashCode());\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object obj) {\n+\t\tif (this == obj)\n+\t\t\treturn true;\n+\t\tif (obj == null)\n+\t\t\treturn false;\n+\t\tif (getClass() != obj.getClass())\n+\t\t\treturn false;\n+\t\tDocument other = (Document) obj;\n+\t\tif (contents == null) {\n+\t\t\tif (other.contents != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!contents.equals(other.contents))\n+\t\t\treturn false;\n+\t\tif (printSourceOnError != other.printSourceOnError)\n+\t\t\treturn false;\n+\t\tif (version == null) {\n+\t\t\tif (other.version != null)\n+\t\t\t\treturn false;\n+\t\t} else if (!version.equals(other.version))\n+\t\t\treturn false;\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\tToStringBuilder b = new ToStringBuilder(this);\n+\t\tb.add(\"version\", version);\n+\t\tb.add(\"contents\", contents);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUyMjY0OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMzozN1rOGN06VQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozMzozN1rOGN06VQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MTU3Mw==", "bodyText": "It would make me so happy to have getOffset instead of getOffSet :D", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417151573", "createdAt": "2020-04-29T08:33:37Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 42}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUyNjQwOnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozNDozOFrOGN08kw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozNDozOFrOGN08kw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1MjE0Nw==", "bodyText": "we could extract a method that created the exception consistently", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417152147", "createdAt": "2020-04-29T08:34:38Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.ide/src/org/eclipse/xtext/ide/server/Document.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/**\n+ * Copyright (c) 2016, 2020 TypeFox GmbH (http://www.typefox.io) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.ide.server;\n+\n+import org.eclipse.lsp4j.DidChangeTextDocumentParams;\n+import org.eclipse.lsp4j.Position;\n+import org.eclipse.lsp4j.Range;\n+import org.eclipse.lsp4j.TextDocumentContentChangeEvent;\n+import org.eclipse.lsp4j.TextEdit;\n+import org.eclipse.xtext.xbase.lib.util.ToStringBuilder;\n+\n+/**\n+ * @author Sven Efftinge - Initial contribution and API\n+ * @since 2.11\n+ */\n+public class Document {\n+\tprivate final Integer version;\n+\n+\tprivate final String contents;\n+\n+\tprivate final boolean printSourceOnError;\n+\n+\tpublic Document(Integer version, String contents) {\n+\t\tthis(version, contents, true);\n+\t}\n+\n+\t/**\n+\t * @since 2.15\n+\t */\n+\tpublic Document(Integer version, String contents, boolean printSourceOnError) {\n+\t\tthis.version = version;\n+\t\tthis.contents = contents;\n+\t\tthis.printSourceOnError = printSourceOnError;\n+\t}\n+\n+\tpublic int getOffSet(Position position) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\t\treturn i;\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\tif (position.getLine() == line && position.getCharacter() == column) {\n+\t\t\treturn l;\n+\t\t}\n+\t\tString source = \"\";\n+\t\tif (printSourceOnError) {\n+\t\t\tsource = \" text was : \" + contents;\n+\t\t}\n+\t\tthrow new IndexOutOfBoundsException(position.toString() + source);\n+\t}\n+\n+\tpublic Position getPosition(int offset) throws IndexOutOfBoundsException {\n+\t\tint l = contents.length();\n+\t\tif (offset < 0 || offset > l) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(offset) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tint line = 0;\n+\t\tint column = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (i == offset) {\n+\t\t\t\treturn new Position(line, column);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t\tcolumn = 0;\n+\t\t\t} else {\n+\t\t\t\tcolumn++;\n+\t\t\t}\n+\t\t}\n+\t\treturn new Position(line, column);\n+\t}\n+\n+\t/**\n+\t * Returns with the text for a certain line without the trailing end line marker. Throws an\n+\t * {@link IndexOutOfBoundsException} if the zero-based {@code lineNumber} argument is negative or exceeds the number\n+\t * of lines in the document.\n+\t */\n+\tpublic String getLineContent(int lineNumber) throws IndexOutOfBoundsException {\n+\t\tif (lineNumber < 0) {\n+\t\t\tString source = \"\";\n+\t\t\tif (printSourceOnError) {\n+\t\t\t\tsource = \" text was : \" + contents;\n+\t\t\t}\n+\t\t\tthrow new IndexOutOfBoundsException(Integer.valueOf(lineNumber) + source);\n+\t\t}\n+\t\tchar NL = '\\n';\n+\t\tchar LF = '\\r';\n+\t\tint l = contents.length();\n+\t\tStringBuilder lineContent = new StringBuilder();\n+\t\tint line = 0;\n+\t\tfor (int i = 0; i < l; i++) {\n+\t\t\tif (line > lineNumber) {\n+\t\t\t\treturn lineContent.toString();\n+\t\t\t}\n+\t\t\tchar ch = contents.charAt(i);\n+\t\t\tif (line == lineNumber && ch != NL && ch != LF) {\n+\t\t\t\tlineContent.append(ch);\n+\t\t\t}\n+\t\t\tif (ch == NL) {\n+\t\t\t\tline++;\n+\t\t\t}\n+\t\t}\n+\t\tif (line < lineNumber) {\n+\t\t\tString source = \"\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 127}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTUzNjU1OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/SubProjectConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozNzoyNFrOGN1C2g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozNzoyNFrOGN1C2g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1Mzc1NA==", "bodyText": "Accessors", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417153754", "createdAt": "2020-04-29T08:37:24Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/model/project/SubProjectConfig.java", "diffHunk": "@@ -0,0 +1,171 @@\n+/**\n+ * Copyright (c) 2015, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xtext.generator.model.project;\n+\n+import org.eclipse.xtend.lib.annotations.AccessorType;\n+import org.eclipse.xtend.lib.annotations.Accessors;\n+import org.eclipse.xtext.xtext.generator.Issues;\n+import org.eclipse.xtext.xtext.generator.model.IXtextGeneratorFileSystemAccess;\n+\n+import com.google.common.base.Strings;\n+import com.google.inject.Inject;\n+import com.google.inject.Injector;\n+\n+/**\n+ * Configuration of subprojects.\n+ * \n+ * @noextend This class should not be extended by clients.\n+ */\n+public class SubProjectConfig implements ISubProjectConfig {\n+\t@Inject\n+\tprivate XtextProjectConfig owner;\n+\n+\tprivate boolean enabled;\n+\n+\tprivate boolean overwriteSrc;\n+\n+\tprivate String name;\n+\n+\tprivate String rootPath;\n+\n+\tprivate IXtextGeneratorFileSystemAccess root;\n+\n+\tprivate String metaInfPath;\n+\n+\tprivate IXtextGeneratorFileSystemAccess metaInf;\n+\n+\tprivate String srcPath;\n+\n+\tprivate IXtextGeneratorFileSystemAccess src;\n+\n+\tprivate String srcGenPath;\n+\n+\tprivate IXtextGeneratorFileSystemAccess srcGen;\n+\n+\t@Accessors(AccessorType.PUBLIC_GETTER)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 51}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjU5NTU0MTM3OnYy", "diffSide": "RIGHT", "path": "org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/serializer/NamedSerializationContexts.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozODo1MVrOGN1F0w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yOVQwODozODo1MVrOGN1F0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNzE1NDUxNQ==", "bodyText": "", "url": "https://github.com/eclipse/xtext-core/pull/1456#discussion_r417154515", "createdAt": "2020-04-29T08:38:51Z", "author": {"login": "szarnekow"}, "path": "org.eclipse.xtext.xtext.generator/src/org/eclipse/xtext/xtext/generator/serializer/NamedSerializationContexts.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/**\n+ * Copyright (c) 2016, 2020 itemis AG (http://www.itemis.eu) and others.\n+ * This program and the accompanying materials are made available under the\n+ * terms of the Eclipse Public License 2.0 which is available at\n+ * http://www.eclipse.org/legal/epl-2.0.\n+ * \n+ * SPDX-License-Identifier: EPL-2.0\n+ */\n+package org.eclipse.xtext.xtext.generator.serializer;\n+\n+import java.util.List;\n+\n+import org.eclipse.emf.ecore.EClass;\n+import org.eclipse.xtext.serializer.ISerializationContext;\n+\n+public class NamedSerializationContexts<T extends Object> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f763ab94c45e628f5bef55f0e9ed360e59bd7493"}, "originalPosition": 16}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1098, "cost": 1, "resetAt": "2021-11-12T18:49:56Z"}}}