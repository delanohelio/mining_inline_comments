{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3OTQ2NTA5", "number": 2485, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNTowNlrOETlJqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNToyNlrOETlKNQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTY3MDgxOnYy", "diffSide": "RIGHT", "path": "docs/source/essentials/using-aliases.mdx", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNTowNlrOG5ZGqQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNjowNlrOG5ZI6g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzMyMQ==", "bodyText": "The second half of the sentence uses we/us. The first half can do that too.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            If you encouter one, please let me know so I can put a valid example here (we usually fix those issues as we go but there certainly are a few left in the wild). Until we fix it in the singularization code, you can use an alias to control the name of the model in your code.\n          \n          \n            \n            If you encouter one, please let us know so we can put a valid example here (we usually fix those issues as we go but there certainly are a few left in the wild). Until we fix it in the singularization code, you can use an alias to control the name of the model in your code.", "url": "https://github.com/apollographql/apollo-android/pull/2485#discussion_r462833321", "createdAt": "2020-07-30T08:25:06Z", "author": {"login": "tasomaniac"}, "path": "docs/source/essentials/using-aliases.mdx", "diffHunk": "@@ -0,0 +1,85 @@\n+---\n+title: Using aliases\n+---\n+\n+When generating code, Apollo Android uses the name of your fields to generate matching typesafe models using a flat hierarchy. The following query:\n+\n+```graphql:title=GetContact.graphql\n+query GetContact {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+    # The generated model will be named `WorkAddress`\n+    workAddress {\n+      country\n+    }\n+  }\n+}\n+```\n+\n+will generate models like this:\n+\n+```kotlin\n+class GetContact {\n+  class Data { ... }\n+  class Contact { ... }\n+  class HomeAddress { ... }\n+  class WorkAddress { ... }\n+}\n+```\n+\n+The driving principles behind the naming conventions are:\n+* Use the field name for model names: we considered using the schema type name instead but that would make a lot of conflicts. In the example above, for an example, we would have two different `Address` classes.\n+* Keep a flat hierarchy of classes: we considered using nested classes but that can lead to very long names and a flat hierarchy is easier to read.\n+* Singularize the field name when it is a list: if your query contains a List fields, such as `nodes` for an example, it makes more sense to generate a `List<Node>` than a `List<Nodes>`.\n+\n+These principles work great for the vast majority of cases but can't account for name clashes or peculiar singularization rules. To workaround these, you can use GraphQL [aliases](https://graphql.org/learn/queries/#aliases).\n+\n+## Using aliases to avoid name clashes\n+\n+Since the class hierarchy is flat, having two fields with the same name in two different parts of the query tree could lead to name clashes. Having relay-style pagination with lots of `nodes` or `edges` fields, might typically trigger name clashes. To avoid them, Apollo Android will append a numeric suffix to your models:\n+\n+```graphql:title=GetContact.graphql\n+query GetContacts {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+  }\n+  emergencyContact {\n+    # The generated model will be named `HomeAddress1` by default\n+    homeAddress {\n+      street\n+    }\n+  }\n+}\n+```\n+\n+Suffixing avoids the name clash but feels a bit out of place and it's hard to remember what `HomeAddress1` is about. To workaround this issue, you can alias the field:\n+\n+```graphql:title=GetContact.graphql\n+query GetContacts {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+  }\n+  emergencyContact {\n+    # With an alias, the generated model will be named `EmergencyAddress`\n+    emergencyAddress: homeAddress {\n+      street\n+    }\n+  }\n+}\n+```\n+\n+## Using aliases to fix singularization rules\n+\n+The [singularization code](https://github.com/martinbonnin/apollo-android/blob/master/apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/Inflector.kt) works most of time but does not contain all the exceptions in the english dictionnary.\n+\n+If you encouter one, please let me know so I can put a valid example here (we usually fix those issues as we go but there certainly are a few left in the wild). Until we fix it in the singularization code, you can use an alias to control the name of the model in your code.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f198d4a2331fb6019a39ee6705e89ae3ab6cc8aa"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzg5OA==", "bodyText": "Good catch, thanks!", "url": "https://github.com/apollographql/apollo-android/pull/2485#discussion_r462833898", "createdAt": "2020-07-30T08:26:06Z", "author": {"login": "martinbonnin"}, "path": "docs/source/essentials/using-aliases.mdx", "diffHunk": "@@ -0,0 +1,85 @@\n+---\n+title: Using aliases\n+---\n+\n+When generating code, Apollo Android uses the name of your fields to generate matching typesafe models using a flat hierarchy. The following query:\n+\n+```graphql:title=GetContact.graphql\n+query GetContact {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+    # The generated model will be named `WorkAddress`\n+    workAddress {\n+      country\n+    }\n+  }\n+}\n+```\n+\n+will generate models like this:\n+\n+```kotlin\n+class GetContact {\n+  class Data { ... }\n+  class Contact { ... }\n+  class HomeAddress { ... }\n+  class WorkAddress { ... }\n+}\n+```\n+\n+The driving principles behind the naming conventions are:\n+* Use the field name for model names: we considered using the schema type name instead but that would make a lot of conflicts. In the example above, for an example, we would have two different `Address` classes.\n+* Keep a flat hierarchy of classes: we considered using nested classes but that can lead to very long names and a flat hierarchy is easier to read.\n+* Singularize the field name when it is a list: if your query contains a List fields, such as `nodes` for an example, it makes more sense to generate a `List<Node>` than a `List<Nodes>`.\n+\n+These principles work great for the vast majority of cases but can't account for name clashes or peculiar singularization rules. To workaround these, you can use GraphQL [aliases](https://graphql.org/learn/queries/#aliases).\n+\n+## Using aliases to avoid name clashes\n+\n+Since the class hierarchy is flat, having two fields with the same name in two different parts of the query tree could lead to name clashes. Having relay-style pagination with lots of `nodes` or `edges` fields, might typically trigger name clashes. To avoid them, Apollo Android will append a numeric suffix to your models:\n+\n+```graphql:title=GetContact.graphql\n+query GetContacts {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+  }\n+  emergencyContact {\n+    # The generated model will be named `HomeAddress1` by default\n+    homeAddress {\n+      street\n+    }\n+  }\n+}\n+```\n+\n+Suffixing avoids the name clash but feels a bit out of place and it's hard to remember what `HomeAddress1` is about. To workaround this issue, you can alias the field:\n+\n+```graphql:title=GetContact.graphql\n+query GetContacts {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+  }\n+  emergencyContact {\n+    # With an alias, the generated model will be named `EmergencyAddress`\n+    emergencyAddress: homeAddress {\n+      street\n+    }\n+  }\n+}\n+```\n+\n+## Using aliases to fix singularization rules\n+\n+The [singularization code](https://github.com/martinbonnin/apollo-android/blob/master/apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/Inflector.kt) works most of time but does not contain all the exceptions in the english dictionnary.\n+\n+If you encouter one, please let me know so I can put a valid example here (we usually fix those issues as we go but there certainly are a few left in the wild). Until we fix it in the singularization code, you can use an alias to control the name of the model in your code.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzMyMQ=="}, "originalCommit": {"oid": "f198d4a2331fb6019a39ee6705e89ae3ab6cc8aa"}, "originalPosition": 84}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4OTY3MjIxOnYy", "diffSide": "RIGHT", "path": "docs/source/essentials/using-aliases.mdx", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNToyNlrOG5ZHgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0zMFQwODoyNToyNlrOG5ZHgA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjgzMzUzNg==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            The [singularization code](https://github.com/martinbonnin/apollo-android/blob/master/apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/Inflector.kt) works most of time but does not contain all the exceptions in the english dictionnary.\n          \n          \n            \n            The [singularization code](https://github.com/martinbonnin/apollo-android/blob/master/apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/Inflector.kt) works most of time but does not contain all the exceptions in the English dictionnary.", "url": "https://github.com/apollographql/apollo-android/pull/2485#discussion_r462833536", "createdAt": "2020-07-30T08:25:26Z", "author": {"login": "tasomaniac"}, "path": "docs/source/essentials/using-aliases.mdx", "diffHunk": "@@ -0,0 +1,85 @@\n+---\n+title: Using aliases\n+---\n+\n+When generating code, Apollo Android uses the name of your fields to generate matching typesafe models using a flat hierarchy. The following query:\n+\n+```graphql:title=GetContact.graphql\n+query GetContact {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+    # The generated model will be named `WorkAddress`\n+    workAddress {\n+      country\n+    }\n+  }\n+}\n+```\n+\n+will generate models like this:\n+\n+```kotlin\n+class GetContact {\n+  class Data { ... }\n+  class Contact { ... }\n+  class HomeAddress { ... }\n+  class WorkAddress { ... }\n+}\n+```\n+\n+The driving principles behind the naming conventions are:\n+* Use the field name for model names: we considered using the schema type name instead but that would make a lot of conflicts. In the example above, for an example, we would have two different `Address` classes.\n+* Keep a flat hierarchy of classes: we considered using nested classes but that can lead to very long names and a flat hierarchy is easier to read.\n+* Singularize the field name when it is a list: if your query contains a List fields, such as `nodes` for an example, it makes more sense to generate a `List<Node>` than a `List<Nodes>`.\n+\n+These principles work great for the vast majority of cases but can't account for name clashes or peculiar singularization rules. To workaround these, you can use GraphQL [aliases](https://graphql.org/learn/queries/#aliases).\n+\n+## Using aliases to avoid name clashes\n+\n+Since the class hierarchy is flat, having two fields with the same name in two different parts of the query tree could lead to name clashes. Having relay-style pagination with lots of `nodes` or `edges` fields, might typically trigger name clashes. To avoid them, Apollo Android will append a numeric suffix to your models:\n+\n+```graphql:title=GetContact.graphql\n+query GetContacts {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+  }\n+  emergencyContact {\n+    # The generated model will be named `HomeAddress1` by default\n+    homeAddress {\n+      street\n+    }\n+  }\n+}\n+```\n+\n+Suffixing avoids the name clash but feels a bit out of place and it's hard to remember what `HomeAddress1` is about. To workaround this issue, you can alias the field:\n+\n+```graphql:title=GetContact.graphql\n+query GetContacts {\n+  contact(name: \"Byron\") {\n+    # The generated model will be named `HomeAddress`\n+    homeAddress {\n+      street\n+    }\n+  }\n+  emergencyContact {\n+    # With an alias, the generated model will be named `EmergencyAddress`\n+    emergencyAddress: homeAddress {\n+      street\n+    }\n+  }\n+}\n+```\n+\n+## Using aliases to fix singularization rules\n+\n+The [singularization code](https://github.com/martinbonnin/apollo-android/blob/master/apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/Inflector.kt) works most of time but does not contain all the exceptions in the english dictionnary.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f198d4a2331fb6019a39ee6705e89ae3ab6cc8aa"}, "originalPosition": 82}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3006, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}