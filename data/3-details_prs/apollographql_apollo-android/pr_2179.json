{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAzOTE4MzIx", "number": 2179, "title": "Add networking layer to KMP sample", "bodyText": "", "createdAt": "2020-04-15T18:25:15Z", "url": "https://github.com/apollographql/apollo-android/pull/2179", "merged": true, "mergeCommit": {"oid": "d024a2b898d3c4ff4692b4d943f0f5178355ec4b"}, "closed": true, "closedAt": "2020-04-15T21:13:42Z", "author": {"login": "sav007"}, "timelineItems": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcX8V6rgH2gAyNDAzOTE4MzIxOjg0MDk0YTU2M2YzNzBlMTY0OGUwODExMTUxMDU4NTQ5YWYyMTVkNzE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcZRzecAFqTM5NjA2NjU1OA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "84094a563f370e1648e0811151058549af215d71", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/84094a563f370e1648e0811151058549af215d71", "committedDate": "2020-04-15T18:24:35Z", "message": "Add networking layer to KMP sample"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MDQzOTg2", "url": "https://github.com/apollographql/apollo-android/pull/2179#pullrequestreview-394043986", "createdAt": "2020-04-15T18:49:37Z", "commit": {"oid": "84094a563f370e1648e0811151058549af215d71"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk0MTI5NTUy", "url": "https://github.com/apollographql/apollo-android/pull/2179#pullrequestreview-394129552", "createdAt": "2020-04-15T20:57:34Z", "commit": {"oid": "84094a563f370e1648e0811151058549af215d71"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MDY2NTU4", "url": "https://github.com/apollographql/apollo-android/pull/2179#pullrequestreview-396066558", "createdAt": "2020-04-19T21:58:47Z", "commit": {"oid": "84094a563f370e1648e0811151058549af215d71"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMTo1ODo0OFrOGH9gUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xOVQyMTo1ODo0OFrOGH9gUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTAwMDkxNQ==", "bodyText": "@sav007 Is there any specific reason to use DetachedObjectGraph here compared to just StableRef ? I was under the impression that the  advantage of DetachedObjectGraph was that it could work with unfrozen references by making sure no one else accesses them but since everything is frozen here, a StableRef would work just as well ?", "url": "https://github.com/apollographql/apollo-android/pull/2179#discussion_r411000915", "createdAt": "2020-04-19T21:58:48Z", "author": {"login": "martinbonnin"}, "path": "samples/multiplatform/kmp-lib-sample/src/iosMain/kotlin/com/apollographql/apollo/kmpsample/data/ApolloNetworkClient.kt", "diffHunk": "@@ -0,0 +1,145 @@\n+package com.apollographql.apollo.kmpsample.data\n+\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import kotlinx.cinterop.ByteVar\n+import kotlinx.cinterop.COpaquePointer\n+import kotlinx.cinterop.CPointer\n+import kotlinx.cinterop.StableRef\n+import kotlinx.cinterop.addressOf\n+import kotlinx.cinterop.asStableRef\n+import kotlinx.cinterop.convert\n+import kotlinx.cinterop.get\n+import kotlinx.cinterop.reinterpret\n+import kotlinx.cinterop.staticCFunction\n+import kotlinx.cinterop.usePinned\n+import kotlinx.coroutines.CancellableContinuation\n+import kotlinx.coroutines.suspendCancellableCoroutine\n+import okio.Buffer\n+import okio.IOException\n+import platform.Foundation.NSData\n+import platform.Foundation.NSError\n+import platform.Foundation.NSHTTPURLResponse\n+import platform.Foundation.NSMutableData\n+import platform.Foundation.NSMutableURLRequest\n+import platform.Foundation.NSThread\n+import platform.Foundation.NSURL\n+import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n+import platform.Foundation.NSURLResponse\n+import platform.Foundation.NSURLSession\n+import platform.Foundation.NSURLSessionConfiguration\n+import platform.Foundation.appendBytes\n+import platform.Foundation.dataTaskWithRequest\n+import platform.Foundation.setHTTPBody\n+import platform.Foundation.setHTTPMethod\n+import platform.Foundation.setValue\n+import platform.darwin.dispatch_async_f\n+import platform.darwin.dispatch_get_main_queue\n+import kotlin.coroutines.resume\n+import kotlin.coroutines.resumeWithException\n+import kotlin.native.concurrent.DetachedObjectGraph\n+import kotlin.native.concurrent.attach\n+import kotlin.native.concurrent.freeze\n+\n+internal class ApolloNetworkClient(\n+    private val url: String,\n+    private val headers: Map<String, String> = emptyMap()\n+) {\n+\n+  suspend fun <T : Operation.Data> Operation<*, T, *>.send(): Response<T> {\n+    val session = NSURLSession.sessionWithConfiguration(NSURLSessionConfiguration.defaultSessionConfiguration())\n+    val request = prepareRequest(url = url, headers = headers)\n+    return suspendCancellableCoroutine { continuation ->\n+      assert(NSThread.isMainThread())\n+      val continuationRef = StableRef.create(continuation).asCPointer()\n+      try {\n+        val delegate = { httpData: NSData?, httpResponse: NSURLResponse?, error: NSError? ->\n+          initRuntimeIfNeeded()\n+          val response = parse(\n+              data = httpData,\n+              httpResponse = httpResponse as NSHTTPURLResponse,\n+              error = error\n+          )\n+          response.dispatchOnMain(continuationRef)\n+        }\n+        session.dataTaskWithRequest(request.freeze(), delegate.freeze()).resume()\n+      } catch (e: Exception) {\n+        continuationRef.asStableRef<CancellableContinuation<Response<T>>>().dispose()\n+        continuation.resumeWithException(e)\n+      }\n+    }\n+  }\n+\n+  private fun <D : Operation.Data> Operation<D, *, *>.prepareRequest(\n+      url: String,\n+      headers: Map<String, String> = emptyMap()\n+  ): NSMutableURLRequest {\n+    return NSMutableURLRequest.requestWithURL(NSURL(string = url)).apply {\n+      setHTTPMethod(\"POST\")\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+      headers.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setValue(operationId(), forHTTPHeaderField = \"X-APOLLO-OPERATION-ID\")\n+      setValue(name().name(), forHTTPHeaderField = \"X-APOLLO-OPERATION-NAME\")\n+      setHTTPBody(composeRequestBody().toByteArray().toNSData())\n+    }\n+  }\n+\n+  private fun <T : Operation.Data> Operation<*, T, *>.parse(\n+      data: NSData?,\n+      httpResponse: NSHTTPURLResponse,\n+      error: NSError?\n+  ): Result<T> {\n+    if (error != null) {\n+      return Result.Failure(IOException(error.localizedDescription))\n+    }\n+\n+    return try {\n+      val statusCode = httpResponse.statusCode.toInt()\n+      if (statusCode in 200..299) {\n+        val payload = data!!.toByteArray()\n+        val response = parse(Buffer().write(payload))\n+        Result.Success(response)\n+      } else {\n+        Result.Failure(IOException(\"Network request failed, HTTP status code `$statusCode`\"))\n+      }\n+    } catch (e: Exception) {\n+      Result.Failure(e)\n+    }\n+  }\n+\n+  private sealed class Result<T : Operation.Data> {\n+    class Success<T : Operation.Data>(val value: Response<T>) : Result<T>()\n+    class Failure<T : Operation.Data>(val error: Exception) : Result<T>()\n+  }\n+\n+  private fun ByteArray.toNSData(): NSData = NSMutableData().apply {\n+    if (isEmpty()) return@apply\n+    this@toNSData.usePinned {\n+      appendBytes(it.addressOf(0), size.convert())\n+    }\n+  }\n+\n+  private fun NSData.toByteArray(): ByteArray {\n+    val data: CPointer<ByteVar> = bytes!!.reinterpret()\n+    return ByteArray(length.toInt()) { index -> data[index] }\n+  }\n+\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun <T : Operation.Data> Result<T>.dispatchOnMain(continuationRef: COpaquePointer) {\n+    dispatch_async_f(\n+        queue = dispatch_get_main_queue(),\n+        context = DetachedObjectGraph { (continuationRef to this).freeze() }.asCPointer(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "84094a563f370e1648e0811151058549af215d71"}, "originalPosition": 131}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3954, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}