{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1Mzk4Mzgx", "number": 2257, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyNjozMlrOD6ztHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyNzowOVrOD6ztdg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxMTM1OnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyNjozMlrOGS2V9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzozNzoxMlrOGS2ebg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzkxMA==", "bodyText": "Just curious: does this actually save time ?", "url": "https://github.com/apollographql/apollo-android/pull/2257#discussion_r422417910", "createdAt": "2020-05-08T23:26:32Z", "author": {"login": "martinbonnin"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "diffHunk": "@@ -645,29 +645,48 @@ class GraphQLDocumentParser(val schema: Schema, private val packageNameProvider:\n     }\n   }\n \n-  private fun Set<String>.usedSchemaTypes(exclude: Set<String> = emptySet()): Set<Schema.Type> {\n+  private fun Set<String>.usedSchemaTypes(): Set<Schema.Type> {\n     if (isEmpty()) {\n       return emptySet()\n     }\n \n-    val usedSchemaTypes = filter { ScalarType.forName(it) == null }\n+    val (scalarTypes, inputObjectTypes) = filter { ScalarType.forName(it) == null }\n         .map { schema[it] ?: throw GraphQLParseException(message = \"Undefined schema type `$it`\") }\n         .filter { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM || type.kind == Schema.Kind.INPUT_OBJECT }\n-        .toSet()\n+        .partition { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM }\n+        .let { (scalarTypes, inputObjectTypes) ->\n+          @Suppress(\"UNCHECKED_CAST\")\n+          scalarTypes to (inputObjectTypes as List<Schema.Type.InputObject>)\n+        }\n \n-    val inputObjectUsedTypes = usedSchemaTypes\n-        .mapNotNull { type -> type as? Schema.Type.InputObject }\n-        .flatMap { inputObject -> inputObject.usedTypes(exclude = this + exclude) }\n-        .toSet()\n-        .usedSchemaTypes(this + exclude)\n+    val usedTypes = (scalarTypes + inputObjectTypes).toMutableSet()\n+    val visitedTypeNames = scalarTypes.map { it.name }.toMutableSet()\n \n-    return usedSchemaTypes + inputObjectUsedTypes\n-  }\n+    val inputTypesToVisit = inputObjectTypes.toMutableList()\n+    while (inputTypesToVisit.isNotEmpty()) {\n+      val inputType = inputTypesToVisit.removeAt(inputTypesToVisit.lastIndex).also {\n+        usedTypes.add(it)\n+        visitedTypeNames.add(it.name)\n+      }\n+      val (nestedScalarTypes, nestedInputTypes) = inputType\n+          .inputFields\n+          .asSequence()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a83f99d446b4423b06aee1fe0d075ef7946de98"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMDA3OA==", "bodyText": "No, it's just a small optimization probably even not noticeable.\nWhat really saves time is:\n\nrecursion replaced with loop\nwe were visiting the same input types over and over when traverse deep nested tree.", "url": "https://github.com/apollographql/apollo-android/pull/2257#discussion_r422420078", "createdAt": "2020-05-08T23:37:12Z", "author": {"login": "sav007"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "diffHunk": "@@ -645,29 +645,48 @@ class GraphQLDocumentParser(val schema: Schema, private val packageNameProvider:\n     }\n   }\n \n-  private fun Set<String>.usedSchemaTypes(exclude: Set<String> = emptySet()): Set<Schema.Type> {\n+  private fun Set<String>.usedSchemaTypes(): Set<Schema.Type> {\n     if (isEmpty()) {\n       return emptySet()\n     }\n \n-    val usedSchemaTypes = filter { ScalarType.forName(it) == null }\n+    val (scalarTypes, inputObjectTypes) = filter { ScalarType.forName(it) == null }\n         .map { schema[it] ?: throw GraphQLParseException(message = \"Undefined schema type `$it`\") }\n         .filter { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM || type.kind == Schema.Kind.INPUT_OBJECT }\n-        .toSet()\n+        .partition { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM }\n+        .let { (scalarTypes, inputObjectTypes) ->\n+          @Suppress(\"UNCHECKED_CAST\")\n+          scalarTypes to (inputObjectTypes as List<Schema.Type.InputObject>)\n+        }\n \n-    val inputObjectUsedTypes = usedSchemaTypes\n-        .mapNotNull { type -> type as? Schema.Type.InputObject }\n-        .flatMap { inputObject -> inputObject.usedTypes(exclude = this + exclude) }\n-        .toSet()\n-        .usedSchemaTypes(this + exclude)\n+    val usedTypes = (scalarTypes + inputObjectTypes).toMutableSet()\n+    val visitedTypeNames = scalarTypes.map { it.name }.toMutableSet()\n \n-    return usedSchemaTypes + inputObjectUsedTypes\n-  }\n+    val inputTypesToVisit = inputObjectTypes.toMutableList()\n+    while (inputTypesToVisit.isNotEmpty()) {\n+      val inputType = inputTypesToVisit.removeAt(inputTypesToVisit.lastIndex).also {\n+        usedTypes.add(it)\n+        visitedTypeNames.add(it.name)\n+      }\n+      val (nestedScalarTypes, nestedInputTypes) = inputType\n+          .inputFields\n+          .asSequence()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxNzkxMA=="}, "originalCommit": {"oid": "8a83f99d446b4423b06aee1fe0d075ef7946de98"}, "originalPosition": 39}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYyOTkxMjIyOnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyNzowOVrOGS2Wew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzoyNzowOVrOGS2Wew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQxODA0Mw==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      .let { (scalaTypes, inputTypes) ->\n          \n          \n            \n                        @Suppress(\"UNCHECKED_CAST\")\n          \n          \n            \n                        scalaTypes.filter { ScalarType.forName(it.name) == null } to (inputTypes as List<Schema.Type.InputObject>)\n          \n          \n            \n                      .let { (scalarTypes, inputTypes) ->\n          \n          \n            \n                        @Suppress(\"UNCHECKED_CAST\")\n          \n          \n            \n                        scalarTypes.filter { ScalarType.forName(it.name) == null } to (inputTypes as List<Schema.Type.InputObject>)", "url": "https://github.com/apollographql/apollo-android/pull/2257#discussion_r422418043", "createdAt": "2020-05-08T23:27:09Z", "author": {"login": "martinbonnin"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "diffHunk": "@@ -645,29 +645,48 @@ class GraphQLDocumentParser(val schema: Schema, private val packageNameProvider:\n     }\n   }\n \n-  private fun Set<String>.usedSchemaTypes(exclude: Set<String> = emptySet()): Set<Schema.Type> {\n+  private fun Set<String>.usedSchemaTypes(): Set<Schema.Type> {\n     if (isEmpty()) {\n       return emptySet()\n     }\n \n-    val usedSchemaTypes = filter { ScalarType.forName(it) == null }\n+    val (scalarTypes, inputObjectTypes) = filter { ScalarType.forName(it) == null }\n         .map { schema[it] ?: throw GraphQLParseException(message = \"Undefined schema type `$it`\") }\n         .filter { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM || type.kind == Schema.Kind.INPUT_OBJECT }\n-        .toSet()\n+        .partition { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM }\n+        .let { (scalarTypes, inputObjectTypes) ->\n+          @Suppress(\"UNCHECKED_CAST\")\n+          scalarTypes to (inputObjectTypes as List<Schema.Type.InputObject>)\n+        }\n \n-    val inputObjectUsedTypes = usedSchemaTypes\n-        .mapNotNull { type -> type as? Schema.Type.InputObject }\n-        .flatMap { inputObject -> inputObject.usedTypes(exclude = this + exclude) }\n-        .toSet()\n-        .usedSchemaTypes(this + exclude)\n+    val usedTypes = (scalarTypes + inputObjectTypes).toMutableSet()\n+    val visitedTypeNames = scalarTypes.map { it.name }.toMutableSet()\n \n-    return usedSchemaTypes + inputObjectUsedTypes\n-  }\n+    val inputTypesToVisit = inputObjectTypes.toMutableList()\n+    while (inputTypesToVisit.isNotEmpty()) {\n+      val inputType = inputTypesToVisit.removeAt(inputTypesToVisit.lastIndex).also {\n+        usedTypes.add(it)\n+        visitedTypeNames.add(it.name)\n+      }\n+      val (nestedScalarTypes, nestedInputTypes) = inputType\n+          .inputFields\n+          .asSequence()\n+          .map { field -> field.type.rawType.name!! }\n+          .filterNot { type -> visitedTypeNames.contains(type) }\n+          .map { schema[it] ?: throw GraphQLParseException(message = \"Undefined schema type `$it`\") }\n+          .filter { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM || type.kind == Schema.Kind.INPUT_OBJECT }\n+          .partition { type -> type.kind == Schema.Kind.SCALAR || type.kind == Schema.Kind.ENUM }\n+          .let { (scalaTypes, inputTypes) ->\n+            @Suppress(\"UNCHECKED_CAST\")\n+            scalaTypes.filter { ScalarType.forName(it.name) == null } to (inputTypes as List<Schema.Type.InputObject>)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8a83f99d446b4423b06aee1fe0d075ef7946de98"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3070, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}