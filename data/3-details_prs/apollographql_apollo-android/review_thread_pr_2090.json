{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzkxOTU3MDkw", "number": 2090, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwODo1NjowOFrODqI8JA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwODo1NjowOFrODqI8JA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ1NTEzMjUyOnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwODo1NjowOFrOF5uJ1Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0yMlQwODo1NjowOFrOF5uJ1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA2OTMzMw==", "bodyText": "You might want to keep the original value if null. Like description = field.description ?: description\nRight now, this always overrides it with empty String if field description is null", "url": "https://github.com/apollographql/apollo-android/pull/2090#discussion_r396069333", "createdAt": "2020-03-22T08:56:08Z", "author": {"login": "tasomaniac"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/GraphQLDocumentParser.kt", "diffHunk": "@@ -387,38 +387,55 @@ class GraphQLDocumentParser(val schema: Schema, private val packageNameProvider:\n   }\n \n   private fun GraphQLParser.InlineFragmentContext.parse(\n-      parentSelectionSet: GraphQLParser.SelectionSetContext,\n-      parentSchemaType: Schema.Type\n+      parentSchemaType: Schema.Type,\n+      parentFields: ParseResult<List<Field>>\n+\n   ): ParseResult<InlineFragment> {\n     val typeCondition = typeCondition().typeName().NAME().text\n     val schemaType = schema[typeCondition] ?: throw ParseException(\n         message = \"Unknown type`$typeCondition}`\",\n         token = typeCondition().typeName().start\n     )\n \n-    if (!parentSchemaType.isAssignableFrom(schema = schema, other = schemaType)) {\n+    if (!parentSchemaType.isAssignableFrom(other = schemaType, schema = schema)) {\n       throw ParseException(\n-          message = \"Fragment cannot be spread here as objects of type `${parentSchemaType.name}` can never be of type `$typeCondition`\",\n+          message = \"Fragment cannot be spread here as result can never be of type `$typeCondition`\",\n           token = typeCondition().typeName().start\n       )\n     }\n \n-    val possibleTypes = when (schemaType) {\n-      is Schema.Type.Interface -> schemaType.possibleTypes?.map { it.rawType.name!! } ?: emptyList()\n-      is Schema.Type.Union -> schemaType.possibleTypes?.map { it.rawType.name!! } ?: emptyList()\n-      else -> listOf(typeCondition)\n-    }.distinct()\n+    val decoratedParentFields = parentFields.let { (parentFields, usedTypes) ->\n+      // if inline fragment conditional type contains the same field as parent type\n+      // carry over meta info such as: `description`, `isDeprecated`, `deprecationReason`\n+      val decoratedFields = parentFields.map { parentField ->\n+        when (schemaType) {\n+          is Schema.Type.Interface -> schemaType.fields?.find { it.name == parentField.fieldName }\n+          is Schema.Type.Object -> schemaType.fields?.find { it.name == parentField.fieldName }\n+          is Schema.Type.Union -> schemaType.fields?.find { it.name == parentField.fieldName }\n+          else -> null\n+        }?.let { field ->\n+          parentField.copy(\n+              description = field.description ?: \"\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de5cd592bc0484c7a608edb53cc263e8c21c3d01"}, "originalPosition": 50}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3155, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}