{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAwOTM4ODY0", "number": 2647, "reviewThreads": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODozNDoxNVrOEsh3cQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODozNTowMlrOEsh5Jg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MTI3NjY1OnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/IRBuilder.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODozNDoxNVrOHf0fng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQxMDowOTowNFrOHf4IFw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEyNzk2Ng==", "bodyText": "Mostly nitpicking at this point but it feels a bit \"off\" that we need a special case for the root fragmentsRefs compared to field.fragmentRefs. What about moving the schema.rootTypeForOperationType(operationType) to the call site and re-using List<FragmentRef>.findFragments ?", "url": "https://github.com/apollographql/apollo-android/pull/2647#discussion_r503127966", "createdAt": "2020-10-12T08:34:15Z", "author": {"login": "martinbonnin"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/IRBuilder.kt", "diffHunk": "@@ -188,6 +195,21 @@ class IRBuilder(private val schema: IntrospectionSchema,\n     return usedTypes\n   }\n \n+  private fun List<FragmentRef>.referencedRootFragmentNames(operationType: String, fragments: List<Fragment>, filePath: String): Set<String> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c3a0663242ddae8d11660f14bbdb9c59d5eabb0"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzE4NzQ3OQ==", "bodyText": "Ah nice catch. A lot of code here ended up being mostly duplicated from List<FragmentRef>.findFragments and I didn't even realize. Will refactor! I think I'll keep this function here though since we still need to do some extra lookups for all the nested fragments inside the root fragment.", "url": "https://github.com/apollographql/apollo-android/pull/2647#discussion_r503187479", "createdAt": "2020-10-12T10:09:04Z", "author": {"login": "tylerbwong"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/IRBuilder.kt", "diffHunk": "@@ -188,6 +195,21 @@ class IRBuilder(private val schema: IntrospectionSchema,\n     return usedTypes\n   }\n \n+  private fun List<FragmentRef>.referencedRootFragmentNames(operationType: String, fragments: List<Fragment>, filePath: String): Set<String> {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEyNzk2Ng=="}, "originalCommit": {"oid": "8c3a0663242ddae8d11660f14bbdb9c59d5eabb0"}, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzE1MTI4MTAyOnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/IRBuilder.kt", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODozNTowMlrOHf0iCw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMlQwODozNTowMlrOHf0iCw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzEyODU4Nw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apollographql/apollo-android/pull/2647#discussion_r503128587", "createdAt": "2020-10-12T08:35:02Z", "author": {"login": "martinbonnin"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ir/IRBuilder.kt", "diffHunk": "@@ -237,22 +259,26 @@ class IRBuilder(private val schema: IntrospectionSchema,\n               filePath = filePath\n           )\n \n-      when (val schemaType = schema[typeCondition]) {\n-        is IntrospectionSchema.Type.Object -> schemaType.possibleTypes(schema)\n-        is IntrospectionSchema.Type.Interface -> schemaType.possibleTypes(schema)\n-        is IntrospectionSchema.Type.Union -> schemaType.possibleTypes(schema)\n-        else -> emptySet()\n-      }.also { possibleTypes ->\n-        if (fragment.possibleTypes.intersect(possibleTypes).isEmpty()) {\n-          throw DocumentParseException(\n-              message = \"Fragment `${ref.name}` can't be spread here as result can never be of type `${fragment.typeCondition}`\",\n-              sourceLocation = ref.sourceLocation,\n-              filePath = filePath\n-          )\n-        }\n-      }\n+      fragment.validateTypeCondition(ref, typeCondition, filePath)\n \n       fragment\n     }\n   }\n+\n+  private fun Fragment.validateTypeCondition(fragmentRef: FragmentRef, typeCondition: String, filePath: String) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8c3a0663242ddae8d11660f14bbdb9c59d5eabb0"}, "originalPosition": 80}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2932, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}