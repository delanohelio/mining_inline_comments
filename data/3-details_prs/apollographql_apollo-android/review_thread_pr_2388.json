{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDM4MjU3NTg0", "number": 2388, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwOTozMDowNVrOEH48Ww==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwOTozMDowNVrOEH48Ww==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjc2NzA4NDQzOnYy", "diffSide": "RIGHT", "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/network/ws/ApolloWebSocketNetworkTransport.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yM1QwOTozMDowNVrOGnhHfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0yNFQxODowNzo0MFrOGodZ6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5MDIzOQ==", "bodyText": "Why is this yield required?", "url": "https://github.com/apollographql/apollo-android/pull/2388#discussion_r444090239", "createdAt": "2020-06-23T09:30:05Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/network/ws/ApolloWebSocketNetworkTransport.kt", "diffHunk": "@@ -205,22 +214,34 @@ class ApolloWebSocketNetworkTransport(\n \n     private suspend fun onUnsubscribed() {\n       mutex.withLock {\n-        if (--activeSubscriptionCount == 0) scheduleAutoClose()\n+        if (--activeSubscriptionCount == 0 && idleTimeoutMs > 0) {\n+          idleTimeoutJob?.cancel()\n+          connectionKeepAliveTimeoutJob?.cancel()\n+\n+          idleTimeoutJob = coroutineScope.launch {\n+            delay(idleTimeoutMs)\n+            close()\n+          }\n+        }\n       }\n     }\n \n-    private fun scheduleAutoClose() {\n-      idleTimeoutJob?.cancel()\n-      if (idleTimeoutMs > 0) {\n-        idleTimeoutJob = coroutineScope.launch {\n-          delay(idleTimeoutMs)\n-          close()\n+    private suspend fun onConnectionKeepAlive() {\n+      mutex.withLock {\n+        if (activeSubscriptionCount > 0 && connectionKeepAliveTimeoutMs > 0) {\n+          connectionKeepAliveTimeoutJob?.cancel()\n+\n+          connectionKeepAliveTimeoutJob = coroutineScope.launch {\n+            delay(idleTimeoutMs)\n+            close()\n+          }\n         }\n       }\n     }\n \n     private suspend fun close() {\n       mutex.withLock {\n+        yield()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "de0dedf61347636d1a5e9fe92e66969e971b21b0"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTA3Nzk5Mg==", "bodyText": "After second thought seems there is no need for it here.\nMy initial thinking was that the coroutine might have been canceled before we acquire mutex, so to handle this case we call yield  that will fail if coroutine is canceled. But mutex.withLock  is suspended function so it will be handled anyway, if coroutine is canceled then mutex.withLock will be canceled.", "url": "https://github.com/apollographql/apollo-android/pull/2388#discussion_r445077992", "createdAt": "2020-06-24T18:07:40Z", "author": {"login": "sav007"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/network/ws/ApolloWebSocketNetworkTransport.kt", "diffHunk": "@@ -205,22 +214,34 @@ class ApolloWebSocketNetworkTransport(\n \n     private suspend fun onUnsubscribed() {\n       mutex.withLock {\n-        if (--activeSubscriptionCount == 0) scheduleAutoClose()\n+        if (--activeSubscriptionCount == 0 && idleTimeoutMs > 0) {\n+          idleTimeoutJob?.cancel()\n+          connectionKeepAliveTimeoutJob?.cancel()\n+\n+          idleTimeoutJob = coroutineScope.launch {\n+            delay(idleTimeoutMs)\n+            close()\n+          }\n+        }\n       }\n     }\n \n-    private fun scheduleAutoClose() {\n-      idleTimeoutJob?.cancel()\n-      if (idleTimeoutMs > 0) {\n-        idleTimeoutJob = coroutineScope.launch {\n-          delay(idleTimeoutMs)\n-          close()\n+    private suspend fun onConnectionKeepAlive() {\n+      mutex.withLock {\n+        if (activeSubscriptionCount > 0 && connectionKeepAliveTimeoutMs > 0) {\n+          connectionKeepAliveTimeoutJob?.cancel()\n+\n+          connectionKeepAliveTimeoutJob = coroutineScope.launch {\n+            delay(idleTimeoutMs)\n+            close()\n+          }\n         }\n       }\n     }\n \n     private suspend fun close() {\n       mutex.withLock {\n+        yield()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA5MDIzOQ=="}, "originalCommit": {"oid": "de0dedf61347636d1a5e9fe92e66969e971b21b0"}, "originalPosition": 112}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3133, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}