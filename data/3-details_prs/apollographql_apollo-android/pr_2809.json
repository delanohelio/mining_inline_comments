{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQxNTU4MDMw", "number": 2809, "title": "Implement support for AWS AppSync in WebSocketSubscriptionTransport", "bodyText": "This PR adds support for the AWS AppSync format of subscriptions. The only difference between AppSync and Apollo is that the payload for the start messages need to look like this:\n{\n  \"id\": \"...\",\n  \"type\": \"start\",\n  \"payload\": {\n    \"data\": \"{\\\"variables\\\":{...},\\\"operationName\\\":\\\"...\\\",\\\"query\\\":\\\"...\\\"}\",\n    \"extensions\": {\n      \"authorization\": ...\n    }\n  }\n}\nThis PR will allow passing a flag for sending the payload as a JSON string as well as allow passing arbitrary extensions.\nThis fixes #2808 and #1864", "createdAt": "2020-12-17T02:27:47Z", "url": "https://github.com/apollographql/apollo-android/pull/2809", "merged": true, "mergeCommit": {"oid": "727abad4900540e042993d55a609694d5a51cb35"}, "closed": true, "closedAt": "2020-12-21T11:16:26Z", "author": {"login": "ansman"}, "timelineItems": {"totalCount": 36, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdm4IKAgH2gAyNTQxNTU4MDMwOmJiMDFhYTg4YzJmZjZjYTRiZTUxMjJkNDUwMDFkZDMwZjNiNWU1Y2Q=", "endCursor": "Y3Vyc29yOnYyOpPPAAABdoUDcSAFqTU1NjMwNTkwNg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "bb01aa88c2ff6ca4be5122d45001dd30f3b5e5cd", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/bb01aa88c2ff6ca4be5122d45001dd30f3b5e5cd", "committedDate": "2020-12-17T00:09:57Z", "message": "Rename .java to .kt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ecea94ecad96883a46b1e914147ec9462ea73f42", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/ecea94ecad96883a46b1e914147ec9462ea73f42", "committedDate": "2020-12-17T00:09:57Z", "message": "Convert WebSocketSubscriptionTransport to Kotlin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "227c29953f56ba1606a5fa16df015d5f1db4755d", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/227c29953f56ba1606a5fa16df015d5f1db4755d", "committedDate": "2020-12-17T01:04:41Z", "message": "Rename .java to .kt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c8a5fa259ff75798ea6f83728554e321f46ad148", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/c8a5fa259ff75798ea6f83728554e321f46ad148", "committedDate": "2020-12-17T01:04:41Z", "message": "Rewrite OperationClientMessage to a sealed class"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/a9cdfbde4ae07c847ecdd645701ed32939c41a15", "committedDate": "2020-12-17T02:14:50Z", "message": "Implement support for AWS AppSync in WebSocketSubscriptionTransport"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0MjM1MTE0", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-554235114", "createdAt": "2020-12-17T02:28:44Z", "commit": {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15"}, "state": "COMMENTED", "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMjoyODo0NFrOIHhytA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QwMjozNTozMFrOIHh8Vg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NDU5Ng==", "bodyText": "Ideally I would want these to be internal but since they live in a separate module the cannot.\nThey are very handy in making the code more readable and makes manual JSON writing much less error prone.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544764596", "createdAt": "2020-12-17T02:28:44Z", "author": {"login": "ansman"}, "path": "apollo-api/src/commonMain/kotlin/com/apollographql/apollo/api/internal/json/JsonWriters.kt", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.apollographql.apollo.api.internal.json\n+\n+inline fun JsonWriter.writeObject(crossinline block: JsonWriter.() -> Unit) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15"}, "originalPosition": 3}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NTI4Ng==", "bodyText": "I kept this as internal since I'm assuming it's there to avoid the synthetic accessor methods from being generated?", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544765286", "createdAt": "2020-12-17T02:30:33Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NjA3OA==", "bodyText": "I'm not very happy with the format of this change and I'm happy talk alternatives.\nI like being able to pass arbitrary extensions but not how this is triggered.\nOne alternative would be to introduce some sort of \"format\" or \"dialect\" enum which there are 2 off. I tried to find some official specification for the websocket format but there doesn't seem to be one?", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544766078", "createdAt": "2020-12-17T02:32:37Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15"}, "originalPosition": 122}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NjQ5Mw==", "bodyText": "This was created as a convenience to do two things for the user:\n\nAdd the header and payload query parameters which AppSync requires\nAdd the authorization as an extension to the start messages.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544766493", "createdAt": "2020-12-17T02:33:52Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,\n+      private val extensions: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory {\n+    private val webSocketRequest: Request = Request.Builder()\n+        .url(webSocketUrl)\n+        .addHeader(\"Sec-WebSocket-Protocol\", \"graphql-ws\")\n+        .addHeader(\"Cookie\", \"\")\n+        .build()\n+\n+    override fun create(callback: SubscriptionTransport.Callback): SubscriptionTransport =\n+        WebSocketSubscriptionTransport(webSocketRequest, webSocketConnectionFactory, callback, writePayloadAsJsonString, extensions)\n+  }\n+\n+  class AppSyncFactory @JvmOverloads constructor(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15"}, "originalPosition": 135}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NjkwNw==", "bodyText": "This duplicates what Request.url does when passing a string. We use it so that we can leverage OkHttp's URL handling here.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544766907", "createdAt": "2020-12-17T02:34:59Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,\n+      private val extensions: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory {\n+    private val webSocketRequest: Request = Request.Builder()\n+        .url(webSocketUrl)\n+        .addHeader(\"Sec-WebSocket-Protocol\", \"graphql-ws\")\n+        .addHeader(\"Cookie\", \"\")\n+        .build()\n+\n+    override fun create(callback: SubscriptionTransport.Callback): SubscriptionTransport =\n+        WebSocketSubscriptionTransport(webSocketRequest, webSocketConnectionFactory, callback, writePayloadAsJsonString, extensions)\n+  }\n+\n+  class AppSyncFactory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      authorization: Map<String, Any?>,\n+      payload: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory by Factory(\n+      webSocketUrl = webSocketUrl\n+          .let {\n+            HttpUrl.get(when {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDc2NzA2Mg==", "bodyText": "I considered checking if the query param is already present but if the user is passing the header manually they shouldn't use the AppSyncFactory.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r544767062", "createdAt": "2020-12-17T02:35:30Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.subscription.OperationClientMessage.Start.Companion.jsonValue\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,\n+      private val extensions: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory {\n+    private val webSocketRequest: Request = Request.Builder()\n+        .url(webSocketUrl)\n+        .addHeader(\"Sec-WebSocket-Protocol\", \"graphql-ws\")\n+        .addHeader(\"Cookie\", \"\")\n+        .build()\n+\n+    override fun create(callback: SubscriptionTransport.Callback): SubscriptionTransport =\n+        WebSocketSubscriptionTransport(webSocketRequest, webSocketConnectionFactory, callback, writePayloadAsJsonString, extensions)\n+  }\n+\n+  class AppSyncFactory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      authorization: Map<String, Any?>,\n+      payload: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory by Factory(\n+      webSocketUrl = webSocketUrl\n+          .let {\n+            HttpUrl.get(when {\n+              it.startsWith(\"ws://\", ignoreCase = true) -> \"http\" + it.drop(2)\n+              it.startsWith(\"wss://\", ignoreCase = true) -> \"https\" + it.drop(3)\n+              else -> it\n+            })\n+          }\n+          .newBuilder()\n+          .setQueryParameter(\"header\", authorization.encodeAsQueryParam())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a9cdfbde4ae07c847ecdd645701ed32939c41a15"}, "originalPosition": 150}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9b22fb7a00e34342eefb54f38eebfce3ed4b4332", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/9b22fb7a00e34342eefb54f38eebfce3ed4b4332", "committedDate": "2020-12-17T02:54:21Z", "message": "Rename .java to .kt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "72c340297bc30e4401a5f277c6ae1ab184a56414", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/72c340297bc30e4401a5f277c6ae1ab184a56414", "committedDate": "2020-12-17T02:54:22Z", "message": "Fix the broken test"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d18c9ef9558231dfee13f80083fc7656e035948d", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/d18c9ef9558231dfee13f80083fc7656e035948d", "committedDate": "2020-12-17T14:35:11Z", "message": "Fix the binary compatibility"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NjYxODU2", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-554661856", "createdAt": "2020-12-17T14:35:53Z", "commit": {"oid": "d18c9ef9558231dfee13f80083fc7656e035948d"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDozNTo1M1rOIH4h0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDozNjozNlrOIH4jzg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzNzEwNg==", "bodyText": "This is still binary compatible", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545137106", "createdAt": "2020-12-17T14:35:53Z", "author": {"login": "ansman"}, "path": "apollo-runtime/api.txt", "diffHunk": "@@ -373,38 +373,65 @@ package com.apollographql.apollo.response {\n \n package com.apollographql.apollo.subscription {\n \n+  public final class JsonWritersKt {\n+  }\n+\n   public interface OnSubscriptionManagerStateChangeListener {\n     method public void onStateChange(com.apollographql.apollo.subscription.SubscriptionManagerState!, com.apollographql.apollo.subscription.SubscriptionManagerState!);\n   }\n \n-  public abstract class OperationClientMessage {\n-    method public String toJsonString();\n-    method public abstract void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter);\n+  public abstract sealed class OperationClientMessage {\n+    method public final String toJsonString(boolean writePayloadAsJsonString = false, java.util.Map<java.lang.String,?> extensions = emptyMap());\n+    method public final String toJsonString(boolean writePayloadAsJsonString = false);\n+    method public final String toJsonString();\n+    method @kotlin.jvm.Throws(exceptionClasses=IOException::class) public final void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter writer);\n+    method public final void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter writer, boolean writePayloadAsJsonString);\n+    method @kotlin.jvm.Throws(exceptionClasses=IOException::class) public abstract void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter writer, boolean writePayloadAsJsonString = false, java.util.Map<java.lang.String,?> extensions = emptyMap());\n+    field public static final com.apollographql.apollo.subscription.OperationClientMessage.Companion Companion;\n+  }\n+\n+  public static final class OperationClientMessage.Companion {\n   }\n \n   public static final class OperationClientMessage.Init extends com.apollographql.apollo.subscription.OperationClientMessage {\n-    ctor public OperationClientMessage.Init(Map<String,Object>);\n-    method public void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter);\n+    ctor public OperationClientMessage.Init(java.util.Map<java.lang.String,?> connectionParams);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18c9ef9558231dfee13f80083fc7656e035948d"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTEzNzYxNA==", "bodyText": "All of the changes here are fine since it was not possible to subclass this class anyway.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545137614", "createdAt": "2020-12-17T14:36:36Z", "author": {"login": "ansman"}, "path": "apollo-runtime/api.txt", "diffHunk": "@@ -373,38 +373,65 @@ package com.apollographql.apollo.response {\n \n package com.apollographql.apollo.subscription {\n \n+  public final class JsonWritersKt {\n+  }\n+\n   public interface OnSubscriptionManagerStateChangeListener {\n     method public void onStateChange(com.apollographql.apollo.subscription.SubscriptionManagerState!, com.apollographql.apollo.subscription.SubscriptionManagerState!);\n   }\n \n-  public abstract class OperationClientMessage {\n-    method public String toJsonString();\n-    method public abstract void writeToJson(com.apollographql.apollo.api.internal.json.JsonWriter);\n+  public abstract sealed class OperationClientMessage {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18c9ef9558231dfee13f80083fc7656e035948d"}, "originalPosition": 14}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0NjgxMDY3", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-554681067", "createdAt": "2020-12-17T14:55:32Z", "commit": {"oid": "d18c9ef9558231dfee13f80083fc7656e035948d"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDo1NTozM1rOIH5dSg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxNDo1NTozM1rOIH5dSg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTE1MjMzMA==", "bodyText": "Maybe call this method toBase64() ? It's used as a query param but the method itself uses Base64 and not urlencoding.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545152330", "createdAt": "2020-12-17T14:55:33Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransport.kt", "diffHunk": "@@ -0,0 +1,165 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okhttp3.HttpUrl\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okio.Buffer\n+import java.lang.ref.WeakReference\n+import java.util.Base64\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * [SubscriptionTransport] implementation based on [WebSocket].\n+ */\n+class WebSocketSubscriptionTransport @JvmOverloads constructor(\n+    private val webSocketRequest: Request,\n+    private val webSocketConnectionFactory: WebSocket.Factory,\n+    private val callback: SubscriptionTransport.Callback,\n+    private val writePayloadAsJsonString: Boolean = false,\n+    private val extensions: Map<String, Any?> = emptyMap()\n+) : SubscriptionTransport {\n+  internal val webSocket = AtomicReference<WebSocket>()\n+  internal val webSocketListener = AtomicReference<WebSocketListener>()\n+\n+  override fun connect() {\n+    val webSocketListener = WebSocketListener(this)\n+    check(this.webSocketListener.compareAndSet(null, webSocketListener)) {\n+      \"Already connected\"\n+    }\n+    webSocket.set(webSocketConnectionFactory.newWebSocket(webSocketRequest, webSocketListener))\n+  }\n+\n+  override fun disconnect(message: OperationClientMessage) {\n+    webSocket.getAndSet(null)\n+        ?.close(1001, message.serializeToJson())\n+    release()\n+  }\n+\n+  override fun send(message: OperationClientMessage) {\n+    val socket = webSocket.get() ?: run {\n+      callback.onFailure(IllegalStateException(\"Send attempted on closed connection\"))\n+      return\n+    }\n+    socket.send(message.serializeToJson())\n+  }\n+\n+  internal fun onOpen() {\n+    callback.onConnected()\n+  }\n+\n+  internal fun onMessage(message: OperationServerMessage?) {\n+    callback.onMessage(message)\n+  }\n+\n+  internal fun onFailure(t: Throwable?) {\n+    try {\n+      callback.onFailure(t)\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  internal fun onClosed() {\n+    try {\n+      callback.onClosed()\n+    } finally {\n+      release()\n+    }\n+  }\n+\n+  private fun release() {\n+    webSocketListener.getAndSet(null)?.release()\n+    webSocket.set(null)\n+  }\n+\n+  private fun OperationClientMessage.serializeToJson(): String =\n+      toJsonString(\n+        writePayloadAsJsonString = writePayloadAsJsonString,\n+        extensions = extensions\n+    )\n+\n+  internal class WebSocketListener(delegate: WebSocketSubscriptionTransport) : okhttp3.WebSocketListener() {\n+    private val delegateRef = WeakReference(delegate)\n+\n+    override fun onOpen(webSocket: WebSocket, response: Response) {\n+      delegateRef.get()?.onOpen()\n+    }\n+\n+    override fun onMessage(webSocket: WebSocket, text: String) {\n+      delegateRef.get()?.onMessage(OperationServerMessage.fromJsonString(text))\n+    }\n+\n+    override fun onFailure(webSocket: WebSocket, t: Throwable, response: Response?) {\n+      delegateRef.get()?.onFailure(t)\n+    }\n+\n+    override fun onClosing(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    override fun onClosed(webSocket: WebSocket, code: Int, reason: String) {\n+      delegateRef.get()?.onClosed()\n+    }\n+\n+    fun release() {\n+      delegateRef.clear()\n+    }\n+  }\n+\n+  /**\n+   * @param webSocketUrl The URL of the GraphQL WebSocket API\n+   * @param webSocketConnectionFactory The [WebSocket.Factory] to use to create the websockets\n+   * @param writePayloadAsJsonString If the payload should be serialized as a JSON String (default false). Set this to `true` for AWS\n+   *                                 AppSync integrations.\n+   * @param extensions Any additional extensions to when sending start commands. Must not be changed after this creating the factory.\n+   */\n+  class Factory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      private val writePayloadAsJsonString: Boolean = false,\n+      private val extensions: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory {\n+    private val webSocketRequest: Request = Request.Builder()\n+        .url(webSocketUrl)\n+        .addHeader(\"Sec-WebSocket-Protocol\", \"graphql-ws\")\n+        .addHeader(\"Cookie\", \"\")\n+        .build()\n+\n+    override fun create(callback: SubscriptionTransport.Callback): SubscriptionTransport =\n+        WebSocketSubscriptionTransport(webSocketRequest, webSocketConnectionFactory, callback, writePayloadAsJsonString, extensions)\n+  }\n+\n+  class AppSyncFactory @JvmOverloads constructor(\n+      webSocketUrl: String,\n+      private val webSocketConnectionFactory: WebSocket.Factory,\n+      authorization: Map<String, Any?>,\n+      payload: Map<String, Any?> = emptyMap()\n+  ) : SubscriptionTransport.Factory by Factory(\n+      webSocketUrl = webSocketUrl\n+          .let {\n+            HttpUrl.get(when {\n+              it.startsWith(\"ws://\", ignoreCase = true) -> \"http\" + it.drop(2)\n+              it.startsWith(\"wss://\", ignoreCase = true) -> \"https\" + it.drop(3)\n+              else -> it\n+            })\n+          }\n+          .newBuilder()\n+          .setQueryParameter(\"header\", authorization.encodeAsQueryParam())\n+          .setQueryParameter(\"payload\", payload.encodeAsQueryParam())\n+          .build()\n+          .toString(),\n+      webSocketConnectionFactory = webSocketConnectionFactory,\n+      writePayloadAsJsonString = true,\n+      extensions = mapOf(\"authorization\" to authorization)\n+  ) {\n+    companion object {\n+      private fun Map<String, Any?>.encodeAsQueryParam(): String {\n+        val buffer = Buffer()\n+        JsonWriter.of(buffer).jsonValue(this)\n+        return Base64.getUrlEncoder().encodeToString(buffer.readByteArray())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d18c9ef9558231dfee13f80083fc7656e035948d"}, "originalPosition": 161}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d4d5739107434d4f99b9c3f4034d114f291dfca7", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/d4d5739107434d4f99b9c3f4034d114f291dfca7", "committedDate": "2020-12-17T15:15:41Z", "message": "Use Utils.writeToJson"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "56e74d858766eca98a4e23c4cf4ee379ef1efda4", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/56e74d858766eca98a4e23c4cf4ee379ef1efda4", "committedDate": "2020-12-17T15:16:05Z", "message": "Use Utils.writeToJson"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "334600f5cf428411e7b795a7ae19b06df21f1083", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/334600f5cf428411e7b795a7ae19b06df21f1083", "committedDate": "2020-12-17T15:44:11Z", "message": "Rename .java to .kt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "57ece09b6632d4cb29ba475511b54dd64edd0786", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/57ece09b6632d4cb29ba475511b54dd64edd0786", "committedDate": "2020-12-17T15:44:11Z", "message": "Convert OperationServerMessage to a sealed class"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "af1b05fbc1dd88f9b7c7a745fce529b7b1218634", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/af1b05fbc1dd88f9b7c7a745fce529b7b1218634", "committedDate": "2020-12-17T17:58:59Z", "message": "Rewrite the writing and reading to use a serializer"}, "afterCommit": {"oid": "fb914ea49077c9e137d0979696975dd17c3b4ce7", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/fb914ea49077c9e137d0979696975dd17c3b4ce7", "committedDate": "2020-12-17T18:03:18Z", "message": "Rewrite the writing and reading to use a serializer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fb914ea49077c9e137d0979696975dd17c3b4ce7", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/fb914ea49077c9e137d0979696975dd17c3b4ce7", "committedDate": "2020-12-17T18:03:18Z", "message": "Rewrite the writing and reading to use a serializer"}, "afterCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/5cf1552f6d55502fde7953f373e31f923c8015ae", "committedDate": "2020-12-17T18:08:42Z", "message": "Rewrite the writing and reading to use a serializer"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/fa441e1ac3e8cb69433860be8636c22e16261866", "committedDate": "2020-12-17T18:53:21Z", "message": "Rewrite the writing and reading to use a serializer"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/5cf1552f6d55502fde7953f373e31f923c8015ae", "committedDate": "2020-12-17T18:08:42Z", "message": "Rewrite the writing and reading to use a serializer"}, "afterCommit": {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/fa441e1ac3e8cb69433860be8636c22e16261866", "committedDate": "2020-12-17T18:53:21Z", "message": "Rewrite the writing and reading to use a serializer"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDE3MDgx", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555017081", "createdAt": "2020-12-17T21:51:43Z", "commit": {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTo1MTo0M1rOIIKM_g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTo1MTo0M1rOIIKM_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyNjY4Ng==", "bodyText": "Any reason this is a class and not an object like ApolloOperationMessageSerializer ?", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545426686", "createdAt": "2020-12-17T21:51:43Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866"}, "originalPosition": 12}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/5181d2d7691f2118f27e709a0ea06245f129d5e2", "committedDate": "2020-12-17T21:55:10Z", "message": "Replace the data classes with regular classes"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDE5Mzc1", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555019375", "createdAt": "2020-12-17T21:55:25Z", "commit": {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTo1NToyNlrOIIKUPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTo1NToyNlrOIIKUPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyODU0MQ==", "bodyText": "Is the implementation by delegation needed here ? I think the same result could be done by actually implementing the readServerMessage method\n  override fun readServerMessage(source: BufferedSource) = ApolloOperationMessageSerializer.readServerMessage(source)\n \n\nIt's a few more bytes but avoid using the \"implement by delegate\" pattern which isn't used a lot in the codebase and it might produce a bit less bytecode too.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545428541", "createdAt": "2020-12-17T21:55:26Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "980a4cc7ed26f35a0777e57e7dfae66452421bda", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/980a4cc7ed26f35a0777e57e7dfae66452421bda", "committedDate": "2020-12-17T21:59:04Z", "message": "Replace delegation with method calls"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDIyODU0", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555022854", "createdAt": "2020-12-17T22:01:08Z", "commit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowMTowOFrOIIKfrg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowMTowOFrOIIKfrg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMTQ3MA==", "bodyText": "Ouch. I guess we want to keep the ws:// to avoid confusing any user there, even if ultimately, okhttp is going to replace everything with http:// ? That feels a bit awkward but I don't really have another suggestion besides using java.net.URL that will end up equally verbose.\nEdit: thinking a bit more about it, if someone passes a http url, this will turn it into a ws url so maybe messing with java.net.URL is better?", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545431470", "createdAt": "2020-12-17T22:01:08Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }\n+    }\n+  }\n+\n+  private fun OperationClientMessage.Start.writeTo(writer: JsonWriter) {\n+    writer.writeObject {\n+      name(ApolloOperationMessageSerializer.JSON_KEY_ID).value(subscriptionId)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_TYPE).value(OperationClientMessage.Start.TYPE)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_PAYLOAD).writeObject {\n+        name(JSON_KEY_DATA).writeObject {\n+          writePayloadContentsTo(writer)\n+        }\n+\n+        if (autoPersistSubscription) {\n+          name(ApolloOperationMessageSerializer.JSON_KEY_EXTENSIONS).writeObject {\n+            name(\"authorization\")\n+            Utils.writeToJson(authorization, writer)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  companion object {\n+    private const val JSON_KEY_DATA = \"data\"\n+\n+    @JvmOverloads\n+    @JvmStatic\n+    fun buildAppSyncWebSocketUrl(\n+        baseWebSocketUrl: String,\n+        authorization: Map<String, Any?>,\n+        payload: Map<String, Any?> = emptyMap(),\n+    ): String =\n+        baseWebSocketUrl\n+          .let { url ->\n+            when {\n+              url.startsWith(\"ws://\", ignoreCase = true) -> \"http\" + url.drop(2)\n+              url.startsWith(\"wss://\", ignoreCase = true) -> \"https\" + url.drop(3)\n+              else -> url\n+            }\n+          }\n+          .let { HttpUrl.get(it) }\n+          .newBuilder()\n+          .setQueryParameter(\"header\", authorization.base64Encode())\n+          .setQueryParameter(\"payload\", payload.base64Encode())\n+          .build()\n+          .toString()\n+          .let { url ->\n+            when {\n+              url.startsWith(\"http://\", ignoreCase = true) -> \"ws\" + url.drop(4)\n+              url.startsWith(\"https://\", ignoreCase = true) -> \"wss\" + url.drop(5)\n+              else -> url", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU0ODU0ODUw", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-554854850", "createdAt": "2020-12-17T18:01:40Z", "commit": {"oid": "af1b05fbc1dd88f9b7c7a745fce529b7b1218634"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QxODowMTo0MFrOIIB_Ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMTo1NzoyOFrOIIKYMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5MjA5MQ==", "bodyText": "This is needed because the old, public, implementation of OperationServerMessage.writeToJson needs to write only the contents, not the outer object.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545292091", "createdAt": "2020-12-17T18:01:40Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/ApolloOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.BufferedSourceJsonReader\n+import com.apollographql.apollo.api.internal.json.JsonReader\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.ResponseJsonStreamReader\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import okio.BufferedSink\n+import okio.BufferedSource\n+import java.io.IOException\n+import java.util.Collections\n+\n+object ApolloOperationMessageSerializer : OperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    JsonWriter.of(sink).use { writer ->\n+      writer.writeObject {\n+        writeContentsTo(writer)\n+      }\n+    }\n+  }\n+\n+  override fun readServerMessage(source: BufferedSource): OperationServerMessage =\n+      try {\n+        source.peek().use {\n+          BufferedSourceJsonReader(it).use { reader ->\n+            reader.readServerMessage()\n+          }\n+        }\n+      } catch (e: Exception) {\n+        OperationServerMessage.Unsupported(source.readUtf8())\n+      }\n+\n+  internal fun OperationClientMessage.writeContentsTo(writer: JsonWriter) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "af1b05fbc1dd88f9b7c7a745fce529b7b1218634"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5NzI4OQ==", "bodyText": "I moved this to an function instead of doing it automatically for you.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545297289", "createdAt": "2020-12-17T18:09:59Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }\n+    }\n+  }\n+\n+  private fun OperationClientMessage.Start.writeTo(writer: JsonWriter) {\n+    writer.writeObject {\n+      name(ApolloOperationMessageSerializer.JSON_KEY_ID).value(subscriptionId)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_TYPE).value(OperationClientMessage.Start.TYPE)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_PAYLOAD).writeObject {\n+        name(JSON_KEY_DATA).writeObject {\n+          writePayloadContentsTo(writer)\n+        }\n+\n+        if (autoPersistSubscription) {\n+          name(ApolloOperationMessageSerializer.JSON_KEY_EXTENSIONS).writeObject {\n+            name(\"authorization\")\n+            Utils.writeToJson(authorization, writer)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  companion object {\n+    private const val JSON_KEY_DATA = \"data\"\n+\n+    @JvmOverloads\n+    fun buildAppSyncWebSocketUrl(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5NzU3Mw==", "bodyText": "payload should always be empty but this future proofs it in case AWS decides that you need to pass something here.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545297573", "createdAt": "2020-12-17T18:10:29Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }\n+    }\n+  }\n+\n+  private fun OperationClientMessage.Start.writeTo(writer: JsonWriter) {\n+    writer.writeObject {\n+      name(ApolloOperationMessageSerializer.JSON_KEY_ID).value(subscriptionId)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_TYPE).value(OperationClientMessage.Start.TYPE)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_PAYLOAD).writeObject {\n+        name(JSON_KEY_DATA).writeObject {\n+          writePayloadContentsTo(writer)\n+        }\n+\n+        if (autoPersistSubscription) {\n+          name(ApolloOperationMessageSerializer.JSON_KEY_EXTENSIONS).writeObject {\n+            name(\"authorization\")\n+            Utils.writeToJson(authorization, writer)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  companion object {\n+    private const val JSON_KEY_DATA = \"data\"\n+\n+    @JvmOverloads\n+    fun buildAppSyncWebSocketUrl(\n+        baseWebSocketUrl: String,\n+        authorization: Map<String, Any?>,\n+        payload: Map<String, Any?> = emptyMap(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5OTQ5Ng==", "bodyText": "I decided to re-add the original scheme since this is now returned rather than being used internally.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545299496", "createdAt": "2020-12-17T18:13:29Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer by ApolloOperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }\n+    }\n+  }\n+\n+  private fun OperationClientMessage.Start.writeTo(writer: JsonWriter) {\n+    writer.writeObject {\n+      name(ApolloOperationMessageSerializer.JSON_KEY_ID).value(subscriptionId)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_TYPE).value(OperationClientMessage.Start.TYPE)\n+      name(ApolloOperationMessageSerializer.JSON_KEY_PAYLOAD).writeObject {\n+        name(JSON_KEY_DATA).writeObject {\n+          writePayloadContentsTo(writer)\n+        }\n+\n+        if (autoPersistSubscription) {\n+          name(ApolloOperationMessageSerializer.JSON_KEY_EXTENSIONS).writeObject {\n+            name(\"authorization\")\n+            Utils.writeToJson(authorization, writer)\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  companion object {\n+    private const val JSON_KEY_DATA = \"data\"\n+\n+    @JvmOverloads\n+    fun buildAppSyncWebSocketUrl(\n+        baseWebSocketUrl: String,\n+        authorization: Map<String, Any?>,\n+        payload: Map<String, Any?> = emptyMap(),\n+    ): String =\n+        baseWebSocketUrl\n+          .let { url ->\n+            when {\n+              url.startsWith(\"ws://\", ignoreCase = true) -> \"http\" + url.drop(2)\n+              url.startsWith(\"wss://\", ignoreCase = true) -> \"https\" + url.drop(3)\n+              else -> url\n+            }\n+          }\n+          .let { HttpUrl.get(it) }\n+          .newBuilder()\n+          .setQueryParameter(\"header\", authorization.base64Encode())\n+          .setQueryParameter(\"payload\", payload.base64Encode())\n+          .build()\n+          .toString()\n+          .let { url ->\n+            when {\n+              url.startsWith(\"http://\", ignoreCase = true) -> \"ws\" + url.drop(4)\n+              url.startsWith(\"https://\", ignoreCase = true) -> \"wss\" + url.drop(5)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae"}, "originalPosition": 69}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTI5OTkyMQ==", "bodyText": "I made these data classes now. They don't have to be however.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545299921", "createdAt": "2020-12-17T18:14:15Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")\n+  fun writeToJson(writer: JsonWriter) {\n+    with(ApolloOperationMessageSerializer) { writeContentsTo(writer) }\n+  }\n+\n+  data class Init(val connectionParams: Map<String, Any?>) : OperationClientMessage() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwMDI0MA==", "bodyText": "All properties here (besides scalarTypeAdapters) have to be @JvmField to keep backwards compatibility.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545300240", "createdAt": "2020-12-17T18:14:42Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")\n+  fun writeToJson(writer: JsonWriter) {\n+    with(ApolloOperationMessageSerializer) { writeContentsTo(writer) }\n+  }\n+\n+  data class Init(val connectionParams: Map<String, Any?>) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"connection_init\"\n+    }\n+  }\n+\n+  data class Start(\n+      @JvmField", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae"}, "originalPosition": 34}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwMDU0MQ==", "bodyText": "This has to be public now that the writing is done externally.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545300541", "createdAt": "2020-12-17T18:15:07Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")\n+  fun writeToJson(writer: JsonWriter) {\n+    with(ApolloOperationMessageSerializer) { writeContentsTo(writer) }\n+  }\n+\n+  data class Init(val connectionParams: Map<String, Any?>) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"connection_init\"\n+    }\n+  }\n+\n+  data class Start(\n+      @JvmField\n+      val subscriptionId: String,\n+      @JvmField\n+      val subscription: Subscription<*, *, *>,\n+      @JvmField\n+      val scalarTypeAdapters: ScalarTypeAdapters,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae"}, "originalPosition": 39}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwMDc4MQ==", "bodyText": "This should ideally be an object but that is a breaking change so I just added hashCode and equals for consistency.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545300781", "createdAt": "2020-12-17T18:15:33Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")\n+  fun writeToJson(writer: JsonWriter) {\n+    with(ApolloOperationMessageSerializer) { writeContentsTo(writer) }\n+  }\n+\n+  data class Init(val connectionParams: Map<String, Any?>) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"connection_init\"\n+    }\n+  }\n+\n+  data class Start(\n+      @JvmField\n+      val subscriptionId: String,\n+      @JvmField\n+      val subscription: Subscription<*, *, *>,\n+      @JvmField\n+      val scalarTypeAdapters: ScalarTypeAdapters,\n+      @JvmField\n+      val autoPersistSubscription: Boolean,\n+      @JvmField\n+      val sendSubscriptionDocument: Boolean\n+  ) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"start\"\n+    }\n+  }\n+\n+  data class Stop(@JvmField val subscriptionId: String) : OperationClientMessage() {\n+    companion object {\n+      internal const val TYPE = \"stop\"\n+    }\n+  }\n+\n+  class Terminate : OperationClientMessage() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTMwMTA5MQ==", "bodyText": "Same here, these are all data classes now. But this can easily be changed.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545301091", "createdAt": "2020-12-17T18:16:02Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationServerMessage.kt", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.apollographql.apollo.subscription\n+\n+import okio.Buffer\n+\n+sealed class OperationServerMessage {\n+  class ConnectionError(val payload: Map<String, Any?>) : OperationServerMessage() {\n+    override fun hashCode(): Int = javaClass.hashCode()\n+    override fun equals(other: Any?): Boolean = other is ConnectionError\n+\n+    companion object {\n+      const val TYPE = \"connection_error\"\n+    }\n+  }\n+\n+  class ConnectionAcknowledge : OperationServerMessage() {\n+    override fun hashCode(): Int = javaClass.hashCode()\n+    override fun equals(other: Any?): Boolean = other is ConnectionAcknowledge\n+\n+    companion object {\n+      const val TYPE = \"connection_ack\"\n+    }\n+  }\n+\n+  data class Data(@JvmField val id: String?, @JvmField val payload: Map<String, Any?>) : OperationServerMessage() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5cf1552f6d55502fde7953f373e31f923c8015ae"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyOTU1Mg==", "bodyText": "Because it accepts the authorization object and cannot be static for that reason.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545429552", "createdAt": "2020-12-17T21:57:28Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,81 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQyNjY4Ng=="}, "originalCommit": {"oid": "fa441e1ac3e8cb69433860be8636c22e16261866"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDI0OTQ1", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555024945", "createdAt": "2020-12-17T22:04:50Z", "commit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowNDo1MFrOIIKmTQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowNDo1MFrOIIKmTQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzMzE2NQ==", "bodyText": "What about writeClientMessage(sink: BufferedSink, message: OperationClientMessage) so that it's more symmetrical with readServerMessage ? I don't have a strong opinion there so either work for me though.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545433165", "createdAt": "2020-12-17T22:04:50Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,13 @@\n+package com.apollographql.apollo.subscription\n+\n+import okio.BufferedSink\n+import okio.BufferedSource\n+import java.io.IOException\n+\n+interface OperationMessageSerializer {\n+  @Throws(IOException::class)\n+  fun OperationClientMessage.writeTo(sink: BufferedSink)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "originalPosition": 9}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDI1OTIz", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555025923", "createdAt": "2020-12-17T22:06:37Z", "commit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowNjozN1rOIIKpkQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowNjozN1rOIIKpkQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNDAwMQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                @Deprecated(\"This method should be used any more. Instead you should use a serializer\")\n          \n          \n            \n                @Deprecated(\"This method is deprecated. Use an OperationMessageSerializer instead.\")", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545434001", "createdAt": "2020-12-17T22:06:37Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationServerMessage.kt", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.apollographql.apollo.subscription\n+\n+import okio.Buffer\n+\n+sealed class OperationServerMessage {\n+  companion object {\n+    const val JSON_KEY_ID = \"id\"\n+    const val JSON_KEY_TYPE = \"type\"\n+    const val JSON_KEY_PAYLOAD = \"payload\"\n+\n+    @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+    @Deprecated(\"This method should be used any more. Instead you should use a serializer\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDI2MzA0", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555026304", "createdAt": "2020-12-17T22:07:15Z", "commit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowNzoxNVrOIIKrPQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowNzoxNVrOIIKrPQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNDQyOQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Deprecated(\"Use a serializer instead\")\n          \n          \n            \n                @Deprecated(\"This method is deprecated. Use an OperationMessageSerializer instead.\")", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545434429", "createdAt": "2020-12-17T22:07:15Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")\n+  fun toJsonString(): String =\n+      try {\n+        val buffer = Buffer()\n+        with(ApolloOperationMessageSerializer) { writeTo(buffer) }\n+        buffer.readUtf8()\n+      } catch (e: IOException) {\n+        throw RuntimeException(\"Failed to serialize to json\", e)\n+      }\n+\n+  @Suppress(\"DeprecatedCallableAddReplaceWith\")\n+  @Throws(IOException::class)\n+  @Deprecated(\"Use a serializer instead\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "originalPosition": 22}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDI2NDAx", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555026401", "createdAt": "2020-12-17T22:07:25Z", "commit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowNzoyNVrOIIKrhA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjowNzoyNVrOIIKrhA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQzNDUwMA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              @Deprecated(\"Use a serializer instead\")\n          \n          \n            \n                @Deprecated(\"This method is deprecated. Use an OperationMessageSerializer instead.\")", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545434500", "createdAt": "2020-12-17T22:07:25Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/OperationClientMessage.kt", "diffHunk": "@@ -0,0 +1,61 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.Subscription\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import okio.Buffer\n+import java.io.IOException\n+\n+sealed class OperationClientMessage {\n+  @Deprecated(\"Use a serializer instead\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5181d2d7691f2118f27e709a0ea06245f129d5e2"}, "originalPosition": 10}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "06b5ac33de7eb6631c136c68b62c1cd9dc693a72", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/06b5ac33de7eb6631c136c68b62c1cd9dc693a72", "committedDate": "2020-12-17T22:07:41Z", "message": "Update the deprecation message"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4ac3a093bb7c711619783ac26a5e6b682de448b", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/e4ac3a093bb7c711619783ac26a5e6b682de448b", "committedDate": "2020-12-17T22:18:03Z", "message": "Rename buildAppSyncWebSocketUrl to buildWebSocketUrl"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MDQxNDg4", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555041488", "createdAt": "2020-12-17T22:34:44Z", "commit": {"oid": "e4ac3a093bb7c711619783ac26a5e6b682de448b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjozNDo0NFrOIILfYQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xN1QyMjozNDo0NFrOIILfYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTQ0Nzc3Nw==", "bodyText": "This reads weirdly. I know it works but it can be tempting to replace with ApolloOperationMessageSerializer.writeTo(sink), which doesn't. That's an argument to rename writeTo to writeClientMessage(sink, message). This is what moshi does for an exemple and will be less surprising for users?", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545447777", "createdAt": "2020-12-17T22:34:44Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime/src/main/java/com/apollographql/apollo/subscription/AppSyncOperationMessageSerializer.kt", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import com.apollographql.apollo.api.internal.json.Utils\n+import com.apollographql.apollo.api.internal.json.writeObject\n+import com.apollographql.apollo.subscription.ApolloOperationMessageSerializer.writePayloadContentsTo\n+import okhttp3.HttpUrl\n+import okio.Buffer\n+import okio.BufferedSink\n+import okio.BufferedSource\n+import java.net.URL\n+import java.util.Base64\n+\n+class AppSyncOperationMessageSerializer(\n+    private val authorization: Map<String, Any?>\n+) : OperationMessageSerializer {\n+  override fun OperationClientMessage.writeTo(sink: BufferedSink) {\n+    when (this) {\n+      is OperationClientMessage.Start -> JsonWriter.of(sink).use { writeTo(it) }\n+      is OperationClientMessage.Init,\n+      is OperationClientMessage.Stop,\n+      is OperationClientMessage.Terminate -> with(ApolloOperationMessageSerializer) { writeTo(sink) }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e4ac3a093bb7c711619783ac26a5e6b682de448b"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "283cd1f92b9240f518c19f8d8a17c4b081835590", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/283cd1f92b9240f518c19f8d8a17c4b081835590", "committedDate": "2020-12-18T02:06:54Z", "message": "Rename .java to .kt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e00cd9ef9b8f32bf4fc81feb8afde91c46dfc7f6", "author": {"user": {"login": "ansman", "name": "Nicklas Ansman Giertz"}}, "url": "https://github.com/apollographql/apollo-android/commit/e00cd9ef9b8f32bf4fc81feb8afde91c46dfc7f6", "committedDate": "2020-12-18T02:06:54Z", "message": "Add tests and documentation"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU1MTI1Nzc2", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-555125776", "createdAt": "2020-12-18T02:10:16Z", "commit": {"oid": "e00cd9ef9b8f32bf4fc81feb8afde91c46dfc7f6"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMjoxMDoxNlrOIIQUgw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xOFQwMjoxMDoxNlrOIIQUgw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NTUyNjkxNQ==", "bodyText": "I ended up rewriting this to Kotlin too since it had some warnings.", "url": "https://github.com/apollographql/apollo-android/pull/2809#discussion_r545526915", "createdAt": "2020-12-18T02:10:16Z", "author": {"login": "ansman"}, "path": "apollo-runtime/src/test/java/com/apollographql/apollo/subscription/WebSocketSubscriptionTransportMessageTest.kt", "diffHunk": "@@ -0,0 +1,191 @@\n+package com.apollographql.apollo.subscription\n+\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.google.common.truth.Truth.assertThat\n+import okhttp3.Protocol\n+import okhttp3.Request\n+import okhttp3.Response\n+import okhttp3.WebSocket\n+import okhttp3.WebSocketListener\n+import okio.ByteString\n+import org.junit.Before\n+import org.junit.Test\n+import java.math.BigDecimal\n+\n+class WebSocketSubscriptionTransportMessageTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e00cd9ef9b8f32bf4fc81feb8afde91c46dfc7f6"}, "originalPosition": 15}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU2MzA1OTA2", "url": "https://github.com/apollographql/apollo-android/pull/2809#pullrequestreview-556305906", "createdAt": "2020-12-21T11:16:04Z", "commit": {"oid": "e00cd9ef9b8f32bf4fc81feb8afde91c46dfc7f6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4119, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}