{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDA2OTEyMDk3", "number": 2203, "title": "Convert ApolloStore to kotlin (#2144)", "bodyText": "I have tried my best to take care of nullability based on the annotations. I hope I have not misunderstood anything", "createdAt": "2020-04-21T21:13:46Z", "url": "https://github.com/apollographql/apollo-android/pull/2203", "merged": true, "mergeCommit": {"oid": "809e8203ce1dedc673023980ffbcd3935c7fbfeb"}, "closed": true, "closedAt": "2020-04-25T06:28:19Z", "author": {"login": "SubhrajyotiSen"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcZ6WffgH2gAyNDA2OTEyMDk3OjNhYmJjY2ZlZDdhNWRmZjY3ZWNiYzMzMzUwYTQ0Yzg3YWNlODkzOWE=", "endCursor": "Y3Vyc29yOnYyOpPPAAABca9zNBgH2gAyNDA2OTEyMDk3OjhhOTNmMjBhNThiNzIwOGU2ZmRiZDNhYzMxMmQ1MDBiMmY3ZDA3MDE=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a", "author": {"user": {"login": "SubhrajyotiSen", "name": "Subhrajyoti Sen"}}, "url": "https://github.com/apollographql/apollo-android/commit/3abbccfed7a5dff67ecbc33350a44c87ace8939a", "committedDate": "2020-04-21T21:13:15Z", "message": "Convert ApolloStore to kotlin (#2144)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk3Njk2ODk5", "url": "https://github.com/apollographql/apollo-android/pull/2203#pullrequestreview-397696899", "createdAt": "2020-04-21T21:41:41Z", "commit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTo0MTo0MlrOGJZs0Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yMVQyMTo0ODo1M1rOGJZ74Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMTQ0MQ==", "bodyText": "Would it be possible to put all parameters and then the return type on a new line?", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412511441", "createdAt": "2020-04-21T21:41:42Z", "author": {"login": "tasomaniac"}, "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a"}, "originalPosition": 139}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMTYxMw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  operation: Operation<D, T, V>): ApolloStoreOperation<T>\n          \n          \n            \n                  operation: Operation<D, T, V>\n          \n          \n            \n              ): ApolloStoreOperation<T>", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412511613", "createdAt": "2020-04-21T21:42:02Z", "author": {"login": "tasomaniac"}, "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a"}, "originalPosition": 124}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMjkyNg==", "bodyText": "This line says any [ ]. Is that a mistake? What should [ ] have?", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412512926", "createdAt": "2020-04-21T21:44:29Z", "author": {"login": "tasomaniac"}, "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,\n+      responseNormalizer: ResponseNormalizer<Record>, cacheHeaders: CacheHeaders): ApolloStoreOperation<Response<T>>\n+\n+  /**\n+   * Read GraphQL fragment from store.\n+   *\n+   * @param fieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param cacheKey    [CacheKey] to be used to find cache record for the fragment\n+   * @param variables   [Operation.Variables] required for fragment arguments resolving\n+   * @param <F>         type of fragment to be read\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached fragment data\n+  </F> */\n+  fun <F : GraphqlFragment> read(fieldMapper: ResponseFieldMapper<F>,\n+                                  cacheKey: CacheKey, variables: Operation.Variables): ApolloStoreOperation<F>\n+\n+  /**\n+   * Write operation to the store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> write(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation to the store and publish changes of [Record] which have changed, that will notify any [ ] that depends on these [Record] to re-fetch.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMzI5Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.\n          \n          \n            \n               * notify any [com.apollographql.apollo.ApolloQueryWatcher] that depends on these [Record] to re-fetch.", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412513296", "createdAt": "2020-04-21T21:45:12Z", "author": {"login": "tasomaniac"}, "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,\n+      responseNormalizer: ResponseNormalizer<Record>, cacheHeaders: CacheHeaders): ApolloStoreOperation<Response<T>>\n+\n+  /**\n+   * Read GraphQL fragment from store.\n+   *\n+   * @param fieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param cacheKey    [CacheKey] to be used to find cache record for the fragment\n+   * @param variables   [Operation.Variables] required for fragment arguments resolving\n+   * @param <F>         type of fragment to be read\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached fragment data\n+  </F> */\n+  fun <F : GraphqlFragment> read(fieldMapper: ResponseFieldMapper<F>,\n+                                  cacheKey: CacheKey, variables: Operation.Variables): ApolloStoreOperation<F>\n+\n+  /**\n+   * Write operation to the store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> write(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation to the store and publish changes of [Record] which have changed, that will notify any [ ] that depends on these [Record] to re-fetch.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeAndPublish(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write fragment to the store.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param {@link   Operation.Variables} required for fragment arguments resolving\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+   */\n+  fun write(fragment: GraphqlFragment, cacheKey: CacheKey,\n+            variables: Operation.Variables): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write fragment to the store and publish changes of [Record] which have changed, that will notify any ApolloQueryWatcher that\n+   * depends on these [Record] to re-fetch.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param variables [Operation.Variables] required for fragment arguments resolving\n+   * @return [ApolloStoreOperation] to be performed\n+   */\n+  fun writeAndPublish(fragment: GraphqlFragment, cacheKey: CacheKey,\n+                      variables: Operation.Variables): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write operation data to the optimistic store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param mutationId    mutation unique identifier\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+   */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeOptimisticUpdates(operation: Operation<D, T, V>, operationData: D, mutationId: UUID): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation data to the optimistic store and publish changes of [Record]s which have changed, that will\n+   * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a"}, "originalPosition": 218}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxMzU0OQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.\n          \n          \n            \n               * notify any [com.apollographql.apollo.ApolloQueryWatcher] that depends on these [Record] to re-fetch.", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412513549", "createdAt": "2020-04-21T21:45:40Z", "author": {"login": "tasomaniac"}, "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,250 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>, responseFieldMapper: ResponseFieldMapper<D>,\n+      responseNormalizer: ResponseNormalizer<Record>, cacheHeaders: CacheHeaders): ApolloStoreOperation<Response<T>>\n+\n+  /**\n+   * Read GraphQL fragment from store.\n+   *\n+   * @param fieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param cacheKey    [CacheKey] to be used to find cache record for the fragment\n+   * @param variables   [Operation.Variables] required for fragment arguments resolving\n+   * @param <F>         type of fragment to be read\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached fragment data\n+  </F> */\n+  fun <F : GraphqlFragment> read(fieldMapper: ResponseFieldMapper<F>,\n+                                  cacheKey: CacheKey, variables: Operation.Variables): ApolloStoreOperation<F>\n+\n+  /**\n+   * Write operation to the store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> write(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation to the store and publish changes of [Record] which have changed, that will notify any [ ] that depends on these [Record] to re-fetch.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeAndPublish(\n+      operation: Operation<D, T, V>, operationData: D): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write fragment to the store.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param {@link   Operation.Variables} required for fragment arguments resolving\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+   */\n+  fun write(fragment: GraphqlFragment, cacheKey: CacheKey,\n+            variables: Operation.Variables): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write fragment to the store and publish changes of [Record] which have changed, that will notify any ApolloQueryWatcher that\n+   * depends on these [Record] to re-fetch.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param variables [Operation.Variables] required for fragment arguments resolving\n+   * @return [ApolloStoreOperation] to be performed\n+   */\n+  fun writeAndPublish(fragment: GraphqlFragment, cacheKey: CacheKey,\n+                      variables: Operation.Variables): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write operation data to the optimistic store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param mutationId    mutation unique identifier\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+   */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeOptimisticUpdates(operation: Operation<D, T, V>, operationData: D, mutationId: UUID): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation data to the optimistic store and publish changes of [Record]s which have changed, that will\n+   * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param mutationId    mutation unique identifier\n+   * @return {@ApolloStoreOperation} to be performed\n+   */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeOptimisticUpdatesAndPublish(operation: Operation<D, T, V>, operationData: D,\n+                                                                                          mutationId: UUID): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Rollback operation data optimistic updates.\n+   *\n+   * @param mutationId mutation unique identifier\n+   * @return {@ApolloStoreOperation} to be performed\n+   */\n+  fun rollbackOptimisticUpdates(mutationId: UUID): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Rollback operation data optimistic updates and publish changes of [Record]s which have changed, that will\n+   * notify any {@linkcom.apollographql.apollo.ApolloQueryWatcher} that depends on these [Record] to re-fetch.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a"}, "originalPosition": 238}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNDU5Ng==", "bodyText": "I think it would be ok to keep the dispatcher NotNull.", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412514596", "createdAt": "2020-04-21T21:47:38Z", "author": {"login": "tasomaniac"}, "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStoreOperation.kt", "diffHunk": "@@ -0,0 +1,102 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.exception.ApolloException\n+import java.util.concurrent.Executor\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * Apollo store operation to be performed.\n+ *\n+ *\n+ * This class is a wrapper around operation to be performed on [ApolloStore]. Due to the fact that any operation\n+ * can potentially include SQLite instruction, any operation on [ApolloStore] must be performed in background\n+ * thread. Use [.enqueue] to schedule such operation in the dispatcher with a callback to get results.\n+ *\n+ *\n+ * @param <T> result type for this operation\n+</T> */\n+abstract class ApolloStoreOperation<T> protected constructor(private val dispatcher: Executor?) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjUxNTI5Nw==", "bodyText": "Let's put 1 space between properties and the function\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              protected abstract fun perform(): T\n          \n          \n            \n            \n          \n          \n            \n              protected abstract fun perform(): T", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r412515297", "createdAt": "2020-04-21T21:48:53Z", "author": {"login": "tasomaniac"}, "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStoreOperation.kt", "diffHunk": "@@ -0,0 +1,102 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.exception.ApolloException\n+import java.util.concurrent.Executor\n+import java.util.concurrent.atomic.AtomicBoolean\n+import java.util.concurrent.atomic.AtomicReference\n+\n+/**\n+ * Apollo store operation to be performed.\n+ *\n+ *\n+ * This class is a wrapper around operation to be performed on [ApolloStore]. Due to the fact that any operation\n+ * can potentially include SQLite instruction, any operation on [ApolloStore] must be performed in background\n+ * thread. Use [.enqueue] to schedule such operation in the dispatcher with a callback to get results.\n+ *\n+ *\n+ * @param <T> result type for this operation\n+</T> */\n+abstract class ApolloStoreOperation<T> protected constructor(private val dispatcher: Executor?) {\n+  private val callback = AtomicReference<Callback<T>?>()\n+  private val executed = AtomicBoolean()\n+  protected abstract fun perform(): T", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3abbccfed7a5dff67ecbc33350a44c87ace8939a"}, "originalPosition": 22}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "author": {"user": {"login": "SubhrajyotiSen", "name": "Subhrajyoti Sen"}}, "url": "https://github.com/apollographql/apollo-android/commit/6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "committedDate": "2020-04-22T19:02:36Z", "message": "Fix formatting and missing documentation references"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "50303c65730a4e53cd57b3d975835d4b45d3e9f6", "author": {"user": {"login": "SubhrajyotiSen", "name": "Subhrajyoti Sen"}}, "url": "https://github.com/apollographql/apollo-android/commit/50303c65730a4e53cd57b3d975835d4b45d3e9f6", "committedDate": "2020-04-22T18:46:07Z", "message": "Fix formatting and missing documentation references"}, "afterCommit": {"oid": "6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "author": {"user": {"login": "SubhrajyotiSen", "name": "Subhrajyoti Sen"}}, "url": "https://github.com/apollographql/apollo-android/commit/6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a", "committedDate": "2020-04-22T19:02:36Z", "message": "Fix formatting and missing documentation references"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAwMjIwOTU5", "url": "https://github.com/apollographql/apollo-android/pull/2203#pullrequestreview-400220959", "createdAt": "2020-04-24T19:38:18Z", "commit": {"oid": "6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOTozODoxOFrOGLmb8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0yNFQxOTozODoxOFrOGLmb8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNDgxNzI2Nw==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * @param {@link   Operation.Variables} required for fragment arguments resolving\n          \n          \n            \n               * @param variables [Operation.Variables] required for fragment arguments resolving", "url": "https://github.com/apollographql/apollo-android/pull/2203#discussion_r414817267", "createdAt": "2020-04-24T19:38:18Z", "author": {"login": "tasomaniac"}, "path": "apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt", "diffHunk": "@@ -0,0 +1,274 @@\n+package com.apollographql.apollo.cache.normalized\n+\n+import com.apollographql.apollo.api.GraphqlFragment\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.ApolloStore.RecordChangeSubscriber\n+import com.apollographql.apollo.cache.normalized.internal.NoOpApolloStore\n+import com.apollographql.apollo.cache.normalized.internal.ReadableStore\n+import com.apollographql.apollo.cache.normalized.internal.ResponseNormalizer\n+import com.apollographql.apollo.cache.normalized.internal.Transaction\n+import com.apollographql.apollo.cache.normalized.internal.WriteableStore\n+import java.util.UUID\n+\n+/**\n+ * ApolloStore exposes a thread-safe api to access a [com.apollographql.apollo.cache.normalized.NormalizedCache].\n+ * It also maintains a list of [RecordChangeSubscriber] that will be notified with changed records.\n+ *\n+ * Most clients should have no need to directly interface with an [ApolloStore].\n+ */\n+interface ApolloStore {\n+  /**\n+   * Listens to changed record keys dispatched via [.publish].\n+   */\n+  interface RecordChangeSubscriber {\n+    /**\n+     * @param changedRecordKeys A set of record keys which correspond to records which have had content changes.\n+     */\n+    fun onCacheRecordsChanged(changedRecordKeys: Set<String>)\n+  }\n+\n+  fun subscribe(subscriber: RecordChangeSubscriber)\n+  fun unsubscribe(subscriber: RecordChangeSubscriber)\n+\n+  /**\n+   * @param keys A set of keys of [Record] which have changed.\n+   */\n+  fun publish(keys: Set<String>)\n+\n+  /**\n+   * Clear all records from this [ApolloStore].\n+   *\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if all records was\n+   * successfully removed, `false` otherwise\n+   */\n+  fun clearAll(): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache record by the key\n+   *\n+   * @param cacheKey of record to be removed\n+   * @param cascade defines if remove operation is propagated to the referenced entities\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with `true` if record with such key\n+   * was successfully removed, `false` otherwise\n+   */\n+  fun remove(cacheKey: CacheKey, cascade: Boolean): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Remove cache records by the list of keys\n+   *\n+   * @param cacheKeys keys of records to be removed\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with the count of records been removed\n+   */\n+  fun remove(cacheKeys: List<CacheKey>): ApolloStoreOperation<Int>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the network.\n+   */\n+  fun networkResponseNormalizer(): ResponseNormalizer<Map<String, Any>>\n+\n+  /**\n+   * @return The [ResponseNormalizer] used to generate normalized records from the cache.\n+   */\n+  fun cacheResponseNormalizer(): ResponseNormalizer<Record>\n+\n+  /**\n+   * Run a operation inside a read-lock. Blocks until read-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the read lock is acquired.\n+   * @param <R>         The result type of this read operation.\n+   * @return A result from the read operation.\n+  </R> */\n+  fun <R> readTransaction(transaction: Transaction<ReadableStore, R>): R\n+\n+  /**\n+   * Run a operation inside a write-lock. Blocks until write-lock is acquired.\n+   *\n+   * @param transaction A code block to run once the write lock is acquired.\n+   * @param <R>         The result type of this write operation.\n+   * @return A result from the write operation.\n+  </R> */\n+  fun <R> writeTransaction(transaction: Transaction<WriteableStore, R>): R\n+\n+  /**\n+   * @return The [NormalizedCache] which backs this ApolloStore.\n+   */\n+  fun normalizedCache(): NormalizedCache\n+\n+  /**\n+   * @return the [CacheKeyResolver] used for resolving field cache keys\n+   */\n+  fun cacheKeyResolver(): CacheKeyResolver\n+\n+  /**\n+   * Read GraphQL operation from store.\n+   *\n+   * @param operation to be read\n+   * @param <D>       type of GraphQL operation data\n+   * @param <T>       type operation cached data will be wrapped with\n+   * @param <V>       type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached data for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>\n+  ): ApolloStoreOperation<T>\n+\n+  /**\n+   * Read GraphQL operation response from store.\n+   *\n+   * @param operation           response of which should be read\n+   * @param responseFieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param responseNormalizer  [ResponseNormalizer] to be used when reading cached response\n+   * @param cacheHeaders        [CacheHeaders] to be used when reading cached response\n+   * @param <D>                 type of GraphQL operation data\n+   * @param <T>                 type operation cached data will be wrapped with\n+   * @param <V>                 type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached response for specified operation\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> read(\n+      operation: Operation<D, T, V>,\n+      responseFieldMapper: ResponseFieldMapper<D>,\n+      responseNormalizer: ResponseNormalizer<Record>,\n+      cacheHeaders: CacheHeaders\n+  ): ApolloStoreOperation<Response<T>>\n+\n+  /**\n+   * Read GraphQL fragment from store.\n+   *\n+   * @param fieldMapper [ResponseFieldMapper] to be used for field mapping\n+   * @param cacheKey    [CacheKey] to be used to find cache record for the fragment\n+   * @param variables   [Operation.Variables] required for fragment arguments resolving\n+   * @param <F>         type of fragment to be read\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with cached fragment data\n+  </F> */\n+  fun <F : GraphqlFragment> read(\n+      fieldMapper: ResponseFieldMapper<F>,\n+      cacheKey: CacheKey,\n+      variables: Operation.Variables\n+  ): ApolloStoreOperation<F>\n+\n+  /**\n+   * Write operation to the store.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed, that will be resolved with set of keys of [Record] which\n+   * have changed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> write(\n+      operation: Operation<D, T, V>,\n+      operationData: D\n+  ): ApolloStoreOperation<Set<String>>\n+\n+  /**\n+   * Write operation to the store and publish changes of [Record] which have changed, that will notify any [com.apollographql.apollo.ApolloQueryWatcher] that depends on these [Record] to re-fetch.\n+   *\n+   * @param operation     [Operation] response data of which should be written to the store\n+   * @param operationData [Operation.Data] operation response data to be written to the store\n+   * @param <D>           type of GraphQL operation data\n+   * @param <T>           type operation cached data will be wrapped with\n+   * @param <V>           type of operation variables\n+   * @return {@ApolloStoreOperation} to be performed\n+  </V></T></D> */\n+  fun <D : Operation.Data, T, V : Operation.Variables> writeAndPublish(\n+      operation: Operation<D, T, V>,\n+      operationData: D\n+  ): ApolloStoreOperation<Boolean>\n+\n+  /**\n+   * Write fragment to the store.\n+   *\n+   * @param fragment data to be written to the store\n+   * @param cacheKey [CacheKey] to be used as root record key\n+   * @param {@link   Operation.Variables} required for fragment arguments resolving", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6dab3ecdd8f70f2dbe1c91d812231e5a93337e6a"}, "originalPosition": 197}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1476ca3873584c0eb188d89711357ea3237a3d8a", "author": {"user": {"login": "tasomaniac", "name": "Said Tahsin Dane"}}, "url": "https://github.com/apollographql/apollo-android/commit/1476ca3873584c0eb188d89711357ea3237a3d8a", "committedDate": "2020-04-24T19:38:36Z", "message": "Update apollo-normalized-cache/src/main/java/com/apollographql/apollo/cache/normalized/ApolloStore.kt"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8a93f20a58b7208e6fdbd3ac312d500b2f7d0701", "author": {"user": {"login": "SubhrajyotiSen", "name": "Subhrajyoti Sen"}}, "url": "https://github.com/apollographql/apollo-android/commit/8a93f20a58b7208e6fdbd3ac312d500b2f7d0701", "committedDate": "2020-04-25T03:48:15Z", "message": "Make dispatcher NotNull in ApolloStoreOperation"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3964, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}