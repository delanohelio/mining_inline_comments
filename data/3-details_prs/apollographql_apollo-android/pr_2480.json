{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3NTg0NTMz", "number": 2480, "title": "Add is disposed checking to single", "bodyText": "This can cause Undeliverable Exception if not checked.", "createdAt": "2020-07-28T06:23:56Z", "url": "https://github.com/apollographql/apollo-android/pull/2480", "merged": true, "mergeCommit": {"oid": "3d7e5ffcc1cfa7c0428f5bb42084e8919fbacea9"}, "closed": true, "closedAt": "2020-07-30T08:50:16Z", "author": {"login": "s1ee"}, "timelineItems": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc5QVPlgH2gAyNDU3NTg0NTMzOjNiNTc3ZTEyMTNkMzQzYjUyNGZmNTkwOTUxYWUxODJlN2Q2OGJmZGM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5zyWPgFqTQ1Nzk2OTY2Mw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3b577e1213d343b524ff590951ae182e7d68bfdc", "author": {"user": {"login": "s1ee", "name": null}}, "url": "https://github.com/apollographql/apollo-android/commit/3b577e1213d343b524ff590951ae182e7d68bfdc", "committedDate": "2020-07-28T06:21:27Z", "message": "add is disposed checking"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "39f9d94e5293238ca46c762dde8282a4230ced54", "author": {"user": {"login": "martinbonnin", "name": "Martin Bonnin"}}, "url": "https://github.com/apollographql/apollo-android/commit/39f9d94e5293238ca46c762dde8282a4230ced54", "committedDate": "2020-07-29T16:29:14Z", "message": "remove the android plugin from integration tests"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "87228d419c17ddd966735bca10afbc646e412bd0", "author": {"user": {"login": "martinbonnin", "name": "Martin Bonnin"}}, "url": "https://github.com/apollographql/apollo-android/commit/87228d419c17ddd966735bca10afbc646e412bd0", "committedDate": "2020-07-29T16:29:41Z", "message": "remove unused import"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e847ad49f25dd609293c691714fa697527f28746", "author": {"user": {"login": "martinbonnin", "name": "Martin Bonnin"}}, "url": "https://github.com/apollographql/apollo-android/commit/e847ad49f25dd609293c691714fa697527f28746", "committedDate": "2020-07-29T16:30:14Z", "message": "fix test without the android plugin"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "c527cc647c920c993c5e0dc1e499f146c74e0441", "author": {"user": {"login": "martinbonnin", "name": "Martin Bonnin"}}, "url": "https://github.com/apollographql/apollo-android/commit/c527cc647c920c993c5e0dc1e499f146c74e0441", "committedDate": "2020-07-29T16:30:39Z", "message": "cleanup buildSrc a bit and do not do network accesses during task\nconfigueration"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "428b4ce17650bbbc7b34e58bd8a87eaf4fc63c3d", "author": {"user": {"login": "martinbonnin", "name": "Martin Bonnin"}}, "url": "https://github.com/apollographql/apollo-android/commit/428b4ce17650bbbc7b34e58bd8a87eaf4fc63c3d", "committedDate": "2020-07-29T16:30:49Z", "message": "add a failing test case"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "44fdceac0a0cc3abc06c68afe404af1103a99382", "author": {"user": {"login": "martinbonnin", "name": "Martin Bonnin"}}, "url": "https://github.com/apollographql/apollo-android/commit/44fdceac0a0cc3abc06c68afe404af1103a99382", "committedDate": "2020-07-29T16:30:59Z", "message": "same test for RxJava3"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b", "author": {"user": {"login": "martinbonnin", "name": "Martin Bonnin"}}, "url": "https://github.com/apollographql/apollo-android/commit/355a340fabcf873e7c6b982a7634151c3517af5b", "committedDate": "2020-07-29T16:35:24Z", "message": "add comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3Njk4MzMy", "url": "https://github.com/apollographql/apollo-android/pull/2480#pullrequestreview-457698332", "createdAt": "2020-07-29T16:37:41Z", "commit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNjozNzo0MlrOG5A04g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNjozNzo0MlrOG5A04g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNTU1NA==", "bodyText": "This is the test that failed before the patch \u261d\ufe0f", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462435554", "createdAt": "2020-07-29T16:37:42Z", "author": {"login": "martinbonnin"}, "path": "apollo-integration/src/test/java/com/apollographql/apollo/Rx2ApolloTest.kt", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.Utils.immediateExecutor\n+import com.apollographql.apollo.Utils.immediateExecutorService\n+import com.apollographql.apollo.Utils.mockResponse\n+import com.apollographql.apollo.api.Input\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import com.apollographql.apollo.cache.normalized.lru.EvictionPolicy\n+import com.apollographql.apollo.cache.normalized.lru.LruNormalizedCacheFactory\n+import com.apollographql.apollo.cache.normalized.NormalizedCacheFactory\n+import com.apollographql.apollo.fetcher.ApolloResponseFetchers.NETWORK_ONLY\n+import com.apollographql.apollo.integration.normalizer.EpisodeHeroNameQuery\n+import com.apollographql.apollo.integration.normalizer.HeroAndFriendsNamesWithIDsQuery\n+import com.apollographql.apollo.integration.normalizer.type.Episode.EMPIRE\n+import com.apollographql.apollo.integration.normalizer.type.Episode.NEWHOPE\n+import com.apollographql.apollo.rx2.Rx2Apollo\n+import com.google.common.truth.Truth\n+import com.google.common.truth.Truth.assertThat\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.observers.TestObserver\n+import io.reactivex.plugins.RxJavaPlugins\n+import io.reactivex.schedulers.TestScheduler\n+import okhttp3.Dispatcher\n+import okhttp3.OkHttpClient\n+import okhttp3.mockwebserver.MockWebServer\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+\n+\n+class Rx2ApolloTest {\n+  private lateinit var apolloClient: ApolloClient\n+\n+  @get:Rule\n+  val server = MockWebServer()\n+\n+  @Before\n+  fun setup() {\n+    val okHttpClient = OkHttpClient.Builder()\n+        .dispatcher(Dispatcher(immediateExecutorService()))\n+        .build()\n+    apolloClient = ApolloClient.builder()\n+        .serverUrl(server.url(\"/\"))\n+        .dispatcher(immediateExecutor())\n+        .okHttpClient(okHttpClient)\n+        .normalizedCache(LruNormalizedCacheFactory(EvictionPolicy.NO_EVICTION), IdFieldCacheKeyResolver())\n+        .build()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callProducesValue() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+        .assertValue({ response ->\n+          assertThat(response.data()?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        })\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<Response<EpisodeHeroNameQuery.Data>> = TestObserver<Response<EpisodeHeroNameQuery.Data>>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchCompletes() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .observeOn(TestScheduler())\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertNotComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedSameQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)))\n+        .responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer.assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotUpdatedSameQuerySameResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedDifferentQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(\"HeroAndFriendsNameWithIdsNameChange.json\"))\n+    apolloClient.query(HeroAndFriendsNamesWithIDsQuery(Input.fromNullable(NEWHOPE))).enqueue(null)\n+    observer\n+        .assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotCalledWhenCanceled() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val scheduler = TestScheduler()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .observeOn(scheduler)\n+        .subscribeWith(testObserver)\n+    scheduler.triggerActions()\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    disposable.dispose()\n+    scheduler.triggerActions()\n+    testObserver\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  fun disposingAnOperationDoesNotThrowUndeliverableException() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "originalPosition": 201}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTY5NDA0", "url": "https://github.com/apollographql/apollo-android/pull/2480#pullrequestreview-457969404", "createdAt": "2020-07-29T23:39:09Z", "commit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTowOVrOG5N7HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTowOVrOG5N7HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDE0MQ==", "bodyText": "I've also used this approach to verify no error has been thrown.\nhttps://bryanherbst.com/2020/07/15/rxjava-uncaught-exception-tests/", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462650141", "createdAt": "2020-07-29T23:39:09Z", "author": {"login": "s1ee"}, "path": "apollo-integration/src/test/java/com/apollographql/apollo/Rx2ApolloTest.kt", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.Utils.immediateExecutor\n+import com.apollographql.apollo.Utils.immediateExecutorService\n+import com.apollographql.apollo.Utils.mockResponse\n+import com.apollographql.apollo.api.Input\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import com.apollographql.apollo.cache.normalized.lru.EvictionPolicy\n+import com.apollographql.apollo.cache.normalized.lru.LruNormalizedCacheFactory\n+import com.apollographql.apollo.cache.normalized.NormalizedCacheFactory\n+import com.apollographql.apollo.fetcher.ApolloResponseFetchers.NETWORK_ONLY\n+import com.apollographql.apollo.integration.normalizer.EpisodeHeroNameQuery\n+import com.apollographql.apollo.integration.normalizer.HeroAndFriendsNamesWithIDsQuery\n+import com.apollographql.apollo.integration.normalizer.type.Episode.EMPIRE\n+import com.apollographql.apollo.integration.normalizer.type.Episode.NEWHOPE\n+import com.apollographql.apollo.rx2.Rx2Apollo\n+import com.google.common.truth.Truth\n+import com.google.common.truth.Truth.assertThat\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.observers.TestObserver\n+import io.reactivex.plugins.RxJavaPlugins\n+import io.reactivex.schedulers.TestScheduler\n+import okhttp3.Dispatcher\n+import okhttp3.OkHttpClient\n+import okhttp3.mockwebserver.MockWebServer\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+\n+\n+class Rx2ApolloTest {\n+  private lateinit var apolloClient: ApolloClient\n+\n+  @get:Rule\n+  val server = MockWebServer()\n+\n+  @Before\n+  fun setup() {\n+    val okHttpClient = OkHttpClient.Builder()\n+        .dispatcher(Dispatcher(immediateExecutorService()))\n+        .build()\n+    apolloClient = ApolloClient.builder()\n+        .serverUrl(server.url(\"/\"))\n+        .dispatcher(immediateExecutor())\n+        .okHttpClient(okHttpClient)\n+        .normalizedCache(LruNormalizedCacheFactory(EvictionPolicy.NO_EVICTION), IdFieldCacheKeyResolver())\n+        .build()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callProducesValue() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+        .assertValue({ response ->\n+          assertThat(response.data()?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        })\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<Response<EpisodeHeroNameQuery.Data>> = TestObserver<Response<EpisodeHeroNameQuery.Data>>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchCompletes() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .observeOn(TestScheduler())\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertNotComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedSameQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)))\n+        .responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer.assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotUpdatedSameQuerySameResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedDifferentQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(\"HeroAndFriendsNameWithIdsNameChange.json\"))\n+    apolloClient.query(HeroAndFriendsNamesWithIDsQuery(Input.fromNullable(NEWHOPE))).enqueue(null)\n+    observer\n+        .assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotCalledWhenCanceled() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val scheduler = TestScheduler()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .observeOn(scheduler)\n+        .subscribeWith(testObserver)\n+    scheduler.triggerActions()\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    disposable.dispose()\n+    scheduler.triggerActions()\n+    testObserver\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  fun disposingAnOperationDoesNotThrowUndeliverableException() {\n+    /*\n+     * A simple cache that will always throw errors\n+     */\n+    val cacheFactory = object: NormalizedCacheFactory<NormalizedCache>() {\n+      override fun create(recordFieldAdapter: RecordFieldJsonAdapter): NormalizedCache {\n+        return object: NormalizedCache() {\n+          override fun clearAll() {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun loadRecord(key: String, cacheHeaders: CacheHeaders): Record? {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun performMerge(apolloRecord: Record, oldRecord: Record?, cacheHeaders: CacheHeaders): Set<String> {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun remove(cacheKey: CacheKey, cascade: Boolean): Boolean {\n+            throw Exception(\"not implemented\")\n+          }\n+        }\n+      }\n+    }\n+\n+    val apolloClient = ApolloClient.builder()\n+        .normalizedCache(cacheFactory)\n+        .serverUrl(\"https://unused/\")\n+        .build()\n+\n+\n+    val savedHandler = RxJavaPlugins.getErrorHandler()\n+\n+    var undeliverableException: Throwable? = null\n+    RxJavaPlugins.setErrorHandler {\n+      undeliverableException = it\n+    }\n+\n+    val operation = apolloClient.apolloStore.write(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)), EpisodeHeroNameQuery.Data(EpisodeHeroNameQuery.Hero(\"\", \"\")))\n+    val testObserver = Rx2Apollo.from(operation)\n+        .test()\n+\n+    testObserver.dispose()\n+\n+    // Since there is no cancellation mechanism for the ApolloStoreOperation, the only way to see if an error is thrown is to wait here\n+    Thread.sleep(200)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "originalPosition": 247}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU3OTY5NjYz", "url": "https://github.com/apollographql/apollo-android/pull/2480#pullrequestreview-457969663", "createdAt": "2020-07-29T23:39:55Z", "commit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTo1NVrOG5N8IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTo1NVrOG5N8IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDQwMQ==", "bodyText": "I totally forgot this library supports Rx3 as well \ud83e\udd26", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462650401", "createdAt": "2020-07-29T23:39:55Z", "author": {"login": "s1ee"}, "path": "apollo-rx3-support/src/main/java/com/apollographql/apollo/rx3/Rx3Apollo.java", "diffHunk": "@@ -212,12 +212,16 @@ public void subscribe(final SingleEmitter<T> emitter) {\n         operation.enqueue(new ApolloStoreOperation.Callback<T>() {\n           @Override\n           public void onSuccess(T result) {\n-            emitter.onSuccess(result);\n+            if (!emitter.isDisposed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4229, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}