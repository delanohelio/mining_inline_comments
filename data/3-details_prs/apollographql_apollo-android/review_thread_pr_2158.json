{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAyNDE3Njg4", "number": 2158, "reviewThreads": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODozODo1OVrODxLepg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODo1MzozNFrODxLsaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODk0ODg2OnYy", "diffSide": "RIGHT", "path": "apollo-sqlite-cache/src/main/sqldelight/com/apollographql/apollo/cache/normalized/sql/cache.sq", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODozODo1OVrOGEgfbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwOToxMjoxM1rOGEhOTw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM3OTgyMQ==", "bodyText": "Nitpicking, maybe not update key ?\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            UPDATE records SET key=:key, record=:record WHERE key=:key;\n          \n          \n            \n            UPDATE records SET record=:record WHERE key=:key;", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407379821", "createdAt": "2020-04-13T08:38:59Z", "author": {"login": "martinbonnin"}, "path": "apollo-sqlite-cache/src/main/sqldelight/com/apollographql/apollo/cache/normalized/sql/cache.sq", "diffHunk": "@@ -0,0 +1,25 @@\n+CREATE TABLE records (\n+  _id INTEGER PRIMARY KEY AUTOINCREMENT,\n+  key TEXT NOT NULL,\n+  record TEXT NOT NULL\n+);\n+\n+CREATE INDEX idx_records_key ON records(key);\n+\n+recordForKey:\n+SELECT key, record FROM records WHERE key=?;\n+\n+insert:\n+INSERT INTO records (key, record) VALUES (?,?);\n+\n+update:\n+UPDATE records SET key=:key, record=:record WHERE key=:key;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM5MTgyMw==", "bodyText": "I saw this too but wanted to keep the same as before \ud83d\ude0a This was like this before.", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407391823", "createdAt": "2020-04-13T09:12:13Z", "author": {"login": "tasomaniac"}, "path": "apollo-sqlite-cache/src/main/sqldelight/com/apollographql/apollo/cache/normalized/sql/cache.sq", "diffHunk": "@@ -0,0 +1,25 @@\n+CREATE TABLE records (\n+  _id INTEGER PRIMARY KEY AUTOINCREMENT,\n+  key TEXT NOT NULL,\n+  record TEXT NOT NULL\n+);\n+\n+CREATE INDEX idx_records_key ON records(key);\n+\n+recordForKey:\n+SELECT key, record FROM records WHERE key=?;\n+\n+insert:\n+INSERT INTO records (key, record) VALUES (?,?);\n+\n+update:\n+UPDATE records SET key=:key, record=:record WHERE key=:key;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM3OTgyMQ=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 16}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODk1ODAzOnYy", "diffSide": "RIGHT", "path": "apollo-sqlite-cache/gradle.properties", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODo0MzowMVrOGEglHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMDo1MDozN1rOGEjPWg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MTI3Nw==", "bodyText": "Nitpicking about the naming: what about apollo-normalized-cache-sqldelight ?  This would:\n\nput the module next to apollo-normalized-cache and apollo-normalized-cache-api when sorted alphabetically\nmake a clear distinction between 'normalized' caches and 'http' ones.\nallow for sqlite implementation without sqldelight", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407381277", "createdAt": "2020-04-13T08:43:01Z", "author": {"login": "martinbonnin"}, "path": "apollo-sqlite-cache/gradle.properties", "diffHunk": "@@ -0,0 +1,4 @@\n+POM_ARTIFACT_ID=apollo-sqlite-cache", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM5MzAwNw==", "bodyText": "What about apollo-normalized-cache-sqlite?\nI genuinely think that SqlDelight should be implementation detail. We provide persisted normalized cache backed by SQLite.\n\nWe wouldn't provide 2nd implementation side by side\nIf we want to replace it in the future, it's easier (not exposed)\nIf a user wants to have a different implementation, they can always implement NormalizedCache from the API", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407393007", "createdAt": "2020-04-13T09:15:17Z", "author": {"login": "tasomaniac"}, "path": "apollo-sqlite-cache/gradle.properties", "diffHunk": "@@ -0,0 +1,4 @@\n+POM_ARTIFACT_ID=apollo-sqlite-cache", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MTI3Nw=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 1}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyNDg1OA==", "bodyText": "Sounds good!", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407424858", "createdAt": "2020-04-13T10:50:37Z", "author": {"login": "martinbonnin"}, "path": "apollo-sqlite-cache/gradle.properties", "diffHunk": "@@ -0,0 +1,4 @@\n+POM_ARTIFACT_ID=apollo-sqlite-cache", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MTI3Nw=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODk3Mjc5OnYy", "diffSide": "RIGHT", "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "isResolved": true, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODo0OTowMFrOGEgtsg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMToxNTo0MFrOGEjtNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MzQ3NA==", "bodyText": "What about SQLDelightNormalizedCache ?", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407383474", "createdAt": "2020-04-13T08:49:00Z", "author": {"login": "martinbonnin"}, "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.apollographql.apollo.cache.normalized.sql\n+\n+import com.apollographql.apollo.cache.ApolloCacheHeaders.EVICT_AFTER_READ\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import okio.IOException\n+\n+class SqlNormalizedCache(\n+    private val recordFieldAdapter: RecordFieldJsonAdapter,\n+    private val cacheQueries: CacheQueries\n+) : NormalizedCache() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM5MzI5NQ==", "bodyText": "That would be backward incompatible.", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407393295", "createdAt": "2020-04-13T09:16:00Z", "author": {"login": "tasomaniac"}, "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.apollographql.apollo.cache.normalized.sql\n+\n+import com.apollographql.apollo.cache.ApolloCacheHeaders.EVICT_AFTER_READ\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import okio.IOException\n+\n+class SqlNormalizedCache(\n+    private val recordFieldAdapter: RecordFieldJsonAdapter,\n+    private val cacheQueries: CacheQueries\n+) : NormalizedCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MzQ3NA=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyNTcwMA==", "bodyText": "I see. Since it had queries in the constructor, I assumed it was already backward incompatible but this is only created through SqlNormalizedCacheFactory, right ? Then mark the constructor internal maybe ?", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407425700", "createdAt": "2020-04-13T10:53:17Z", "author": {"login": "martinbonnin"}, "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.apollographql.apollo.cache.normalized.sql\n+\n+import com.apollographql.apollo.cache.ApolloCacheHeaders.EVICT_AFTER_READ\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import okio.IOException\n+\n+class SqlNormalizedCache(\n+    private val recordFieldAdapter: RecordFieldJsonAdapter,\n+    private val cacheQueries: CacheQueries\n+) : NormalizedCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MzQ3NA=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQzMjUwMw==", "bodyText": "Yes. That I missed. Before the constructor was package private. Now it is internal. It is not something users should be instantiating themselves. They should use the factory.\nBut they may assign SqlNormalizedCache to somewhere. The name is still public. I don't like it either :) but we need to keep it.", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407432503", "createdAt": "2020-04-13T11:15:40Z", "author": {"login": "tasomaniac"}, "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.apollographql.apollo.cache.normalized.sql\n+\n+import com.apollographql.apollo.cache.ApolloCacheHeaders.EVICT_AFTER_READ\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import okio.IOException\n+\n+class SqlNormalizedCache(\n+    private val recordFieldAdapter: RecordFieldJsonAdapter,\n+    private val cacheQueries: CacheQueries\n+) : NormalizedCache() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4MzQ3NA=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODk4NDExOnYy", "diffSide": "RIGHT", "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "isResolved": false, "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwODo1MzozNFrOGEg0NA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QxMjozODo1OVrOGElSeg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTE0MA==", "bodyText": "This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      .executeAsList()\n          \n          \n            \n                      .firstOrNull()\n          \n          \n            \n                      .executeAsOneOrNull()", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407385140", "createdAt": "2020-04-13T08:53:34Z", "author": {"login": "martinbonnin"}, "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.apollographql.apollo.cache.normalized.sql\n+\n+import com.apollographql.apollo.cache.ApolloCacheHeaders.EVICT_AFTER_READ\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import okio.IOException\n+\n+class SqlNormalizedCache(\n+    private val recordFieldAdapter: RecordFieldJsonAdapter,\n+    private val cacheQueries: CacheQueries\n+) : NormalizedCache() {\n+\n+  override fun loadRecord(key: String, cacheHeaders: CacheHeaders): Record? {\n+    val record = selectRecordForKey(key)\n+\n+    if (record != null) {\n+      if (cacheHeaders.hasHeader(EVICT_AFTER_READ)) {\n+        deleteRecord(key)\n+      }\n+      return record\n+    }\n+    return nextCache?.loadRecord(key, cacheHeaders)\n+  }\n+\n+  override fun clearAll() {\n+    nextCache?.clearAll()\n+    cacheQueries.deleteAll()\n+  }\n+\n+  override fun remove(cacheKey: CacheKey, cascade: Boolean): Boolean {\n+    val result: Boolean = nextCache?.remove(cacheKey, cascade) ?: false\n+    if (result) {\n+      return true\n+    }\n+    return if (cascade) {\n+      selectRecordForKey(cacheKey.key)\n+          ?.referencedFields()\n+          ?.all { remove(CacheKey(it.key()), cascade = true) }\n+          ?: false\n+    } else {\n+      deleteRecord(cacheKey.key)\n+    }\n+  }\n+\n+  override fun performMerge(apolloRecord: Record, cacheHeaders: CacheHeaders): Set<String> {\n+    val oldRecord = selectRecordForKey(apolloRecord.key())\n+    return if (oldRecord == null) {\n+      cacheQueries.insert(apolloRecord.key(), recordFieldAdapter.toJson(apolloRecord.fields()))\n+      emptySet()\n+    } else {\n+      oldRecord.mergeWith(apolloRecord).also {\n+        if (it.isNotEmpty()) {\n+          cacheQueries.update(oldRecord.key(), recordFieldAdapter.toJson(oldRecord.fields()))\n+        }\n+      }\n+    }\n+  }\n+\n+  fun selectRecordForKey(key: String): Record? {\n+    return try {\n+      cacheQueries.recordForKey(key)\n+          .executeAsList()\n+          .firstOrNull()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyNDg1NQ==", "bodyText": "I remember there was a specific reason why I chose asList. I will double check.", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407424855", "createdAt": "2020-04-13T10:50:37Z", "author": {"login": "tasomaniac"}, "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.apollographql.apollo.cache.normalized.sql\n+\n+import com.apollographql.apollo.cache.ApolloCacheHeaders.EVICT_AFTER_READ\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import okio.IOException\n+\n+class SqlNormalizedCache(\n+    private val recordFieldAdapter: RecordFieldJsonAdapter,\n+    private val cacheQueries: CacheQueries\n+) : NormalizedCache() {\n+\n+  override fun loadRecord(key: String, cacheHeaders: CacheHeaders): Record? {\n+    val record = selectRecordForKey(key)\n+\n+    if (record != null) {\n+      if (cacheHeaders.hasHeader(EVICT_AFTER_READ)) {\n+        deleteRecord(key)\n+      }\n+      return record\n+    }\n+    return nextCache?.loadRecord(key, cacheHeaders)\n+  }\n+\n+  override fun clearAll() {\n+    nextCache?.clearAll()\n+    cacheQueries.deleteAll()\n+  }\n+\n+  override fun remove(cacheKey: CacheKey, cascade: Boolean): Boolean {\n+    val result: Boolean = nextCache?.remove(cacheKey, cascade) ?: false\n+    if (result) {\n+      return true\n+    }\n+    return if (cascade) {\n+      selectRecordForKey(cacheKey.key)\n+          ?.referencedFields()\n+          ?.all { remove(CacheKey(it.key()), cascade = true) }\n+          ?: false\n+    } else {\n+      deleteRecord(cacheKey.key)\n+    }\n+  }\n+\n+  override fun performMerge(apolloRecord: Record, cacheHeaders: CacheHeaders): Set<String> {\n+    val oldRecord = selectRecordForKey(apolloRecord.key())\n+    return if (oldRecord == null) {\n+      cacheQueries.insert(apolloRecord.key(), recordFieldAdapter.toJson(apolloRecord.fields()))\n+      emptySet()\n+    } else {\n+      oldRecord.mergeWith(apolloRecord).also {\n+        if (it.isNotEmpty()) {\n+          cacheQueries.update(oldRecord.key(), recordFieldAdapter.toJson(oldRecord.fields()))\n+        }\n+      }\n+    }\n+  }\n+\n+  fun selectRecordForKey(key: String): Record? {\n+    return try {\n+      cacheQueries.recordForKey(key)\n+          .executeAsList()\n+          .firstOrNull()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTE0MA=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyOTQ3Ng==", "bodyText": "Ok, I see now. executeAsOneOrNull is more like singleOrNull function in Kotlin. If there are more, it crashes. The old logic was going to over the Cursor and picks the first match too. Since key in the database is not UNIQUE, we may have multiple of them.\nNot sure if we should though \ud83d\ude04 Don't really want to change the behavior now. It can be something we may look in the future.", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407429476", "createdAt": "2020-04-13T11:05:51Z", "author": {"login": "tasomaniac"}, "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.apollographql.apollo.cache.normalized.sql\n+\n+import com.apollographql.apollo.cache.ApolloCacheHeaders.EVICT_AFTER_READ\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import okio.IOException\n+\n+class SqlNormalizedCache(\n+    private val recordFieldAdapter: RecordFieldJsonAdapter,\n+    private val cacheQueries: CacheQueries\n+) : NormalizedCache() {\n+\n+  override fun loadRecord(key: String, cacheHeaders: CacheHeaders): Record? {\n+    val record = selectRecordForKey(key)\n+\n+    if (record != null) {\n+      if (cacheHeaders.hasHeader(EVICT_AFTER_READ)) {\n+        deleteRecord(key)\n+      }\n+      return record\n+    }\n+    return nextCache?.loadRecord(key, cacheHeaders)\n+  }\n+\n+  override fun clearAll() {\n+    nextCache?.clearAll()\n+    cacheQueries.deleteAll()\n+  }\n+\n+  override fun remove(cacheKey: CacheKey, cascade: Boolean): Boolean {\n+    val result: Boolean = nextCache?.remove(cacheKey, cascade) ?: false\n+    if (result) {\n+      return true\n+    }\n+    return if (cascade) {\n+      selectRecordForKey(cacheKey.key)\n+          ?.referencedFields()\n+          ?.all { remove(CacheKey(it.key()), cascade = true) }\n+          ?: false\n+    } else {\n+      deleteRecord(cacheKey.key)\n+    }\n+  }\n+\n+  override fun performMerge(apolloRecord: Record, cacheHeaders: CacheHeaders): Set<String> {\n+    val oldRecord = selectRecordForKey(apolloRecord.key())\n+    return if (oldRecord == null) {\n+      cacheQueries.insert(apolloRecord.key(), recordFieldAdapter.toJson(apolloRecord.fields()))\n+      emptySet()\n+    } else {\n+      oldRecord.mergeWith(apolloRecord).also {\n+        if (it.isNotEmpty()) {\n+          cacheQueries.update(oldRecord.key(), recordFieldAdapter.toJson(oldRecord.fields()))\n+        }\n+      }\n+    }\n+  }\n+\n+  fun selectRecordForKey(key: String): Record? {\n+    return try {\n+      cacheQueries.recordForKey(key)\n+          .executeAsList()\n+          .firstOrNull()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTE0MA=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQ1ODQyNg==", "bodyText": "Makes senses \ud83d\udc4d", "url": "https://github.com/apollographql/apollo-android/pull/2158#discussion_r407458426", "createdAt": "2020-04-13T12:38:59Z", "author": {"login": "martinbonnin"}, "path": "apollo-sqlite-cache/src/main/java/com/apollographql/apollo/cache/normalized/sql/SqlNormalizedCache.kt", "diffHunk": "@@ -0,0 +1,97 @@\n+package com.apollographql.apollo.cache.normalized.sql\n+\n+import com.apollographql.apollo.cache.ApolloCacheHeaders.EVICT_AFTER_READ\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import okio.IOException\n+\n+class SqlNormalizedCache(\n+    private val recordFieldAdapter: RecordFieldJsonAdapter,\n+    private val cacheQueries: CacheQueries\n+) : NormalizedCache() {\n+\n+  override fun loadRecord(key: String, cacheHeaders: CacheHeaders): Record? {\n+    val record = selectRecordForKey(key)\n+\n+    if (record != null) {\n+      if (cacheHeaders.hasHeader(EVICT_AFTER_READ)) {\n+        deleteRecord(key)\n+      }\n+      return record\n+    }\n+    return nextCache?.loadRecord(key, cacheHeaders)\n+  }\n+\n+  override fun clearAll() {\n+    nextCache?.clearAll()\n+    cacheQueries.deleteAll()\n+  }\n+\n+  override fun remove(cacheKey: CacheKey, cascade: Boolean): Boolean {\n+    val result: Boolean = nextCache?.remove(cacheKey, cascade) ?: false\n+    if (result) {\n+      return true\n+    }\n+    return if (cascade) {\n+      selectRecordForKey(cacheKey.key)\n+          ?.referencedFields()\n+          ?.all { remove(CacheKey(it.key()), cascade = true) }\n+          ?: false\n+    } else {\n+      deleteRecord(cacheKey.key)\n+    }\n+  }\n+\n+  override fun performMerge(apolloRecord: Record, cacheHeaders: CacheHeaders): Set<String> {\n+    val oldRecord = selectRecordForKey(apolloRecord.key())\n+    return if (oldRecord == null) {\n+      cacheQueries.insert(apolloRecord.key(), recordFieldAdapter.toJson(apolloRecord.fields()))\n+      emptySet()\n+    } else {\n+      oldRecord.mergeWith(apolloRecord).also {\n+        if (it.isNotEmpty()) {\n+          cacheQueries.update(oldRecord.key(), recordFieldAdapter.toJson(oldRecord.fields()))\n+        }\n+      }\n+    }\n+  }\n+\n+  fun selectRecordForKey(key: String): Record? {\n+    return try {\n+      cacheQueries.recordForKey(key)\n+          .executeAsList()\n+          .firstOrNull()", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTE0MA=="}, "originalCommit": {"oid": "973b065a9dc625e606c7db494ab02413727e0db9"}, "originalPosition": 66}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3186, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}