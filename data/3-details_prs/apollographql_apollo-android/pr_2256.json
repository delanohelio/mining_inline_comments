{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDE1MDQ4NDc3", "number": 2256, "title": "Kotlin runtime initial structure", "bodyText": "Introduce new apollo-runtime-kotlin module with initial structure:\n\nApolloClient similar to JVM version, a facade for user interface\nRequestExecutor is a business logic layer responsible for query execution. Allows to create a chain / pipeline of several executors. Each executor observes, modifies, and potentially short-circuits GraphQL operation requests. NetworkExecutor is a final / terminal request executor in the chain, responsible for network execution via configured NetworkTransport\nNetworkTransport is an abstraction for networking. Apollo is going to provide several NetworkTransport implementations: Http(JVM/iOS) and WebSocket(JVM/iOS)\nDispatchersContext provides configuration for coroutine dispatchers, that will be put into ExecutionContext\n\nSee ApolloClientTest as an idea how everything connected.\nHere is the rough idea how normalized cache will be integrated:\n\nit's going to be completely isolated from runtime\nit will copy ApolloClient with injected executor into ApolloClient#executors to provide cache functionality via extension function fun ApolloClient.withCache(<some config>) -> ApolloClient\nit will add own execution context into Apollo#executionContext to provide default configuration such as default cache policy\nit will provide extension functions for ApolloQueryCall that will make copy of RealApolloCall with and injected request execution context (in such way we can provide request cache policy that will override default one) via fun ApolloQueryCall.cachePolicy(CachePolicy.CacheFirst) -> ApolloQueryCall\ncache executor will handle all cache logic by intercepting operation execution before NetworkExecutor\n\nPart of #2222", "createdAt": "2020-05-08T05:08:33Z", "url": "https://github.com/apollographql/apollo-android/pull/2256", "merged": true, "mergeCommit": {"oid": "8c194cd3bb3c8b5064ee3cc5bae40f2a2b358e6b"}, "closed": true, "closedAt": "2020-05-13T04:28:25Z", "author": {"login": "sav007"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcfK5atAFqTQwODAwMTY3NA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcgwy6rgH2gAyNDE1MDQ4NDc3OjA5YjlmMjYzZjY3Yjk2NGRlOGUxMDhhMjRlNzk0Y2E5OWM0NTkyYmI=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDAxNjc0", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408001674", "createdAt": "2020-05-08T05:19:29Z", "commit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNToxOToyOVrOGSZZpA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNToxOToyOVrOGSZZpA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0MzcxNg==", "bodyText": "Sample of custom user RequestExecutor", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r421943716", "createdAt": "2020-05-08T05:19:29Z", "author": {"login": "sav007"}, "path": "apollo-runtime-kotlin/src/commonTest/kotlin/com/apollographql/apollo/mock/TestLoggerExecutor.kt", "diffHunk": "@@ -0,0 +1,23 @@\n+package com.apollographql.apollo.mock\n+\n+import com.apollographql.apollo.executor.ExecutionRequest\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.executor.RequestExecutor\n+import com.apollographql.apollo.executor.RequestExecutorChain\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.catch\n+import kotlinx.coroutines.flow.onEach\n+import kotlinx.coroutines.flow.onStart\n+\n+object TestLoggerExecutor : RequestExecutor {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 12}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MDAyMjA4", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408002208", "createdAt": "2020-05-08T05:21:15Z", "commit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNToyMToxNVrOGSZbaw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQwNToyMToxNVrOGSZbaw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTk0NDE3MQ==", "bodyText": "KN doesn't provide runBlocking in common coroutines artifact, only in JVM and KN.", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r421944171", "createdAt": "2020-05-08T05:21:15Z", "author": {"login": "sav007"}, "path": "apollo-runtime-kotlin/src/commonTest/kotlin/com/apollographql/apollo/TestUtils.kt", "diffHunk": "@@ -0,0 +1,7 @@\n+package com.apollographql.apollo\n+\n+import kotlinx.coroutines.CoroutineScope\n+import kotlin.coroutines.CoroutineContext\n+import kotlin.coroutines.EmptyCoroutineContext\n+\n+expect fun <T> runBlocking(context: CoroutineContext = EmptyCoroutineContext, block: suspend CoroutineScope.() -> T): T", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4MzA4NTEz", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408308513", "createdAt": "2020-05-08T15:09:57Z", "commit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNTowOTo1N1rOGSpAFQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQxNToxMzo1NVrOGSpIag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjE5OTMxNw==", "bodyText": "silly question: Why is this a class and not a data class?", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422199317", "createdAt": "2020-05-08T15:09:57Z", "author": {"login": "designatednerd"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/network/NetworkRequest.kt", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.apollographql.apollo.network\n+\n+class NetworkRequest(\n+    val operationName: String,\n+    val document: String,\n+    val variables: String,\n+    val extensions: String = \"\"\n+)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMDc0OQ==", "bodyText": "omg i want the retryWhen API for everything I do now", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422200749", "createdAt": "2020-05-08T15:12:43Z", "author": {"login": "designatednerd"}, "path": "apollo-runtime-kotlin/src/commonTest/kotlin/com/apollographql/apollo/ApolloClientTest.kt", "diffHunk": "@@ -0,0 +1,108 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.context.DispatchersContext\n+import com.apollographql.apollo.mock.MockNetworkTransport\n+import com.apollographql.apollo.mock.MockQuery\n+import com.apollographql.apollo.mock.TestLoggerExecutor\n+import com.apollographql.apollo.network.NetworkResponse\n+import kotlinx.coroutines.Dispatchers\n+import kotlinx.coroutines.flow.retryWhen\n+import kotlinx.coroutines.flow.single\n+import okio.Buffer\n+import okio.ByteString.Companion.encodeUtf8\n+import kotlin.test.BeforeTest\n+import kotlin.test.Test\n+import kotlin.test.assertEquals\n+import kotlin.test.assertNotNull\n+import kotlin.test.assertTrue\n+\n+@Suppress(\"EXPERIMENTAL_API_USAGE\")\n+class ApolloClientTest {\n+  private lateinit var networkTransport: MockNetworkTransport\n+  private lateinit var apolloClient: ApolloClient\n+\n+  @BeforeTest\n+  fun setUp() {\n+    networkTransport = MockNetworkTransport()\n+    apolloClient = ApolloClient(\n+        networkTransport = networkTransport,\n+        executionContext = ExecutionContext.Empty + DispatchersContext(\n+            ioDispatcher = Dispatchers.Unconfined\n+        ),\n+        executors = listOf(TestLoggerExecutor)\n+    )\n+  }\n+\n+  @Test\n+  fun `when query and success network response, assert success`() {\n+    networkTransport.offer(\n+        NetworkResponse(\n+            body = Buffer().write(\"{\\\"data\\\":{\\\"name\\\":\\\"MockQuery\\\"}}\".encodeUtf8()),\n+            executionContext = ExecutionContext.Empty\n+        )\n+    )\n+\n+    val response = runBlocking {\n+      apolloClient\n+          .query(MockQuery())\n+          .execute()\n+          .single()\n+    }\n+\n+    assertNotNull(response.data)\n+    assertEquals(expected = MockQuery.Data, actual = response.data)\n+  }\n+\n+  @Test\n+  fun `when query and malformed network response, assert parse error`() {\n+    networkTransport.offer(\n+        NetworkResponse(\n+            body = Buffer(),\n+            executionContext = ExecutionContext.Empty\n+        )\n+    )\n+\n+    val result = runBlocking {\n+      kotlin.runCatching {\n+        apolloClient\n+            .query(MockQuery())\n+            .execute()\n+            .single()\n+      }\n+    }\n+\n+    assertTrue(result.isFailure)\n+    result.onFailure { e ->\n+      assertTrue(e is ApolloException)\n+      assertTrue(e.error is ApolloError.ParseError)\n+    }\n+  }\n+\n+  @Test\n+  fun `when query and malformed network response, assert success after retry`() {\n+    networkTransport.offer(\n+        NetworkResponse(\n+            body = Buffer(),\n+            executionContext = ExecutionContext.Empty\n+        )\n+    )\n+    networkTransport.offer(\n+        NetworkResponse(\n+            body = Buffer().write(\"{\\\"data\\\":{\\\"name\\\":\\\"MockQuery\\\"}}\".encodeUtf8()),\n+            executionContext = ExecutionContext.Empty\n+        )\n+    )\n+\n+    val response = runBlocking {\n+      apolloClient\n+          .query(MockQuery())\n+          .execute()\n+          .retryWhen { cause, attempt -> cause is ApolloException && attempt == 0L }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 101}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjIwMTQ1MA==", "bodyText": "Do these need tot be TODO or should they actively throw an exception?", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422201450", "createdAt": "2020-05-08T15:13:55Z", "author": {"login": "designatednerd"}, "path": "apollo-runtime-kotlin/src/commonTest/kotlin/com/apollographql/apollo/mock/MockQuery.kt", "diffHunk": "@@ -0,0 +1,76 @@\n+package com.apollographql.apollo.mock\n+\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.OperationName\n+import com.apollographql.apollo.api.Query\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.api.internal.ResponseFieldMapper\n+import com.apollographql.apollo.api.internal.ResponseFieldMarshaller\n+import okio.BufferedSource\n+import okio.ByteString\n+\n+internal class MockQuery : Query<MockQuery.Data, MockQuery.Data, Operation.Variables> {\n+\n+  override fun composeRequestBody(\n+      autoPersistQueries: Boolean,\n+      withQueryDocument: Boolean,\n+      scalarTypeAdapters: ScalarTypeAdapters\n+  ): ByteString {\n+    return ByteString.of()\n+  }\n+\n+  override fun queryDocument(): String = \"query MockQuery { name }\"\n+\n+  override fun variables(): Operation.Variables = Operation.EMPTY_VARIABLES\n+\n+  override fun responseFieldMapper(): ResponseFieldMapper<Data> = ResponseFieldMapper.invoke {\n+    Data\n+  }\n+\n+  override fun wrapData(data: Data?): Data? = data\n+\n+  override fun name(): OperationName = object : OperationName {\n+    override fun name(): String = \"MockQuery\"\n+  }\n+\n+  override fun operationId(): String = \"operationId\"\n+\n+  override fun parse(source: BufferedSource, scalarTypeAdapters: ScalarTypeAdapters): Response<Data> {\n+    require(source.readUtf8() == \"{\\\"data\\\":{\\\"name\\\":\\\"MockQuery\\\"}}\")\n+    return Response(\n+        operation = this,\n+        data = Data\n+    )\n+  }\n+\n+  override fun parse(byteString: ByteString, scalarTypeAdapters: ScalarTypeAdapters): Response<Data> {\n+    require(byteString.toString() == \"{\\\"data\\\":{\\\"name\\\":\\\"MockQuery\\\"}}\")\n+    return Response(\n+        operation = this,\n+        data = Data\n+    )\n+  }\n+\n+  override fun parse(source: BufferedSource): Response<Data> {\n+    return parse(source, ScalarTypeAdapters.DEFAULT)\n+  }\n+\n+  override fun parse(byteString: ByteString): Response<Data> {\n+    return parse(byteString, ScalarTypeAdapters.DEFAULT)\n+  }\n+\n+  override fun composeRequestBody(scalarTypeAdapters: ScalarTypeAdapters): ByteString {\n+    TODO(\"Unsupported\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 64}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTgxMjUy", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408581252", "createdAt": "2020-05-08T23:43:52Z", "commit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo0Mzo1MlrOGS2jTg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo0Mzo1MlrOGS2jTg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMTMyNg==", "bodyText": "why not use the interceptors wording here instead ? Executors always remind me of https://docs.oracle.com/javase/7/docs/api/java/util/concurrent/Executor.html but maybe I've done too much java.", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422421326", "createdAt": "2020-05-08T23:43:52Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/ApolloClient.kt", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.Mutation\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Query\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.executor.NetworkExecutor\n+import com.apollographql.apollo.executor.RequestExecutor\n+import com.apollographql.apollo.internal.RealApolloCall\n+import com.apollographql.apollo.network.NetworkTransport\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+class ApolloClient constructor(\n+    private val networkTransport: NetworkTransport,\n+    private val scalarTypeAdapters: ScalarTypeAdapters = ScalarTypeAdapters.DEFAULT,\n+    private val executors: List<RequestExecutor> = emptyList(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTgyMDYw", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408582060", "createdAt": "2020-05-08T23:48:00Z", "commit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo0ODowMFrOGS2mbw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo0ODowMFrOGS2mbw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMjEyNw==", "bodyText": "I guess operationId will need to be in there as well ?", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422422127", "createdAt": "2020-05-08T23:48:00Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/network/NetworkRequest.kt", "diffHunk": "@@ -0,0 +1,8 @@\n+package com.apollographql.apollo.network\n+\n+class NetworkRequest(\n+    val operationName: String,\n+    val document: String,\n+    val variables: String,\n+    val extensions: String = \"\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 7}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTgyOTU1", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408582955", "createdAt": "2020-05-08T23:52:39Z", "commit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo1MjozOVrOGS2psQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOFQyMzo1MjozOVrOGS2psQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyMjk2MQ==", "bodyText": "Why not just:\nreturn RealRequestExecutorChain(executors).proceed(request = request)\n\n?", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422422961", "createdAt": "2020-05-08T23:52:39Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/internal/RealApolloCall.kt", "diffHunk": "@@ -0,0 +1,39 @@\n+package com.apollographql.apollo.internal\n+\n+import com.apollographql.apollo.ApolloMutationCall\n+import com.apollographql.apollo.ApolloQueryCall\n+import com.apollographql.apollo.executor.ExecutionRequest\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.executor.RealRequestExecutorChain\n+import com.apollographql.apollo.executor.RequestExecutor\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.flatMapLatest\n+import kotlinx.coroutines.flow.flow\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+class RealApolloCall<T> constructor(\n+    private val operation: Operation<*, T, *>,\n+    private val scalarTypeAdapters: ScalarTypeAdapters,\n+    private val executors: List<RequestExecutor>,\n+    private val executionContext: ExecutionContext\n+) : ApolloQueryCall<T>, ApolloMutationCall<T> {\n+\n+  override fun execute(): Flow<Response<T>> {\n+    val request = ExecutionRequest(\n+        operation = operation,\n+        scalarTypeAdapters = scalarTypeAdapters,\n+        executionContext = executionContext\n+    )\n+    return flow {\n+      emit(RealRequestExecutorChain(executors))\n+    }.flatMapLatest { executorChain ->\n+      executorChain.proceed(request)\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 37}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4NTg3Nzc5", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408587779", "createdAt": "2020-05-09T00:15:13Z", "commit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNToxM1rOGS263Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wOVQwMDoxNToxM1rOGS263Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjQyNzM1Nw==", "bodyText": "Do we need the dispatcher to be configurable per-request ? I was thinking this could be a property of the NetworkTransport instead ?", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422427357", "createdAt": "2020-05-09T00:15:13Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/executor/NetworkExecutor.kt", "diffHunk": "@@ -0,0 +1,90 @@\n+package com.apollographql.apollo.executor\n+\n+import com.apollographql.apollo.ApolloError\n+import com.apollographql.apollo.ApolloException\n+import com.apollographql.apollo.context.DispatchersContext\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.network.NetworkRequest\n+import com.apollographql.apollo.network.NetworkResponse\n+import com.apollographql.apollo.network.NetworkTransport\n+import kotlinx.coroutines.CoroutineDispatcher\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.catch\n+import kotlinx.coroutines.flow.flatMapLatest\n+import kotlinx.coroutines.flow.flow\n+import kotlinx.coroutines.flow.flowOn\n+import kotlinx.coroutines.flow.map\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+class NetworkExecutor(\n+    private val networkTransport: NetworkTransport\n+) : RequestExecutor {\n+\n+  override fun <T> execute(request: ExecutionRequest<T>, executorChain: RequestExecutorChain): Flow<Response<T>> {\n+    return flow { emit(request.toNetworkRequest()) }\n+        .flatMapLatest { networkRequest -> networkRequest.execute(request.executionContext) }\n+        .map { networkResponse -> networkResponse.parse(request) }\n+        .flowOn(request.executionContext.ioDispatcher)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "074d7bf0f7af26324761b168ccf662710a21f982"}, "originalPosition": 31}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "80f75f15bdc97955cb42bf27b6b9135a3680e376", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/80f75f15bdc97955cb42bf27b6b9135a3680e376", "committedDate": "2020-05-10T19:38:26Z", "message": "Network layer + update sample"}, "afterCommit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/4e531a18ada0b09161aea833468ad5d989185142", "committedDate": "2020-05-10T19:42:45Z", "message": "Network layer + update sample"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4Nzc1NTg0", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408775584", "createdAt": "2020-05-10T19:43:46Z", "commit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxOTo0Mzo0NlrOGTG-vQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQxOTo0Mzo0NlrOGTG-vQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjY5MDQ5Mw==", "bodyText": "will be rebased after merge this PR: #2258", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422690493", "createdAt": "2020-05-10T19:43:46Z", "author": {"login": "sav007"}, "path": "apollo-api/src/commonMain/kotlin/com/apollographql/apollo/api/ExecutionContext.kt", "diffHunk": "@@ -8,46 +8,110 @@ import kotlin.jvm.JvmField\n  * A context of GraphQL operation execution, represented as a set of [Key] keys and corresponding [Element] values.\n  */\n @ApolloExperimental\n-class ExecutionContext private constructor(private val context: Map<Key<*>, Element>) {\n+interface ExecutionContext {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4Nzg1Mzc0", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408785374", "createdAt": "2020-05-10T21:56:27Z", "commit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMTo1NjoyN1rOGTH6xw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMTo1NjoyN1rOGTH6xw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwNTg2Mw==", "bodyText": "Some users might not want to enable ExperimentalCoroutinesApi in their repo. As long as it's only for multiplatform I guess it's fine but the day apollo-runtime-kotlin becomes the default JVM implementation, it might be an issue (if the api hasn't been promoted to stable before that)", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422705863", "createdAt": "2020-05-10T21:56:27Z", "author": {"login": "martinbonnin"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/ApolloClient.kt", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.Mutation\n+import com.apollographql.apollo.api.Operation\n+import com.apollographql.apollo.api.Query\n+import com.apollographql.apollo.api.ScalarTypeAdapters\n+import com.apollographql.apollo.executor.NetworkExecutor\n+import com.apollographql.apollo.executor.RequestExecutor\n+import com.apollographql.apollo.internal.RealApolloCall\n+import com.apollographql.apollo.network.NetworkTransport\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142"}, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4Nzg3NjQ2", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408787646", "createdAt": "2020-05-10T22:30:22Z", "commit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMjozMDoyMlrOGTIJGQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMjozMDoyMlrOGTIJGQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwOTUyOQ==", "bodyText": "A common use case is to have an interceptor that can refresh the token. Should we add a concept of interceptors there as well ?", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422709529", "createdAt": "2020-05-10T22:30:22Z", "author": {"login": "martinbonnin"}, "path": "samples/multiplatform/kmp-lib-sample/src/commonMain/kotlin/com/apollographql/apollo/kmpsample/data/ApolloCoroutinesRepository.kt", "diffHunk": "@@ -1,26 +1,39 @@\n package com.apollographql.apollo.kmpsample.data\n \n-import com.apollographql.apollo.kmpsample.fragment.RepositoryFragment\n+import com.apollographql.apollo.ApolloClient\n import com.apollographql.apollo.kmpsample.GithubRepositoriesQuery\n import com.apollographql.apollo.kmpsample.GithubRepositoryCommitsQuery\n import com.apollographql.apollo.kmpsample.GithubRepositoryDetailQuery\n import com.apollographql.apollo.kmpsample.fragment.RepositoryDetail\n+import com.apollographql.apollo.kmpsample.fragment.RepositoryFragment\n import com.apollographql.apollo.kmpsample.type.OrderDirection\n import com.apollographql.apollo.kmpsample.type.PullRequestState\n import com.apollographql.apollo.kmpsample.type.RepositoryOrderField\n+import com.apollographql.apollo.network.ApolloHttpNetworkTransport\n+import kotlinx.coroutines.flow.single\n \n /**\n  * An implementation of a [GitHubDataSource] that shows how we can use coroutines to make our apollo requests.\n  */\n-class ApolloCoroutinesRepository(private val service: ApolloCoroutinesService) {\n+class ApolloCoroutinesRepository {\n+  private val apolloClient = ApolloClient(\n+      networkTransport = ApolloHttpNetworkTransport(\n+          serverUrl = \"https://api.github.com/graphql\",\n+          httpHeaders = mapOf(\n+              \"Accept\" to \"application/json\",\n+              \"Content-Type\" to \"application/json\",\n+              \"Authorization\" to \"bearer $GITHUB_KEY\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA4Nzg3Njky", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-408787692", "createdAt": "2020-05-10T22:30:53Z", "commit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMjozMDo1M1rOGTIJVQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMFQyMjozMDo1M1rOGTIJVQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMjcwOTU4OQ==", "bodyText": "\ud83d\ude0e", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r422709589", "createdAt": "2020-05-10T22:30:53Z", "author": {"login": "martinbonnin"}, "path": "samples/multiplatform/kmp-lib-sample/src/iosMain/kotlin/com/apollographql/apollo/kmpsample/data/ApolloNetworkClient.kt", "diffHunk": "@@ -1,138 +0,0 @@\n-package com.apollographql.apollo.kmpsample.data\n-\n-import com.apollographql.apollo.api.Operation\n-import com.apollographql.apollo.api.Response\n-import kotlinx.cinterop.COpaquePointer\n-import kotlinx.cinterop.StableRef\n-import kotlinx.cinterop.addressOf\n-import kotlinx.cinterop.asStableRef\n-import kotlinx.cinterop.convert\n-import kotlinx.cinterop.staticCFunction\n-import kotlinx.cinterop.usePinned\n-import kotlinx.coroutines.CancellableContinuation\n-import kotlinx.coroutines.suspendCancellableCoroutine\n-import okio.IOException\n-import okio.toByteString\n-import platform.Foundation.NSData\n-import platform.Foundation.NSError\n-import platform.Foundation.NSHTTPURLResponse\n-import platform.Foundation.NSMutableData\n-import platform.Foundation.NSMutableURLRequest\n-import platform.Foundation.NSThread\n-import platform.Foundation.NSURL\n-import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n-import platform.Foundation.NSURLResponse\n-import platform.Foundation.NSURLSession\n-import platform.Foundation.NSURLSessionConfiguration\n-import platform.Foundation.appendBytes\n-import platform.Foundation.dataTaskWithRequest\n-import platform.Foundation.setHTTPBody\n-import platform.Foundation.setHTTPMethod\n-import platform.Foundation.setValue\n-import platform.darwin.dispatch_async_f\n-import platform.darwin.dispatch_get_main_queue\n-import kotlin.coroutines.resume\n-import kotlin.coroutines.resumeWithException\n-import kotlin.native.concurrent.freeze\n-\n-internal class ApolloNetworkClient(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142"}, "originalPosition": 38}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4e531a18ada0b09161aea833468ad5d989185142", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/4e531a18ada0b09161aea833468ad5d989185142", "committedDate": "2020-05-10T19:42:45Z", "message": "Network layer + update sample"}, "afterCommit": {"oid": "a4533ed25b147c22e17218d2899dff4866d98bcd", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/a4533ed25b147c22e17218d2899dff4866d98bcd", "committedDate": "2020-05-11T00:57:13Z", "message": "Network layer + update sample"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "3972ff739de1933abb97d29d717d567fb7a0c542", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/3972ff739de1933abb97d29d717d567fb7a0c542", "committedDate": "2020-05-11T22:08:55Z", "message": "Introduce GraphQL execution context\n\nProvide type safe container to customize and extend `Response` with additional context, such as providing access to raw OkHttp response.\n\nCloses https://github.com/apollographql/apollo-android/issues/2205"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "ae27b274382b33ddfe967f6f0ad6230c62217865", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/ae27b274382b33ddfe967f6f0ad6230c62217865", "committedDate": "2020-05-11T22:08:55Z", "message": "Feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f74bbcf35c52a74dea04b257b76e3a3a9e6d9eb0", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/f74bbcf35c52a74dea04b257b76e3a3a9e6d9eb0", "committedDate": "2020-05-11T22:08:55Z", "message": "Kotlin runtime initial structure\n\nIntroduce new `apollo-runtime-kotlin` module with initial structure:\n- `ApolloClient` similar to JVM version, a facade for user interface\n- `RequestExecutor` is a business logic layer responsible for query execution. Allows to create a chain / pipeline of several executors. Each executor observes, modifies, and potentially short-circuits GraphQL operation requests. `NetworkExecutor` is a final / terminal request executor in the chain, responsible for network execution via configured `NetworkTransport`\n- `NetworkTransport` is an abstraction for networking. Apollo is going to provide several `NetworkTransport` implementations: Http(JVM/iOS) and WebSocket(JVM/iOS)\n- `DispatchersContext` provides configuration for coroutine dispatchers, that will be put into `ExecutionContext`\n\nPart of https://github.com/apollographql/apollo-android/issues/2222"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "4793711acfac8aba6e6e6fe43fc697d9f139293f", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/4793711acfac8aba6e6e6fe43fc697d9f139293f", "committedDate": "2020-05-11T22:08:55Z", "message": "Network layer + update sample"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4533ed25b147c22e17218d2899dff4866d98bcd", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/a4533ed25b147c22e17218d2899dff4866d98bcd", "committedDate": "2020-05-11T00:57:13Z", "message": "Network layer + update sample"}, "afterCommit": {"oid": "4793711acfac8aba6e6e6fe43fc697d9f139293f", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/4793711acfac8aba6e6e6fe43fc697d9f139293f", "committedDate": "2020-05-11T22:08:55Z", "message": "Network layer + update sample"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/f1fac05dae8a5a2e02c12669c5a65bc743d44fa4", "committedDate": "2020-05-12T00:44:42Z", "message": "Address feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA5NjY2NTkz", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-409666593", "createdAt": "2020-05-12T03:03:10Z", "commit": {"oid": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMzowMzoxMFrOGT0YwA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0xMlQwMzoyNToyMFrOGT0tYQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzNDQzMg==", "bodyText": "I have two somewhat contradictory questions:\n\nWhy are we using multiple interfaces here if they're not adding any functionality?\nWhy isn't there an ApolloSubscriptionCall<T>?", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423434432", "createdAt": "2020-05-12T03:03:10Z", "author": {"login": "designatednerd"}, "path": "apollo-runtime-kotlin/src/commonMain/kotlin/com/apollographql/apollo/ApolloCall.kt", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.api.Response\n+import kotlinx.coroutines.flow.Flow\n+\n+interface ApolloCall<T> {\n+  fun execute(): Flow<Response<T>>\n+}\n+\n+interface ApolloQueryCall<T> : ApolloCall<T>\n+\n+interface ApolloMutationCall<T> : ApolloCall<T>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzODY1MQ==", "bodyText": "is it such a rare occurrence that ref would be null that the force-unwrap is appropriate here?", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423438651", "createdAt": "2020-05-12T03:20:36Z", "author": {"login": "designatednerd"}, "path": "apollo-runtime-kotlin/src/iosMain/kotlin/com/apollographql/apollo/network/ApolloHttpNetworkTransport.kt", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.apollographql.apollo.network\n+\n+import com.apollographql.apollo.ApolloError\n+import com.apollographql.apollo.ApolloException\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import kotlinx.cinterop.COpaquePointer\n+import kotlinx.cinterop.StableRef\n+import kotlinx.cinterop.addressOf\n+import kotlinx.cinterop.asStableRef\n+import kotlinx.cinterop.convert\n+import kotlinx.cinterop.staticCFunction\n+import kotlinx.cinterop.usePinned\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.channels.ProducerScope\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import okio.Buffer\n+import okio.IOException\n+import okio.toByteString\n+import platform.Foundation.NSData\n+import platform.Foundation.NSError\n+import platform.Foundation.NSHTTPURLResponse\n+import platform.Foundation.NSMutableData\n+import platform.Foundation.NSMutableURLRequest\n+import platform.Foundation.NSThread\n+import platform.Foundation.NSURL\n+import platform.Foundation.NSURLComponents\n+import platform.Foundation.NSURLQueryItem\n+import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n+import platform.Foundation.NSURLResponse\n+import platform.Foundation.NSURLSession\n+import platform.Foundation.NSURLSessionConfiguration\n+import platform.Foundation.appendBytes\n+import platform.Foundation.dataTaskWithRequest\n+import platform.Foundation.setHTTPBody\n+import platform.Foundation.setHTTPMethod\n+import platform.Foundation.setValue\n+import platform.darwin.dispatch_async_f\n+import platform.darwin.dispatch_get_main_queue\n+import kotlin.native.concurrent.freeze\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+actual class ApolloHttpNetworkTransport(\n+    private val serverUrl: NSURL,\n+    private val httpHeaders: Map<String, String>,\n+    private val httpMethod: HttpMethod,\n+    private val urlSession: NSURLSession\n+) : NetworkTransport {\n+\n+  actual constructor(\n+      serverUrl: String,\n+      httpHeaders: Map<String, String>,\n+      httpMethod: HttpMethod\n+  ) : this(\n+      serverUrl = NSURL(string = serverUrl),\n+      httpHeaders = httpHeaders,\n+      httpMethod = httpMethod,\n+      urlSession = NSURLSession.sessionWithConfiguration(NSURLSessionConfiguration.defaultSessionConfiguration())\n+  )\n+\n+  override fun execute(request: GraphQLRequest): Flow<GraphQLResponse> {\n+    return callbackFlow {\n+      assert(NSThread.isMainThread())\n+\n+      val producerRef = StableRef.create(this).asCPointer()\n+      val delegate = { httpData: NSData?, httpResponse: NSURLResponse?, error: NSError? ->\n+        initRuntimeIfNeeded()\n+        val response = parse(\n+            data = httpData,\n+            httpResponse = httpResponse as NSHTTPURLResponse,\n+            error = error\n+        )\n+        response.dispatchOnMain(producerRef)\n+      }\n+      val httpRequest = request.toHttpRequest()\n+      val task = urlSession.dataTaskWithRequest(httpRequest.freeze(), delegate.freeze()).apply {\n+        resume()\n+      }\n+      awaitClose {\n+        task.cancel()\n+      }\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpRequest(): NSMutableURLRequest {\n+    return when (httpMethod) {\n+      HttpMethod.Get -> toHttpGetRequest()\n+      HttpMethod.Post -> toHttpPostRequest()\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpGetRequest(): NSMutableURLRequest {\n+    val urlComponents = NSURLComponents(uRL = serverUrl, resolvingAgainstBaseURL = false)\n+    urlComponents.queryItems = listOfNotNull(\n+        NSURLQueryItem(name = \"query\", value = document),\n+        NSURLQueryItem(name = \"operationName\", value = operationName),\n+        if (variables.isNotEmpty()) NSURLQueryItem(name = \"variables\", value = variables) else null\n+    )\n+    return NSMutableURLRequest.requestWithURL(urlComponents.URL!!).apply {\n+      setHTTPMethod(\"GET\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpPostRequest(): NSMutableURLRequest {\n+    return NSMutableURLRequest.requestWithURL(serverUrl).apply {\n+      val buffer = Buffer()\n+      JsonWriter.of(buffer)\n+          .beginObject()\n+          .name(\"operationName\").value(operationName)\n+          .name(\"query\").value(document)\n+          .name(\"variables\").value(variables)\n+          .endObject()\n+          .close()\n+      val postBody = buffer.readByteArray().toNSData()\n+\n+      setHTTPMethod(\"POST\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+      setHTTPBody(postBody)\n+    }\n+  }\n+\n+  private fun parse(\n+      data: NSData?,\n+      httpResponse: NSHTTPURLResponse,\n+      error: NSError?\n+  ): Result {\n+    if (error != null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to execute GraphQL http network request\",\n+            error = ApolloError.Network,\n+            cause = IOException(error.localizedDescription)\n+        )\n+    )\n+\n+    val statusCode = httpResponse.statusCode.toInt()\n+    if (statusCode !in 200..299) return Result.Failure(\n+        ApolloException(\n+            message = \"Http request failed with status code `$statusCode`\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    if (data == null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to parse GraphQL http network response: EOF\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    return Result.Success(data)\n+  }\n+\n+  sealed class Result {\n+    class Success(val data: NSData) : Result()\n+    class Failure(val cause: ApolloException) : Result()\n+  }\n+\n+  private fun ByteArray.toNSData(): NSData = NSMutableData().apply {\n+    if (isEmpty()) return@apply\n+    this@toNSData.usePinned {\n+      appendBytes(it.addressOf(0), size.convert())\n+    }\n+  }\n+\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun Result.dispatchOnMain(producerRef: COpaquePointer) {\n+    val producerWithResultRef = StableRef.create((producerRef to this).freeze())\n+    dispatch_async_f(\n+        queue = dispatch_get_main_queue(),\n+        context = producerWithResultRef.asCPointer(),\n+        work = staticCFunction { ref ->\n+          val producerWithResultRef = ref!!.asStableRef<Pair<COpaquePointer, Result>>()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4"}, "originalPosition": 180}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTMzNQ==", "bodyText": "context and queue here are properties of NetworkTransport, right? I think you're OK in terms of automatic reference counting here, but it might be worth doing some profiling to make sure you're not creating retain cycles.", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423439335", "createdAt": "2020-05-12T03:23:44Z", "author": {"login": "designatednerd"}, "path": "apollo-runtime-kotlin/src/iosMain/kotlin/com/apollographql/apollo/network/ApolloHttpNetworkTransport.kt", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.apollographql.apollo.network\n+\n+import com.apollographql.apollo.ApolloError\n+import com.apollographql.apollo.ApolloException\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import kotlinx.cinterop.COpaquePointer\n+import kotlinx.cinterop.StableRef\n+import kotlinx.cinterop.addressOf\n+import kotlinx.cinterop.asStableRef\n+import kotlinx.cinterop.convert\n+import kotlinx.cinterop.staticCFunction\n+import kotlinx.cinterop.usePinned\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.channels.ProducerScope\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import okio.Buffer\n+import okio.IOException\n+import okio.toByteString\n+import platform.Foundation.NSData\n+import platform.Foundation.NSError\n+import platform.Foundation.NSHTTPURLResponse\n+import platform.Foundation.NSMutableData\n+import platform.Foundation.NSMutableURLRequest\n+import platform.Foundation.NSThread\n+import platform.Foundation.NSURL\n+import platform.Foundation.NSURLComponents\n+import platform.Foundation.NSURLQueryItem\n+import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n+import platform.Foundation.NSURLResponse\n+import platform.Foundation.NSURLSession\n+import platform.Foundation.NSURLSessionConfiguration\n+import platform.Foundation.appendBytes\n+import platform.Foundation.dataTaskWithRequest\n+import platform.Foundation.setHTTPBody\n+import platform.Foundation.setHTTPMethod\n+import platform.Foundation.setValue\n+import platform.darwin.dispatch_async_f\n+import platform.darwin.dispatch_get_main_queue\n+import kotlin.native.concurrent.freeze\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+actual class ApolloHttpNetworkTransport(\n+    private val serverUrl: NSURL,\n+    private val httpHeaders: Map<String, String>,\n+    private val httpMethod: HttpMethod,\n+    private val urlSession: NSURLSession\n+) : NetworkTransport {\n+\n+  actual constructor(\n+      serverUrl: String,\n+      httpHeaders: Map<String, String>,\n+      httpMethod: HttpMethod\n+  ) : this(\n+      serverUrl = NSURL(string = serverUrl),\n+      httpHeaders = httpHeaders,\n+      httpMethod = httpMethod,\n+      urlSession = NSURLSession.sessionWithConfiguration(NSURLSessionConfiguration.defaultSessionConfiguration())\n+  )\n+\n+  override fun execute(request: GraphQLRequest): Flow<GraphQLResponse> {\n+    return callbackFlow {\n+      assert(NSThread.isMainThread())\n+\n+      val producerRef = StableRef.create(this).asCPointer()\n+      val delegate = { httpData: NSData?, httpResponse: NSURLResponse?, error: NSError? ->\n+        initRuntimeIfNeeded()\n+        val response = parse(\n+            data = httpData,\n+            httpResponse = httpResponse as NSHTTPURLResponse,\n+            error = error\n+        )\n+        response.dispatchOnMain(producerRef)\n+      }\n+      val httpRequest = request.toHttpRequest()\n+      val task = urlSession.dataTaskWithRequest(httpRequest.freeze(), delegate.freeze()).apply {\n+        resume()\n+      }\n+      awaitClose {\n+        task.cancel()\n+      }\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpRequest(): NSMutableURLRequest {\n+    return when (httpMethod) {\n+      HttpMethod.Get -> toHttpGetRequest()\n+      HttpMethod.Post -> toHttpPostRequest()\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpGetRequest(): NSMutableURLRequest {\n+    val urlComponents = NSURLComponents(uRL = serverUrl, resolvingAgainstBaseURL = false)\n+    urlComponents.queryItems = listOfNotNull(\n+        NSURLQueryItem(name = \"query\", value = document),\n+        NSURLQueryItem(name = \"operationName\", value = operationName),\n+        if (variables.isNotEmpty()) NSURLQueryItem(name = \"variables\", value = variables) else null\n+    )\n+    return NSMutableURLRequest.requestWithURL(urlComponents.URL!!).apply {\n+      setHTTPMethod(\"GET\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpPostRequest(): NSMutableURLRequest {\n+    return NSMutableURLRequest.requestWithURL(serverUrl).apply {\n+      val buffer = Buffer()\n+      JsonWriter.of(buffer)\n+          .beginObject()\n+          .name(\"operationName\").value(operationName)\n+          .name(\"query\").value(document)\n+          .name(\"variables\").value(variables)\n+          .endObject()\n+          .close()\n+      val postBody = buffer.readByteArray().toNSData()\n+\n+      setHTTPMethod(\"POST\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+      setHTTPBody(postBody)\n+    }\n+  }\n+\n+  private fun parse(\n+      data: NSData?,\n+      httpResponse: NSHTTPURLResponse,\n+      error: NSError?\n+  ): Result {\n+    if (error != null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to execute GraphQL http network request\",\n+            error = ApolloError.Network,\n+            cause = IOException(error.localizedDescription)\n+        )\n+    )\n+\n+    val statusCode = httpResponse.statusCode.toInt()\n+    if (statusCode !in 200..299) return Result.Failure(\n+        ApolloException(\n+            message = \"Http request failed with status code `$statusCode`\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    if (data == null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to parse GraphQL http network response: EOF\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    return Result.Success(data)\n+  }\n+\n+  sealed class Result {\n+    class Success(val data: NSData) : Result()\n+    class Failure(val cause: ApolloException) : Result()\n+  }\n+\n+  private fun ByteArray.toNSData(): NSData = NSMutableData().apply {\n+    if (isEmpty()) return@apply\n+    this@toNSData.usePinned {\n+      appendBytes(it.addressOf(0), size.convert())\n+    }\n+  }\n+\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun Result.dispatchOnMain(producerRef: COpaquePointer) {\n+    val producerWithResultRef = StableRef.create((producerRef to this).freeze())\n+    dispatch_async_f(\n+        queue = dispatch_get_main_queue(),\n+        context = producerWithResultRef.asCPointer(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4"}, "originalPosition": 178}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMzQzOTcxMw==", "bodyText": "Again if producer is a property of NetworkTransport, it's worth looking into what happens if the instance gets deallocated before this gets called. This is where you see [weak self] sprinkled liberally around Swift code, I'm not entirely sure what the equivalent is with coroutines and flows.", "url": "https://github.com/apollographql/apollo-android/pull/2256#discussion_r423439713", "createdAt": "2020-05-12T03:25:20Z", "author": {"login": "designatednerd"}, "path": "apollo-runtime-kotlin/src/iosMain/kotlin/com/apollographql/apollo/network/ApolloHttpNetworkTransport.kt", "diffHunk": "@@ -0,0 +1,208 @@\n+package com.apollographql.apollo.network\n+\n+import com.apollographql.apollo.ApolloError\n+import com.apollographql.apollo.ApolloException\n+import com.apollographql.apollo.api.ApolloExperimental\n+import com.apollographql.apollo.api.ExecutionContext\n+import com.apollographql.apollo.api.internal.json.JsonWriter\n+import kotlinx.cinterop.COpaquePointer\n+import kotlinx.cinterop.StableRef\n+import kotlinx.cinterop.addressOf\n+import kotlinx.cinterop.asStableRef\n+import kotlinx.cinterop.convert\n+import kotlinx.cinterop.staticCFunction\n+import kotlinx.cinterop.usePinned\n+import kotlinx.coroutines.ExperimentalCoroutinesApi\n+import kotlinx.coroutines.cancel\n+import kotlinx.coroutines.channels.ProducerScope\n+import kotlinx.coroutines.channels.awaitClose\n+import kotlinx.coroutines.flow.Flow\n+import kotlinx.coroutines.flow.callbackFlow\n+import okio.Buffer\n+import okio.IOException\n+import okio.toByteString\n+import platform.Foundation.NSData\n+import platform.Foundation.NSError\n+import platform.Foundation.NSHTTPURLResponse\n+import platform.Foundation.NSMutableData\n+import platform.Foundation.NSMutableURLRequest\n+import platform.Foundation.NSThread\n+import platform.Foundation.NSURL\n+import platform.Foundation.NSURLComponents\n+import platform.Foundation.NSURLQueryItem\n+import platform.Foundation.NSURLRequestReloadIgnoringCacheData\n+import platform.Foundation.NSURLResponse\n+import platform.Foundation.NSURLSession\n+import platform.Foundation.NSURLSessionConfiguration\n+import platform.Foundation.appendBytes\n+import platform.Foundation.dataTaskWithRequest\n+import platform.Foundation.setHTTPBody\n+import platform.Foundation.setHTTPMethod\n+import platform.Foundation.setValue\n+import platform.darwin.dispatch_async_f\n+import platform.darwin.dispatch_get_main_queue\n+import kotlin.native.concurrent.freeze\n+\n+@ApolloExperimental\n+@ExperimentalCoroutinesApi\n+actual class ApolloHttpNetworkTransport(\n+    private val serverUrl: NSURL,\n+    private val httpHeaders: Map<String, String>,\n+    private val httpMethod: HttpMethod,\n+    private val urlSession: NSURLSession\n+) : NetworkTransport {\n+\n+  actual constructor(\n+      serverUrl: String,\n+      httpHeaders: Map<String, String>,\n+      httpMethod: HttpMethod\n+  ) : this(\n+      serverUrl = NSURL(string = serverUrl),\n+      httpHeaders = httpHeaders,\n+      httpMethod = httpMethod,\n+      urlSession = NSURLSession.sessionWithConfiguration(NSURLSessionConfiguration.defaultSessionConfiguration())\n+  )\n+\n+  override fun execute(request: GraphQLRequest): Flow<GraphQLResponse> {\n+    return callbackFlow {\n+      assert(NSThread.isMainThread())\n+\n+      val producerRef = StableRef.create(this).asCPointer()\n+      val delegate = { httpData: NSData?, httpResponse: NSURLResponse?, error: NSError? ->\n+        initRuntimeIfNeeded()\n+        val response = parse(\n+            data = httpData,\n+            httpResponse = httpResponse as NSHTTPURLResponse,\n+            error = error\n+        )\n+        response.dispatchOnMain(producerRef)\n+      }\n+      val httpRequest = request.toHttpRequest()\n+      val task = urlSession.dataTaskWithRequest(httpRequest.freeze(), delegate.freeze()).apply {\n+        resume()\n+      }\n+      awaitClose {\n+        task.cancel()\n+      }\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpRequest(): NSMutableURLRequest {\n+    return when (httpMethod) {\n+      HttpMethod.Get -> toHttpGetRequest()\n+      HttpMethod.Post -> toHttpPostRequest()\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpGetRequest(): NSMutableURLRequest {\n+    val urlComponents = NSURLComponents(uRL = serverUrl, resolvingAgainstBaseURL = false)\n+    urlComponents.queryItems = listOfNotNull(\n+        NSURLQueryItem(name = \"query\", value = document),\n+        NSURLQueryItem(name = \"operationName\", value = operationName),\n+        if (variables.isNotEmpty()) NSURLQueryItem(name = \"variables\", value = variables) else null\n+    )\n+    return NSMutableURLRequest.requestWithURL(urlComponents.URL!!).apply {\n+      setHTTPMethod(\"GET\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+    }\n+  }\n+\n+  private fun GraphQLRequest.toHttpPostRequest(): NSMutableURLRequest {\n+    return NSMutableURLRequest.requestWithURL(serverUrl).apply {\n+      val buffer = Buffer()\n+      JsonWriter.of(buffer)\n+          .beginObject()\n+          .name(\"operationName\").value(operationName)\n+          .name(\"query\").value(document)\n+          .name(\"variables\").value(variables)\n+          .endObject()\n+          .close()\n+      val postBody = buffer.readByteArray().toNSData()\n+\n+      setHTTPMethod(\"POST\")\n+      httpHeaders.forEach { (key, value) -> setValue(value, forHTTPHeaderField = key) }\n+      setCachePolicy(NSURLRequestReloadIgnoringCacheData)\n+      setHTTPBody(postBody)\n+    }\n+  }\n+\n+  private fun parse(\n+      data: NSData?,\n+      httpResponse: NSHTTPURLResponse,\n+      error: NSError?\n+  ): Result {\n+    if (error != null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to execute GraphQL http network request\",\n+            error = ApolloError.Network,\n+            cause = IOException(error.localizedDescription)\n+        )\n+    )\n+\n+    val statusCode = httpResponse.statusCode.toInt()\n+    if (statusCode !in 200..299) return Result.Failure(\n+        ApolloException(\n+            message = \"Http request failed with status code `$statusCode`\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    if (data == null) return Result.Failure(\n+        ApolloException(\n+            message = \"Failed to parse GraphQL http network response: EOF\",\n+            error = ApolloError.Network\n+        )\n+    )\n+\n+    return Result.Success(data)\n+  }\n+\n+  sealed class Result {\n+    class Success(val data: NSData) : Result()\n+    class Failure(val cause: ApolloException) : Result()\n+  }\n+\n+  private fun ByteArray.toNSData(): NSData = NSMutableData().apply {\n+    if (isEmpty()) return@apply\n+    this@toNSData.usePinned {\n+      appendBytes(it.addressOf(0), size.convert())\n+    }\n+  }\n+\n+  @Suppress(\"NAME_SHADOWING\")\n+  private fun Result.dispatchOnMain(producerRef: COpaquePointer) {\n+    val producerWithResultRef = StableRef.create((producerRef to this).freeze())\n+    dispatch_async_f(\n+        queue = dispatch_get_main_queue(),\n+        context = producerWithResultRef.asCPointer(),\n+        work = staticCFunction { ref ->\n+          val producerWithResultRef = ref!!.asStableRef<Pair<COpaquePointer, Result>>()\n+          val (producerPointer, result) = producerWithResultRef.get()\n+          producerWithResultRef.dispose()\n+\n+          val producerRef = producerPointer.asStableRef<ProducerScope<GraphQLResponse>>()\n+          val producer = producerRef.get()\n+          producerRef.dispose()\n+\n+          when (result) {\n+            is Result.Success -> {\n+              producer.offer(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f1fac05dae8a5a2e02c12669c5a65bc743d44fa4"}, "originalPosition": 190}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "294f0b9764dc07d92267f2996a73cd636e17ab00", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/294f0b9764dc07d92267f2996a73cd636e17ab00", "committedDate": "2020-05-12T05:52:02Z", "message": "iOS ApolloHttpNetworkTransportTest"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d464cf4fb0450f1f39716e2c4a41730dcf26f49b", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/d464cf4fb0450f1f39716e2c4a41730dcf26f49b", "committedDate": "2020-05-12T06:16:09Z", "message": "Check if flow is still active before dispatch"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "03036dab549beb8602b5d613c6792baa93370f6e", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/03036dab549beb8602b5d613c6792baa93370f6e", "committedDate": "2020-05-12T15:18:11Z", "message": "Wrap dispatching GraphQL response with `runCatching`"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDEwNDQ4MDYx", "url": "https://github.com/apollographql/apollo-android/pull/2256#pullrequestreview-410448061", "createdAt": "2020-05-12T21:49:57Z", "commit": {"oid": "03036dab549beb8602b5d613c6792baa93370f6e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "09b9f263f67b964de8e108a24e794ca99c4592bb", "author": {"user": {"login": "sav007", "name": "Ivan Savytskyi"}}, "url": "https://github.com/apollographql/apollo-android/commit/09b9f263f67b964de8e108a24e794ca99c4592bb", "committedDate": "2020-05-13T04:02:43Z", "message": "Address issue with `callbackFlow`. When http request is completed we call `producer#close` that cancels OkHttp call (via `awaitClose {call.cancel}`) that closes http response before we parse it.\n\nReplace callbackFlow with regular `flow` + `suspendCancellableCoroutine`\n\nFix Android sample\n\nRename `NetworkExecutor` to `NetworkInterceptor`"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3780, "cost": 1, "resetAt": "2021-11-01T11:59:11Z"}}}