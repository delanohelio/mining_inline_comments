{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU3NTg0NTMz", "number": 2480, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNjozNzo0MlrOETVepw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTo1NVrOETdyWw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4NzEwMzExOnYy", "diffSide": "RIGHT", "path": "apollo-integration/src/test/java/com/apollographql/apollo/Rx2ApolloTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNjozNzo0MlrOG5A04g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQxNjozNzo0MlrOG5A04g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQzNTU1NA==", "bodyText": "This is the test that failed before the patch \u261d\ufe0f", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462435554", "createdAt": "2020-07-29T16:37:42Z", "author": {"login": "martinbonnin"}, "path": "apollo-integration/src/test/java/com/apollographql/apollo/Rx2ApolloTest.kt", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.Utils.immediateExecutor\n+import com.apollographql.apollo.Utils.immediateExecutorService\n+import com.apollographql.apollo.Utils.mockResponse\n+import com.apollographql.apollo.api.Input\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import com.apollographql.apollo.cache.normalized.lru.EvictionPolicy\n+import com.apollographql.apollo.cache.normalized.lru.LruNormalizedCacheFactory\n+import com.apollographql.apollo.cache.normalized.NormalizedCacheFactory\n+import com.apollographql.apollo.fetcher.ApolloResponseFetchers.NETWORK_ONLY\n+import com.apollographql.apollo.integration.normalizer.EpisodeHeroNameQuery\n+import com.apollographql.apollo.integration.normalizer.HeroAndFriendsNamesWithIDsQuery\n+import com.apollographql.apollo.integration.normalizer.type.Episode.EMPIRE\n+import com.apollographql.apollo.integration.normalizer.type.Episode.NEWHOPE\n+import com.apollographql.apollo.rx2.Rx2Apollo\n+import com.google.common.truth.Truth\n+import com.google.common.truth.Truth.assertThat\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.observers.TestObserver\n+import io.reactivex.plugins.RxJavaPlugins\n+import io.reactivex.schedulers.TestScheduler\n+import okhttp3.Dispatcher\n+import okhttp3.OkHttpClient\n+import okhttp3.mockwebserver.MockWebServer\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+\n+\n+class Rx2ApolloTest {\n+  private lateinit var apolloClient: ApolloClient\n+\n+  @get:Rule\n+  val server = MockWebServer()\n+\n+  @Before\n+  fun setup() {\n+    val okHttpClient = OkHttpClient.Builder()\n+        .dispatcher(Dispatcher(immediateExecutorService()))\n+        .build()\n+    apolloClient = ApolloClient.builder()\n+        .serverUrl(server.url(\"/\"))\n+        .dispatcher(immediateExecutor())\n+        .okHttpClient(okHttpClient)\n+        .normalizedCache(LruNormalizedCacheFactory(EvictionPolicy.NO_EVICTION), IdFieldCacheKeyResolver())\n+        .build()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callProducesValue() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+        .assertValue({ response ->\n+          assertThat(response.data()?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        })\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<Response<EpisodeHeroNameQuery.Data>> = TestObserver<Response<EpisodeHeroNameQuery.Data>>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchCompletes() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .observeOn(TestScheduler())\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertNotComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedSameQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)))\n+        .responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer.assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotUpdatedSameQuerySameResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedDifferentQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(\"HeroAndFriendsNameWithIdsNameChange.json\"))\n+    apolloClient.query(HeroAndFriendsNamesWithIDsQuery(Input.fromNullable(NEWHOPE))).enqueue(null)\n+    observer\n+        .assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotCalledWhenCanceled() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val scheduler = TestScheduler()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .observeOn(scheduler)\n+        .subscribeWith(testObserver)\n+    scheduler.triggerActions()\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    disposable.dispose()\n+    scheduler.triggerActions()\n+    testObserver\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  fun disposingAnOperationDoesNotThrowUndeliverableException() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "originalPosition": 201}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODQ2MjM4OnYy", "diffSide": "RIGHT", "path": "apollo-integration/src/test/java/com/apollographql/apollo/Rx2ApolloTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTowOVrOG5N7HQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTowOVrOG5N7HQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDE0MQ==", "bodyText": "I've also used this approach to verify no error has been thrown.\nhttps://bryanherbst.com/2020/07/15/rxjava-uncaught-exception-tests/", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462650141", "createdAt": "2020-07-29T23:39:09Z", "author": {"login": "s1ee"}, "path": "apollo-integration/src/test/java/com/apollographql/apollo/Rx2ApolloTest.kt", "diffHunk": "@@ -0,0 +1,256 @@\n+package com.apollographql.apollo\n+\n+import com.apollographql.apollo.Utils.immediateExecutor\n+import com.apollographql.apollo.Utils.immediateExecutorService\n+import com.apollographql.apollo.Utils.mockResponse\n+import com.apollographql.apollo.api.Input\n+import com.apollographql.apollo.api.Response\n+import com.apollographql.apollo.cache.CacheHeaders\n+import com.apollographql.apollo.cache.normalized.Record\n+import com.apollographql.apollo.cache.normalized.CacheKey\n+import com.apollographql.apollo.cache.normalized.NormalizedCache\n+import com.apollographql.apollo.cache.normalized.RecordFieldJsonAdapter\n+import com.apollographql.apollo.cache.normalized.lru.EvictionPolicy\n+import com.apollographql.apollo.cache.normalized.lru.LruNormalizedCacheFactory\n+import com.apollographql.apollo.cache.normalized.NormalizedCacheFactory\n+import com.apollographql.apollo.fetcher.ApolloResponseFetchers.NETWORK_ONLY\n+import com.apollographql.apollo.integration.normalizer.EpisodeHeroNameQuery\n+import com.apollographql.apollo.integration.normalizer.HeroAndFriendsNamesWithIDsQuery\n+import com.apollographql.apollo.integration.normalizer.type.Episode.EMPIRE\n+import com.apollographql.apollo.integration.normalizer.type.Episode.NEWHOPE\n+import com.apollographql.apollo.rx2.Rx2Apollo\n+import com.google.common.truth.Truth\n+import com.google.common.truth.Truth.assertThat\n+import io.reactivex.disposables.Disposable\n+import io.reactivex.observers.TestObserver\n+import io.reactivex.plugins.RxJavaPlugins\n+import io.reactivex.schedulers.TestScheduler\n+import okhttp3.Dispatcher\n+import okhttp3.OkHttpClient\n+import okhttp3.mockwebserver.MockWebServer\n+import org.junit.Before\n+import org.junit.Rule\n+import org.junit.Test\n+\n+\n+class Rx2ApolloTest {\n+  private lateinit var apolloClient: ApolloClient\n+\n+  @get:Rule\n+  val server = MockWebServer()\n+\n+  @Before\n+  fun setup() {\n+    val okHttpClient = OkHttpClient.Builder()\n+        .dispatcher(Dispatcher(immediateExecutorService()))\n+        .build()\n+    apolloClient = ApolloClient.builder()\n+        .serverUrl(server.url(\"/\"))\n+        .dispatcher(immediateExecutor())\n+        .okHttpClient(okHttpClient)\n+        .normalizedCache(LruNormalizedCacheFactory(EvictionPolicy.NO_EVICTION), IdFieldCacheKeyResolver())\n+        .build()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callProducesValue() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+        .assertValue({ response ->\n+          assertThat(response.data()?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        })\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun callIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<Response<EpisodeHeroNameQuery.Data>> = TestObserver<Response<EpisodeHeroNameQuery.Data>>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchCompletes() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .test()\n+        .assertNoErrors()\n+        .assertComplete()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun prefetchIsCanceledWhenDisposed() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.prefetch(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))))\n+        .observeOn(TestScheduler())\n+        .subscribeWith(testObserver)\n+    disposable.dispose()\n+    testObserver.assertNotComplete()\n+    Truth.assertThat(testObserver.isDisposed()).isTrue()\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedSameQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)))\n+        .responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer.assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotUpdatedSameQuerySameResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    observer\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherUpdatedDifferentQueryDifferentResults() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val observer: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .subscribeWith(observer)\n+    server.enqueue(mockResponse(\"HeroAndFriendsNameWithIdsNameChange.json\"))\n+    apolloClient.query(HeroAndFriendsNamesWithIDsQuery(Input.fromNullable(NEWHOPE))).enqueue(null)\n+    observer\n+        .assertValueCount(2)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+        .assertValueAt(1) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"Artoo\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  @Throws(Exception::class)\n+  fun queryWatcherNotCalledWhenCanceled() {\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_WITH_ID))\n+    val testObserver: TestObserver<EpisodeHeroNameQuery.Data> = TestObserver<EpisodeHeroNameQuery.Data>()\n+    val scheduler = TestScheduler()\n+    val disposable: Disposable = Rx2Apollo\n+        .from(apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).watcher())\n+        .map({ response -> response.data() })\n+        .observeOn(scheduler)\n+        .subscribeWith(testObserver)\n+    scheduler.triggerActions()\n+    server.enqueue(mockResponse(FILE_EPISODE_HERO_NAME_CHANGE))\n+    apolloClient.query(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE))).responseFetcher(NETWORK_ONLY)\n+        .enqueue(null)\n+    disposable.dispose()\n+    scheduler.triggerActions()\n+    testObserver\n+        .assertValueCount(1)\n+        .assertValueAt(0) { data ->\n+          assertThat(data?.hero()?.name()).isEqualTo(\"R2-D2\")\n+          true\n+        }\n+  }\n+\n+  @Test\n+  fun disposingAnOperationDoesNotThrowUndeliverableException() {\n+    /*\n+     * A simple cache that will always throw errors\n+     */\n+    val cacheFactory = object: NormalizedCacheFactory<NormalizedCache>() {\n+      override fun create(recordFieldAdapter: RecordFieldJsonAdapter): NormalizedCache {\n+        return object: NormalizedCache() {\n+          override fun clearAll() {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun loadRecord(key: String, cacheHeaders: CacheHeaders): Record? {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun performMerge(apolloRecord: Record, oldRecord: Record?, cacheHeaders: CacheHeaders): Set<String> {\n+            throw Exception(\"not implemented\")\n+          }\n+\n+          override fun remove(cacheKey: CacheKey, cascade: Boolean): Boolean {\n+            throw Exception(\"not implemented\")\n+          }\n+        }\n+      }\n+    }\n+\n+    val apolloClient = ApolloClient.builder()\n+        .normalizedCache(cacheFactory)\n+        .serverUrl(\"https://unused/\")\n+        .build()\n+\n+\n+    val savedHandler = RxJavaPlugins.getErrorHandler()\n+\n+    var undeliverableException: Throwable? = null\n+    RxJavaPlugins.setErrorHandler {\n+      undeliverableException = it\n+    }\n+\n+    val operation = apolloClient.apolloStore.write(EpisodeHeroNameQuery(Input.fromNullable(EMPIRE)), EpisodeHeroNameQuery.Data(EpisodeHeroNameQuery.Hero(\"\", \"\")))\n+    val testObserver = Rx2Apollo.from(operation)\n+        .test()\n+\n+    testObserver.dispose()\n+\n+    // Since there is no cancellation mechanism for the ApolloStoreOperation, the only way to see if an error is thrown is to wait here\n+    Thread.sleep(200)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "originalPosition": 247}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjg4ODQ2NDI3OnYy", "diffSide": "RIGHT", "path": "apollo-rx3-support/src/main/java/com/apollographql/apollo/rx3/Rx3Apollo.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTo1NVrOG5N8IQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOVQyMzozOTo1NVrOG5N8IQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjY1MDQwMQ==", "bodyText": "I totally forgot this library supports Rx3 as well \ud83e\udd26", "url": "https://github.com/apollographql/apollo-android/pull/2480#discussion_r462650401", "createdAt": "2020-07-29T23:39:55Z", "author": {"login": "s1ee"}, "path": "apollo-rx3-support/src/main/java/com/apollographql/apollo/rx3/Rx3Apollo.java", "diffHunk": "@@ -212,12 +212,16 @@ public void subscribe(final SingleEmitter<T> emitter) {\n         operation.enqueue(new ApolloStoreOperation.Callback<T>() {\n           @Override\n           public void onSuccess(T result) {\n-            emitter.onSuccess(result);\n+            if (!emitter.isDisposed()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "355a340fabcf873e7c6b982a7634151c3517af5b"}, "originalPosition": 5}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3003, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}