{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTIxNzYyMzQ1", "number": 2756, "reviewThreads": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoxMzoyOVrOE8z91w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNTo0MjoxNFrOE9Ektw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjAxNDMxOnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ast/CodeGenerationAst.kt", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoxMzoyOVrOH5KMpQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzoxNDo1MFrOH5M-nA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY5Nzk1Nw==", "bodyText": "\ud83d\udc4d", "url": "https://github.com/apollographql/apollo-android/pull/2756#discussion_r529697957", "createdAt": "2020-11-24T16:13:29Z", "author": {"login": "sav007"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ast/CodeGenerationAst.kt", "diffHunk": "@@ -43,6 +43,7 @@ internal data class CodeGenerationAst(\n   data class FragmentType(\n       val graphqlName: String,\n       val rootType: TypeRef,\n+      val description: String,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458047913284d30bd9fa1b8d379fb9d7d5101bec"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0MzUxNg==", "bodyText": "Once this is merged and used, I think we should try to upstream this inside the GraphQL spec so that other tools don't choke on it.", "url": "https://github.com/apollographql/apollo-android/pull/2756#discussion_r529743516", "createdAt": "2020-11-24T17:14:50Z", "author": {"login": "martinbonnin"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/ast/CodeGenerationAst.kt", "diffHunk": "@@ -43,6 +43,7 @@ internal data class CodeGenerationAst(\n   data class FragmentType(\n       val graphqlName: String,\n       val rootType: TypeRef,\n+      val description: String,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTY5Nzk1Nw=="}, "originalCommit": {"oid": "458047913284d30bd9fa1b8d379fb9d7d5101bec"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjA1ODc1OnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/gql/Schema.kt", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoyMDo1NVrOH5KoUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNzoxNzoxOVrOH5NFGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwNTA0Mw==", "bodyText": "nit: should we call it GQLSchema?", "url": "https://github.com/apollographql/apollo-android/pull/2756#discussion_r529705043", "createdAt": "2020-11-24T16:20:55Z", "author": {"login": "sav007"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/gql/Schema.kt", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.apollographql.apollo.compiler.parser.gql\n+\n+/**\n+ * a very thin wrapper around a schema GQLDocument\n+ *\n+ * It serves as a common ground between GQLDocument and IntrospectionSchema\n+ *\n+ * Schema should always contain all types, including the builtin ones\n+ */\n+class Schema(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458047913284d30bd9fa1b8d379fb9d7d5101bec"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTc0NTE3OA==", "bodyText": "I'd like to keep the GQL prefix for everything that is in the GQLNode type hierarchy and Schema doesn't inherit from GQLNode.\nThere should be only 2 instances of schemas: one for introspection and this one so I think having Schema and IntrospectionSchema isn't too confusing but I'm happy to think of another prefix if needed.", "url": "https://github.com/apollographql/apollo-android/pull/2756#discussion_r529745178", "createdAt": "2020-11-24T17:17:19Z", "author": {"login": "martinbonnin"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/gql/Schema.kt", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.apollographql.apollo.compiler.parser.gql\n+\n+/**\n+ * a very thin wrapper around a schema GQLDocument\n+ *\n+ * It serves as a common ground between GQLDocument and IntrospectionSchema\n+ *\n+ * Schema should always contain all types, including the builtin ones\n+ */\n+class Schema(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwNTA0Mw=="}, "originalCommit": {"oid": "458047913284d30bd9fa1b8d379fb9d7d5101bec"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyMjA2NDIxOnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/gql/add_typename.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoyMjowNVrOH5KrtQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQxNjoyMjowNVrOH5KrtQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTcwNTkwOQ==", "bodyText": "\ud83d\udc4d \ud83d\udc4d \ud83d\udc4d  very important for fragment parsing", "url": "https://github.com/apollographql/apollo-android/pull/2756#discussion_r529705909", "createdAt": "2020-11-24T16:22:05Z", "author": {"login": "sav007"}, "path": "apollo-compiler/src/main/kotlin/com/apollographql/apollo/compiler/parser/gql/add_typename.kt", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.apollographql.apollo.compiler.parser.gql\n+\n+fun GQLOperationDefinition.withTypenameWhenNeeded(schema: Schema): GQLOperationDefinition {\n+  val hasFragmentSpread = selectionSet.selections.filterIsInstance<GQLFragmentSpread>().isNotEmpty()\n+\n+  return copy(\n+      selectionSet = selectionSet.withTypenameWhenNeeded(schema, hasFragmentSpread)\n+  )\n+}\n+\n+fun GQLFragmentDefinition.withTypenameWhenNeeded(schema: Schema): GQLFragmentDefinition {\n+  return copy(\n+      selectionSet = selectionSet.withTypenameWhenNeeded(schema, true)\n+  )\n+}\n+\n+private val typeNameField = GQLField(\n+    name = \"__typename\",\n+    arguments = null,\n+    selectionSet = null,\n+    sourceLocation = SourceLocation.UNKNOWN,\n+    directives = emptyList(),\n+    alias = null\n+)\n+\n+/**\n+ * XXX: add typename less often\n+ */\n+private fun GQLSelectionSet.withTypenameWhenNeeded(schema: Schema, needed: Boolean): GQLSelectionSet {\n+\n+  var newSelections = selections.map {\n+    when (it) {\n+      is GQLInlineFragment -> {\n+        val neededInInlineFragments = it.selectionSet.selections.filterIsInstance<GQLInlineFragment>().isNotEmpty()\n+        it.copy(\n+            selectionSet = it.selectionSet.withTypenameWhenNeeded(schema, neededInInlineFragments)\n+        )\n+      }\n+      is GQLFragmentSpread -> it\n+      is GQLField -> it.copy(\n+          selectionSet = it.selectionSet?.withTypenameWhenNeeded(schema, true)\n+      )\n+    }\n+  }\n+\n+  newSelections = if (needed) {\n+    // remove the __typename if it exists\n+    // and add it again at the top so we're guaranteed to have it at the beginning of json parsing", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "458047913284d30bd9fa1b8d379fb9d7d5101bec"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDY3MDA4OnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/test/typename/fragment_spread.graphql", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNTowNjowOFrOH5jYag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwOTozNToxNVrOH5qpFA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMDU3MA==", "bodyText": "it should because we have nested inline fragment here Droid", "url": "https://github.com/apollographql/apollo-android/pull/2756#discussion_r530110570", "createdAt": "2020-11-25T05:06:08Z", "author": {"login": "sav007"}, "path": "apollo-compiler/src/test/typename/fragment_spread.graphql", "diffHunk": "@@ -0,0 +1,13 @@\n+query TestQuery {\n+    hero {\n+        ...heroFragment\n+    }\n+}\n+\n+fragment heroFragment on Character {\n+    # No typename should be appended here", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "000dd2090793fdaa53a92f45851708e065bfbe62"}, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDIyOTUyNA==", "bodyText": "I thought that as well but since the Fragment spread will always be queried on a parent field, the __typename will be added there. In that case, the transformed definitions will be:\nquery TestQuery {\n    hero {\n        # added in the containing field\n        __typename\n        ...heroFragment\n    }\n}\n\n# Fragment did'nt change\nfragment heroFragment on Character {\n    name\n    ... on Droid {\n        primaryFunction\n    }\n} \nUnless the codegen assumes it to generate fragments?", "url": "https://github.com/apollographql/apollo-android/pull/2756#discussion_r530229524", "createdAt": "2020-11-25T09:35:15Z", "author": {"login": "martinbonnin"}, "path": "apollo-compiler/src/test/typename/fragment_spread.graphql", "diffHunk": "@@ -0,0 +1,13 @@\n+query TestQuery {\n+    hero {\n+        ...heroFragment\n+    }\n+}\n+\n+fragment heroFragment on Character {\n+    # No typename should be appended here", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDExMDU3MA=="}, "originalCommit": {"oid": "000dd2090793fdaa53a92f45851708e065bfbe62"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMyNDczNTI3OnYy", "diffSide": "RIGHT", "path": "apollo-compiler/src/test/kotlin/com/apollographql/apollo/compiler/TypenameTest.kt", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNTo0MjoxNFrOH5j-Bg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNVQwNTo0MjoxNFrOH5j-Bg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDEyMDE5OA==", "bodyText": "remove?", "url": "https://github.com/apollographql/apollo-android/pull/2756#discussion_r530120198", "createdAt": "2020-11-25T05:42:14Z", "author": {"login": "sav007"}, "path": "apollo-compiler/src/test/kotlin/com/apollographql/apollo/compiler/TypenameTest.kt", "diffHunk": "@@ -0,0 +1,63 @@\n+package com.apollographql.apollo.compiler\n+\n+import com.apollographql.apollo.compiler.parser.gql.GQLFragmentDefinition\n+import com.apollographql.apollo.compiler.parser.gql.GQLOperationDefinition\n+import com.apollographql.apollo.compiler.parser.gql.GraphQLParser\n+import com.apollographql.apollo.compiler.parser.gql.toFile\n+import com.apollographql.apollo.compiler.parser.gql.toSchema\n+import com.apollographql.apollo.compiler.parser.gql.toUtf8\n+import com.apollographql.apollo.compiler.parser.gql.toUtf8WithIndents\n+import com.apollographql.apollo.compiler.parser.gql.withTypenameWhenNeeded\n+import com.apollographql.apollo.compiler.parser.introspection.IntrospectionSchema\n+import com.google.common.truth.Truth.assertThat\n+import org.junit.Test\n+import org.junit.runner.RunWith\n+import org.junit.runners.Parameterized\n+import java.io.File\n+\n+@Suppress(\"UNUSED_PARAMETER\")\n+@RunWith(Parameterized::class)\n+class TypenameTest(val name: String, private val graphQLFile: File) {\n+\n+  @Test\n+  fun testTypename() {\n+    val schemaFile = File(\"src/test/graphql/schema.sdl\")\n+    val schema = GraphQLParser.parseSchema(schemaFile)\n+\n+    val document = GraphQLParser.parseOperations(graphQLFile, schema).orThrow()\n+\n+    val documentWithTypename = document.copy(\n+        definitions = document.definitions.map {\n+          when (it) {\n+            is GQLOperationDefinition -> it.withTypenameWhenNeeded(schema)\n+            is GQLFragmentDefinition -> it.withTypenameWhenNeeded(schema)\n+            else -> it\n+          }\n+        }\n+    ).toUtf8WithIndents()\n+\n+    val expectedFile = File(graphQLFile.parentFile, \"${name}.with_typename\")\n+\n+\n+    if (TestUtils.shouldUpdateTestFixtures()) {\n+      expectedFile.writeText(documentWithTypename)\n+    } else {\n+      assertThat(documentWithTypename).isEqualTo(expectedFile.readText())\n+    }\n+  }\n+\n+  companion object {\n+    @JvmStatic\n+    @Parameterized.Parameters(name = \"{0}\")\n+    fun data(): Collection<Array<Any>> {\n+      return File(\"src/test/typename/\")\n+          .walk()\n+          .toList()\n+          .filter { it.isFile }\n+          .filter { it.extension == \"graphql\" }\n+          .sortedBy { it.name }\n+          //.filter { it.name.contains(\"InputObjectFieldType\") }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "000dd2090793fdaa53a92f45851708e065bfbe62"}, "originalPosition": 59}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2980, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}