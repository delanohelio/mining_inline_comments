{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTE4MjE1MTU0", "number": 1480, "reviewThreads": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMTo0Mjo1N1rOE50I2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowNDowN1rOE8f80g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MDU4NTIzOnYy", "diffSide": "RIGHT", "path": "digdag-core/src/main/java/io/digdag/core/agent/OperatorManager.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMTo0Mjo1N1rOH0hG1g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMTo0Mjo1N1rOH0hG1g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzMDQyMg==", "bodyText": "is canceled is better?", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r524830422", "createdAt": "2020-11-17T01:42:57Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/OperatorManager.java", "diffHunk": "@@ -160,8 +160,13 @@ protected void runWithHeartbeat(TaskRequest request)\n                         callback.retryTask(request, agentId, ex.getRetryInterval().get(), ex.getStateParams(cf).get(), ex.getError(cf));\n                     }\n                     else {\n-                        logger.error(\"Task {} failed.\\n{}\", request.getTaskName(), formatExceptionMessage(ex));\n-                        logger.debug(\"\", ex);\n+                        if (request.isCancelRequested()) {\n+                            logger.warn(\"Task {} canceled.\", request.getTaskName());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MDYzODE3OnYy", "diffSide": "RIGHT", "path": "digdag-core/src/main/java/io/digdag/core/workflow/WorkflowExecutor.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMjowNzoyMVrOH0hlBQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMjowNzoyMVrOH0hlBQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDgzODE0OQ==", "bodyText": "This is outside the scope of this PR, but I'm wondering a successfully finished task should be handled as SUCCESS not as CANCELED even if it's received a cancel request...", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r524838149", "createdAt": "2020-11-17T02:07:21Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/workflow/WorkflowExecutor.java", "diffHunk": "@@ -104,6 +104,8 @@\n  *       : ERROR with error\n  *\n  *   taskSucceeded:\n+ *     (if CANCEL_REQUESTED flag is set) lockedTask.setToCanceled:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 22}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MDY2MDk3OnYy", "diffSide": "RIGHT", "path": "digdag-standards/src/main/java/io/digdag/standards/command/EcsCommandExecutor.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMjoxOToyNlrOH0hyNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMzoyNjowN1rOH28HDg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MTUyNA==", "bodyText": "The responsibility of this method is only cleaning up a task and cancel requests are not related to this method, I think. This method can be used by non-cancel operation in the future. So maybe this message shouldn't mention cancel requests.", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r524841524", "createdAt": "2020-11-17T02:19:26Z", "author": {"login": "komamitsu"}, "path": "digdag-standards/src/main/java/io/digdag/standards/command/EcsCommandExecutor.java", "diffHunk": "@@ -289,6 +282,42 @@ public CommandStatus poll(\n         }\n     }\n \n+    @Override\n+    public void cleanup(\n+            final CommandContext commandContext,\n+            final Config state)\n+            throws IOException\n+    {\n+        final TaskRequest request = commandContext.getTaskRequest();\n+        final long attemptId = request.getAttemptId();\n+        final long taskId = request.getTaskId();\n+        final Config taskConfig = request.getConfig();\n+\n+        final ObjectNode commandStatus = state.get(\"commandStatus\", ObjectNode.class);\n+        final String clusterName = commandStatus.get(\"cluster_name\").asText();\n+        final String taskArn = commandStatus.get(\"task_arn\").asText();\n+        final EcsClientConfig clientConfig = createEcsClientConfig(Optional.of(clusterName), systemConfig, taskConfig); // ConfigException\n+\n+        try (final EcsClient client = ecsClientFactory.createClient(clientConfig)) { // ConfigException\n+            final Task task;\n+            try {\n+                task = client.getTask(clusterName, taskArn);\n+            }\n+            catch (TaskSetNotFoundException e) {\n+                final String message = s(\"Cannot get the ECS task status. attemptId=%d, taskId=%d\", attemptId, taskId);\n+                logger.warn(message);\n+                // Throw exception to stop the task\n+                throw new TaskExecutionException(message);\n+            }\n+            final String message = s(\"Command task execution cancel requested: attemptId=%d, taskId=%d\", attemptId, taskId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg4MTYzOQ==", "bodyText": "Good point, I agree with you, I will change this message to a more general one.", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r524881639", "createdAt": "2020-11-17T04:46:12Z", "author": {"login": "szyn"}, "path": "digdag-standards/src/main/java/io/digdag/standards/command/EcsCommandExecutor.java", "diffHunk": "@@ -289,6 +282,42 @@ public CommandStatus poll(\n         }\n     }\n \n+    @Override\n+    public void cleanup(\n+            final CommandContext commandContext,\n+            final Config state)\n+            throws IOException\n+    {\n+        final TaskRequest request = commandContext.getTaskRequest();\n+        final long attemptId = request.getAttemptId();\n+        final long taskId = request.getTaskId();\n+        final Config taskConfig = request.getConfig();\n+\n+        final ObjectNode commandStatus = state.get(\"commandStatus\", ObjectNode.class);\n+        final String clusterName = commandStatus.get(\"cluster_name\").asText();\n+        final String taskArn = commandStatus.get(\"task_arn\").asText();\n+        final EcsClientConfig clientConfig = createEcsClientConfig(Optional.of(clusterName), systemConfig, taskConfig); // ConfigException\n+\n+        try (final EcsClient client = ecsClientFactory.createClient(clientConfig)) { // ConfigException\n+            final Task task;\n+            try {\n+                task = client.getTask(clusterName, taskArn);\n+            }\n+            catch (TaskSetNotFoundException e) {\n+                final String message = s(\"Cannot get the ECS task status. attemptId=%d, taskId=%d\", attemptId, taskId);\n+                logger.warn(message);\n+                // Throw exception to stop the task\n+                throw new TaskExecutionException(message);\n+            }\n+            final String message = s(\"Command task execution cancel requested: attemptId=%d, taskId=%d\", attemptId, taskId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MTUyNA=="}, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM2OTk5OA==", "bodyText": "Updated: be276de", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r527369998", "createdAt": "2020-11-20T03:26:07Z", "author": {"login": "szyn"}, "path": "digdag-standards/src/main/java/io/digdag/standards/command/EcsCommandExecutor.java", "diffHunk": "@@ -289,6 +282,42 @@ public CommandStatus poll(\n         }\n     }\n \n+    @Override\n+    public void cleanup(\n+            final CommandContext commandContext,\n+            final Config state)\n+            throws IOException\n+    {\n+        final TaskRequest request = commandContext.getTaskRequest();\n+        final long attemptId = request.getAttemptId();\n+        final long taskId = request.getTaskId();\n+        final Config taskConfig = request.getConfig();\n+\n+        final ObjectNode commandStatus = state.get(\"commandStatus\", ObjectNode.class);\n+        final String clusterName = commandStatus.get(\"cluster_name\").asText();\n+        final String taskArn = commandStatus.get(\"task_arn\").asText();\n+        final EcsClientConfig clientConfig = createEcsClientConfig(Optional.of(clusterName), systemConfig, taskConfig); // ConfigException\n+\n+        try (final EcsClient client = ecsClientFactory.createClient(clientConfig)) { // ConfigException\n+            final Task task;\n+            try {\n+                task = client.getTask(clusterName, taskArn);\n+            }\n+            catch (TaskSetNotFoundException e) {\n+                final String message = s(\"Cannot get the ECS task status. attemptId=%d, taskId=%d\", attemptId, taskId);\n+                logger.warn(message);\n+                // Throw exception to stop the task\n+                throw new TaskExecutionException(message);\n+            }\n+            final String message = s(\"Command task execution cancel requested: attemptId=%d, taskId=%d\", attemptId, taskId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MTUyNA=="}, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 73}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MDY2ODQ1OnYy", "diffSide": "RIGHT", "path": "digdag-standards/src/main/java/io/digdag/standards/operator/PyOperatorFactory.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMjoyMjo0MFrOH0h2QA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMzoyNTowNFrOH28FzA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU2MA==", "bodyText": "When is this line executed?", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r524842560", "createdAt": "2020-11-17T02:22:40Z", "author": {"login": "komamitsu"}, "path": "digdag-standards/src/main/java/io/digdag/standards/operator/PyOperatorFactory.java", "diffHunk": "@@ -124,6 +125,25 @@ public TaskResult runTask()\n                 .build();\n         }\n \n+        @Override\n+        public TaskResult cleanup(TaskRequest request)\n+        {\n+            final Path projectPath = workspace.getProjectPath(); // absolute\n+            final CommandContext commandContext = buildCommandContext(projectPath);\n+            final long attemptId = request.getAttemptId();\n+            final long taskId = request.getTaskId();\n+            Config state = TaskState.of(request).params();\n+            if (state.has(\"commandStatus\")) {\n+                logger.debug(String.format(\"Starting cleanup: attemptId=%d, taskId=%d\",  attemptId, taskId));\n+                try {\n+                    exec.cleanup(commandContext, state);\n+                } catch (IOException ex) {\n+                    throw Throwables.propagate(ex);\n+                }\n+            }\n+            return TaskResult.empty(request);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTY0NDkyMQ==", "bodyText": "This line is executed when the state does not have \"commandStatus\".  e.g. Not a polling-based task. But now I feel it'd better change to void as return type because cleanup has responsibility for cleaning up and do not have to return TaskResult.", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r525644921", "createdAt": "2020-11-18T01:58:07Z", "author": {"login": "szyn"}, "path": "digdag-standards/src/main/java/io/digdag/standards/operator/PyOperatorFactory.java", "diffHunk": "@@ -124,6 +125,25 @@ public TaskResult runTask()\n                 .build();\n         }\n \n+        @Override\n+        public TaskResult cleanup(TaskRequest request)\n+        {\n+            final Path projectPath = workspace.getProjectPath(); // absolute\n+            final CommandContext commandContext = buildCommandContext(projectPath);\n+            final long attemptId = request.getAttemptId();\n+            final long taskId = request.getTaskId();\n+            Config state = TaskState.of(request).params();\n+            if (state.has(\"commandStatus\")) {\n+                logger.debug(String.format(\"Starting cleanup: attemptId=%d, taskId=%d\",  attemptId, taskId));\n+                try {\n+                    exec.cleanup(commandContext, state);\n+                } catch (IOException ex) {\n+                    throw Throwables.propagate(ex);\n+                }\n+            }\n+            return TaskResult.empty(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU2MA=="}, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM2OTY3Ng==", "bodyText": "Updated: 36655d2", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r527369676", "createdAt": "2020-11-20T03:25:04Z", "author": {"login": "szyn"}, "path": "digdag-standards/src/main/java/io/digdag/standards/operator/PyOperatorFactory.java", "diffHunk": "@@ -124,6 +125,25 @@ public TaskResult runTask()\n                 .build();\n         }\n \n+        @Override\n+        public TaskResult cleanup(TaskRequest request)\n+        {\n+            final Path projectPath = workspace.getProjectPath(); // absolute\n+            final CommandContext commandContext = buildCommandContext(projectPath);\n+            final long attemptId = request.getAttemptId();\n+            final long taskId = request.getTaskId();\n+            Config state = TaskState.of(request).params();\n+            if (state.has(\"commandStatus\")) {\n+                logger.debug(String.format(\"Starting cleanup: attemptId=%d, taskId=%d\",  attemptId, taskId));\n+                try {\n+                    exec.cleanup(commandContext, state);\n+                } catch (IOException ex) {\n+                    throw Throwables.propagate(ex);\n+                }\n+            }\n+            return TaskResult.empty(request);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0MjU2MA=="}, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 28}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzI5MDY3NzA5OnYy", "diffSide": "RIGHT", "path": "digdag-core/src/main/java/io/digdag/core/agent/OperatorManager.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0xN1QwMjoyNjo0NlrOH0h7UQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMFQwMzoyMzowMlrOH28Dmg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0Mzg1Nw==", "bodyText": "What if runWithWorkspace throws TaskExecutionException not from operator.cleanup(mergedRequest)? It looks the clean up won't be called.", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r524843857", "createdAt": "2020-11-17T02:26:46Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/OperatorManager.java", "diffHunk": "@@ -160,8 +160,13 @@ protected void runWithHeartbeat(TaskRequest request)\n                         callback.retryTask(request, agentId, ex.getRetryInterval().get(), ex.getStateParams(cf).get(), ex.getError(cf));\n                     }\n                     else {\n-                        logger.error(\"Task {} failed.\\n{}\", request.getTaskName(), formatExceptionMessage(ex));\n-                        logger.debug(\"\", ex);\n+                        if (request.isCancelRequested()) {\n+                            logger.warn(\"Task {} canceled.\", request.getTaskName());\n+                        }\n+                        else {\n+                            logger.error(\"Task {} failed.\\n{}\", request.getTaskName(), formatExceptionMessage(ex));\n+                            logger.debug(\"\", ex);\n+                        }\n                         // TODO use debug to log stacktrace here\n                         callback.taskFailed(request, agentId, ex.getError(cf).get());  // TODO is error set?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzM2OTExNA==", "bodyText": "If runWithWorkspace throws TaskExecutionException, it depends on what type of TaskExecutionException, but it will retry the task if it is called by TaskExecutionException#ofNextPolling which is used by a polling-based task. And then cleanup be executed at that time if mergedResest.isCancelRequested() is true.\nOn the other hand, if cleanup failed to perform, target components will remain, I added a note about that and throw TaskExecutionException after cleanup to stop the task. afb2610", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r527369114", "createdAt": "2020-11-20T03:23:02Z", "author": {"login": "szyn"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/OperatorManager.java", "diffHunk": "@@ -160,8 +160,13 @@ protected void runWithHeartbeat(TaskRequest request)\n                         callback.retryTask(request, agentId, ex.getRetryInterval().get(), ex.getStateParams(cf).get(), ex.getError(cf));\n                     }\n                     else {\n-                        logger.error(\"Task {} failed.\\n{}\", request.getTaskName(), formatExceptionMessage(ex));\n-                        logger.debug(\"\", ex);\n+                        if (request.isCancelRequested()) {\n+                            logger.warn(\"Task {} canceled.\", request.getTaskName());\n+                        }\n+                        else {\n+                            logger.error(\"Task {} failed.\\n{}\", request.getTaskName(), formatExceptionMessage(ex));\n+                            logger.debug(\"\", ex);\n+                        }\n                         // TODO use debug to log stacktrace here\n                         callback.taskFailed(request, agentId, ex.getError(cf).get());  // TODO is error set?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDg0Mzg1Nw=="}, "originalCommit": {"oid": "b15393bb595d776246302bf7a282dd7217e56f89"}, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzMxODczNDkwOnYy", "diffSide": "RIGHT", "path": "digdag-core/src/test/java/io/digdag/core/agent/OperatorManagerTest.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwMzowNDowN1rOH4qByQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yNFQwNDo0Nzo0MFrOH4r0YQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MDg4OQ==", "bodyText": "Don't need to check if taskFailed is called?", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r529170889", "createdAt": "2020-11-24T03:04:07Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/test/java/io/digdag/core/agent/OperatorManagerTest.java", "diffHunk": "@@ -88,6 +90,21 @@ public void testRunWithHeartbeatWithSuccessTask()\n         verify(callback, times(0)).retryTask(any(), any(), anyInt(), any(), any());\n     }\n \n+    @Test\n+    public void testRunWithHeartbeatWithCancelRequestedTask()\n+    {\n+        TaskRequest taskRequest = OperatorTestingUtils.newTaskRequest(simpleConfig).withIsCancelRequested(true);\n+\n+        OperatorManager om = spy(operatorManager);\n+        Operator op = mock(Operator.class);\n+        OperatorFactory of = mock(OperatorFactory.class);\n+        doReturn(of).when(registry).get(any(), any());\n+        doReturn(op).when(of).newOperator(any());\n+        om.runWithHeartbeat(taskRequest);\n+        verify(op, times(0)).run();\n+        verify(op, times(1)).cleanup(any(TaskRequest.class));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a407c11893e527460dcb23b7fb0597b1d5abf235"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE5NzMzOA==", "bodyText": "I think it would be better to check, I'll add it. Thank you!", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r529197338", "createdAt": "2020-11-24T04:37:27Z", "author": {"login": "szyn"}, "path": "digdag-core/src/test/java/io/digdag/core/agent/OperatorManagerTest.java", "diffHunk": "@@ -88,6 +90,21 @@ public void testRunWithHeartbeatWithSuccessTask()\n         verify(callback, times(0)).retryTask(any(), any(), anyInt(), any(), any());\n     }\n \n+    @Test\n+    public void testRunWithHeartbeatWithCancelRequestedTask()\n+    {\n+        TaskRequest taskRequest = OperatorTestingUtils.newTaskRequest(simpleConfig).withIsCancelRequested(true);\n+\n+        OperatorManager om = spy(operatorManager);\n+        Operator op = mock(Operator.class);\n+        OperatorFactory of = mock(OperatorFactory.class);\n+        doReturn(of).when(registry).get(any(), any());\n+        doReturn(op).when(of).newOperator(any());\n+        om.runWithHeartbeat(taskRequest);\n+        verify(op, times(0)).run();\n+        verify(op, times(1)).cleanup(any(TaskRequest.class));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MDg4OQ=="}, "originalCommit": {"oid": "a407c11893e527460dcb23b7fb0597b1d5abf235"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMDIyNQ==", "bodyText": "I also added other callback cases, just in case.", "url": "https://github.com/treasure-data/digdag/pull/1480#discussion_r529200225", "createdAt": "2020-11-24T04:47:40Z", "author": {"login": "szyn"}, "path": "digdag-core/src/test/java/io/digdag/core/agent/OperatorManagerTest.java", "diffHunk": "@@ -88,6 +90,21 @@ public void testRunWithHeartbeatWithSuccessTask()\n         verify(callback, times(0)).retryTask(any(), any(), anyInt(), any(), any());\n     }\n \n+    @Test\n+    public void testRunWithHeartbeatWithCancelRequestedTask()\n+    {\n+        TaskRequest taskRequest = OperatorTestingUtils.newTaskRequest(simpleConfig).withIsCancelRequested(true);\n+\n+        OperatorManager om = spy(operatorManager);\n+        Operator op = mock(Operator.class);\n+        OperatorFactory of = mock(OperatorFactory.class);\n+        doReturn(of).when(registry).get(any(), any());\n+        doReturn(op).when(of).newOperator(any());\n+        om.runWithHeartbeat(taskRequest);\n+        verify(op, times(0)).run();\n+        verify(op, times(1)).cleanup(any(TaskRequest.class));\n+    }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTE3MDg4OQ=="}, "originalCommit": {"oid": "a407c11893e527460dcb23b7fb0597b1d5abf235"}, "originalPosition": 26}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1164, "cost": 1, "resetAt": "2021-11-13T14:23:39Z"}}}