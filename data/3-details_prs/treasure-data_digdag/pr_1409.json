{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDIzMDc0ODk1", "number": 1409, "title": "require> enhancement", "bodyText": "This PR is follow up PR to #1405 and enhance require> operator.\n\nIntroduce rerun_on: (none,failed,all).\nIgnore retry_attempt_name from out of operator. (fix #712 )\nexponential backoff for task retry (max 10 secs)\n\nTo exclude #1405 fix from file changes, following view may be good.\nhttps://github.com/treasure-data/digdag/pull/1409/files/48b9ae47b4554f8b5b1fa0fadcc1a28842cd07b7..ef1f5fdeb1b8f248d281b5fb989f714b5b75649e\nFollowing is the flow chart of require>", "createdAt": "2020-05-26T08:57:54Z", "url": "https://github.com/treasure-data/digdag/pull/1409", "merged": true, "mergeCommit": {"oid": "9a30fb6df5e69b7484f08af3169287b6186bbdf2"}, "closed": true, "closedAt": "2020-06-11T02:03:14Z", "author": {"login": "yoyama"}, "timelineItems": {"totalCount": 41, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABchZ1v3gH2gAyNDIzMDc0ODk1OjNlOTE5ZjFhMTI0MDNhOTY2ZGQwMWM3ODVkZjI1MDE5NzM4ZmYyMTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcpKMA4gBqjM0MTgyNjI4MTQ=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "3e919f1a12403a966dd01c785df25019738ff212", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/3e919f1a12403a966dd01c785df25019738ff212", "committedDate": "2020-05-15T03:51:55Z", "message": "Implement project_name param in require>."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "48b9ae47b4554f8b5b1fa0fadcc1a28842cd07b7", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/48b9ae47b4554f8b5b1fa0fadcc1a28842cd07b7", "committedDate": "2020-05-19T01:40:10Z", "message": "Fix documents, template var in test based on the revew."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b7f4528ff17926ee323896240c341b332fa5f3f0", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/b7f4528ff17926ee323896240c341b332fa5f3f0", "committedDate": "2020-05-27T09:12:47Z", "message": "Update document."}, "afterCommit": {"oid": "db8b0259eddf44c9344ae13e208f2d5152e9515b", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/db8b0259eddf44c9344ae13e208f2d5152e9515b", "committedDate": "2020-05-27T09:19:23Z", "message": "Update document."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "1ee80d1fa43d02ad2a1f255804a0918f823e9984", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/1ee80d1fa43d02ad2a1f255804a0918f823e9984", "committedDate": "2020-05-29T02:57:25Z", "message": "Remove ignore_no_existence and refactoring."}, "afterCommit": {"oid": "fa92db5b52f841a54bff5cbe7fe822fea8daf97f", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/fa92db5b52f841a54bff5cbe7fe822fea8daf97f", "committedDate": "2020-05-29T03:16:37Z", "message": "Remove ignore_no_existence and refactoring."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a4d09990327359fd65edab33e9fa4986644b75ea", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/a4d09990327359fd65edab33e9fa4986644b75ea", "committedDate": "2020-05-29T08:08:19Z", "message": "Implement exponential backoff to reduce num of task retry."}, "afterCommit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/ef1f5fdeb1b8f248d281b5fb989f714b5b75649e", "committedDate": "2020-06-01T05:54:42Z", "message": "Implement exponential backoff to reduce num of task retry."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIyNzQ4MzM2", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-422748336", "createdAt": "2020-06-02T14:40:46Z", "commit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDo0MDo0NlrOGd09MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wMlQxNDo0MDo0NlrOGd09MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkyOTUyMA==", "bodyText": "There is an unexpected space between workflowName and ).", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r433929520", "createdAt": "2020-06-02T14:40:46Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,42 +68,157 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<StoredSessionAttempt> attempt = Optional.absent();\n+            Optional<SessionAttemptConflictException> sessionAttemptConflictException = Optional.absent();\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                attempt = Optional.of(callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n-                        overrideParams);\n+                        overrideParams));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                sessionAttemptConflictException = Optional.of(ex);\n+            }\n+            catch (ResourceNotFoundException ex) {\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform((p)->p.toString()).or(\"\"), workflowName ));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e"}, "originalPosition": 96}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjMzMzkz", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-423233393", "createdAt": "2020-06-03T05:44:06Z", "commit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTo0NDowNlrOGeM00g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTo0NDowNlrOGeM00g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMDU5NA==", "bodyText": "What about the case the conflict attempt failed like If failed, xxx?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434320594", "createdAt": "2020-06-03T05:44:06Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -64,46 +68,109 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<StoredSessionAttempt> attempt = Optional.absent();\n+            Optional<SessionAttemptConflictException> sessionAttemptConflictException = Optional.absent();\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e"}, "originalPosition": 58}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjM2Njkx", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-423236691", "createdAt": "2020-06-03T05:53:20Z", "commit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTo1MzoyMFrOGeM_DQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTo1MzoyMFrOGeM_DQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzIxMw==", "bodyText": "How about moving this block to the above catch (SessionAttemptConflictException ex) { ... } block? Maybe we can remove the Optional?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434323213", "createdAt": "2020-06-03T05:53:20Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -64,46 +68,109 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<StoredSessionAttempt> attempt = Optional.absent();\n+            Optional<SessionAttemptConflictException> sessionAttemptConflictException = Optional.absent();\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                ProjectIdentifier projectIdentifier = makeProjectIdentifier();\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n \n-                StoredSessionAttempt attempt = callback.startSession(\n+                attempt = Optional.of(callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectIdentifier,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n-                        overrideParams);\n+                        overrideParams));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                sessionAttemptConflictException = Optional.of(ex);\n+            }\n+            catch (ResourceNotFoundException ex) {\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform((p)->p.toString()).or(\"\"), workflowName ));\n+            }\n+            catch (ResourceLimitExceededException ex) {\n+                throw new TaskExecutionException(ex);\n+            }\n \n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+            if (sessionAttemptConflictException.isPresent()) {\n+                StoredSessionAttempt conflictedAttempt = sessionAttemptConflictException.get().getConflictedSession();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e"}, "originalPosition": 97}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMjM3MjU4", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-423237258", "createdAt": "2020-06-03T05:54:51Z", "commit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTo1NDo1MVrOGeNA9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wM1QwNTo1NDo1MVrOGeNA9g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDMyMzcwMg==", "bodyText": "How about moving this line to right after calling callback.startSession()  in the above try { ... } block? Maybe we can remove the Optional?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434323702", "createdAt": "2020-06-03T05:54:51Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -64,46 +68,109 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<StoredSessionAttempt> attempt = Optional.absent();\n+            Optional<SessionAttemptConflictException> sessionAttemptConflictException = Optional.absent();\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                ProjectIdentifier projectIdentifier = makeProjectIdentifier();\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n \n-                StoredSessionAttempt attempt = callback.startSession(\n+                attempt = Optional.of(callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectIdentifier,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n-                        overrideParams);\n+                        overrideParams));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                sessionAttemptConflictException = Optional.of(ex);\n+            }\n+            catch (ResourceNotFoundException ex) {\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform((p)->p.toString()).or(\"\"), workflowName ));\n+            }\n+            catch (ResourceLimitExceededException ex) {\n+                throw new TaskExecutionException(ex);\n+            }\n \n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+            if (sessionAttemptConflictException.isPresent()) {\n+                StoredSessionAttempt conflictedAttempt = sessionAttemptConflictException.get().getConflictedSession();\n+                if (conflictedAttempt.getStateFlags().isDone()) {\n+                    // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                    boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                    if (!requireKicked &&  (\n+                            rerunOn == OptionRerunOn.ALL ||\n+                            rerunOn == OptionRerunOn.FAILED && !conflictedAttempt.getStateFlags().isSuccess())) {\n+\n+                        //To force run, set flag gen_retry_attempt_name and do polling\n+                        throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                    }\n+                    if (!ignoreFailure && !conflictedAttempt.getStateFlags().isSuccess()) {\n                         // ignore_failure is false and the attempt is in error state. Make this operator failed.\n                         throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            conflictedAttempt.getSessionId(), conflictedAttempt.getId()));\n                     }\n                     return TaskResult.empty(cf);\n                 }\n                 else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n+                    // Wait for finish running attempt\n+                    throw nextPolling(request.getLastStateParams().deepCopy());\n                 }\n             }\n-            catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+            else if (attempt.isPresent()) { // startSession succeeded and created new attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "ef1f5fdeb1b8f248d281b5fb989f714b5b75649e"}, "originalPosition": 128}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MDYyNzcy", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424062772", "createdAt": "2020-06-04T02:39:11Z", "commit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjozOToxMVrOGez1tg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjozOToxMVrOGez1tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk1OTc5OA==", "bodyText": "I'm wondering if this scope reduction of retry_attempt_name can affect existing workflows...", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434959798", "createdAt": "2020-06-04T02:39:11Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "originalPosition": 48}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MDY4Njky", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424068692", "createdAt": "2020-06-04T02:58:37Z", "commit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjo1ODozN1rOGe0JMw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMjo1ODozN1rOGe0JMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2NDc4Nw==", "bodyText": "This isn't used?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434964787", "createdAt": "2020-06-04T02:58:37Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||\n+                                rerunOn == OptionRerunOn.FAILED && !attempt.getStateFlags().isSuccess())) {\n+\n+                    //To force run, set flag gen_retry_attempt_name and do polling\n+                    throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                }\n+                if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+                    // ignore_failure is false and the attempt is in error state. Make this operator failed.\n+                    throw new TaskExecutionException(String.format(ENGLISH,\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            attempt.getSessionId(), attempt.getId()));\n+                }\n+                return TaskResult.empty(cf);\n+            }\n+            else {\n+                // Wait for finish running attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy());\n+            }\n+        }\n+\n+        private TaskExecutionException nextPolling(Config stateParams)\n+        {\n+            int iteration = stateParams.get(\"retry\", int.class, 0);\n+            stateParams.set(\"retry\", iteration+1);\n+            int interval = (int) Math.min(1 * Math.pow(2, iteration), MAX_TASK_RETRY_INTERVAL);\n+\n+            return TaskExecutionException.ofNextPolling( interval, ConfigElement.copyOf(stateParams));\n+        }\n+\n+        /**\n+         * Make ProjectIdentifier from parameters.\n+         * @return\n+         */\n+        private ProjectIdentifier makeProjectIdentifier()\n+        {\n+            Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            int projectId = config.get(\"project_id\", int.class);\n+            Optional<Integer> projectIdParam = localConfig.getOptional(\"project_id\", Integer.class);\n+            Optional<String> projectNameParam = localConfig.getOptional(\"project_name\", String.class);\n+\n+            if (projectIdParam.isPresent() && projectNameParam.isPresent()) {\n+                throw new ConfigException(\"Both project_id and project_name can't be set\");\n+            }\n+            ProjectIdentifier projectIdentifier;\n+            if (projectNameParam.isPresent()) {\n+                projectIdentifier = ProjectIdentifier.ofName(projectNameParam.get());\n+            }\n+            else if (projectIdParam.isPresent()) {\n+                projectIdentifier = ProjectIdentifier.ofId(projectIdParam.get());\n+            }\n+            else {\n+                projectIdentifier = ProjectIdentifier.ofId(projectId);\n+            }\n+            return projectIdentifier;\n+        }\n+    }\n+\n+    enum OptionRerunOn\n+    {\n+        NONE(\"none\"),\n+        FAILED( \"failed\"),\n+        ALL (\"all\");\n+\n+        private final String name;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "originalPosition": 187}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MDcyOTkw", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424072990", "createdAt": "2020-06-04T03:13:34Z", "commit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMzoxMzozNVrOGe0WoA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwMzoxMzozNVrOGe0WoA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDk2ODIyNA==", "bodyText": "When OptionRerunOn.ALL is set, the workflow should be executed regardless it was executed via require operator or not, right? If so, rerunOn == OptionRerunOn.ALL should not depend on requireKicked?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r434968224", "createdAt": "2020-06-04T03:13:35Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "originalPosition": 123}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTMyMjU4", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424132258", "createdAt": "2020-06-04T06:20:41Z", "commit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyMDo0MVrOGe3T5Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyMDo0MVrOGe3T5Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNjY3Nw==", "bodyText": "A space on the left of interval", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435016677", "createdAt": "2020-06-04T06:20:41Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||\n+                                rerunOn == OptionRerunOn.FAILED && !attempt.getStateFlags().isSuccess())) {\n+\n+                    //To force run, set flag gen_retry_attempt_name and do polling\n+                    throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                }\n+                if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+                    // ignore_failure is false and the attempt is in error state. Make this operator failed.\n+                    throw new TaskExecutionException(String.format(ENGLISH,\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            attempt.getSessionId(), attempt.getId()));\n+                }\n+                return TaskResult.empty(cf);\n+            }\n+            else {\n+                // Wait for finish running attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy());\n+            }\n+        }\n+\n+        private TaskExecutionException nextPolling(Config stateParams)\n+        {\n+            int iteration = stateParams.get(\"retry\", int.class, 0);\n+            stateParams.set(\"retry\", iteration+1);\n+            int interval = (int) Math.min(1 * Math.pow(2, iteration), MAX_TASK_RETRY_INTERVAL);\n+\n+            return TaskExecutionException.ofNextPolling( interval, ConfigElement.copyOf(stateParams));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "originalPosition": 149}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTMyNTY5", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424132569", "createdAt": "2020-06-04T06:21:26Z", "commit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyMToyNlrOGe3U6A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyMToyNlrOGe3U6A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNjkzNg==", "bodyText": "Spaces on the both sides of + would be better?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435016936", "createdAt": "2020-06-04T06:21:26Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||\n+                                rerunOn == OptionRerunOn.FAILED && !attempt.getStateFlags().isSuccess())) {\n+\n+                    //To force run, set flag gen_retry_attempt_name and do polling\n+                    throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                }\n+                if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+                    // ignore_failure is false and the attempt is in error state. Make this operator failed.\n+                    throw new TaskExecutionException(String.format(ENGLISH,\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            attempt.getSessionId(), attempt.getId()));\n+                }\n+                return TaskResult.empty(cf);\n+            }\n+            else {\n+                // Wait for finish running attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy());\n+            }\n+        }\n+\n+        private TaskExecutionException nextPolling(Config stateParams)\n+        {\n+            int iteration = stateParams.get(\"retry\", int.class, 0);\n+            stateParams.set(\"retry\", iteration+1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "originalPosition": 146}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTMzNTc1", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424133575", "createdAt": "2020-06-04T06:23:39Z", "commit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyMzo0MFrOGe3YFg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyMzo0MFrOGe3YFg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxNzc1MA==", "bodyText": "Maybe duplicated deep copy?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435017750", "createdAt": "2020-06-04T06:23:40Z", "author": {"login": "komamitsu"}, "path": "digdag-core/src/main/java/io/digdag/core/agent/RequireOperatorFactory.java", "diffHunk": "@@ -65,43 +68,149 @@ private RequireOperator(OperatorContext context, TaskCallbackApi callback)\n         public TaskResult runTask()\n         {\n             Config config = request.getConfig();\n+            Config localConfig = request.getLocalConfig();\n+            Config lastStateParams = request.getLastStateParams();\n+\n             String workflowName = config.get(\"_command\", String.class);\n-            int projectId = config.get(\"project_id\", int.class);\n             Instant instant = config.get(\"session_time\", Instant.class);\n             boolean ignoreFailure = config.get(\"ignore_failure\", boolean.class, false);\n-            Optional<String> retryAttemptName = config.getOptional(\"retry_attempt_name\", String.class);\n+            OptionRerunOn rerunOn = OptionRerunOn.of(config.get(\"rerun_on\", String.class, \"none\"));\n+\n+            //retry_attempt_name is set from local config only.\n+            Optional<String> retryAttemptName = localConfig.getOptional(\"retry_attempt_name\", String.class);\n+            if (lastStateParams.has(\"rerun_on_retry_attempt_name\")) { // set for rerun_on parameter.\n+                retryAttemptName = lastStateParams.getOptional(\"rerun_on_retry_attempt_name\", String.class);\n+            }\n+\n             Config overrideParams = config.getNestedOrGetEmpty(\"params\");\n+\n+            Optional<ProjectIdentifier> projectIdentifier = Optional.absent();\n+            /**\n+             *  First of all, try to start attempt by startSession()\n+             *  If no attempt exists (no conflict), it return new StoredSessionAttempt.\n+             *    - set state param \"require_kicked\" to true.\n+             *    - task is retried to wait for done by nextPolling.\n+             *  If something errors happen, it will throw following exceptions.\n+             *    - ResourceNotFoundException ... workflow ,project name(or id) are wrong. -> processed as deterministic error\n+             *    - ResourceLimitExceededException ... this exception should be deterministic error\n+             *    - SessionAttemptConflictException ... this is not error.\n+             *      - If the conflict attempt is still running, wait for until done by nextPolling.\n+             *      - If done, check the state param \"require_kicked\" and whether the attempt is kicked by this require> or not.\n+             *        - If not kicked by this require>, check result and rerun_on option and determine rerun or not.\n+             *          - if need to rerun, generate unique retry_attempt_name and set to \"rerun_on_retry_attempt_name\"\n+             *          - throw nextPolling and in next call of runTask(), \"rerun_on_retry_attempt_name\" is used as retry_attempt_name and must succeed to create new attempt because it is unique.\n+             *        - For both kicked and not kicked, check the result and ignore_failure option\n+             *          - If ignore_failure is true or attempt finished successfully, require> op finished successfully\n+             *          - else finished with exception.\n+             */\n             try {\n-                StoredSessionAttempt attempt = callback.startSession(\n+                projectIdentifier = Optional.of(makeProjectIdentifier());\n+\n+                callback.startSession(\n                         context,\n                         request.getSiteId(),\n-                        projectId,\n+                        projectIdentifier.get(),\n                         workflowName,\n                         instant,\n                         retryAttemptName,\n                         overrideParams);\n-\n-                boolean isDone = attempt.getStateFlags().isDone();\n-                if (isDone) {\n-                    if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n-                        // ignore_failure is false and the attempt is in error state. Make this operator failed.\n-                        throw new TaskExecutionException(String.format(ENGLISH,\n-                                    \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n-                                    attempt.getSessionId(), attempt.getId()));\n-                    }\n-                    return TaskResult.empty(cf);\n-                }\n-                else {\n-                    // TODO use exponential-backoff to calculate retry interval\n-                    throw TaskExecutionException.ofNextPolling(1, ConfigElement.copyOf(request.getLastStateParams()));\n-                }\n+                throw nextPolling(request.getLastStateParams().deepCopy().set(\"require_kicked\", true));\n+            }\n+            catch (SessionAttemptConflictException ex) {\n+                return processAttempt(ex.getConflictedSession(), lastStateParams, rerunOn, ignoreFailure);\n             }\n             catch (ResourceNotFoundException ex) {\n-                throw new ConfigException(ex);\n+                throw new TaskExecutionException(String.format(ENGLISH, \"Dependent workflow does not exist. %s, workflowName:%s\",\n+                        projectIdentifier.transform(ProjectIdentifier::toString).or(\"\"), workflowName));\n             }\n             catch (ResourceLimitExceededException ex) {\n                 throw new TaskExecutionException(ex);\n             }\n         }\n+\n+        private TaskResult processAttempt(StoredSessionAttempt attempt, Config lastStateParams, OptionRerunOn rerunOn, boolean ignoreFailure)\n+        {\n+            if (attempt.getStateFlags().isDone()) {\n+                // A flag to distinguish whether the attempt is kicked by require> or previous attempt.\n+                boolean requireKicked = lastStateParams.get(\"require_kicked\", boolean.class, false);\n+                if (!requireKicked &&  (\n+                        rerunOn == OptionRerunOn.ALL ||\n+                                rerunOn == OptionRerunOn.FAILED && !attempt.getStateFlags().isSuccess())) {\n+\n+                    //To force run, set flag gen_retry_attempt_name and do polling\n+                    throw nextPolling(lastStateParams.deepCopy().set(\"rerun_on_retry_attempt_name\", UUID.randomUUID().toString()));\n+                }\n+                if (!ignoreFailure && !attempt.getStateFlags().isSuccess()) {\n+                    // ignore_failure is false and the attempt is in error state. Make this operator failed.\n+                    throw new TaskExecutionException(String.format(ENGLISH,\n+                            \"Dependent workflow failed. Session id: %d, attempt id: %d\",\n+                            attempt.getSessionId(), attempt.getId()));\n+                }\n+                return TaskResult.empty(cf);\n+            }\n+            else {\n+                // Wait for finish running attempt\n+                throw nextPolling(request.getLastStateParams().deepCopy());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "originalPosition": 139}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTM0OTEz", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424134913", "createdAt": "2020-06-04T06:26:21Z", "commit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyNjoyMVrOGe3cNA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyNjoyMVrOGe3cNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxODgwNA==", "bodyText": "Unnecessary space on the right of digdag retry", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435018804", "createdAt": "2020-06-04T06:26:21Z", "author": {"login": "komamitsu"}, "path": "digdag-docs/src/operators/require.md", "diffHunk": "@@ -71,3 +88,8 @@\n   ignore_failure: true\n   ```\n \n+  require> evaluates *ignore_failure* at last of its process. If rerun_on is set and require> run new attempt, the result of new attempt is checked.\n+\n+## Notes\n+- require> has been changed to ignore inherited *retry_attempt_name* parameter. \n+  `digdag retry ` command generates unique retry_attempt_name to run, but it is not passed to require>.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "originalPosition": 44}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MTM1NDM1", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424135435", "createdAt": "2020-06-04T06:27:33Z", "commit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyNzozNFrOGe3dxQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwNjoyNzozNFrOGe3dxQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTAxOTIwNQ==", "bodyText": "Adding since v0.10 or something may be helpful for users, I think.", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435019205", "createdAt": "2020-06-04T06:27:34Z", "author": {"login": "komamitsu"}, "path": "digdag-docs/src/operators/require.md", "diffHunk": "@@ -71,3 +88,8 @@\n   ignore_failure: true\n   ```\n \n+  require> evaluates *ignore_failure* at last of its process. If rerun_on is set and require> run new attempt, the result of new attempt is checked.\n+\n+## Notes\n+- require> has been changed to ignore inherited *retry_attempt_name* parameter. ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "1bee39f38f9c07cee67357e846d3021616b171a5"}, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0MjU4OTcz", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424258973", "createdAt": "2020-06-04T09:21:54Z", "commit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyMTo1NFrOGe9O3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNFQwOToyMTo1NFrOGe9O3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTExMzY5Mg==", "bodyText": "Just posted a comment https://github.com/treasure-data/digdag/pull/1405/files#r435112975", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435113692", "createdAt": "2020-06-04T09:21:54Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "originalPosition": 102}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "211dde3347f2dde718b149b3e0d440721f177b55", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/211dde3347f2dde718b149b3e0d440721f177b55", "committedDate": "2020-06-05T02:14:45Z", "message": "Fix RequireIT"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTkxNjE4", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424991618", "createdAt": "2020-06-05T04:42:08Z", "commit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNDo0MjowOFrOGfgMZQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNDo0MjowOFrOGfgMZQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NjUwMQ==", "bodyText": "[minor] Space", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435686501", "createdAt": "2020-06-05T04:42:08Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail) throws InterruptedException\n+    {\n+        //Start a child\n+        String childFailParam = previousChildRunFail ? \"yes\" : \"no\";\n+        CommandStatus childStatus = startAndWait(true,\"require\", \"child\", \"--session\", sessionTime,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTkxNjYz", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424991663", "createdAt": "2020-06-05T04:42:20Z", "commit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNDo0MjoyMFrOGfgMhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNDo0MjoyMFrOGfgMhg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY4NjUzNA==", "bodyText": "Same as above", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435686534", "createdAt": "2020-06-05T04:42:20Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail) throws InterruptedException\n+    {\n+        //Start a child\n+        String childFailParam = previousChildRunFail ? \"yes\" : \"no\";\n+        CommandStatus childStatus = startAndWait(true,\"require\", \"child\", \"--session\", sessionTime,\n+                \"-p\", \"child_fail=\" + childFailParam);\n+        assertThat(isAttemptSuccess(childStatus), not(previousChildRunFail));\n+\n+        // Start a parent with same session time.\n+        CommandStatus rerunOnNoneStatus = startAndWait(false,\"require\", \"parent\", \"--session\", sessionTime,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "originalPosition": 167}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTk3OTUy", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424997952", "createdAt": "2020-06-05T05:05:02Z", "commit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNTowNTowMlrOGfggtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNTowNTowMlrOGfggtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MTcwMA==", "bodyText": "I'm wondering why this method call always passes ignoreAttemptFailure=true (sorry, a bit too difficult for me \ud83d\ude05.)\nCould I ask you the followings?\n\nAdd a comment for each case about why target attempt is expected to fail\n2. If possible, make this method call pass attemptShouldFail or something deterministic instead of  ignoreAttemptFailure (probably related to https://github.com/treasure-data/digdag/pull/1409/files#r435692688)", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435691700", "createdAt": "2020-06-05T05:05:02Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail) throws InterruptedException\n+    {\n+        //Start a child\n+        String childFailParam = previousChildRunFail ? \"yes\" : \"no\";\n+        CommandStatus childStatus = startAndWait(true,\"require\", \"child\", \"--session\", sessionTime,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI0OTk5MTAx", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-424999101", "createdAt": "2020-06-05T05:08:46Z", "commit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNTowODo0N1rOGfgkkA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNTowODo0N1rOGfgkkA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5MjY4OA==", "bodyText": "Oh, the same check is done above like assertThat(isAttemptSuccess(childStatus), not(previousChildRunFail))?\nSo we can remove this to make things simpler?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435692688", "createdAt": "2020-06-05T05:08:47Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail) throws InterruptedException\n+    {\n+        //Start a child\n+        String childFailParam = previousChildRunFail ? \"yes\" : \"no\";\n+        CommandStatus childStatus = startAndWait(true,\"require\", \"child\", \"--session\", sessionTime,\n+                \"-p\", \"child_fail=\" + childFailParam);\n+        assertThat(isAttemptSuccess(childStatus), not(previousChildRunFail));\n+\n+        // Start a parent with same session time.\n+        CommandStatus rerunOnNoneStatus = startAndWait(false,\"require\", \"parent\", \"--session\", sessionTime,\n+                \"-p\", \"param_rerun_on=\" + rerunOn,\n+                \"-p\", \"child_fail=no\");\n+\n+        assertThat(isAttemptSuccess(rerunOnNoneStatus), is(true));\n+        RestSessionAttemptCollection attempts = client.getSessionAttemptRetries(getAttemptId(childStatus));\n+        return attempts;\n+    }\n+\n+    private static boolean isAttemptSuccess(CommandStatus status) { return status.outUtf8().contains(\"status: success\"); }\n+\n+    private CommandStatus startAndWait(boolean ignoreAttemptFailure, String... args) throws InterruptedException\n+    {\n+        List<String> newArgs = new ArrayList<>(Arrays.asList(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint()\n+                ));\n+        newArgs.addAll(Arrays.asList(args));\n+        CommandStatus startStatus = main(newArgs);\n+        Id startAttemptId = getAttemptId(startStatus);\n+        CommandStatus attemptsStatus = null;\n+        // Wait for the attempt to complete\n+        boolean success = false;\n+        for (int i = 0; i < 30; i++) {\n+            attemptsStatus = main(\"attempt\",\n+                    \"-c\", config.toString(),\n+                    \"-e\", server.endpoint(),\n+                    String.valueOf(startAttemptId));\n+            if (attemptsStatus.outUtf8().contains(\"status: success\")) {\n+                success = true;\n+                break;\n+            }\n+            else if (attemptsStatus.outUtf8().contains(\"status: error\")) {\n+                break;\n+            }\n+            Thread.sleep(1000);\n+        }\n+        if (!ignoreAttemptFailure) {\n+            assertThat(success, is(true));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "originalPosition": 205}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDAwNDc1", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-425000475", "createdAt": "2020-06-05T05:13:22Z", "commit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToxMzoyMlrOGfgo3A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToxMzoyMlrOGfgo3A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5Mzc4OA==", "bodyText": "Is this line needed?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435693788", "createdAt": "2020-06-05T05:13:22Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "originalPosition": 116}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDAzMTE4", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-425003118", "createdAt": "2020-06-05T05:22:21Z", "commit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToyMjoyMVrOGfgw-Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToyMjoyMVrOGfgw-Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTg2NQ==", "bodyText": "How about adding a test case of the combination of none and true?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435695865", "createdAt": "2020-06-05T05:22:21Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "originalPosition": 132}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MDAzMTgz", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-425003183", "createdAt": "2020-06-05T05:22:33Z", "commit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToyMjozM1rOGfgxKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwNToyMjozM1rOGfgxKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTY5NTkxNA==", "bodyText": "How about adding a test case of the combination of all and true?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435695914", "createdAt": "2020-06-05T05:22:33Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,159 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        Path childOutFile = projectDir.resolve(\"child.out\").toAbsolutePath().normalize();\n+        prepareForChildWF(childOutFile);\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5e899ca2ad3760e3b946633f172ed6e9990a018f"}, "originalPosition": 139}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f5ff6f1b6c3163374558949d8dd861d8ab9f2749", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/f5ff6f1b6c3163374558949d8dd861d8ab9f2749", "committedDate": "2020-06-05T06:37:44Z", "message": "Improve project_name test in RequireIT."}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTI1NDg0", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-425125484", "createdAt": "2020-06-05T09:05:51Z", "commit": {"oid": "5c033679d7efbf4efb4f0ca8d3764a2453ae8ae2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowNTo1MVrOGfme4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowNTo1MVrOGfme4A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTUzNg==", "bodyText": "\ud83d\udcaf", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435789536", "createdAt": "2020-06-05T09:05:51Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/java/acceptance/RequireIT.java", "diffHunk": "@@ -185,6 +203,176 @@ public void testIgnoreProjectIdParam()\n         assertThat(success, is(true)); // --param project_id=-1 is ignored.\n     }\n \n+    /**\n+     * Test for project_id and project_name parameter\n+     *\n+     * @throws Exception\n+     */\n+    @Test\n+    public void testRequireToAnotherProject()\n+            throws Exception\n+    {\n+        final String childProjectName = \"child_another\";\n+\n+        // Push child project\n+        Path childProjectDir = folder.getRoot().toPath().resolve(\"another_foobar\");\n+        Files.createDirectories(childProjectDir);\n+        copyResource(\"acceptance/require/child_another_project.dig\", childProjectDir);\n+        CommandStatus pushChildStatus = main(\"push\",\n+                \"--project\", childProjectDir.toString(),\n+                childProjectName,\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushChildStatus.errUtf8(), pushChildStatus.code(), is(0));\n+\n+        // extract child project id\n+        Matcher m = Pattern.compile(\".*\\\\s+id:\\\\s+(\\\\d+).*\").matcher(pushChildStatus.outUtf8());\n+        assertThat(m.find(), is(true));\n+        String childProjectId = m.group(1);\n+\n+        // Push parent project\n+        Files.write(projectDir.resolve(\"parent_another_project.dig\"), asList(Resources.toString(\n+                Resources.getResource(\"acceptance/require/parent_another_project.dig\"), UTF_8)\n+                .replace(\"__CHILD_PROJECT_ID__\", childProjectId)\n+                .replace(\"__CHILD_PROJECT_NAME__\", childProjectName)));\n+        CommandStatus pushParentStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"parent_another\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint());\n+        assertThat(pushParentStatus.errUtf8(), pushParentStatus.code(), is(0));\n+\n+        CommandStatus startStatus = main(\"start\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"parent_another\", \"parent_another_project\",\n+                \"--session\", \"now\"\n+        );\n+        assertThat(startStatus.errUtf8(), startStatus.code(), is(0));\n+    }\n+\n+    @Test\n+    public void testRerunOnParam()\n+            throws Exception\n+    {\n+        // Create new project\n+        CommandStatus initStatus = main(\"init\",\n+                \"-c\", config.toString(),\n+                projectDir.toString());\n+        assertThat(initStatus.errUtf8(), initStatus.code(), is(0));\n+\n+        copyResource(\"acceptance/require/parent_rerun_on.dig\", projectDir.resolve(\"parent.dig\"));\n+        copyResource(\"acceptance/require/child_rerun_on.dig\", projectDir.resolve(\"child.dig\"));\n+\n+        // Push the project\n+        CommandStatus pushStatus = main(\"push\",\n+                \"--project\", projectDir.toString(),\n+                \"require\",\n+                \"-c\", config.toString(),\n+                \"-e\", server.endpoint(),\n+                \"-r\", \"4711\");\n+        assertThat(pushStatus.errUtf8(), pushStatus.code(), is(0));\n+\n+        // test for rerun_on: none and previous child succeeded. parent will succeed.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:01\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", false, true);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: none and previous child failed. parent will fail.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:02\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"none\", true, false);\n+            assertThat(\"Number of child's attempt must be one. (== require> skip the call)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+\n+        // test for rerun_on: all and previous child succeeded. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:11\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", false, true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: all and previous child failed. require> kick child always.\n+        {\n+            String sessionTime = \"2020-05-28 12:34:12\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"all\", true, true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt failed\n+        {\n+            String sessionTime = \"2020-05-28 12:34:21\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", true, true);\n+            assertThat(\"Number of child's attempt must be two. (== require> kick child)\", childAttempts.getAttempts().size(), is(2));\n+        }\n+\n+        // test for rerun_on: failed. previous child attempt succeeded\n+        {\n+            String sessionTime = \"2020-05-28 12:34:31\";\n+            RestSessionAttemptCollection childAttempts = testRerunOnParam(sessionTime, \"failed\", false, true);\n+            assertThat(\"Number of child's attempt must be one. (== require> kick)\", childAttempts.getAttempts().size(), is(1));\n+        }\n+    }\n+\n+    /**\n+     * Test for rerun_on\n+     *\n+     * @param sessionTime\n+     * @param rerunOn              parameter for rerun_on:  \"none\" or \"fail\" or \"all\"\n+     * @param previousChildRunFail if true, first child workflow failed.\n+     * @return\n+     * @throws InterruptedException\n+     */\n+    private RestSessionAttemptCollection testRerunOnParam(String sessionTime, String rerunOn, boolean previousChildRunFail, boolean expectParentSucceed) throws InterruptedException", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c033679d7efbf4efb4f0ca8d3764a2453ae8ae2"}, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTI1ODI5", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-425125829", "createdAt": "2020-06-05T09:06:22Z", "commit": {"oid": "5c033679d7efbf4efb4f0ca8d3764a2453ae8ae2"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowNjoyMlrOGfmf7w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNi0wNVQwOTowNjoyMlrOGfmf7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTgwNw==", "bodyText": "Empty line?", "url": "https://github.com/treasure-data/digdag/pull/1409#discussion_r435789807", "createdAt": "2020-06-05T09:06:22Z", "author": {"login": "komamitsu"}, "path": "digdag-tests/src/test/resources/acceptance/require/parent_rerun_on.dig", "diffHunk": "@@ -0,0 +1,6 @@\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "5c033679d7efbf4efb4f0ca8d3764a2453ae8ae2"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDI1MTI3NDU1", "url": "https://github.com/treasure-data/digdag/pull/1409#pullrequestreview-425127455", "createdAt": "2020-06-05T09:08:43Z", "commit": {"oid": "5c033679d7efbf4efb4f0ca8d3764a2453ae8ae2"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc449ed4351d8dfacde2312e7518f5431532a39f", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/bc449ed4351d8dfacde2312e7518f5431532a39f", "committedDate": "2020-06-08T05:50:51Z", "message": "Fix minor comment issue"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8d5a559f06d7832fff917464bcb329b8e0b5dcea", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/8d5a559f06d7832fff917464bcb329b8e0b5dcea", "committedDate": "2020-06-08T06:02:50Z", "message": "Enhance require> operator.\n\nIgnore retry_attempt_name from out of operator.\nIntroduce ignore_no_existence option.\nIntroduce return_on: (none,failed,all)."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "361f0be3a6217c724fc60c0bf5373cd9869d95d4", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/361f0be3a6217c724fc60c0bf5373cd9869d95d4", "committedDate": "2020-06-08T06:02:50Z", "message": "Update document."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "886213d28c5b0c06ea3d86ec3bcf22b3756012d6", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/886213d28c5b0c06ea3d86ec3bcf22b3756012d6", "committedDate": "2020-06-08T06:04:08Z", "message": "Integration test for require>"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "88ee5a12d662e804a857f41fb831c4d5906f0f2d", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/88ee5a12d662e804a857f41fb831c4d5906f0f2d", "committedDate": "2020-06-08T06:05:03Z", "message": "Remove ignore_no_existence and refactoring."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "60d546cb0237b70b1dcc23ba6c7edf9f4f8fe62c", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/60d546cb0237b70b1dcc23ba6c7edf9f4f8fe62c", "committedDate": "2020-06-08T06:05:03Z", "message": "Implement exponential backoff to reduce num of task retry."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "12e8fc167a2ff39ca09138e2d0ffc610bbad2ff1", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/12e8fc167a2ff39ca09138e2d0ffc610bbad2ff1", "committedDate": "2020-06-08T06:05:03Z", "message": "Refactoring based on review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "9f37b38c83fa4c4124f772187763d5b1a2c0070a", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/9f37b38c83fa4c4124f772187763d5b1a2c0070a", "committedDate": "2020-06-08T06:05:03Z", "message": "Refactoring based on review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6aa1f20780e028bb5b444eb9616ccf4993ed3ceb", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/6aa1f20780e028bb5b444eb9616ccf4993ed3ceb", "committedDate": "2020-06-08T06:05:22Z", "message": "Refactoring based on the review."}}, {"__typename": "PullRequestCommit", "commit": {"oid": "dd583ebbdda4e440879adc83f73c036471179cad", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/dd583ebbdda4e440879adc83f73c036471179cad", "committedDate": "2020-06-08T06:05:22Z", "message": "Cover all conditions in testRerunOnParam()."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "5c033679d7efbf4efb4f0ca8d3764a2453ae8ae2", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/5c033679d7efbf4efb4f0ca8d3764a2453ae8ae2", "committedDate": "2020-06-05T07:35:54Z", "message": "Cover all conditions in testRerunOnParam()."}, "afterCommit": {"oid": "dd583ebbdda4e440879adc83f73c036471179cad", "author": {"user": null}, "url": "https://github.com/treasure-data/digdag/commit/dd583ebbdda4e440879adc83f73c036471179cad", "committedDate": "2020-06-08T06:05:22Z", "message": "Cover all conditions in testRerunOnParam()."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4024, "cost": 1, "resetAt": "2021-11-01T16:37:27Z"}}}