{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDYzNTIxMTE3", "number": 2181, "title": "PLANNER-2087: Assign a time budget for the LS to execute", "bodyText": "", "createdAt": "2020-08-05T16:55:49Z", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181", "merged": true, "mergeCommit": {"oid": "e09ee879a319946707bc3a8e59fdb08a64431bcd"}, "closed": true, "closedAt": "2020-08-12T15:29:38Z", "author": {"login": "wmedvede"}, "timelineItems": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc8Mv4hABqjM2MjgyOTk4Nzk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc-FYdtAFqTQ2NTYyMTk2Ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "70446ea89c866132bb41319b6ea583e15df0d857", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/70446ea89c866132bb41319b6ea583e15df0d857", "committedDate": "2020-08-05T16:54:38Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}, "afterCommit": {"oid": "d788d67cb631acbc8c8841da04fbb1920320d1ec", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d788d67cb631acbc8c8841da04fbb1920320d1ec", "committedDate": "2020-08-06T09:47:10Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d788d67cb631acbc8c8841da04fbb1920320d1ec", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d788d67cb631acbc8c8841da04fbb1920320d1ec", "committedDate": "2020-08-06T09:47:10Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}, "afterCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/8744ee8013894c78258d26726e3da7de98aaeb95", "committedDate": "2020-08-06T12:57:46Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMTE1NTg2", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#pullrequestreview-463115586", "createdAt": "2020-08-07T08:06:29Z", "commit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QwODowNjozMFrOG9Ql7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0wN1QxMDo0MDoxMVrOG9VGpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njg4ODE3Mg==", "bodyText": "Could you please explain why the pool has exactly 4 threads?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466888172", "createdAt": "2020-08-07T08:06:30Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TaskAssigningPlanningKieServerExtension.java", "diffHunk": "@@ -154,7 +154,7 @@ public void init(KieServerImpl kieServer, KieServerRegistry registry) {\n             throw new KieServicesException(String.format(USER_SYSTEM_CONFIGURATION_ERROR, e.getMessage()), e);\n         }\n \n-        this.executorService = Executors.newFixedThreadPool(3);\n+        this.executorService = Executors.newScheduledThreadPool(4);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNTMyMw==", "bodyText": "Why not failing fast in the constructor if the usersSyncInterval is < 0 ?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466905323", "createdAt": "2020-08-07T08:41:36Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -263,11 +324,29 @@ Action doSynchronizeSolution() {\n     }\n \n     protected boolean isUsersSyncTime() {\n-        return System.currentTimeMillis() > nextUsersSyncTime;\n+        return nextUsersSyncTime > 0 && getSystemTime() > nextUsersSyncTime;\n     }\n \n     protected long calculateNextUsersSyncTime() {\n-        return System.currentTimeMillis() + usersSyncInterval.toMillis();\n+        if (usersSyncInterval.toMillis() > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 210}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkwNjU3NQ==", "bodyText": "Is it really necessary to accept negative or zero periods if we ignore them later? Why not failing fast?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466906575", "createdAt": "2020-08-07T08:44:09Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -119,12 +148,32 @@ public void initSolverExecutor() {\n         startPermit.release();\n     }\n \n+    /**\n+     * Starts the synchronization of the solution from the indicated last modification date.\n+     * @param solution a non null solution instance to synchronize.\n+     * @param fromLastModificationDate filtering parameter for reading the modifications.\n+     */\n     public void synchronizeSolution(TaskAssigningSolution solution, LocalDateTime fromLastModificationDate) {\n+        synchronizeSolution(solution, fromLastModificationDate, Duration.ofMillis(0));\n+    }\n+\n+    /**\n+     * Starts the synchronization of the solution from the indicated last modification date.\n+     * @param solution a non null solution instance to synchronize.\n+     * @param fromLastModificationDate filtering parameter for reading the modifications.\n+     * @param unchangedPeriodTimeout a non null period of time for returning from the synchronization if no changes were\n+     * produced during that period. A negative or zero period is ignored.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkxNjI5NQ==", "bodyText": "Suggestion: if the Result had nextAction field, we wouldn't need to use the generic Pair.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466916295", "createdAt": "2020-08-07T09:02:56Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -143,23 +192,18 @@ public void destroy() {\n     @Override\n     public void run() {\n         LOGGER.debug(\"Solution Synchronizer Started\");\n-        Action nextAction;\n+        Pair<Action, Result> nextActionOrResult;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkyODAwNw==", "bodyText": "Thinking aloud:\nDoes the firstLevelLocalSearchTime and secondLevelLocalSearchTime set expectations regarding which one blocks?\nHow about:\nwaitForImprovedSolutionDuration vs. improveSolutionOnBackgroundDuration", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466928007", "createdAt": "2020-08-07T09:26:12Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TaskAssigningConstants.java", "diffHunk": "@@ -91,6 +91,32 @@ private TaskAssigningConstants() {\n      */\n     public static final String TASK_ASSIGNING_USERS_SYNC_INTERVAL = \"org.kie.server.taskAssigning.usersSyncInterval\";\n \n+    /**\n+     * Property for configuring the amount of time to execute LS phase before sending any plan to the kie-server with\n+     * the jBPM runtime. Allows an early improvement of the solution. This value should typically be low, e.g. 500\n+     * milliseconds, etc.\n+     *\n+     * The formats accepted are based on the ISO-8601 duration format {@code PnDTnHnMn.nS} with days considered to\n+     * be exactly 24 hours.\n+     * <p>\n+     * e.g.\n+     * \"PT0.500S\"  configures 500 milliseconds.\n+     */\n+    public static final String TASK_ASSIGNING_FIRST_LEVEL_LOCAL_SEARCH_TIME = \"org.kie.server.taskAssigning.firstLevelLocalSearchTime\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMTc2Ng==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n          \n          \n            \n                private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n          \n      \n    \n    \n  \n\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n          \n          \n            \n                private void scheduleOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466931766", "createdAt": "2020-08-07T09:33:39Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -164,24 +177,84 @@ private void addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>\n      * @param event event produced by the solver.\n      */\n     private void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n-        LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {}, isCurrentChangeSetProcessed: {}\",\n-                     event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(), context.isProcessedChangeSet(context.getCurrentChangeSetId()));\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                                 \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                         event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                         context.isProcessedChangeSet(context.getCurrentChangeSetId()), event.getNewBestSolution());\n+        }\n+\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            lastBestSolution.set(newBestSolution);\n+            if (hasFirstLevelLocalSearchTime()) {\n+                scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());\n+            } else {\n+                onBestSolutionChange(newBestSolution);\n+            }\n+        }\n+    }\n \n-        if (event.isEveryProblemFactChangeProcessed() &&\n-                event.getNewBestSolution().getScore().isSolutionInitialized() &&\n-                !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n+    private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMjE1NA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());\n          \n          \n            \n                            scheduleOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466932154", "createdAt": "2020-08-07T09:34:29Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -164,24 +177,84 @@ private void addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>\n      * @param event event produced by the solver.\n      */\n     private void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n-        LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {}, isCurrentChangeSetProcessed: {}\",\n-                     event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(), context.isProcessedChangeSet(context.getCurrentChangeSetId()));\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                                 \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                         event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                         context.isProcessedChangeSet(context.getCurrentChangeSetId()), event.getNewBestSolution());\n+        }\n+\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            lastBestSolution.set(newBestSolution);\n+            if (hasFirstLevelLocalSearchTime()) {\n+                scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzMzk2Ng==", "bodyText": "The SolverHandlerContext already knows everything to be able to provide \"isProcessedCurrentChangeSet\". No need to ask it for the current changeset ID only to pass it back.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466933966", "createdAt": "2020-08-07T09:38:19Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -164,24 +177,84 @@ private void addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>\n      * @param event event produced by the solver.\n      */\n     private void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n-        LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {}, isCurrentChangeSetProcessed: {}\",\n-                     event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(), context.isProcessedChangeSet(context.getCurrentChangeSetId()));\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                                 \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                         event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                         context.isProcessedChangeSet(context.getCurrentChangeSetId()), event.getNewBestSolution());\n+        }\n+\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            lastBestSolution.set(newBestSolution);\n+            if (hasFirstLevelLocalSearchTime()) {\n+                scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());\n+            } else {\n+                onBestSolutionChange(newBestSolution);\n+            }\n+        }\n+    }\n \n-        if (event.isEveryProblemFactChangeProcessed() &&\n-                event.getNewBestSolution().getScore().isSolutionInitialized() &&\n-                !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n+    private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n+        if (scheduledFuture.get() == null && !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 137}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NjkzNTk5NA==", "bodyText": "Is the check for the same instance of a solution intended?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466935994", "createdAt": "2020-08-07T09:42:23Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -164,24 +177,84 @@ private void addProblemFactChanges(List<ProblemFactChange<TaskAssigningSolution>\n      * @param event event produced by the solver.\n      */\n     private void onBestSolutionChange(BestSolutionChangedEvent<TaskAssigningSolution> event) {\n-        LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {}, isCurrentChangeSetProcessed: {}\",\n-                     event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(), context.isProcessedChangeSet(context.getCurrentChangeSetId()));\n+        if (LOGGER.isDebugEnabled()) {\n+            LOGGER.debug(\"onBestSolutionChange: isEveryProblemFactChangeProcessed: {}, currentChangeSetId: {},\" +\n+                                 \" isCurrentChangeSetProcessed: {}, newBestSolution: {}\",\n+                         event.isEveryProblemFactChangeProcessed(), context.getCurrentChangeSetId(),\n+                         context.isProcessedChangeSet(context.getCurrentChangeSetId()), event.getNewBestSolution());\n+        }\n+\n+        TaskAssigningSolution newBestSolution = event.getNewBestSolution();\n+        if (event.isEveryProblemFactChangeProcessed() && newBestSolution.getScore().isSolutionInitialized()) {\n+            lastBestSolution.set(newBestSolution);\n+            if (hasFirstLevelLocalSearchTime()) {\n+                scheduledOnBestSolutionChange(newBestSolution, getFirstLevelLocalSearchTime().toMillis());\n+            } else {\n+                onBestSolutionChange(newBestSolution);\n+            }\n+        }\n+    }\n \n-        if (event.isEveryProblemFactChangeProcessed() &&\n-                event.getNewBestSolution().getScore().isSolutionInitialized() &&\n-                !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n+    private void scheduledOnBestSolutionChange(TaskAssigningSolution chBestSolution, long delay) {\n+        if (scheduledFuture.get() == null && !context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n             lock.lock();\n+            LOGGER.debug(\"Schedule execute solution change with previous chBestSolution: {}\", chBestSolution);\n             try {\n-                LOGGER.debug(\"A new solution has been produced for changeSetId: {}\", context.getCurrentChangeSetId());\n-                currentSolution = event.getNewBestSolution();\n-                context.setProcessedChangeSet(context.getCurrentChangeSetId());\n-                solutionProcessor.process(currentSolution);\n+                Supplier<TaskAssigningSolution> solutionSupplier = () -> lastBestSolution.get();\n+                ScheduledFuture<?> future = executorService.schedule(() -> executeSolutionChange(chBestSolution, solutionSupplier),\n+                                                                     delay,\n+                                                                     TimeUnit.MILLISECONDS);\n+                scheduledFuture.set(future);\n             } finally {\n                 lock.unlock();\n             }\n         }\n     }\n \n+    private void onBestSolutionChange(TaskAssigningSolution newBestSolution) {\n+        if (!context.isProcessedChangeSet(context.getCurrentChangeSetId())) {\n+            executeSolutionChange(newBestSolution);\n+        }\n+    }\n+\n+    private void executeSolutionChange(TaskAssigningSolution chBestSolution, Supplier<TaskAssigningSolution> solutionSupplier) {\n+        lock.lock();\n+        try {\n+            TaskAssigningSolution currentLastBestSolution = solutionSupplier.get();\n+            LOGGER.debug(\"Executing delayed solution change for currentChangeSetId: {}, lastBestSolution: {}, lastBestSolution: {}\",\n+                         context.getCurrentChangeSetId(), currentLastBestSolution.getScore(), currentLastBestSolution);\n+\n+            if (chBestSolution == currentLastBestSolution) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk1NzM0MA==", "bodyText": "Do we need the compound condition? Maybe we should send the new best solution if its score is better than the score of the current solution.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466957340", "createdAt": "2020-08-07T10:28:58Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandler.java", "diffHunk": "@@ -215,13 +295,32 @@ private void onSolutionProcessed(SolutionProcessor.Result result) {\n \n     /**\n      * Invoked every time the SolutionSynchronizer gets updated information from the jBPM runtime and there are changes\n-     * to apply.\n+     * to apply, or when the configurable amount of time with no changes has elapsed.\n      * @param result Contains the list of changes to apply.\n      */\n-    private void onUpdateSolution(SolutionSynchronizer.Result result) {\n+    private void onSolutionSynchronized(SolutionSynchronizer.Result result) {\n         lock.lock();\n         try {\n-            addProblemFactChanges(result.getChanges());\n+            if (result.hasChanges()) {\n+                addProblemFactChanges(result.getChanges());\n+            } else {\n+                LOGGER.debug(\"Processing synchronization unchanged period timeout. Checking if there is a\" +\n+                                     \" lastBestSolution with an improved score to send\");\n+                TaskAssigningSolution bestSolution = lastBestSolution.get();\n+                secondLevelSolutionSent.set(true);\n+                if (currentSolution.get() != bestSolution && !currentSolution.get().getScore().equals(bestSolution.getScore())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk1ODg0OQ==", "bodyText": "Why not start at 0?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466958849", "createdAt": "2020-08-07T10:32:30Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizerTest.java", "diffHunk": "@@ -57,6 +62,7 @@\n     private static final Duration SYNCH_INTERVAL = Duration.ofMillis(2);\n     private static final Duration USERS_SYNCH_INTERVAL = Duration.ofMillis(4000);\n     private static final Duration QUERY_SHIFT = Duration.parse(\"PT2S\");\n+    private static final long SYSTEM_TIME = 123;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 30}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Njk2MjA4Ng==", "bodyText": "If the goal is to test the propagation of the parameters to the SolverHandler, the assertion should be the other way around:\nassertThat(handler.getTargetUserId()).isEqualTo(TARGET_USER);\nPlease see the other tests too.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#discussion_r466962086", "createdAt": "2020-08-07T10:40:11Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolverHandlerTest.java", "diffHunk": "@@ -125,6 +149,62 @@ public void setUp() {\n         doReturn(solutionProcessor).when(handler).createSolutionProcessor(eq(delegate), any(), eq(TARGET_USER), anyInt());\n     }\n \n+    @After\n+    public void cleanUp() {\n+        System.clearProperty(TASK_ASSIGNING_PROCESS_RUNTIME_TARGET_USER);\n+        System.clearProperty(TASK_ASSIGNING_PUBLISH_WINDOW_SIZE);\n+        System.clearProperty(TASK_ASSIGNING_SYNC_INTERVAL);\n+        System.clearProperty(TASK_ASSIGNING_SYNC_QUERIES_SHIFT);\n+        System.clearProperty(TASK_ASSIGNING_USERS_SYNC_INTERVAL);\n+        System.clearProperty(TASK_ASSIGNING_FIRST_LEVEL_LOCAL_SEARCH_TIME);\n+        System.clearProperty(TASK_ASSIGNING_SECOND_LEVEL_LOCAL_SEARCH_TIME);\n+    }\n+\n+    @Test\n+    public void getTargetUserId() {\n+        assertThat(TARGET_USER).isEqualTo(handler.getTargetUserId());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95"}, "originalPosition": 118}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "8744ee8013894c78258d26726e3da7de98aaeb95", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/8744ee8013894c78258d26726e3da7de98aaeb95", "committedDate": "2020-08-06T12:57:46Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}, "afterCommit": {"oid": "d200a976c0cc13f6db9f73e57a53bf55ee239366", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d200a976c0cc13f6db9f73e57a53bf55ee239366", "committedDate": "2020-08-11T14:55:17Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8405abf152c66b506ac8625f71137c796076c693", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/8405abf152c66b506ac8625f71137c796076c693", "committedDate": "2020-08-12T04:44:11Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d200a976c0cc13f6db9f73e57a53bf55ee239366", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d200a976c0cc13f6db9f73e57a53bf55ee239366", "committedDate": "2020-08-11T14:55:17Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}, "afterCommit": {"oid": "8405abf152c66b506ac8625f71137c796076c693", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/8405abf152c66b506ac8625f71137c796076c693", "committedDate": "2020-08-12T04:44:11Z", "message": "PLANNER-2087: Assign a time budget for the LS to execute"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY1NjIxOTY2", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2181#pullrequestreview-465621966", "createdAt": "2020-08-12T06:25:38Z", "commit": {"oid": "8405abf152c66b506ac8625f71137c796076c693"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1319, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}