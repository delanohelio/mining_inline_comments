{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDU1NjU4Mzcz", "number": 2166, "title": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)", "bodyText": "", "createdAt": "2020-07-23T11:57:27Z", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166", "merged": true, "mergeCommit": {"oid": "49881d0a7e382b6d26d4c40a1576bcde86798b53"}, "closed": true, "closedAt": "2020-07-28T18:30:28Z", "author": {"login": "wmedvede"}, "timelineItems": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABc3xtv1ABqjM1ODA2OTY2Mjk=", "endCursor": "Y3Vyc29yOnYyOpPPAAABc5XFqZABqjM1OTQ1NzA0NTg=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e514a075b5ca944181c194ad1d45d9224a61a15c", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/e514a075b5ca944181c194ad1d45d9224a61a15c", "committedDate": "2020-07-23T09:32:31Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}, "afterCommit": {"oid": "d64b49dd44d24632a030917fae8eefff1d7f138b", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d64b49dd44d24632a030917fae8eefff1d7f138b", "committedDate": "2020-07-23T16:06:45Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d64b49dd44d24632a030917fae8eefff1d7f138b", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d64b49dd44d24632a030917fae8eefff1d7f138b", "committedDate": "2020-07-23T16:06:45Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}, "afterCommit": {"oid": "d0913622968397b74fb0f01c191769a02d5ceb9e", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d0913622968397b74fb0f01c191769a02d5ceb9e", "committedDate": "2020-07-27T14:39:13Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDU2NDYyMzE0", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#pullrequestreview-456462314", "createdAt": "2020-07-28T09:30:20Z", "commit": {"oid": "d0913622968397b74fb0f01c191769a02d5ceb9e"}, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQwOTozMDoyMFrOG4Ehqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0yOFQxMDoyNzo1OVrOG4GfjQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ0NzU5NQ==", "bodyText": "There is more precise matcher for this situation:\nhttp://joel-costigliola.github.io/assertj/core-8/api/org/assertj/core/api/AbstractAssert.html#isInstanceOf-java.lang.Class-", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#discussion_r461447595", "createdAt": "2020-07-28T09:30:20Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-api/src/test/java/org/kie/server/api/model/KieServerConfigProviderLoaderTest.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model;\n+\n+import java.util.List;\n+\n+import org.junit.Test;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+public class KieServerConfigProviderLoaderTest {\n+\n+    @Test\n+    public void getConfigProviders() {\n+        List<KieServerConfigProvider> providers = KieServerConfigProviderLoader.getConfigProviders();\n+        assertThat(providers.size()).isEqualTo(2);\n+        assertThat(providers.stream().anyMatch(provider -> provider instanceof KieServerConfigProvider1)).isTrue();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0913622968397b74fb0f01c191769a02d5ceb9e"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ1MTE4Mg==", "bodyText": "Is it worth the additional compile-time dependency? The StringUtils methods used in the PR seem to be easily replaceable.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#discussion_r461451182", "createdAt": "2020-07-28T09:36:02Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-optaplanner/pom.xml", "diffHunk": "@@ -70,6 +70,18 @@\n       <artifactId>slf4j-api</artifactId>\n     </dependency>\n \n+    <dependency>\n+      <groupId>org.apache.commons</groupId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0913622968397b74fb0f01c191769a02d5ceb9e"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3NTg3Nw==", "bodyText": "Soft suggestion: assigning solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig() to a local variable will make the following lines more readable", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#discussion_r461475877", "createdAt": "2020-07-28T10:20:09Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-optaplanner/src/test/java/org/kie/server/services/optaplanner/SolverServiceBaseTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.optaplanner;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+\n+import org.drools.core.impl.InternalKieContainer;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.kie.server.api.model.ServiceResponse;\n+import org.kie.server.api.model.instance.SolverInstance;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.impl.KieContainerInstanceImpl;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SolverServiceBaseTest {\n+\n+    private static final String CONTAINER_ID = \"CONTAINER_ID\";\n+    private static final String SOLVER_ID = \"SOLVER_ID\";\n+    private static final String SOLVER_CONFIG = \"org/kie/server/services/optaplanner/SolverConfig.xml\";\n+    private static final String SOLVER_CONFIG_WRONG = \"org/kie/server/services/optaplanner/SolverConfigWrong.xml\";\n+    private static final String SOLVER_CONFIG_GLOBAL_SCAN_SET = \"org/kie/server/services/optaplanner/SolverConfigGlobalScanSet.xml\";\n+    private static final String SOLVER_CONFIG_FILTERED_SCAN_SET = \"org/kie/server/services/optaplanner/SolverConfigFilteredScanSet.xml\";\n+\n+    private static final String PRE_CONFIGURED_PACKAGE_INCLUDE = \"pre.configured.package.include\";\n+    private static final String PRE_CONFIGURED_PACKAGE_EXCLUDE = \"pre.configured.package.exclude\";\n+\n+    private static final String CREATE_SOLVER_FOR_CONTAINER_ERROR = \"Failed to create solver for container %s\";\n+    private static final String CREATE_SOLVER_CONTAINER_NOT_EXISTS_ERROR = \"Failed to create solver. Container does not exist: %s\";\n+    private static final String CREATING_SOLVER_FACTORY_ERROR = \"Error creating solver factory for solver: %s\";\n+    private static final String SOLVER_ALREADY_EXISTS_ERROR = \"Failed to create solver. Solver '%s' already exists for container '%s'.\";\n+    private static final String SOLVER_CREATED_SUCCESSFULLY_MESSAGE = \"Solver '%s' successfully created in container '%s'\";\n+\n+    @Mock\n+    private KieServerRegistry context;\n+\n+    @Mock\n+    private ExecutorService executorService;\n+\n+    @Mock\n+    private SolverInstance solverInstance;\n+\n+    @Mock\n+    private KieContainerInstanceImpl containerInstance;\n+\n+    @Mock\n+    private InternalKieContainer internalKieContainer;\n+\n+    @Captor\n+    private ArgumentCaptor<SolverFactory<Object>> solverFactory;\n+\n+    @Mock\n+    private Solver<Object> solver;\n+\n+    private SolverServiceBase serviceBase;\n+\n+    @Before\n+    public void setUp() {\n+        solverInstance = new SolverInstance();\n+        solverInstance.setContainerId(CONTAINER_ID);\n+        solverInstance.setSolverId(SOLVER_ID);\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG);\n+\n+        doReturn(CONTAINER_ID).when(containerInstance).getContainerId();\n+        doReturn(internalKieContainer).when(containerInstance).getKieContainer();\n+        doReturn(getClass().getClassLoader()).when(internalKieContainer).getClassLoader();\n+        doReturn(containerInstance).when(context).getContainer(CONTAINER_ID);\n+\n+        serviceBase = spy(new SolverServiceBase(context, executorService));\n+    }\n+\n+    @Test\n+    public void createSolverWithInstanceNullFailure() {\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, null);\n+        assertFailure(response, String.format(CREATE_SOLVER_FOR_CONTAINER_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithConfigFileNullFailure() {\n+        solverInstance.setSolverConfigFile(null);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATE_SOLVER_FOR_CONTAINER_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithContainerNotExistsFailure() {\n+        when(context.getContainer(CONTAINER_ID)).thenReturn(null);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATE_SOLVER_CONTAINER_NOT_EXISTS_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithSolverConfigurationFileWrongFailure() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_WRONG);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATING_SOLVER_FACTORY_ERROR, \"\"));\n+    }\n+\n+    @Test\n+    public void createSolverWithErrorCreatingSolverFailure() {\n+        String internalError = \"An error was produced\";\n+        doThrow(new RuntimeException(internalError))\n+                .when(serviceBase)\n+                .newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+        assertFailure(response, String.format(CREATING_SOLVER_FACTORY_ERROR, internalError));\n+    }\n+\n+    @Test\n+    public void createSolverWithSolverAlreadyExistsFailure() {\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(SOLVER_ALREADY_EXISTS_ERROR, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithNoScanSetSuccessful() {\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithGlobalScanSetSuccessful() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_GLOBAL_SCAN_SET);\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(Arrays.asList(TestConfigProvider1.PACKAGE1,\n+                                                   TestConfigProvider1.PACKAGE2,\n+                                                   TestConfigProvider1.PACKAGE3,\n+                                                   TestConfigProvider2.PACKAGE1));\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithFilteredScanSetSuccessful() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_FILTERED_SCAN_SET);\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(Collections.singletonList(PRE_CONFIGURED_PACKAGE_INCLUDE),\n+                                     Arrays.asList(TestConfigProvider1.PACKAGE1,\n+                                                   TestConfigProvider1.PACKAGE2,\n+                                                   TestConfigProvider1.PACKAGE3,\n+                                                   TestConfigProvider2.PACKAGE1,\n+                                                   PRE_CONFIGURED_PACKAGE_EXCLUDE));\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    private void assertFailure(ServiceResponse<SolverInstance> response, String messagePrefix) {\n+        assertThat(response.getType()).isEqualTo(ServiceResponse.ResponseType.FAILURE);\n+        assertThat(response.getMsg()).startsWith(messagePrefix);\n+    }\n+\n+    private void assertSuccess(ServiceResponse<SolverInstance> response, String messagePrefix) {\n+        assertThat(response.getType()).isEqualTo(ServiceResponse.ResponseType.SUCCESS);\n+        assertThat(response.getMsg()).startsWith(messagePrefix);\n+    }\n+\n+    private void assertBuildFactoryWasInvoked(List<String> expectedExcludedPackages) {\n+        assertBuildFactoryWasInvoked(null, expectedExcludedPackages);\n+    }\n+\n+    private void assertBuildFactoryWasInvoked(List<String> expectedIncludedPackages, List<String> expectedExcludedPackages) {\n+        verify(serviceBase).newSolver(solverFactory.capture());\n+        if (expectedExcludedPackages != null) {\n+            assertThat(solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig()).isNotNull();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0913622968397b74fb0f01c191769a02d5ceb9e"}, "originalPosition": 208}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTQ3OTgyMQ==", "bodyText": "Soft suggestion: if the goal is to verify the list contains all items of the expected list and nothing else, there is either containsExactlyElementsOf or containsExactlyInAnyOrderElementsOf - depends whether you care about element order in the collections.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2166#discussion_r461479821", "createdAt": "2020-07-28T10:27:59Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-optaplanner/src/test/java/org/kie/server/services/optaplanner/SolverServiceBaseTest.java", "diffHunk": "@@ -0,0 +1,220 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.optaplanner;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+\n+import org.drools.core.impl.InternalKieContainer;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.kie.server.api.model.ServiceResponse;\n+import org.kie.server.api.model.instance.SolverInstance;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.impl.KieContainerInstanceImpl;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.doThrow;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class SolverServiceBaseTest {\n+\n+    private static final String CONTAINER_ID = \"CONTAINER_ID\";\n+    private static final String SOLVER_ID = \"SOLVER_ID\";\n+    private static final String SOLVER_CONFIG = \"org/kie/server/services/optaplanner/SolverConfig.xml\";\n+    private static final String SOLVER_CONFIG_WRONG = \"org/kie/server/services/optaplanner/SolverConfigWrong.xml\";\n+    private static final String SOLVER_CONFIG_GLOBAL_SCAN_SET = \"org/kie/server/services/optaplanner/SolverConfigGlobalScanSet.xml\";\n+    private static final String SOLVER_CONFIG_FILTERED_SCAN_SET = \"org/kie/server/services/optaplanner/SolverConfigFilteredScanSet.xml\";\n+\n+    private static final String PRE_CONFIGURED_PACKAGE_INCLUDE = \"pre.configured.package.include\";\n+    private static final String PRE_CONFIGURED_PACKAGE_EXCLUDE = \"pre.configured.package.exclude\";\n+\n+    private static final String CREATE_SOLVER_FOR_CONTAINER_ERROR = \"Failed to create solver for container %s\";\n+    private static final String CREATE_SOLVER_CONTAINER_NOT_EXISTS_ERROR = \"Failed to create solver. Container does not exist: %s\";\n+    private static final String CREATING_SOLVER_FACTORY_ERROR = \"Error creating solver factory for solver: %s\";\n+    private static final String SOLVER_ALREADY_EXISTS_ERROR = \"Failed to create solver. Solver '%s' already exists for container '%s'.\";\n+    private static final String SOLVER_CREATED_SUCCESSFULLY_MESSAGE = \"Solver '%s' successfully created in container '%s'\";\n+\n+    @Mock\n+    private KieServerRegistry context;\n+\n+    @Mock\n+    private ExecutorService executorService;\n+\n+    @Mock\n+    private SolverInstance solverInstance;\n+\n+    @Mock\n+    private KieContainerInstanceImpl containerInstance;\n+\n+    @Mock\n+    private InternalKieContainer internalKieContainer;\n+\n+    @Captor\n+    private ArgumentCaptor<SolverFactory<Object>> solverFactory;\n+\n+    @Mock\n+    private Solver<Object> solver;\n+\n+    private SolverServiceBase serviceBase;\n+\n+    @Before\n+    public void setUp() {\n+        solverInstance = new SolverInstance();\n+        solverInstance.setContainerId(CONTAINER_ID);\n+        solverInstance.setSolverId(SOLVER_ID);\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG);\n+\n+        doReturn(CONTAINER_ID).when(containerInstance).getContainerId();\n+        doReturn(internalKieContainer).when(containerInstance).getKieContainer();\n+        doReturn(getClass().getClassLoader()).when(internalKieContainer).getClassLoader();\n+        doReturn(containerInstance).when(context).getContainer(CONTAINER_ID);\n+\n+        serviceBase = spy(new SolverServiceBase(context, executorService));\n+    }\n+\n+    @Test\n+    public void createSolverWithInstanceNullFailure() {\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, null);\n+        assertFailure(response, String.format(CREATE_SOLVER_FOR_CONTAINER_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithConfigFileNullFailure() {\n+        solverInstance.setSolverConfigFile(null);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATE_SOLVER_FOR_CONTAINER_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithContainerNotExistsFailure() {\n+        when(context.getContainer(CONTAINER_ID)).thenReturn(null);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATE_SOLVER_CONTAINER_NOT_EXISTS_ERROR, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithSolverConfigurationFileWrongFailure() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_WRONG);\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(CREATING_SOLVER_FACTORY_ERROR, \"\"));\n+    }\n+\n+    @Test\n+    public void createSolverWithErrorCreatingSolverFailure() {\n+        String internalError = \"An error was produced\";\n+        doThrow(new RuntimeException(internalError))\n+                .when(serviceBase)\n+                .newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+        assertFailure(response, String.format(CREATING_SOLVER_FACTORY_ERROR, internalError));\n+    }\n+\n+    @Test\n+    public void createSolverWithSolverAlreadyExistsFailure() {\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertFailure(response, String.format(SOLVER_ALREADY_EXISTS_ERROR, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithNoScanSetSuccessful() {\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(null);\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithGlobalScanSetSuccessful() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_GLOBAL_SCAN_SET);\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(Arrays.asList(TestConfigProvider1.PACKAGE1,\n+                                                   TestConfigProvider1.PACKAGE2,\n+                                                   TestConfigProvider1.PACKAGE3,\n+                                                   TestConfigProvider2.PACKAGE1));\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    @Test\n+    public void createSolverWithFilteredScanSetSuccessful() {\n+        solverInstance.setSolverConfigFile(SOLVER_CONFIG_FILTERED_SCAN_SET);\n+        doReturn(solver).when(serviceBase).newSolver(any(SolverFactory.class));\n+\n+        ServiceResponse<SolverInstance> response = serviceBase.createSolver(CONTAINER_ID, SOLVER_ID, solverInstance);\n+        assertBuildFactoryWasInvoked(Collections.singletonList(PRE_CONFIGURED_PACKAGE_INCLUDE),\n+                                     Arrays.asList(TestConfigProvider1.PACKAGE1,\n+                                                   TestConfigProvider1.PACKAGE2,\n+                                                   TestConfigProvider1.PACKAGE3,\n+                                                   TestConfigProvider2.PACKAGE1,\n+                                                   PRE_CONFIGURED_PACKAGE_EXCLUDE));\n+        assertSuccess(response, String.format(SOLVER_CREATED_SUCCESSFULLY_MESSAGE, SOLVER_ID, CONTAINER_ID));\n+    }\n+\n+    private void assertFailure(ServiceResponse<SolverInstance> response, String messagePrefix) {\n+        assertThat(response.getType()).isEqualTo(ServiceResponse.ResponseType.FAILURE);\n+        assertThat(response.getMsg()).startsWith(messagePrefix);\n+    }\n+\n+    private void assertSuccess(ServiceResponse<SolverInstance> response, String messagePrefix) {\n+        assertThat(response.getType()).isEqualTo(ServiceResponse.ResponseType.SUCCESS);\n+        assertThat(response.getMsg()).startsWith(messagePrefix);\n+    }\n+\n+    private void assertBuildFactoryWasInvoked(List<String> expectedExcludedPackages) {\n+        assertBuildFactoryWasInvoked(null, expectedExcludedPackages);\n+    }\n+\n+    private void assertBuildFactoryWasInvoked(List<String> expectedIncludedPackages, List<String> expectedExcludedPackages) {\n+        verify(serviceBase).newSolver(solverFactory.capture());\n+        if (expectedExcludedPackages != null) {\n+            assertThat(solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig()).isNotNull();\n+            assertThat(solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig().getPackageExcludeList()).hasSize(expectedExcludedPackages.size());\n+            assertThat(solverFactory.getValue().getSolverConfig().getScanAnnotatedClassesConfig().getPackageExcludeList()).containsAll(expectedExcludedPackages);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d0913622968397b74fb0f01c191769a02d5ceb9e"}, "originalPosition": 210}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "d0913622968397b74fb0f01c191769a02d5ceb9e", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/d0913622968397b74fb0f01c191769a02d5ceb9e", "committedDate": "2020-07-27T14:39:13Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}, "afterCommit": {"oid": "91df80ea50ec2db8dbbfe515dc9d47551494a3e5", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/91df80ea50ec2db8dbbfe515dc9d47551494a3e5", "committedDate": "2020-07-28T13:59:16Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "5a3d9621adb1e36d68d1d7c918d4212cc4c6e5f4", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/5a3d9621adb1e36d68d1d7c918d4212cc4c6e5f4", "committedDate": "2020-07-28T14:13:16Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "91df80ea50ec2db8dbbfe515dc9d47551494a3e5", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/91df80ea50ec2db8dbbfe515dc9d47551494a3e5", "committedDate": "2020-07-28T13:59:16Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}, "afterCommit": {"oid": "5a3d9621adb1e36d68d1d7c918d4212cc4c6e5f4", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/5a3d9621adb1e36d68d1d7c918d4212cc4c6e5f4", "committedDate": "2020-07-28T14:13:16Z", "message": "PLANNER-2068: KIE server can't handle OptaPlanner solver configs that use scanAnnotatedClasses when new task assignment extension is in classpath (regression)"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1309, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}