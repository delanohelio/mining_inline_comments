{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNTA5MTc1", "number": 2059, "title": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned", "bodyText": "", "createdAt": "2020-04-07T21:21:53Z", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059", "merged": true, "mergeCommit": {"oid": "3846c08bf38e3d8fd449023bbbe105f2c95b3652"}, "closed": true, "closedAt": "2020-04-09T06:49:45Z", "author": {"login": "wmedvede"}, "timelineItems": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcViT1sAH2gAyNDAwNTA5MTc1OjA3MWUyZmNkMmZmNjAzOGJmODAyOGMwYWRmYTJhMzNjYTdlMTk0ZTY=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcVlIB6gFqTM4OTgzNzgxNA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "committedDate": "2020-04-08T06:56:56Z", "message": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "74d4d95cce3cae869d5a62013b17fffd5e58bbc0", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/74d4d95cce3cae869d5a62013b17fffd5e58bbc0", "committedDate": "2020-04-07T16:55:28Z", "message": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned"}, "afterCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6", "committedDate": "2020-04-08T06:56:56Z", "message": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NzI4OTQ5", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#pullrequestreview-389728949", "createdAt": "2020-04-08T07:47:45Z", "commit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo0Nzo0NVrOGCi_ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo1NTo1MlrOGCjSSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyMzY4Mw==", "bodyText": "Nitpicking: multiline comment is more suitable here for easier readability.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405323683", "createdAt": "2020-04-08T07:47:45Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizerTest.java", "diffHunk": "@@ -142,17 +156,41 @@ public void synchronizeSolution() throws Exception {\n         // wait for the query executions to happen\n         queryExecutionsCountDown.await();\n \n-        //execution0: initial query execution was ok, but result0 has no results.\n-        verify(delegate).findTasks(anyList(), eq(startTime.withNano(0)), anyObject());\n-        //execution1: next retry is with result0.queryTime, but result1 hs no results.\n-        verify(delegate).findTasks(anyList(), eq(results.get(0).getQueryTime().withNano(0)), anyObject());\n-        //execution2: next retry is with result1.queryTime, but result2 has no results.\n-        verify(delegate).findTasks(anyList(), eq(results.get(1).getQueryTime().withNano(0)), anyObject());\n-        //execution3: next retry is with result2.queryTime. but execution3 and execution4 failed.\n-        verify(delegate, times(3)).findTasks(anyList(), eq(results.get(2).getQueryTime().withNano(0)), anyObject());\n-        //execution5: executed ok., but result5 has no results. next retry is with result5.queryTime\n-        verify(delegate).findTasks(anyList(), eq(results.get(5).getQueryTime().withNano(0)), anyObject());\n-        //result6, executed ok and produced changes.\n+        // initial setup queryTimes -> [startTime]\n+        // execution0:\n+        //    execute query with lastModification = startTime\n+        //    execution was ok, but result0 has no results.\n+        //    nextQueryTime = startTime since minimum distance with result0.getQueryTime() is not met -> queryTimes -> [startTime, startTime]\n+        // execution1:\n+        //     execute query with lastModification = startTime\n+        //     execution is ok, but result1 has no values.\n+        //     nextQueryTime = result1.getQueryTime() since minimum distance with startTime is met -> [startTime, result1.getQueryTime()]\n+        // execution2:\n+        //     execute query with lastModification = startTime\n+        //     execution is ok, but result2 has no values.\n+        //     nextQueryTime = result1.getQueryTime() since minimum distance with result2.getQueryTime() is not met -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution3:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution fails.\n+        //     a retry is produced. -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution4:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution fails.\n+        //     a retry is produced. -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution5:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution is ok, but result5 has no values\n+        //     nextQueryTime = result5.getQueryTime() since minimum distance with result1.getQueryTime() is met -> [result1.getQueryTime(), result5.getQueryTime()]\n+        // execution6:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution is ok, and result6 has values!\n+        //     nextQueryTime = result6.getQueryTime() since minimum distance is met -> [result5.getQueryTime(), result6.getQueryTime()]\n+        //     End of loop since results are produced.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "originalPosition": 103}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyNjQ1MA==", "bodyText": "I think the forEach can be called directly from the stream, right after the map call.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405326450", "createdAt": "2020-04-08T07:52:31Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandlerContext.java", "diffHunk": "@@ -49,11 +67,113 @@ public void clearProcessedChangeSet() {\n         lastProcessedChangeSetId = -1;\n     }\n \n-    public LocalDateTime getLastModificationDate() {\n-        return lastModificationDate;\n+    /**\n+     * Registers the time of the last change processed for a task.\n+     * @param taskId identifier of the task to register.\n+     * @param changeTime the task change time to register.\n+     */\n+    public void setTaskChangeTime(long taskId, LocalDateTime changeTime) {\n+        taskChangeTimes.put(taskId, changeTime);\n+    }\n+\n+    /**\n+     * Indicates if a change has already been processed for a given task.\n+     * @param taskId identifier of the task to query.\n+     * @param changeTime the task change time to query.\n+     * @return true if the change has already been processed, false in any other case.\n+     */\n+    public boolean isProcessedTaskChange(long taskId, LocalDateTime changeTime) {\n+        return changeTime.equals(taskChangeTimes.get(taskId));\n+    }\n+\n+    /**\n+     * Removes all the registered task change times that occurred strictly before a given time.\n+     * @param untilLocalDateTime the time for filtering the changes to remove.\n+     */\n+    public void clearTaskChangeTimes(LocalDateTime untilLocalDateTime) {\n+        if (untilLocalDateTime != null) {\n+            final List<Long> removableChanges = taskChangeTimes.entrySet().stream()\n+                    .filter(entry -> untilLocalDateTime.compareTo(entry.getValue()) > 0)\n+                    .map(Map.Entry::getKey)\n+                    .collect(Collectors.toList());\n+            removableChanges.forEach(removableChange -> taskChangeTimes.remove(removableChange));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyODQ1OQ==", "bodyText": "SonarCloud complains about potential NPE due to nextQueryTime might be null.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405328459", "createdAt": "2020-04-08T07:55:52Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -240,7 +249,14 @@ private TaskAssigningSolution recoverSolution() {\n                                                                                                      Suspended),\n                                                                                        null,\n                                                                                        TaskInputVariablesReadMode.READ_FOR_ALL);\n-        context.setLastModificationDate(result.getQueryTime());\n+\n+        final LocalDateTime nextQueryTime = trimMillis(result.getQueryTime());\n+        final LocalDateTime adjustedFirstQueryTime = nextQueryTime != null ? nextQueryTime.minusHours(1) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "originalPosition": 42}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "232ce7f9a096f252b1e59df3cbffa66d0d6910cd", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/232ce7f9a096f252b1e59df3cbffa66d0d6910cd", "committedDate": "2020-04-08T09:00:02Z", "message": "PLANNER-1943: [Task assignment] Ensure previous query time is used when synchronization is re-runned\n    - Revision suggestions I"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5ODM3ODE0", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#pullrequestreview-389837814", "createdAt": "2020-04-08T10:13:45Z", "commit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1380, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}