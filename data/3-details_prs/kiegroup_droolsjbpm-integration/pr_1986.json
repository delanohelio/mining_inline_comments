{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY0NTU5MzMx", "number": 1986, "title": "PLANNER-1627: Planning Server iteration #2 (target architecture)", "bodyText": "- Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774", "createdAt": "2020-01-19T17:47:28Z", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986", "merged": true, "mergeCommit": {"oid": "24ca78c763635a7de5e3cf266ff717ab329a65c7"}, "closed": true, "closedAt": "2020-02-28T13:17:05Z", "author": {"login": "wmedvede"}, "timelineItems": {"totalCount": 25, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb7-EOBgFqTM0NTAyMzAxMw==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcIictAAFqTM2NjAyMTY1Nw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ1MDIzMDEz", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-345023013", "createdAt": "2020-01-19T20:09:57Z", "commit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "state": "COMMENTED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQyMDowOTo1OFrOFfQYVA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0xOVQyMDozMjozOVrOFfQflQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODU0OA==", "bodyText": "I'm not sure why this class is necessary. The same effect should be achievable by adding the following to package-info.java:\n@XmlJavaTypeAdapters({\n    @XmlJavaTypeAdapter(type = LocalDateTime.class, value = LocalDateTimeXmlAdapter.class)\n})", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318548", "createdAt": "2020-01-19T20:09:58Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/LocalDateTimeValue.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.time.LocalDateTime;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.adapters.XmlJavaTypeAdapter;\n+\n+import org.kie.internal.jaxb.LocalDateTimeXmlAdapter;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"local-date-time-value\")\n+public class LocalDateTimeValue {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODY0Nw==", "bodyText": "10 minutes seems to me to be far too long for anything.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318647", "createdAt": "2020-01-19T20:11:54Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.KieServerConstants;\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());\n+    }\n+\n+    static KieServicesClient createKieServicesClient(final String endpoint,\n+                                                     final String login,\n+                                                     final String password) {\n+\n+        final KieServicesConfiguration configuration = KieServicesFactory.newRestConfiguration(endpoint, login, password);\n+        configuration.setTimeout(600000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODcxMA==", "bodyText": "I think you can use Collections.singletonMap().", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318710", "createdAt": "2020-01-19T20:13:02Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/helper/TaskAssigningRuntimeServicesClientBuilder.java", "diffHunk": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.helper;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.kie.server.client.KieServicesConfiguration;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+import org.kie.server.client.impl.TaskAssigningRuntimeClientImpl;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeServicesClientBuilder implements KieServicesClientBuilder {\n+\n+    @Override\n+    public String getImplementedCapability() {\n+        return CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+    }\n+\n+    @Override\n+    public Map<Class<?>, Object> build(KieServicesConfiguration configuration, ClassLoader classLoader) {\n+        final Map<Class<?>, Object> services = new HashMap<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODc3MQ==", "bodyText": "Can we get away with this? Is it normal that some KIE server components would not implement JMS, only REST?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318771", "createdAt": "2020-01-19T20:13:53Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/impl/TaskAssigningRuntimeClientImpl.java", "diffHunk": "@@ -0,0 +1,144 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.impl;\n+\n+import java.time.LocalDateTime;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.kie.server.api.exception.KieServicesException;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.api.rest.RestURI;\n+import org.kie.server.client.KieServicesConfiguration;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_LAST_MODIFICATION_DATE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_TASK_ID;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE_SIZE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.STATUS;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TASK_INPUT_VARIABLES_MODE;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_EXECUTE_PLANNING_URI;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_QUERIES_TASK_DATA_URI;\n+import static org.kie.server.api.model.taskassigning.TaskAssigningRestURI.TASK_ASSIGNING_RUNTIME_URI;\n+\n+public class TaskAssigningRuntimeClientImpl extends AbstractKieServicesClientImpl implements TaskAssigningRuntimeClient {\n+\n+    public TaskAssigningRuntimeClientImpl(KieServicesConfiguration config) {\n+        super(config);\n+    }\n+\n+    public TaskAssigningRuntimeClientImpl(KieServicesConfiguration config, ClassLoader classLoader) {\n+        super(config, classLoader);\n+    }\n+\n+    @Override\n+    public ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId) {\n+        if (config.isRest()) {\n+            final String uri = TASK_ASSIGNING_RUNTIME_URI + \"/\" + TASK_ASSIGNING_EXECUTE_PLANNING_URI + \"?user=\" + userId;\n+            return makeHttpPostRequestAndCreateCustomResponse(RestURI.build(loadBalancer.getUrl(),\n+                                                                            uri,\n+                                                                            Collections.emptyMap()),\n+                                                              planningItemList,\n+                                                              ExecutePlanningResult.class);\n+        } else {\n+            throw new KieServicesException(\"JMS protocol is not implemented for this service.\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 65}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxODk0Nw==", "bodyText": "Would you please explain (possibly in comments) the logic of this loop?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368318947", "createdAt": "2020-01-19T20:16:09Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.util;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+public class TaskDataReader {\n+\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    private TaskDataReader(TaskAssigningRuntimeClient runtimeClient) {\n+        this.runtimeClient = runtimeClient;\n+    }\n+\n+    public static class Result {\n+\n+        LocalDateTime queryTime;\n+\n+        List<TaskData> tasks;\n+\n+        private Result(LocalDateTime queryTime, List<TaskData> tasks) {\n+            this.queryTime = queryTime;\n+            this.tasks = tasks;\n+        }\n+\n+        public LocalDateTime getQueryTime() {\n+            return queryTime;\n+        }\n+\n+        public List<TaskData> getTasks() {\n+            return tasks;\n+        }\n+    }\n+\n+    public static TaskDataReader from(TaskAssigningRuntimeClient runtimeClient) {\n+        return new TaskDataReader(runtimeClient);\n+    }\n+\n+    public Result readTasks(long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,\n+                            int pageSize, TaskInputVariablesReadMode taskInputVariablesReadMode) {\n+        final List<TaskData> result = new ArrayList<>();\n+        boolean finished = false;\n+        List<TaskData> partialResult;\n+        TaskDataList taskDataList;\n+        TaskData lastItem = null;\n+        LocalDateTime queryTime = null;\n+\n+        long taskId = fromTaskId;\n+        int nextPageSize = pageSize;\n+        while (!finished) {\n+            taskDataList = runtimeClient.findTasks(taskId, status, fromLastModificationDate,\n+                                                   0, nextPageSize, taskInputVariablesReadMode);\n+            partialResult = new ArrayList<>(taskDataList.getItems());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTQxMw==", "bodyText": "Would you consider switching to constraint streams? The task assigning Optaplanner example already has a ConstraintProvider implementation that could hopefully be reused.\n(It needn't be done now, just something to consider. The API is easier to work with than DRL and we would like to promote it more in the future.)", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319413", "createdAt": "2020-01-19T20:21:35Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-core/src/main/resources/org/kie/server/services/taskassigning/solver/taskAssigningDefaultSolverConfig.xml", "diffHunk": "@@ -0,0 +1,14 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<solver>\n+\n+  <solutionClass>org.kie.server.services.taskassigning.core.model.TaskAssigningSolution</solutionClass>\n+  <entityClass>org.kie.server.services.taskassigning.core.model.TaskOrUser</entityClass>\n+  <entityClass>org.kie.server.services.taskassigning.core.model.Task</entityClass>\n+\n+  <daemon>true</daemon>\n+\n+  <scoreDirectorFactory>\n+    <scoreDrl>org/kie/server/services/taskassigning/solver/taskAssigningScoreRules.drl</scoreDrl>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 11}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTYxMA==", "bodyText": "This method is very long. I think it would be good to split it into a couple sub-methods.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319610", "createdAt": "2020-01-19T20:23:48Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionChangesBuilder.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AddTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.ReleaseTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.RemoveTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.TaskPropertyChangeProblemFactChange;\n+import org.kie.server.services.taskassigning.user.system.api.UserSystemService;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.DUMMY_TASK_PLANNER_241;\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.PLANNING_USER;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Completed;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Error;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Exited;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Failed;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Obsolete;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+import static org.kie.server.services.taskassigning.planning.SolutionBuilder.addInOrder;\n+import static org.kie.server.services.taskassigning.planning.SolutionBuilder.fromTaskData;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.fromExternalUser;\n+\n+/**\n+ * This class performs the calculation of the impact (i.e. the set of changes to be applied) on a solution given the\n+ * updated information about the tasks in the jBPM runtime.\n+ */\n+public class SolutionChangesBuilder {\n+\n+    private static Logger LOGGER = LoggerFactory.getLogger(SolutionChangesBuilder.class);\n+\n+    private TaskAssigningSolution solution;\n+\n+    private List<TaskData> taskDataList;\n+\n+    private UserSystemService systemService;\n+\n+    private SolverHandlerContext context;\n+\n+    public SolutionChangesBuilder() {\n+    }\n+\n+    public SolutionChangesBuilder withSolution(TaskAssigningSolution solution) {\n+        this.solution = solution;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withTasks(List<TaskData> taskDataList) {\n+        this.taskDataList = taskDataList;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withUserSystem(UserSystemService userSystemService) {\n+        this.systemService = userSystemService;\n+        return this;\n+    }\n+\n+    public SolutionChangesBuilder withContext(SolverHandlerContext context) {\n+        this.context = context;\n+        return this;\n+    }\n+\n+    public List<ProblemFactChange<TaskAssigningSolution>> build() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 97}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTc1Ng==", "bodyText": "Another very long and cryptic method.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319756", "createdAt": "2020-01-19T20:25:26Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -0,0 +1,234 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.time.LocalDateTime;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.function.Consumer;\n+\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.user.system.api.UserSystemService;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manages the periodical reading (polling strategy) of current tasks from the jBPM runtime and depending\n+ * on the \"action\" INIT_SOLVER_EXECUTOR / SYNCHRONIZE_SOLUTION determines if the solver executor must be restarted with\n+ * a fully recovered solution or instead the tasks updated information is used for calculating the required changes\n+ * for the proper solution update. If any changes are calculated they are notified to the resultConsumer.\n+ * This class implements proper retries in case of connection issues with the target jBPM runtime, etc.\n+ */\n+public class SolutionSynchronizer extends RunnableBase {\n+\n+    public static final int INIT_SOLVER_EXECUTOR = 0;\n+    public static final int SYNCHRONIZE_SOLUTION = 1;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionSynchronizer.class);\n+\n+    private final SolverExecutor solverExecutor;\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final UserSystemService userSystemService;\n+    private final long syncInterval;\n+    private final SolverHandlerContext context;\n+    private final Consumer<Result> resultConsumer;\n+    private int solverExecutorStarts = 0;\n+    private TaskAssigningSolution solution;\n+    private LocalDateTime fromLastModificationDate;\n+    private int action = INIT_SOLVER_EXECUTOR;\n+\n+    private final Semaphore startPermit = new Semaphore(0);\n+\n+    public static class Result {\n+\n+        private List<ProblemFactChange<TaskAssigningSolution>> changes;\n+\n+        public Result(List<ProblemFactChange<TaskAssigningSolution>> changes) {\n+            this.changes = changes;\n+        }\n+\n+        public List<ProblemFactChange<TaskAssigningSolution>> getChanges() {\n+            return changes;\n+        }\n+    }\n+\n+    public SolutionSynchronizer(final SolverExecutor solverExecutor,\n+                                final TaskAssigningRuntimeDelegate delegate,\n+                                final UserSystemService userSystem,\n+                                final long syncInterval,\n+                                final SolverHandlerContext context,\n+                                final Consumer<Result> resultConsumer) {\n+        checkNotNull(\"solverExecutor\", solverExecutor);\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"userSystem\", userSystem);\n+        checkCondition(\"syncInterval\", syncInterval > 0);\n+        checkNotNull(\"context\", context);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+\n+        this.solverExecutor = solverExecutor;\n+        this.delegate = delegate;\n+        this.userSystemService = userSystem;\n+        this.syncInterval = syncInterval;\n+        this.context = context;\n+        this.resultConsumer = resultConsumer;\n+    }\n+\n+    public void initSolverExecutor() {\n+        this.action = INIT_SOLVER_EXECUTOR;\n+        startPermit.release();\n+    }\n+\n+    public void synchronizeSolution(TaskAssigningSolution solution, LocalDateTime fromLastModificationDate) {\n+        this.solution = solution;\n+        this.fromLastModificationDate = fromLastModificationDate;\n+        this.action = SYNCHRONIZE_SOLUTION;\n+        LOGGER.debug(\"Start synchronizeSolution fromLastModificationDate: \" + fromLastModificationDate);\n+        startPermit.release();\n+    }\n+\n+    /**\n+     * Starts the synchronizing finalization, that will be produced as soon as possible.\n+     * It's a non thread-safe method, but only first invocation has effect.\n+     */\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        startPermit.release(); //in case it's waiting for start.\n+    }\n+\n+    @Override\n+    public void run() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 126}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg==", "bodyText": "Have you considered using the new SolverManager API? It was designed for use cases such as yours, and I think it would save you a lot of code in the parts where you run/synchronize the solver.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368319852", "createdAt": "2020-01-19T20:26:42Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.time.LocalDateTime;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+\n+public interface TaskAssigningRuntimeClient {\n+\n+    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMyMDQwNQ==", "bodyText": "Did we ever consider what happens on Websphere, Weblogic and Tomcat?\n(I'm not sure we're being asked to deliver those. Traditionally, we would have been. A question for PM, perhaps?)", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r368320405", "createdAt": "2020-01-19T20:32:39Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/main/java/org/kie/server/services/taskassigning/user/system/simple/WildflyUtil.java", "diffHunk": "@@ -0,0 +1,114 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.user.system.simple;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.nio.file.Files;\n+import java.nio.file.Paths;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.io.IOUtils;\n+import org.kie.server.services.taskassigning.user.system.api.Group;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+\n+import static org.apache.commons.lang3.StringUtils.isEmpty;\n+\n+public class WildflyUtil {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 39}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/64260a2898b6386a3da061fdf31cf36d7775d6be", "committedDate": "2020-01-19T17:14:51Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}, "afterCommit": {"oid": "e3481e09293a730bebdaa38e8399cf36fefe4916", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/e3481e09293a730bebdaa38e8399cf36fefe4916", "committedDate": "2020-01-20T16:00:56Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e3481e09293a730bebdaa38e8399cf36fefe4916", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/e3481e09293a730bebdaa38e8399cf36fefe4916", "committedDate": "2020-01-20T16:00:56Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}, "afterCommit": {"oid": "15d5275064a5fb2238fdf246bb7a52e5ff186bba", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/15d5275064a5fb2238fdf246bb7a52e5ff186bba", "committedDate": "2020-01-21T09:15:59Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "15d5275064a5fb2238fdf246bb7a52e5ff186bba", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/15d5275064a5fb2238fdf246bb7a52e5ff186bba", "committedDate": "2020-01-21T09:15:59Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}, "afterCommit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/3971a9e009547e449964d8c4a91f669111db24ce", "committedDate": "2020-01-21T20:20:59Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDk4MTQw", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-346498140", "createdAt": "2020-01-22T10:52:08Z", "commit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDo1MjowOVrOFgX8cg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDo1MjowOVrOFgX8cg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTA1OA==", "bodyText": "This is a bit confusing. Constants names are usually all upper case.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369491058", "createdAt": "2020-01-22T10:52:09Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.time.StopWatch;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.instance.ProcessInstance;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.util.TaskDataReader;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+\n+public class IntegrationTests {\n+\n+    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n+    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n+\n+    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n+    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n+\n+    private static List<Integer> pageSizes = Arrays.asList(3000);\n+\n+    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n+\n+    private TaskAssigningRuntimeClient client;\n+\n+    @Before\n+    public void setUp() {\n+        timeRegistry.clear();\n+        client = newTaskAssigningRuntimeClient();\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDk4ODUz", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-346498853", "createdAt": "2020-01-22T10:53:20Z", "commit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDo1MzoyMFrOFgX-ng==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDo1MzoyMFrOFgX-ng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MTYxNA==", "bodyText": "Could be an enum. Btw, isn't this already available somewhere in jBPM API?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369491614", "createdAt": "2020-01-22T10:53:20Z", "author": {"login": "yurloc"}, "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class UserType {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce"}, "originalPosition": 19}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTAwMDk2", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-346500096", "createdAt": "2020-01-22T10:55:31Z", "commit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDo1NTozMVrOFgYCPg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMDo1NTozMVrOFgYCPg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQ5MjU0Mg==", "bodyText": "Import property name from org.kie.server.api.KieServerConstants?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369492542", "createdAt": "2020-01-22T10:55:31Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce"}, "originalPosition": 34}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/3971a9e009547e449964d8c4a91f669111db24ce", "committedDate": "2020-01-21T20:20:59Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}, "afterCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/842cdd76a6181d4a11da8afd8aab8d14e1df92f7", "committedDate": "2020-01-22T10:30:34Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NTI1NDE1", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-346525415", "createdAt": "2020-01-22T11:42:31Z", "commit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMTo0MjozMVrOFgZPpg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxMTo0MjozMVrOFgZPpg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMjM1OA==", "bodyText": "inputParams is unused. Maybe it should be passed here?\nBtw, how do I run IntegrationTests? If I run it from IDEA I get this:\n\norg.kie.server.common.rest.NoEndpointFoundException: No available endpoints found\n\nIf I do mvn clean install the test doesn't seem to be run at all.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369512358", "createdAt": "2020-01-22T11:42:31Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.time.StopWatch;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.instance.ProcessInstance;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.util.TaskDataReader;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+\n+public class IntegrationTests {\n+\n+    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n+    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n+\n+    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n+    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n+\n+    private static List<Integer> pageSizes = Arrays.asList(3000);\n+\n+    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n+\n+    private TaskAssigningRuntimeClient client;\n+\n+    @Before\n+    public void setUp() {\n+        timeRegistry.clear();\n+        client = newTaskAssigningRuntimeClient();\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,\n+                                            Reserved,\n+                                            InProgress,\n+                                            Suspended);\n+\n+        registerStartTime(\"findTasks\");\n+        List<TaskData> list = client.findTasks(0L, status, null, 0, pageSize, inputVariablesReadMode).getItems();\n+        StopWatch stopWatch = registerEndTime(\"findTasks\");\n+        System.out.println(\"Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime((stopWatch)));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderNoVariables() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.DONT_READ));\n+    }\n+\n+    private void findTasksWithTasksReaderTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,\n+                                            Reserved,\n+                                            InProgress,\n+                                            Suspended);\n+\n+        registerStartTime(\"findTasks\");\n+        List<TaskData> list = TaskDataReader.from(client).readTasks(0L, status, null, pageSize, inputVariablesReadMode).getTasks();\n+        StopWatch stopWatch = registerEndTime(\"findTasks\");\n+        System.out.println(\"With TaskDataReader, Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime(stopWatch));\n+    }\n+\n+    private static String printTime(StopWatch stopWatch) {\n+        return stopWatch.toString();\n+    }\n+\n+    @Test\n+    public void createProcessInstances() {\n+\n+        int processInstancesSize = 5;\n+        List<Long> processInstances = new ArrayList<>();\n+\n+        ProcessServicesClient processServices = newKieServicesClient().getServicesClient(ProcessServicesClient.class);\n+\n+        long processInstanceId;\n+        for (int i = 0; i < processInstancesSize; i++) {\n+            HashMap inputParams = new HashMap();\n+            inputParams.put(\"processVar1\", \"generatedValue.for.taskInput1_\" + i);\n+            inputParams.put(\"processVar2\", \"generatedValue.for.taskInput2_\" + i);\n+            processInstanceId = processServices.startProcess(CONTAINER_ID, PROCESS_ID);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ2NDI5NDc1", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-346429475", "createdAt": "2020-01-22T09:03:29Z", "commit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQwOTowMzoyOVrOFgUrJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yMlQxNTozODoxM1rOFggrbA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTQzNzQ3Nw==", "bodyText": "The project uses \"javax.xml.bind.annotation\" package, but does not declare any jaxb-api dependency, which it gets transitively via kie-server-api.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369437477", "createdAt": "2020-01-22T09:03:29Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-api-task-assigning/pom.xml", "diffHunk": "@@ -0,0 +1,26 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.kie.server</groupId>\n+    <artifactId>jbpm-task-assigning</artifactId>\n+    <version>7.33.0-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>kie-server-api-task-assigning</artifactId>\n+\n+  <name>KIE :: Execution Server :: API :: Task Assigning</name>\n+  <description>KIE Execution Server API Task Assigning</description>\n+\n+  <dependencies>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "3971a9e009547e449964d8c4a91f669111db24ce"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3NzY2OA==", "bodyText": "As a part of API, would be good to put there javadoc explaining what individual values mean.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369577668", "createdAt": "2020-01-22T14:06:15Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/TaskInputVariablesReadMode.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public enum TaskInputVariablesReadMode {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 19}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU3OTI0Mw==", "bodyText": "It has a potential to help you get rid of a lot of code, including testing.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369579243", "createdAt": "2020-01-22T14:09:08Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.time.LocalDateTime;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+\n+public interface TaskAssigningRuntimeClient {\n+\n+    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMxOTg1Mg=="}, "originalCommit": {"oid": "64260a2898b6386a3da061fdf31cf36d7775d6be"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU4MjM0Nw==", "bodyText": "Thinking aloud: if we wrap the kie server client, does it make sense to make the timeout configurable?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369582347", "createdAt": "2020-01-22T14:14:34Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClientFactory.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.kie.server.api.marshalling.MarshallingFormat;\n+import org.kie.server.api.model.taskassigning.LocalDateTimeValue;\n+\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_BPM;\n+import static org.kie.server.api.KieServerConstants.CAPABILITY_TASK_ASSIGNING_RUNTIME;\n+\n+public class TaskAssigningRuntimeClientFactory {\n+\n+    static {\n+        // Ensure user bypass is on to be able to e.g. let the client \"admin\" user to claim/delegate tasks on behalf\n+        // of other users\n+        System.setProperty(\"org.kie.server.bypass.auth.user\", Boolean.TRUE.toString());\n+    }\n+\n+    static KieServicesClient createKieServicesClient(final String endpoint,\n+                                                     final String login,\n+                                                     final String password) {\n+\n+        final KieServicesConfiguration configuration = KieServicesFactory.newRestConfiguration(endpoint, login, password);\n+        configuration.setTimeout(90000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTU5MDUzOQ==", "bodyText": "The method is rather complex and sonarcloud complains about cognitive complexity going over a threshold too [1].\nThere are no tests for this method and with its complicated logic it will be very difficult to write them.\n[1] https://sonarcloud.io/component_measures?id=org.drools%3Adroolsjbpm-integration&metric=new_coverage&pullRequest=1986&selected=org.drools%3Adroolsjbpm-integration%3Ajbpm-task-assigning%2Fkie-server-client-task-assigning%2Fsrc%2Fmain%2Fjava%2Forg%2Fkie%2Fserver%2Fclient%2Futil%2FTaskDataReader.java&view=treemap", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369590539", "createdAt": "2020-01-22T14:27:46Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/util/TaskDataReader.java", "diffHunk": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client.util;\n+\n+import java.time.LocalDateTime;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+\n+public class TaskDataReader {\n+\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    private TaskDataReader(TaskAssigningRuntimeClient runtimeClient) {\n+        this.runtimeClient = runtimeClient;\n+    }\n+\n+    public static class Result {\n+\n+        LocalDateTime queryTime;\n+\n+        List<TaskData> tasks;\n+\n+        private Result(LocalDateTime queryTime, List<TaskData> tasks) {\n+            this.queryTime = queryTime;\n+            this.tasks = tasks;\n+        }\n+\n+        public LocalDateTime getQueryTime() {\n+            return queryTime;\n+        }\n+\n+        public List<TaskData> getTasks() {\n+            return tasks;\n+        }\n+    }\n+\n+    public static TaskDataReader from(TaskAssigningRuntimeClient runtimeClient) {\n+        return new TaskDataReader(runtimeClient);\n+    }\n+\n+    public Result readTasks(long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxMzQ4MA==", "bodyText": "If there is no need to re-throw the InterruptedException, let's set the interrupted flag via Thread.interrupt().\nSee e.g. https://dzone.com/articles/understanding-thread-interruption-in-java", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369613480", "createdAt": "2020-01-22T15:04:52Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNDgxMw==", "bodyText": "Every call to LOGGER.trace will print a new trace message - with a new timestamp. I suspect we should rather format the entire solution string first and then just print it once.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369614813", "createdAt": "2020-01-22T15:07:03Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {\n+                super.destroy();\n+                LOGGER.error(\"Solution Processor was interrupted\", e);\n+            }\n+        }\n+        LOGGER.debug(\"Solution Processor finished\");\n+    }\n+\n+    private void doProcess(final TaskAssigningSolution solution) {\n+        LOGGER.debug(\"Starting processing of solution: \" + solution);\n+        final List<PlanningItem> planningItems = new ArrayList<>(solution.getTaskList().size());\n+        List<PlanningItem> userPlanningItems;\n+        Iterator<PlanningItem> userPlanningItemsIt;\n+        PlanningItem planningItem;\n+        int index;\n+        int publishedCount;\n+        for (User user : solution.getUserList()) {\n+            userPlanningItems = new ArrayList<>();\n+            index = 0;\n+            publishedCount = 0;\n+            Task nextTask = user.getNextTask();\n+\n+            while (nextTask != null) {\n+                if (IS_NOT_DUMMY.test(nextTask)) {\n+                    //dummy tasks has nothing to with the jBPM runtime, don't process them\n+                    planningItem = PlanningItem.builder()\n+                            .containerId(nextTask.getContainerId())\n+                            .taskId(nextTask.getId())\n+                            .processInstanceId(nextTask.getProcessInstanceId())\n+                            .planningTask(PlanningTask.builder()\n+                                                  .taskId(nextTask.getId())\n+                                                  .published(nextTask.isPinned())\n+                                                  .assignedUser(user.getUser().getEntityId())\n+                                                  .index(index++)\n+                                                  .build())\n+                            .build();\n+\n+                    userPlanningItems.add(planningItem);\n+                    publishedCount += planningItem.getPlanningTask().isPublished() ? 1 : 0;\n+                }\n+                nextTask = nextTask.getNextTask();\n+            }\n+            if (!IS_PLANNING_USER.test(user.getEntityId())) {\n+                userPlanningItemsIt = userPlanningItems.iterator();\n+                while (userPlanningItemsIt.hasNext() && publishedCount < publishWindowSize) {\n+                    planningItem = userPlanningItemsIt.next();\n+                    if (!planningItem.getPlanningTask().isPublished()) {\n+                        planningItem.getPlanningTask().setPublished(true);\n+                        publishedCount++;\n+                    }\n+                }\n+            }\n+            planningItems.addAll(userPlanningItems);\n+        }\n+\n+        final List<PlanningItem> publishedTasks = planningItems.stream().filter(item -> item.getPlanningTask().isPublished()).collect(Collectors.toList());\n+\n+        if (LOGGER.isTraceEnabled()) {\n+            traceSolution(solution);\n+            tracePublishedTasks(publishedTasks);\n+        }\n+\n+        Result result;\n+        try {\n+            ExecutePlanningResult executeResult = delegate.executePlanning(publishedTasks, targetUserId);\n+            result = new Result(executeResult);\n+        } catch (Exception e) {\n+            LOGGER.error(\"An error was produced during solution processing, planning execution failed.\", e);\n+            result = new Result(e);\n+        }\n+\n+        LOGGER.debug(\"Solution processing finished: \" + solution);\n+        processing.set(false);\n+        resultConsumer.accept(result);\n+    }\n+\n+    private void traceSolution(TaskAssigningSolution solution) {\n+        LOGGER.trace(\"\\n\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYxNDk1NA==", "bodyText": "ditto", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369614954", "createdAt": "2020-01-22T15:07:16Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionProcessor.java", "diffHunk": "@@ -0,0 +1,249 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.Semaphore;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static org.kie.server.services.taskassigning.core.model.Task.IS_NOT_DUMMY;\n+import static org.kie.server.services.taskassigning.core.model.User.IS_PLANNING_USER;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkCondition;\n+import static org.kie.soup.commons.validation.PortablePreconditions.checkNotNull;\n+\n+/**\n+ * This class manges the processing of new a solution produced by the solver.\n+ */\n+public class SolutionProcessor extends RunnableBase {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SolutionProcessor.class);\n+\n+    private final TaskAssigningRuntimeDelegate delegate;\n+    private final Consumer<Result> resultConsumer;\n+    private final String targetUserId;\n+    private final int publishWindowSize;\n+\n+    private final Semaphore solutionResource = new Semaphore(0);\n+    private final AtomicBoolean processing = new AtomicBoolean(false);\n+\n+    private TaskAssigningSolution solution;\n+\n+    public static class Result {\n+\n+        private Exception exception;\n+\n+        private ExecutePlanningResult executeResult;\n+\n+        private Result() {\n+\n+        }\n+\n+        private Result(Exception exception) {\n+            this.exception = exception;\n+        }\n+\n+        public Result(ExecutePlanningResult executeResult) {\n+            this.executeResult = executeResult;\n+        }\n+\n+        public boolean hasException() {\n+            return exception != null;\n+        }\n+\n+        public Exception getException() {\n+            return exception;\n+        }\n+\n+        public ExecutePlanningResult getExecuteResult() {\n+            return executeResult;\n+        }\n+    }\n+\n+    /**\n+     * @param delegate a TaskAssigningRuntimeDelegate instance for executing methods into the jBPM runtime.\n+     * @param resultConsumer a consumer for processing the results.\n+     * @param targetUserId a user identifier for using as the \"on behalf of\" user when interacting with the jBPM runtime.\n+     * @param publishWindowSize Integer value > 0 that indicates the number of tasks to be published.\n+     */\n+    public SolutionProcessor(final TaskAssigningRuntimeDelegate delegate,\n+                             final Consumer<Result> resultConsumer,\n+                             final String targetUserId,\n+                             final int publishWindowSize) {\n+        checkNotNull(\"delegate\", delegate);\n+        checkNotNull(\"resultConsumer\", resultConsumer);\n+        checkNotNull(\"targetUserId\", targetUserId);\n+        checkCondition(\"publishWindowSize\", publishWindowSize > 0);\n+        this.delegate = delegate;\n+        this.resultConsumer = resultConsumer;\n+        this.targetUserId = targetUserId;\n+        this.publishWindowSize = publishWindowSize;\n+    }\n+\n+    /**\n+     * @return true if a solution is being processed at this time, false in any other case.\n+     */\n+    public boolean isProcessing() {\n+        return processing.get();\n+    }\n+\n+    /**\n+     * This method is invoked form a different thread for doing the processing of a solution. This method is not\n+     * thread-safe and it's expected that any synchronization required between the isProcessing() and process()\n+     * methods is performed by the caller. Since only one solution can be processed at time, the caller should typically\n+     * execute in the following sequence.\n+     * if (!solutionProcessor.isProcessing()) {\n+     * solutionProcessor.process(solution);\n+     * } else {\n+     * //invoke at a later time.\n+     * }\n+     * A null value will throw an exception.\n+     * @param solution a solution to process.\n+     */\n+    public void process(final TaskAssigningSolution solution) {\n+        checkNotNull(\"solution\", solution);\n+        processing.set(true);\n+        this.solution = solution;\n+        solutionResource.release();\n+    }\n+\n+    @Override\n+    public void destroy() {\n+        super.destroy();\n+        solutionResource.release(); //un-lock in case it was waiting for a solution to process.\n+    }\n+\n+    @Override\n+    public void run() {\n+        while (isAlive()) {\n+            try {\n+                solutionResource.acquire();\n+                if (isAlive()) {\n+                    doProcess(solution);\n+                }\n+            } catch (InterruptedException e) {\n+                super.destroy();\n+                LOGGER.error(\"Solution Processor was interrupted\", e);\n+            }\n+        }\n+        LOGGER.debug(\"Solution Processor finished\");\n+    }\n+\n+    private void doProcess(final TaskAssigningSolution solution) {\n+        LOGGER.debug(\"Starting processing of solution: \" + solution);\n+        final List<PlanningItem> planningItems = new ArrayList<>(solution.getTaskList().size());\n+        List<PlanningItem> userPlanningItems;\n+        Iterator<PlanningItem> userPlanningItemsIt;\n+        PlanningItem planningItem;\n+        int index;\n+        int publishedCount;\n+        for (User user : solution.getUserList()) {\n+            userPlanningItems = new ArrayList<>();\n+            index = 0;\n+            publishedCount = 0;\n+            Task nextTask = user.getNextTask();\n+\n+            while (nextTask != null) {\n+                if (IS_NOT_DUMMY.test(nextTask)) {\n+                    //dummy tasks has nothing to with the jBPM runtime, don't process them\n+                    planningItem = PlanningItem.builder()\n+                            .containerId(nextTask.getContainerId())\n+                            .taskId(nextTask.getId())\n+                            .processInstanceId(nextTask.getProcessInstanceId())\n+                            .planningTask(PlanningTask.builder()\n+                                                  .taskId(nextTask.getId())\n+                                                  .published(nextTask.isPinned())\n+                                                  .assignedUser(user.getUser().getEntityId())\n+                                                  .index(index++)\n+                                                  .build())\n+                            .build();\n+\n+                    userPlanningItems.add(planningItem);\n+                    publishedCount += planningItem.getPlanningTask().isPublished() ? 1 : 0;\n+                }\n+                nextTask = nextTask.getNextTask();\n+            }\n+            if (!IS_PLANNING_USER.test(user.getEntityId())) {\n+                userPlanningItemsIt = userPlanningItems.iterator();\n+                while (userPlanningItemsIt.hasNext() && publishedCount < publishWindowSize) {\n+                    planningItem = userPlanningItemsIt.next();\n+                    if (!planningItem.getPlanningTask().isPublished()) {\n+                        planningItem.getPlanningTask().setPublished(true);\n+                        publishedCount++;\n+                    }\n+                }\n+            }\n+            planningItems.addAll(userPlanningItems);\n+        }\n+\n+        final List<PlanningItem> publishedTasks = planningItems.stream().filter(item -> item.getPlanningTask().isPublished()).collect(Collectors.toList());\n+\n+        if (LOGGER.isTraceEnabled()) {\n+            traceSolution(solution);\n+            tracePublishedTasks(publishedTasks);\n+        }\n+\n+        Result result;\n+        try {\n+            ExecutePlanningResult executeResult = delegate.executePlanning(publishedTasks, targetUserId);\n+            result = new Result(executeResult);\n+        } catch (Exception e) {\n+            LOGGER.error(\"An error was produced during solution processing, planning execution failed.\", e);\n+            result = new Result(e);\n+        }\n+\n+        LOGGER.debug(\"Solution processing finished: \" + solution);\n+        processing.set(false);\n+        resultConsumer.accept(result);\n+    }\n+\n+    private void traceSolution(TaskAssigningSolution solution) {\n+        LOGGER.trace(\"\\n\");\n+        LOGGER.trace(\"*** Start of solution trace, with users = {} and tasks = {} ***\", solution.getUserList().size(), solution.getTaskList().size());\n+        for (User user : solution.getUserList()) {\n+            Task nextTask = user.getNextTask();\n+            while (nextTask != null) {\n+                LOGGER.trace(user.getEntityId() + \" -> \" + nextTask.getId() + \", pinned: \" + nextTask.isPinned() + \" priority: \" + nextTask.getPriority() + \", status: \" + nextTask.getStatus());\n+                nextTask = nextTask.getNextTask();\n+            }\n+        }\n+        LOGGER.trace(\"*** End of solution trace ***\");\n+        LOGGER.trace(\"\\n\");\n+    }\n+\n+    private void tracePublishedTasks(List<PlanningItem> publishedTasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 240}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYyMjc0NA==", "bodyText": "It's more readable to invert the logic, so that you just:\nif (true.equals(...)) { return; } and the rest of the method keeps the original level of indentation.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369622744", "createdAt": "2020-01-22T15:19:54Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java", "diffHunk": "@@ -787,6 +790,37 @@ protected EntityManagerFactory build(Map<String, String> properties) {\n         }\n     }\n \n+    private void checkAndAddTaskAssigningEntities(PersistenceUnitInfo info) {\n+        if (\"false\".equals(System.getProperty(KIE_TASK_ASSIGNING_RUNTIME_EXT_DISABLED))) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzMTk2MA==", "bodyText": "What is the purpose of this method? Is it required to register task planning JPA entities into the PersistenceContext to make them writeable into database together with jBPM classes?\nIn other words, does it serve the purpose of saving the task assignment at a safe point in a jBPM process?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369631960", "createdAt": "2020-01-22T15:34:26Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-jbpm/src/main/java/org/kie/server/services/jbpm/JbpmKieServerExtension.java", "diffHunk": "@@ -787,6 +790,37 @@ protected EntityManagerFactory build(Map<String, String> properties) {\n         }\n     }\n \n+    private void checkAndAddTaskAssigningEntities(PersistenceUnitInfo info) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTYzNDE1Ng==", "bodyText": "The same for me.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r369634156", "createdAt": "2020-01-22T15:38:13Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/test/java/org/kie/server/client/IntegrationTests.java", "diffHunk": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.time.StopWatch;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.instance.ProcessInstance;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.client.util.TaskDataReader;\n+\n+import static org.kie.server.api.model.taskassigning.TaskStatus.InProgress;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Ready;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Reserved;\n+import static org.kie.server.api.model.taskassigning.TaskStatus.Suspended;\n+\n+public class IntegrationTests {\n+\n+    private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server|http://localhost:8080/kie-server/services/rest/server\";\n+    //private static final String SERVER_URL = \"http://localhost:8180/kie-server/services/rest/server\";\n+\n+    private static String CONTAINER_ID = \"com.myspace:test-process:1.0.0-SNAPSHOT\";\n+    private static String PROCESS_ID = \"test-process.Produce_Task_For_HR\";\n+\n+    private static List<Integer> pageSizes = Arrays.asList(3000);\n+\n+    private Map<String, StopWatch> timeRegistry = new HashMap<>();\n+\n+    private TaskAssigningRuntimeClient client;\n+\n+    @Before\n+    public void setUp() {\n+        timeRegistry.clear();\n+        client = newTaskAssigningRuntimeClient();\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTaskAssigningClientVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> testFindTasksWithTaskAssigningClientTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    private void testFindTasksWithTaskAssigningClientTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,\n+                                            Reserved,\n+                                            InProgress,\n+                                            Suspended);\n+\n+        registerStartTime(\"findTasks\");\n+        List<TaskData> list = client.findTasks(0L, status, null, 0, pageSize, inputVariablesReadMode).getItems();\n+        StopWatch stopWatch = registerEndTime(\"findTasks\");\n+        System.out.println(\"Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime((stopWatch)));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderAllVariablesReadTime() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_FOR_ALL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderVariablesWhenPlanningTaskIsNull() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.READ_WHEN_PLANNING_TASK_IS_NULL));\n+    }\n+\n+    @Test\n+    public void findTasksWithTasksReaderNoVariables() {\n+        pageSizes.forEach(pageSize -> findTasksWithTasksReaderTimes(pageSize, TaskInputVariablesReadMode.DONT_READ));\n+    }\n+\n+    private void findTasksWithTasksReaderTimes(int pageSize, TaskInputVariablesReadMode inputVariablesReadMode) {\n+        List<String> status = Arrays.asList(Ready,\n+                                            Reserved,\n+                                            InProgress,\n+                                            Suspended);\n+\n+        registerStartTime(\"findTasks\");\n+        List<TaskData> list = TaskDataReader.from(client).readTasks(0L, status, null, pageSize, inputVariablesReadMode).getTasks();\n+        StopWatch stopWatch = registerEndTime(\"findTasks\");\n+        System.out.println(\"With TaskDataReader, Tasks size with variablesReadMode: \" + inputVariablesReadMode + \" pageSize: \" + pageSize + \" totalTasks: \" + list.size() + \" in \" + printTime(stopWatch));\n+    }\n+\n+    private static String printTime(StopWatch stopWatch) {\n+        return stopWatch.toString();\n+    }\n+\n+    @Test\n+    public void createProcessInstances() {\n+\n+        int processInstancesSize = 5;\n+        List<Long> processInstances = new ArrayList<>();\n+\n+        ProcessServicesClient processServices = newKieServicesClient().getServicesClient(ProcessServicesClient.class);\n+\n+        long processInstanceId;\n+        for (int i = 0; i < processInstancesSize; i++) {\n+            HashMap inputParams = new HashMap();\n+            inputParams.put(\"processVar1\", \"generatedValue.for.taskInput1_\" + i);\n+            inputParams.put(\"processVar2\", \"generatedValue.for.taskInput2_\" + i);\n+            processInstanceId = processServices.startProcess(CONTAINER_ID, PROCESS_ID);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTUxMjM1OA=="}, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 129}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ3MTkwMjc0", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-347190274", "createdAt": "2020-01-23T10:22:29Z", "commit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDoyMjozMFrOFg5NzQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yM1QxMDoyMjozMFrOFg5NzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAzNjE3Mw==", "bodyText": "Should be upper case and maybe an enum.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370036173", "createdAt": "2020-01-23T10:22:30Z", "author": {"login": "yurloc"}, "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/TaskStatus.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class TaskStatus {\n+\n+    public static final String Created = \"Created\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "842cdd76a6181d4a11da8afd8aab8d14e1df92f7"}, "originalPosition": 21}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzQ4MTAwOTQw", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-348100940", "createdAt": "2020-01-24T17:14:36Z", "commit": {"oid": "a31167c12ed4a67d20c60824cb8bef850b79d499"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzoxNDozNlrOFhkinA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yNFQxNzoxNDozNlrOFhkinA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDc0NjAxMg==", "bodyText": "This is where we typically throw an exception - that's defensive programming. If, in the future, you add another value and forget to change it here, that's how you'll find out.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r370746012", "createdAt": "2020-01-24T17:14:36Z", "author": {"login": "triceo"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionBuilder.java", "diffHunk": "@@ -127,6 +131,10 @@ public TaskAssigningSolution build() {\n                             addTaskToUser(assignedTasksByUserId, task, taskData.getActualOwner(), -1, pinned);\n                         }\n                     }\n+                    break;\n+                default:\n+                    //no other cases exists, sonar required.\n+                    break;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "a31167c12ed4a67d20c60824cb8bef850b79d499"}, "originalPosition": 37}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a31167c12ed4a67d20c60824cb8bef850b79d499", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/a31167c12ed4a67d20c60824cb8bef850b79d499", "committedDate": "2020-01-24T16:59:47Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests I"}, "afterCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "committedDate": "2020-02-14T17:57:45Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests II"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NTY3ODgw", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-359567880", "createdAt": "2020-02-17T08:51:06Z", "commit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "state": "COMMENTED", "comments": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QwODo1MTowNlrOFqcWSA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMjowNToxOFrOFqiJJw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0ODk2OA==", "bodyText": "typo", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380048968", "createdAt": "2020-02-17T08:51:06Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/util/TaskUtil.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning.util;\n+\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.services.taskassigning.core.model.Group;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TypedLabel;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.isUser;\n+\n+public class TaskUtil {\n+\n+    private TaskUtil() {\n+    }\n+\n+    public static Task fromTaskData(TaskData taskData) {\n+        final Task task = new Task(taskData.getTaskId(),\n+                                   taskData.getProcessInstanceId(),\n+                                   taskData.getProcessId(),\n+                                   taskData.getContainerId(),\n+                                   taskData.getName(),\n+                                   taskData.getPriority(),\n+                                   taskData.getStatus(),\n+                                   taskData.getInputData());\n+        if (taskData.getPotentialOwners() != null) {\n+            taskData.getPotentialOwners().forEach(potentialOwner -> {\n+                if (isUser(potentialOwner.getType())) {\n+                    task.getPotentialOwners().add(new User(potentialOwner.getName().hashCode(), potentialOwner.getName()));\n+                } else {\n+                    task.getPotentialOwners().add(new Group(potentialOwner.getName().hashCode(), potentialOwner.getName()));\n+                }\n+            });\n+        }\n+        //TODO expermiental for the demo", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA0OTg1NQ==", "bodyText": "This is a candidate for a parametrized test:\nhttps://github.com/junit-team/junit4/wiki/Parameterized-tests", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380049855", "createdAt": "2020-02-17T08:53:02Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/PlanningBuilderTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.PLANNING_USER_ID;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.initializeUser;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.mockUser;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.extractTasks;\n+\n+public class PlanningBuilderTest {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NTgyMA==", "bodyText": "Is this delay really needed? Could the mock just do nothing?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380055820", "createdAt": "2020-02-17T09:04:54Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionProcessorTest.java", "diffHunk": "@@ -0,0 +1,149 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.function.Consumer;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.client.TaskAssigningRuntimeClient;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyInt;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+public class SolutionProcessorTest extends RunnableBaseTest<SolutionProcessor> {\n+\n+    private static final String TARGET_USER_ID = \"TARGET_USER_ID\";\n+    private static final int PUBLISH_WINDOW_SIZE = 2;\n+\n+    private TaskAssigningRuntimeDelegate delegate;\n+\n+    @Mock\n+    private TaskAssigningRuntimeClient runtimeClient;\n+\n+    @Mock\n+    private Consumer<SolutionProcessor.Result> resultConsumer;\n+\n+    @Mock\n+    private ExecutePlanningResult result;\n+\n+    @Captor\n+    private ArgumentCaptor<SolutionProcessor.Result> resultCaptor;\n+\n+    @Mock\n+    private List<PlanningItem> generatedPlan;\n+\n+    @Override\n+    protected SolutionProcessor createRunnableBase() {\n+        delegate = spy(new TaskAssigningRuntimeDelegateMock(runtimeClient));\n+        SolutionProcessor processor = spy(new SolutionProcessor(delegate, resultConsumer, TARGET_USER_ID, PUBLISH_WINDOW_SIZE));\n+        doReturn(generatedPlan).when(processor).buildPlanning(any(), anyInt());\n+        return processor;\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void process() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+        runnableBase.process(solution);\n+        assertTrue(runnableBase.isProcessing());\n+\n+        // wait while the processing is occurring.\n+        while (runnableBase.isProcessing()) {\n+            Thread.sleep(100);\n+        }\n+\n+        verify(delegate).executePlanning(generatedPlan, TARGET_USER_ID);\n+        verify(resultConsumer).accept(resultCaptor.capture());\n+        assertEquals(result, resultCaptor.getValue().getExecuteResult());\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void processWithFailure() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+        runnableBase.process(solution);\n+        Assertions.assertThatThrownBy(() -> runnableBase.process(solution))\n+                .hasMessage(\"SolutionProcessor process method can only be invoked when the status is STOPPED\");\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    public void processWithDelegateError() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        TaskAssigningSolution solution = new TaskAssigningSolution(-1, new ArrayList<>(), new ArrayList<>());\n+\n+        RuntimeException generatedError = new RuntimeException(\"Emulate a service invocation error.\");\n+        when(delegate.executePlanning(generatedPlan, TARGET_USER_ID)).thenThrow(generatedError);\n+\n+        runnableBase.process(solution);\n+\n+        // wait while the processing is occurring.\n+        while (runnableBase.isProcessing()) {\n+            Thread.sleep(100);\n+        }\n+\n+        verify(resultConsumer).accept(resultCaptor.capture());\n+        assertTrue(resultCaptor.getValue().hasException());\n+        assertEquals(generatedError, resultCaptor.getValue().getException());\n+\n+        runnableBase.destroy();\n+        assertTrue(runnableBase.isDestroyed());\n+        future.get();\n+    }\n+\n+    private class TaskAssigningRuntimeDelegateMock extends TaskAssigningRuntimeDelegate {\n+\n+        public TaskAssigningRuntimeDelegateMock(TaskAssigningRuntimeClient runtimeClient) {\n+            super(runtimeClient);\n+        }\n+\n+        @Override\n+        public ExecutePlanningResult executePlanning(List<PlanningItem> planningItems, String userId) {\n+            try {\n+                // emulate some time to finish\n+                Thread.sleep(500);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 141}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA1NzcwNg==", "bodyText": "Once the test is active, this Thread.sleep possibly becomes a cause of instability.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380057706", "createdAt": "2020-02-17T09:08:59Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolverExecutorTest.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.Semaphore;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.optaplanner.core.api.score.Score;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.event.BestSolutionChangedEvent;\n+import org.optaplanner.core.api.solver.event.SolverEventListener;\n+import org.optaplanner.core.impl.score.director.ScoreDirectorFactory;\n+import org.optaplanner.core.impl.solver.ProblemFactChange;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+\n+public class SolverExecutorTest extends RunnableBaseTest<SolverExecutor> {\n+\n+    @Mock\n+    private SolverDef solverDef;\n+\n+    @Mock\n+    private KieServerRegistry registry;\n+\n+    private Solver<TaskAssigningSolution> solver;\n+\n+    @Mock\n+    private TaskAssigningSolution solution;\n+\n+    @Mock\n+    private SolverEventListener<TaskAssigningSolution> eventListener;\n+\n+    @Captor\n+    private ArgumentCaptor<SolverEventListener<TaskAssigningSolution>> eventListenerCaptor;\n+\n+    @Mock\n+    private BestSolutionChangedEvent<TaskAssigningSolution> event;\n+\n+    @Override\n+    protected SolverExecutor createRunnableBase() {\n+        solver = spy(new SolverMock());\n+        return new SolverExecutorMock(solverDef, registry, eventListener);\n+    }\n+\n+    @Test(timeout = TEST_TIMEOUT)\n+    //TODO, In fix process. Temporary commented due to an issue probably related with JUnit.\n+    @Ignore\n+    public void start() throws Exception {\n+        CompletableFuture future = startRunnableBase();\n+        runnableBase.start(solution);\n+        // give some time for the start method to execute.\n+        Thread.sleep(1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA2NjI4NA==", "bodyText": "I wonder if we could rather create some Task instances with these properties instead of creating tenths of the fields directly in the test and having methods with 8+ parameters.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380066284", "createdAt": "2020-02-17T09:26:03Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/query/AbstractTaskAssigningDataQueryMapperTest.java", "diffHunk": "@@ -0,0 +1,314 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.runtime.query;\n+\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.lang3.tuple.Pair;\n+import org.dashbuilder.dataset.DataColumn;\n+import org.dashbuilder.dataset.DataSet;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public abstract class AbstractTaskAssigningDataQueryMapperTest<T extends AbstractTaskAssigningQueryMapper<?>> {\n+\n+    /**\n+     * Task1 has planning task and potential owners.\n+     */\n+    static final Long TASK1_ID = 1L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 45}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDA4NTc4Mw==", "bodyText": "Does the test call this mock 3 times that it returns 3 different answers?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380085783", "createdAt": "2020-02-17T10:01:26Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-runtime/src/test/java/org/kie/server/services/taskassigning/runtime/TaskAssigningRuntimeServiceQueryHelperTest.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.runtime;\n+\n+import java.sql.Date;\n+import java.time.LocalDateTime;\n+import java.time.ZoneId;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.UserTaskService;\n+import org.jbpm.services.api.query.QueryService;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.Status;\n+import org.kie.server.api.model.KieContainerStatus;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+import org.kie.server.services.api.KieServerRegistry;\n+import org.kie.server.services.impl.KieContainerInstanceImpl;\n+import org.kie.server.services.taskassigning.runtime.query.AbstractTaskAssigningQueryMapper;\n+import org.kie.server.services.taskassigning.runtime.query.TaskAssigningTaskDataQueryMapper;\n+import org.mockito.ArgumentCaptor;\n+import org.mockito.Captor;\n+import org.mockito.Mock;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.runners.MockitoJUnitRunner;\n+import org.mockito.stubbing.Answer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_LAST_MODIFICATION_DATE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.FROM_TASK_ID;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.PAGE_SIZE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.STATUS;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TASK_INPUT_VARIABLES_MODE;\n+import static org.kie.server.api.model.taskassigning.QueryParamName.TO_TASK_ID;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.anyString;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.spy;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.when;\n+\n+@RunWith(MockitoJUnitRunner.class)\n+public class TaskAssigningRuntimeServiceQueryHelperTest {\n+\n+    private static final String GREATER_OR_EQUALS_TO = \"GREATER_OR_EQUALS_TO\";\n+    private static final String LOWER_OR_EQUALS_TO = \"LOWER_OR_EQUALS_TO\";\n+    private static final String EQUALS_TO = \"EQUALS_TO\";\n+\n+    private static final String FROM_LAST_MODIFICATION_STR_VALUE = \"2020-02-11T16:07:34.332\";\n+    private static final LocalDateTime FROM_LAST_MODIFICATION_VALUE = LocalDateTime.parse(FROM_LAST_MODIFICATION_STR_VALUE);\n+    private static final List<String> STATUS_VALUE = Arrays.asList(\"Ready\", \"Reserved\");\n+\n+    private static final Long FROM_TASK_ID_VALUE = 1L;\n+    private static final Long TO_TASK_ID_VALUE = 2L;\n+    private static final Integer PAGE_VALUE = 3;\n+    private static final Integer PAGE_SIZE_VALUE = 4;\n+\n+    //  Task1 is Ready and has PlanningTask\n+    private static final Long TASK1_ID = 1L;\n+    // Task2 is Reserved and doesn't have PlanningTask\n+    private static final Long TASK2_ID = 2L;\n+    // Task3 is Completed\n+    private static final Long TASK3_ID = 3L;\n+\n+    private static final Map<String, Object> TASK1_INPUTS = new HashMap<>();\n+    private static final Map<String, Object> TASK2_INPUTS = new HashMap<>();\n+    private static final Map<String, Object> TASK3_INPUTS = new HashMap<>();\n+\n+    private static final String CONTAINER_ID = \"CONTAINER_ID\";\n+\n+    @Mock\n+    private KieServerRegistry registry;\n+\n+    @Mock\n+    private QueryService queryService;\n+\n+    @Mock\n+    private UserTaskService userTaskService;\n+\n+    private TaskAssigningRuntimeServiceQueryHelper helper;\n+\n+    @Captor\n+    private ArgumentCaptor<QueryParam[]> paramsCaptor;\n+\n+    @Captor\n+    private ArgumentCaptor<QueryContext> contextCaptor;\n+\n+    @Before\n+    public void setUp() {\n+        this.helper = spy(new TaskAssigningRuntimeServiceQueryHelper(registry, userTaskService, queryService));\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadNoInputs() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.DONT_READ);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // no inputs were loaded\n+        assertNull(result.get(0).getInputData());\n+        assertNull(result.get(1).getInputData());\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadNoInputsByDefault() {\n+        Map<String, Object> params = prepareQuery(null);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // no inputs were loaded\n+        assertNull(result.get(0).getInputData());\n+        assertNull(result.get(1).getInputData());\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadInputsForAll() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.READ_FOR_ALL);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // all the inputs were loaded\n+        assertEquals(TASK1_INPUTS, result.get(0).getInputData());\n+        assertEquals(TASK2_INPUTS, result.get(1).getInputData());\n+        assertEquals(TASK3_INPUTS, result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void executeFindTaskQueryReadInputsForActiveTasks() {\n+        Map<String, Object> params = prepareQuery(TaskInputVariablesReadMode.READ_FOR_ACTIVE_TASKS_WITH_NO_PLANNING_ENTITY);\n+\n+        List<TaskData> result = helper.executeFindTasksQuery(params);\n+\n+        verifyQueryWasExecuted();\n+\n+        // task1 is Ready and has PlanningTask\n+        assertEquals(TASK1_INPUTS, result.get(0).getInputData());\n+        // task2 is Reserved but hasn't PlanningTask\n+        assertNull(result.get(1).getInputData());\n+        // task3 is not active.\n+        assertNull(result.get(2).getInputData());\n+    }\n+\n+    @Test\n+    public void readTaskDataSummary() {\n+        List<TaskData> invocation0 = mockTasks();\n+        List<TaskData> invocation1 = Arrays.asList(mockTaskData(4L), mockTaskData(5L));\n+        List<TaskData> invocation2 = Collections.singletonList(mockTaskData(6L));\n+        doAnswer(new Answer() {\n+            private int invocations = 0;\n+\n+            public Object answer(InvocationOnMock invocation) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 188}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzNzc4MQ==", "bodyText": "This should be rather a single trace message. In such a case, StringBuilder could be more suitable for preparing the message than the BREAK function.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380137781", "createdAt": "2020-02-17T11:51:01Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/TraceHelper.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+\n+import org.kie.server.api.model.taskassigning.PlanningItem;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AddTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.AssignTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.ReleaseTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.RemoveTaskProblemFactChange;\n+import org.kie.server.services.taskassigning.core.model.solver.realtime.TaskPropertyChangeProblemFactChange;\n+import org.kie.server.services.taskassigning.planning.util.IndexedElement;\n+import org.slf4j.Logger;\n+\n+public class TraceHelper {\n+\n+    private static final Function<String, String> BREAK = (s) -> System.lineSeparator() + s;\n+    private static final String TASK_WITH_NAME_FORMAT = \" -> ({}, {})\";\n+\n+    private TraceHelper() {\n+    }\n+\n+    static void traceProgrammedChanges(Logger logger, List<RemoveTaskProblemFactChange> removedTasksChanges,\n+                                       List<ReleaseTaskProblemFactChange> releasedTasksChanges,\n+                                       Map<String, List<IndexedElement<AssignTaskProblemFactChange>>> changesByUserId,\n+                                       List<TaskPropertyChangeProblemFactChange> propertyChanges,\n+                                       List<AddTaskProblemFactChange> newTaskChanges) {\n+\n+        logger.trace(BREAK.apply(\"*** Removed tasks ***\"));\n+        logger.trace(\"Total tasks removed from solution is {}\", removedTasksChanges.size());\n+        removedTasksChanges.forEach(change -> logger.trace(TASK_WITH_NAME_FORMAT, change.getTask().getId(), change.getTask().getName()));\n+        logger.trace(\"*** End of Removed tasks ***\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MTgwMA==", "bodyText": "There are no assertions; is the test supposed to only check that no exception is thrown?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380141800", "createdAt": "2020-02-17T12:00:29Z", "author": {"login": "rsynek"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-user-system/kie-server-services-task-assigning-user-system-simple/src/test/java/org/kie/server/services/taskassigning/user/system/simple/SimpleUserSystemServiceTest.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.user.system.simple;\n+\n+import java.net.URL;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.server.services.taskassigning.user.system.api.Group;\n+import org.kie.server.services.taskassigning.user.system.api.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.kie.server.services.taskassigning.user.system.simple.SimpleUserSystemService.USERS_FILE_LOADING_ERROR;\n+import static org.kie.server.services.taskassigning.user.system.simple.SimpleUserSystemService.USERS_FILE_NOT_CONFIGURED_ERROR;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP1;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP2;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.GROUP3;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER1;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER2;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER3;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER4;\n+import static org.kie.server.services.taskassigning.user.system.simple.WildflyUtilTest.USER5;\n+\n+public class SimpleUserSystemServiceTest {\n+\n+    private SimpleUserSystemService userSystem;\n+    private static final List<String> USERS = Arrays.asList(USER1, USER2, USER3, USER4, USER5);\n+    private static final List<String> GROUPS = Arrays.asList(GROUP1, GROUP2, GROUP3);\n+\n+    @Before\n+    public void setUp() {\n+        URL url = SimpleUserSystemServiceTest.class.getResource(WildflyUtilTest.USERS_FILE);\n+        String path = Paths.get(url.getPath()).toUri().toString();\n+        System.setProperty(SimpleUserSystemService.USERS_FILE, path);\n+        userSystem = new SimpleUserSystemService();\n+    }\n+\n+    @After\n+    public void cleanUp() {\n+        System.clearProperty(SimpleUserSystemService.USERS_FILE);\n+    }\n+\n+    @Test\n+    public void start() {\n+        userSystem.start();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzkxMQ==", "bodyText": "The constants should be in upper case; but an enum, as @yurloc suggested, is definitely preferable.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380143911", "createdAt": "2020-02-17T12:05:18Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/UserType.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+public class UserType {\n+\n+    private UserType() {\n+    }\n+\n+    public static final String User = \"User\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 24}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU5NjU3NTA1", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-359657505", "createdAt": "2020-02-17T11:09:48Z", "commit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 13, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxMTowOTo0OFrOFqgthQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xN1QxNDowNjo0NlrOFqloMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEyMDQ1Mw==", "bodyText": "Unused imports.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380120453", "createdAt": "2020-02-17T11:09:48Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/test/java/org/kie/server/api/model/taskassigning/util/StatusConverterTest.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning.util;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.junit.Test;\n+import org.kie.api.task.model.Status;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.kie.api.task.model.Status.Completed;\n+import static org.kie.api.task.model.Status.Ready;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDEzMDYyMg==", "bodyText": "Javadoc please \ud83d\ude42. Please explain what fromTaskId and fromLastModificationDate do.\nQuestions:\n\nWhy toTaskId is not here (but QueryParamName.TO_TASK_ID exists)?\nCan we use List<Status> status? Otherwise how does the user know what are the possible string values?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380130622", "createdAt": "2020-02-17T11:33:27Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-client-task-assigning/src/main/java/org/kie/server/client/TaskAssigningRuntimeClient.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.client;\n+\n+import java.time.LocalDateTime;\n+import java.util.List;\n+\n+import org.kie.server.api.model.taskassigning.ExecutePlanningResult;\n+import org.kie.server.api.model.taskassigning.PlanningItemList;\n+import org.kie.server.api.model.taskassigning.TaskDataList;\n+import org.kie.server.api.model.taskassigning.TaskInputVariablesReadMode;\n+\n+public interface TaskAssigningRuntimeClient {\n+\n+    ExecutePlanningResult executePlanning(PlanningItemList planningItemList, String userId);\n+\n+    TaskDataList findTasks(Long fromTaskId, List<String> status, LocalDateTime fromLastModificationDate,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MDk3Mg==", "bodyText": "Classes in the same package are already in kie-server-parent/kie-server-api. Why is the package split between two modules? Maybe the package in this module (jbpm-task-assigning/kie-server-api-task-assigning) is some kind of internal API or data model for the remote API whereas kie-serve-api is the Java client API? Not sure but I would recommend not to use same package name in different modules unless necessary.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380140972", "createdAt": "2020-02-17T11:58:22Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-api-task-assigning/src/main/java/org/kie/server/api/model/taskassigning/QueryParamName.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE0MzU2Ng==", "bodyText": "Typo: expeted.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380143566", "createdAt": "2020-02-17T12:04:33Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionBuilderTest.java", "diffHunk": "@@ -0,0 +1,412 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.services.taskassigning.planning;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.junit.Test;\n+import org.kie.api.task.model.Status;\n+import org.kie.server.api.model.taskassigning.PlanningTask;\n+import org.kie.server.api.model.taskassigning.TaskData;\n+import org.kie.server.services.taskassigning.core.model.Task;\n+import org.kie.server.services.taskassigning.core.model.TaskAssigningSolution;\n+import org.kie.server.services.taskassigning.core.model.User;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+\n+import static org.kie.api.task.model.Status.InProgress;\n+import static org.kie.api.task.model.Status.Ready;\n+import static org.kie.api.task.model.Status.Reserved;\n+import static org.kie.api.task.model.Status.Suspended;\n+import static org.kie.server.api.model.taskassigning.util.StatusConverter.convertToString;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.DUMMY_TASK;\n+import static org.kie.server.services.taskassigning.core.model.ModelConstants.PLANNING_USER_ID;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.assertContains;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.assertNotContains;\n+import static org.kie.server.services.taskassigning.planning.TestUtil.mockExternalUser;\n+import static org.kie.server.services.taskassigning.planning.util.UserUtil.extractTasks;\n+\n+public class SolutionBuilderTest {\n+\n+    // enabled user\n+    private static final String USER1 = \"USER1\";\n+    // disabled user\n+    private static final String USER2 = \"USER2\";\n+    // enabled user\n+    private static final String USER3 = \"USER3\";\n+    // user not present in the external users\n+    private static final String USER_NOT_PRESENT = \"USER_NOT_PRESENT\";\n+\n+    @Test\n+    public void buildAndCheckUsersWhereAdded() {\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.emptyList())\n+                .withUsers(externalUsers)\n+                .build();\n+\n+        assertContains(USER1, solution.getUserList());\n+        assertNotContains(USER2, solution.getUserList()); //externalUser2 is disabled.\n+        assertContains(USER3, solution.getUserList());\n+        assertContains(PLANNING_USER_ID, solution.getUserList()); //is always added.\n+        assertEquals(3, solution.getUserList().size(), 0);\n+    }\n+\n+    @Test\n+    public void buildAndCheckDummyTaskWasAdded() {\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.emptyList())\n+                .withUsers(Collections.emptyList())\n+                .build();\n+        assertEquals(1, solution.getTaskList().size());\n+        assertEquals(DUMMY_TASK, solution.getTaskList().get(0));\n+    }\n+\n+    @Test\n+    public void buildAndCheckReadyTaskWasProcessedCorrect() {\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskData taskData = mockTaskData(1L, Ready);\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Collections.singletonList(taskData))\n+                .withUsers(externalUsers)\n+                .build();\n+        assertEquals(2, solution.getTaskList().size());\n+        assertContainsNotAssignedTask(taskData, solution);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Reserved, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, InProgress, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Suspended, USER1), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckTaskForNotPresentUserWithNoPlanningTaskWasProcessedCorrect() {\n+        buildAndCheckTaskWithNoPlanningTaskWasProcessedCorrect(mockTaskData(1L, Reserved, USER_NOT_PRESENT), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithUnChangedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithUnChangedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, planningTask.getAssignedUser());\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, planningTask.getAssignedUser(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedForPlanningUserTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, PLANNING_USER_ID);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckReservedForPlanningUserTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Reserved, PLANNING_USER_ID);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), false);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckInProgressTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, InProgress, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithModifiedPlanningTaskPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAndCheckSuspendedTaskWithModifiedPlanningTaskNotPublishedWasProcessedCorrect() {\n+        PlanningTask planningTask = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData = mockTaskData(1L, Suspended, USER2);\n+        buildAndCheckTaskWithPlanningTaskWasProcessedCorrect(taskData, planningTask, taskData.getActualOwner(), true);\n+    }\n+\n+    @Test\n+    public void buildAnExample() {\n+        PlanningTask planningTask1 = PlanningTask.builder()\n+                .taskId(1L)\n+                .assignedUser(USER1)\n+                .published(false)\n+                .index(1)\n+                .build();\n+        TaskData taskData1 = mockTaskData(1L, Reserved, USER1);\n+        taskData1.setPlanningTask(planningTask1);\n+\n+        PlanningTask planningTask2 = PlanningTask.builder()\n+                .taskId(2L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(2)\n+                .build();\n+        TaskData taskData2 = mockTaskData(2L, Suspended, USER1);\n+        taskData2.setPlanningTask(planningTask2);\n+\n+        PlanningTask planningTask3 = PlanningTask.builder()\n+                .taskId(3L)\n+                .assignedUser(USER1)\n+                .published(true)\n+                .index(3)\n+                .build();\n+        TaskData taskData3 = mockTaskData(3L, InProgress, USER1);\n+        taskData3.setPlanningTask(planningTask3);\n+\n+        PlanningTask planningTask4 = PlanningTask.builder()\n+                .taskId(4L)\n+                .assignedUser(USER2)\n+                .published(false)\n+                .index(4)\n+                .build();\n+        TaskData taskData4 = mockTaskData(4L, InProgress, USER1);\n+        taskData4.setPlanningTask(planningTask4);\n+\n+        List<org.kie.server.services.taskassigning.user.system.api.User> externalUsers = buildExternalUsers();\n+        TaskAssigningSolution solution = SolutionBuilder.create()\n+                .withTasks(Arrays.asList(taskData4, taskData1, taskData3, taskData2))\n+                .withUsers(externalUsers)\n+                .build();\n+\n+        assertEquals(5, solution.getTaskList().size());\n+        User user1 = solution.getUserList().stream()\n+                .filter(user -> user.getEntityId().equals(USER1))\n+                .findFirst().orElse(null);\n+        assertNotNull(user1);\n+        List<Task> user1Tasks = extractTasks(user1, (task) -> true);\n+        assertEquals(4L, user1Tasks.size(), 0);\n+\n+        assertExpetedTaskAtPosition(taskData2.getTaskId(), 0, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData3.getTaskId(), 1, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData4.getTaskId(), 2, true, user1Tasks);\n+        assertExpetedTaskAtPosition(taskData1.getTaskId(), 3, false, user1Tasks);\n+    }\n+\n+    void assertExpetedTaskAtPosition(long taskId, int position, boolean pinned, List<Task> tasks) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 341}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4NjgzMg==", "bodyText": "Is there any reason for abbreviating the element names? I'd personally avoid abbreviations since the XML should be human readable (think of the documentation with REST call examples).", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380186832", "createdAt": "2020-02-17T13:39:44Z", "author": {"login": "yurloc"}, "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/OrganizationalEntity.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.util.Objects;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-oe\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 27}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE4Nzg4OA==", "bodyText": "Redundant \"-task\".", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380187888", "createdAt": "2020-02-17T13:41:51Z", "author": {"login": "yurloc"}, "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/PlanningItemList.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+import org.kie.server.api.model.ItemList;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-task-planning-item-list\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA==", "bodyText": "Probably s/Execute/Execution/. Is this a result of a planning execution? Then it should be PlanningExecutionResult.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380192678", "createdAt": "2020-02-17T13:50:55Z", "author": {"login": "yurloc"}, "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/ExecutePlanningResult.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-exec-planning-result\")\n+public class ExecutePlanningResult {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5NTIyMw==", "bodyText": "Also, by looking at the class fields, it seem this only serves to report an execution error. Should the class name reflect this?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380195223", "createdAt": "2020-02-17T13:55:41Z", "author": {"login": "yurloc"}, "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/model/taskassigning/ExecutePlanningResult.java", "diffHunk": "@@ -0,0 +1,100 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.kie.server.api.model.taskassigning;\n+\n+import javax.xml.bind.annotation.XmlAccessType;\n+import javax.xml.bind.annotation.XmlAccessorType;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+\n+@XmlAccessorType(XmlAccessType.FIELD)\n+@XmlRootElement(name = \"tsk-assig-exec-planning-result\")\n+public class ExecutePlanningResult {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5MjY3OA=="}, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5NjI1OA==", "bodyText": "Will this work without ExecutePlanningResult and OrganizationalEntity?", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380196258", "createdAt": "2020-02-17T13:57:35Z", "author": {"login": "yurloc"}, "path": "kie-server-parent/kie-server-api/src/main/java/org/kie/server/api/marshalling/jaxb/JaxbMarshaller.java", "diffHunk": "@@ -381,13 +386,20 @@\n                 DMNDecisionInfo.class,\n                 DMNInputDataInfo.class,\n                 DMNItemDefinitionInfo.class,\n-                \n+\n                 // Kie PMML\n                 PMML4Result.class,\n                 IntegerFieldOutput.class,\n                 DoubleFieldOutput.class,\n                 StringFieldOutput.class,\n-                ScoreCard.class\n+                ScoreCard.class,\n+\n+                //TaskAssigning\n+                PlanningItem.class,\n+                PlanningItemList.class,\n+                PlanningTask.class,\n+                TaskDataList.class,\n+                TaskData.class", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 31}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5ODIyNw==", "bodyText": "Should be removed before merging. I know it seems obvious but the PR is so huge this could slip through. This comment will make it stick out.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380198227", "createdAt": "2020-02-17T14:01:20Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/scripts/build-kie-server.sh", "diffHunk": "@@ -0,0 +1,75 @@\n+# Development script for quickly generating a kie-server.war file that contains all the task assigning\n+# related jars until this code is moved to the final location in kie-sever-parent project structure and is", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDE5OTA0OA==", "bodyText": "Do not merge this.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380199048", "createdAt": "2020-02-17T14:02:55Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/pom.xml", "diffHunk": "@@ -40,10 +50,45 @@\n         <type>pom</type>\n         <scope>import</scope>\n       </dependency>\n+\n+      <!-- TODO same here, this modules declaration will finally go in the proper kie-server-bom etc. -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIwMDg2MA==", "bodyText": "Seems like a dead code (isn't part of Maven build).", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380200860", "createdAt": "2020-02-17T14:06:28Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-task-assigning-user-system-simple-kjar/pom.xml", "diffHunk": "@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-4.0.0.xsd\">\n+  \n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.kie.server</groupId>\n+    <artifactId>jbpm-task-assigning</artifactId>\n+    <version>7.34.0-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>kie-server-task-assigning-user-system-simple-kjar</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDIwMTAwOA==", "bodyText": "Seems like a dead code (isn't part of Maven build).", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#discussion_r380201008", "createdAt": "2020-02-17T14:06:46Z", "author": {"login": "yurloc"}, "path": "jbpm-task-assigning/kie-server-task-assigning-default-planner-kjar/pom.xml", "diffHunk": "@@ -0,0 +1,39 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\"\n+         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-4.0.0.xsd\">\n+\n+  <modelVersion>4.0.0</modelVersion>\n+\n+  <parent>\n+    <groupId>org.kie.server</groupId>\n+    <artifactId>jbpm-task-assigning</artifactId>\n+    <version>7.34.0-SNAPSHOT</version>\n+  </parent>\n+\n+  <artifactId>kie-server-task-assigning-default-planner-kjar</artifactId>", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8"}, "originalPosition": 14}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/f05631c0eafb5ff084e5493a80f25bcca89fa6a5", "committedDate": "2020-02-20T20:44:47Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Includes: PLANNER-1623, PLANNER-1625, PLANNER-1626, PLANNER-1774"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f797da226fee8a2b8df32bc606b869bb66f33492", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/f797da226fee8a2b8df32bc606b869bb66f33492", "committedDate": "2020-02-20T20:44:47Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests I"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "6b6465776075428ebfdc3f9018be38703a7571ce", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/6b6465776075428ebfdc3f9018be38703a7571ce", "committedDate": "2020-02-20T20:44:47Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests II"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/db9e03bb968b28a37642f4b825cfe35aec2e8132", "committedDate": "2020-02-20T20:44:47Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests III"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/801b6de8dc4ee801ca9eb7048360d79db89cc4e8", "committedDate": "2020-02-14T17:57:45Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests II"}, "afterCommit": {"oid": "db9e03bb968b28a37642f4b825cfe35aec2e8132", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/db9e03bb968b28a37642f4b825cfe35aec2e8132", "committedDate": "2020-02-20T20:44:47Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests III"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "00c0a6fb5eec3c39538f1e28c7cf478ebc674c0d", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/00c0a6fb5eec3c39538f1e28c7cf478ebc674c0d", "committedDate": "2020-02-25T17:21:55Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests IV"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f", "author": {"user": {"login": "wmedvede", "name": "Walter Medvedeo"}}, "url": "https://github.com/kiegroup/droolsjbpm-integration/commit/aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f", "committedDate": "2020-02-26T09:17:25Z", "message": "PLANNER-1627: Planning Server iteration #2 (target architecture)\n    - Tests V"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NjMxODI5", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-365631829", "createdAt": "2020-02-27T12:13:14Z", "commit": {"oid": "aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f"}, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY1NzAwMzI1", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-365700325", "createdAt": "2020-02-27T13:58:21Z", "commit": {"oid": "aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2MDIxNjU3", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/1986#pullrequestreview-366021657", "createdAt": "2020-02-27T21:45:36Z", "commit": {"oid": "aae3659cabb4a0f35d4ef6e9e7e76ec7b9e02b0f"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 1438, "cost": 1, "resetAt": "2021-11-01T15:33:45Z"}}}