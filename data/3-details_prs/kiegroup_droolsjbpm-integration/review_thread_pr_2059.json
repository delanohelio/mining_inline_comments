{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwNTA5MTc1", "number": 2059, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo0Nzo0NVrODv33tA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo1NTo1MlrODv4Dlw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTI1MDQ0OnYy", "diffSide": "RIGHT", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizerTest.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo0Nzo0NVrOGCi_ow==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo0Nzo0NVrOGCi_ow==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyMzY4Mw==", "bodyText": "Nitpicking: multiline comment is more suitable here for easier readability.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405323683", "createdAt": "2020-04-08T07:47:45Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/test/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizerTest.java", "diffHunk": "@@ -142,17 +156,41 @@ public void synchronizeSolution() throws Exception {\n         // wait for the query executions to happen\n         queryExecutionsCountDown.await();\n \n-        //execution0: initial query execution was ok, but result0 has no results.\n-        verify(delegate).findTasks(anyList(), eq(startTime.withNano(0)), anyObject());\n-        //execution1: next retry is with result0.queryTime, but result1 hs no results.\n-        verify(delegate).findTasks(anyList(), eq(results.get(0).getQueryTime().withNano(0)), anyObject());\n-        //execution2: next retry is with result1.queryTime, but result2 has no results.\n-        verify(delegate).findTasks(anyList(), eq(results.get(1).getQueryTime().withNano(0)), anyObject());\n-        //execution3: next retry is with result2.queryTime. but execution3 and execution4 failed.\n-        verify(delegate, times(3)).findTasks(anyList(), eq(results.get(2).getQueryTime().withNano(0)), anyObject());\n-        //execution5: executed ok., but result5 has no results. next retry is with result5.queryTime\n-        verify(delegate).findTasks(anyList(), eq(results.get(5).getQueryTime().withNano(0)), anyObject());\n-        //result6, executed ok and produced changes.\n+        // initial setup queryTimes -> [startTime]\n+        // execution0:\n+        //    execute query with lastModification = startTime\n+        //    execution was ok, but result0 has no results.\n+        //    nextQueryTime = startTime since minimum distance with result0.getQueryTime() is not met -> queryTimes -> [startTime, startTime]\n+        // execution1:\n+        //     execute query with lastModification = startTime\n+        //     execution is ok, but result1 has no values.\n+        //     nextQueryTime = result1.getQueryTime() since minimum distance with startTime is met -> [startTime, result1.getQueryTime()]\n+        // execution2:\n+        //     execute query with lastModification = startTime\n+        //     execution is ok, but result2 has no values.\n+        //     nextQueryTime = result1.getQueryTime() since minimum distance with result2.getQueryTime() is not met -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution3:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution fails.\n+        //     a retry is produced. -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution4:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution fails.\n+        //     a retry is produced. -> [result1.getQueryTime(), result1.getQueryTime()]\n+        // execution5:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution is ok, but result5 has no values\n+        //     nextQueryTime = result5.getQueryTime() since minimum distance with result1.getQueryTime() is met -> [result1.getQueryTime(), result5.getQueryTime()]\n+        // execution6:\n+        //     execute query with lastModification = result1.getQueryTime()\n+        //     execution is ok, and result6 has values!\n+        //     nextQueryTime = result6.getQueryTime() since minimum distance is met -> [result5.getQueryTime(), result6.getQueryTime()]\n+        //     End of loop since results are produced.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "originalPosition": 103}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTI2NzkxOnYy", "diffSide": "RIGHT", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandlerContext.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo1MjozMVrOGCjKcg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwODo1MDo1N1rOGClVaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyNjQ1MA==", "bodyText": "I think the forEach can be called directly from the stream, right after the map call.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405326450", "createdAt": "2020-04-08T07:52:31Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandlerContext.java", "diffHunk": "@@ -49,11 +67,113 @@ public void clearProcessedChangeSet() {\n         lastProcessedChangeSetId = -1;\n     }\n \n-    public LocalDateTime getLastModificationDate() {\n-        return lastModificationDate;\n+    /**\n+     * Registers the time of the last change processed for a task.\n+     * @param taskId identifier of the task to register.\n+     * @param changeTime the task change time to register.\n+     */\n+    public void setTaskChangeTime(long taskId, LocalDateTime changeTime) {\n+        taskChangeTimes.put(taskId, changeTime);\n+    }\n+\n+    /**\n+     * Indicates if a change has already been processed for a given task.\n+     * @param taskId identifier of the task to query.\n+     * @param changeTime the task change time to query.\n+     * @return true if the change has already been processed, false in any other case.\n+     */\n+    public boolean isProcessedTaskChange(long taskId, LocalDateTime changeTime) {\n+        return changeTime.equals(taskChangeTimes.get(taskId));\n+    }\n+\n+    /**\n+     * Removes all the registered task change times that occurred strictly before a given time.\n+     * @param untilLocalDateTime the time for filtering the changes to remove.\n+     */\n+    public void clearTaskChangeTimes(LocalDateTime untilLocalDateTime) {\n+        if (untilLocalDateTime != null) {\n+            final List<Long> removableChanges = taskChangeTimes.entrySet().stream()\n+                    .filter(entry -> untilLocalDateTime.compareTo(entry.getValue()) > 0)\n+                    .map(Map.Entry::getKey)\n+                    .collect(Collectors.toList());\n+            removableChanges.forEach(removableChange -> taskChangeTimes.remove(removableChange));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTM2MjAyNQ==", "bodyText": "the forEach can be chained after the .collect(Collectos.toList()) but not not after the map, otherwise a java.util.ConcurrentModificationException will be produced", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405362025", "createdAt": "2020-04-08T08:50:57Z", "author": {"login": "wmedvede"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolverHandlerContext.java", "diffHunk": "@@ -49,11 +67,113 @@ public void clearProcessedChangeSet() {\n         lastProcessedChangeSetId = -1;\n     }\n \n-    public LocalDateTime getLastModificationDate() {\n-        return lastModificationDate;\n+    /**\n+     * Registers the time of the last change processed for a task.\n+     * @param taskId identifier of the task to register.\n+     * @param changeTime the task change time to register.\n+     */\n+    public void setTaskChangeTime(long taskId, LocalDateTime changeTime) {\n+        taskChangeTimes.put(taskId, changeTime);\n+    }\n+\n+    /**\n+     * Indicates if a change has already been processed for a given task.\n+     * @param taskId identifier of the task to query.\n+     * @param changeTime the task change time to query.\n+     * @return true if the change has already been processed, false in any other case.\n+     */\n+    public boolean isProcessedTaskChange(long taskId, LocalDateTime changeTime) {\n+        return changeTime.equals(taskChangeTimes.get(taskId));\n+    }\n+\n+    /**\n+     * Removes all the registered task change times that occurred strictly before a given time.\n+     * @param untilLocalDateTime the time for filtering the changes to remove.\n+     */\n+    public void clearTaskChangeTimes(LocalDateTime untilLocalDateTime) {\n+        if (untilLocalDateTime != null) {\n+            final List<Long> removableChanges = taskChangeTimes.entrySet().stream()\n+                    .filter(entry -> untilLocalDateTime.compareTo(entry.getValue()) > 0)\n+                    .map(Map.Entry::getKey)\n+                    .collect(Collectors.toList());\n+            removableChanges.forEach(removableChange -> taskChangeTimes.remove(removableChange));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyNjQ1MA=="}, "originalCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "originalPosition": 68}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUxNTI4MDg3OnYy", "diffSide": "RIGHT", "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo1NTo1MlrOGCjSSw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0wOFQwNzo1OTowOFrOGCjZ9A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyODQ1OQ==", "bodyText": "SonarCloud complains about potential NPE due to nextQueryTime might be null.", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405328459", "createdAt": "2020-04-08T07:55:52Z", "author": {"login": "rsynek"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -240,7 +249,14 @@ private TaskAssigningSolution recoverSolution() {\n                                                                                                      Suspended),\n                                                                                        null,\n                                                                                        TaskInputVariablesReadMode.READ_FOR_ALL);\n-        context.setLastModificationDate(result.getQueryTime());\n+\n+        final LocalDateTime nextQueryTime = trimMillis(result.getQueryTime());\n+        final LocalDateTime adjustedFirstQueryTime = nextQueryTime != null ? nextQueryTime.minusHours(1) : null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "originalPosition": 42}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMzMDQyMA==", "bodyText": "already fixed", "url": "https://github.com/kiegroup/droolsjbpm-integration/pull/2059#discussion_r405330420", "createdAt": "2020-04-08T07:59:08Z", "author": {"login": "wmedvede"}, "path": "kie-server-parent/kie-server-services/kie-server-services-task-assigning/kie-server-services-task-assigning-planning/src/main/java/org/kie/server/services/taskassigning/planning/SolutionSynchronizer.java", "diffHunk": "@@ -240,7 +249,14 @@ private TaskAssigningSolution recoverSolution() {\n                                                                                                      Suspended),\n                                                                                        null,\n                                                                                        TaskInputVariablesReadMode.READ_FOR_ALL);\n-        context.setLastModificationDate(result.getQueryTime());\n+\n+        final LocalDateTime nextQueryTime = trimMillis(result.getQueryTime());\n+        final LocalDateTime adjustedFirstQueryTime = nextQueryTime != null ? nextQueryTime.minusHours(1) : null;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTMyODQ1OQ=="}, "originalCommit": {"oid": "071e2fcd2ff6038bf8028c0adfa2a33ca7e194e6"}, "originalPosition": 42}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2122, "cost": 1, "resetAt": "2021-11-12T20:28:25Z"}}}