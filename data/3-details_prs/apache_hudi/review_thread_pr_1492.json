{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDAwMDQwMDE5", "number": 1492, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjozOTo0NVrODxJ8vw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjozOTo0NVrODxJ8vw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjUyODY5ODIzOnYy", "diffSide": "RIGHT", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/rollback/CopyOnWriteRollbackActionExecutor.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjozOTo0NVrOGEeL5A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0xM1QwNjo1NTo0MVrOGEeeaQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MjA1Mg==", "bodyText": "This is not related to current change. Wondering why COW rollback needs to deal with  log files rollback. Should not be a correctness issue but would warrant a fix. I can open a jira and look at this later if you also think this is weird.", "url": "https://github.com/apache/hudi/pull/1492#discussion_r407342052", "createdAt": "2020-04-13T06:39:45Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/rollback/CopyOnWriteRollbackActionExecutor.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.rollback;\n+\n+import org.apache.hudi.common.HoodieRollbackStat;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CopyOnWriteRollbackActionExecutor extends BaseRollbackActionExecutor {\n+\n+  private static final Logger LOG = LogManager.getLogger(CopyOnWriteRollbackActionExecutor.class);\n+\n+  public CopyOnWriteRollbackActionExecutor(JavaSparkContext jsc,\n+                                           HoodieWriteConfig config,\n+                                           HoodieTable<?> table,\n+                                           String instantTime,\n+                                           HoodieInstant commitInstant,\n+                                           boolean deleteInstants) {\n+    super(jsc, config, table, instantTime, commitInstant, deleteInstants);\n+  }\n+\n+  public CopyOnWriteRollbackActionExecutor(JavaSparkContext jsc,\n+                                           HoodieWriteConfig config,\n+                                           HoodieTable<?> table,\n+                                           String instantTime,\n+                                           HoodieInstant commitInstant,\n+                                           boolean deleteInstants,\n+                                           boolean skipTimelinePublish) {\n+    super(jsc, config, table, instantTime, commitInstant, deleteInstants, skipTimelinePublish);\n+  }\n+\n+  @Override\n+  protected List<HoodieRollbackStat> executeRollback() throws IOException {\n+    long startTime = System.currentTimeMillis();\n+    List<HoodieRollbackStat> stats = new ArrayList<>();\n+    HoodieActiveTimeline activeTimeline = table.getActiveTimeline();\n+    HoodieInstant resolvedInstant = instantToRollback;\n+\n+    if (instantToRollback.isCompleted()) {\n+      LOG.info(\"Unpublishing instant \" + instantToRollback);\n+      resolvedInstant = activeTimeline.revertToInflight(instantToRollback);\n+    }\n+\n+    // For Requested State (like failure during index lookup), there is nothing to do rollback other than\n+    // deleting the timeline file\n+    if (!resolvedInstant.isRequested()) {\n+      // delete all the data files for this commit\n+      LOG.info(\"Clean out all parquet files generated for commit: \" + resolvedInstant);\n+      List<RollbackRequest> rollbackRequests = generateRollbackRequests(resolvedInstant);\n+\n+      //TODO: We need to persist this as rollback workload and use it in case of partial failures\n+      stats = new RollbackHelper(table.getMetaClient(), config).performRollback(jsc, resolvedInstant, rollbackRequests);\n+    }\n+    // Delete Inflight instant if enabled\n+    deleteInflightAndRequestedInstant(deleteInstants, activeTimeline, resolvedInstant);\n+    LOG.info(\"Time(in ms) taken to finish rollback \" + (System.currentTimeMillis() - startTime));\n+    return stats;\n+  }\n+\n+  private List<RollbackRequest> generateRollbackRequests(HoodieInstant instantToRollback)\n+      throws IOException {\n+    return FSUtils.getAllPartitionPaths(table.getMetaClient().getFs(), table.getMetaClient().getBasePath(),\n+        config.shouldAssumeDatePartitioning()).stream()\n+        .map(partitionPath -> RollbackRequest.createRollbackRequestWithDeleteDataAndLogFilesAction(partitionPath, instantToRollback))", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 91}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0Njc5Mw==", "bodyText": "it is.. https://github.com/apache/incubator-hudi/blob/master/hudi-client/src/main/java/org/apache/hudi/table/HoodieCopyOnWriteTable.java#L237 does call this.. and this is the commit that introduce this.. https://github.com/apache/incubator-hudi/pull/968/files#diff-47ab1d64d6b64228b07d3c4c4559786cR328\ndef worth following up", "url": "https://github.com/apache/hudi/pull/1492#discussion_r407346793", "createdAt": "2020-04-13T06:55:41Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/rollback/CopyOnWriteRollbackActionExecutor.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.table.action.rollback;\n+\n+import org.apache.hudi.common.HoodieRollbackStat;\n+import org.apache.hudi.common.fs.FSUtils;\n+import org.apache.hudi.common.table.timeline.HoodieActiveTimeline;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+public class CopyOnWriteRollbackActionExecutor extends BaseRollbackActionExecutor {\n+\n+  private static final Logger LOG = LogManager.getLogger(CopyOnWriteRollbackActionExecutor.class);\n+\n+  public CopyOnWriteRollbackActionExecutor(JavaSparkContext jsc,\n+                                           HoodieWriteConfig config,\n+                                           HoodieTable<?> table,\n+                                           String instantTime,\n+                                           HoodieInstant commitInstant,\n+                                           boolean deleteInstants) {\n+    super(jsc, config, table, instantTime, commitInstant, deleteInstants);\n+  }\n+\n+  public CopyOnWriteRollbackActionExecutor(JavaSparkContext jsc,\n+                                           HoodieWriteConfig config,\n+                                           HoodieTable<?> table,\n+                                           String instantTime,\n+                                           HoodieInstant commitInstant,\n+                                           boolean deleteInstants,\n+                                           boolean skipTimelinePublish) {\n+    super(jsc, config, table, instantTime, commitInstant, deleteInstants, skipTimelinePublish);\n+  }\n+\n+  @Override\n+  protected List<HoodieRollbackStat> executeRollback() throws IOException {\n+    long startTime = System.currentTimeMillis();\n+    List<HoodieRollbackStat> stats = new ArrayList<>();\n+    HoodieActiveTimeline activeTimeline = table.getActiveTimeline();\n+    HoodieInstant resolvedInstant = instantToRollback;\n+\n+    if (instantToRollback.isCompleted()) {\n+      LOG.info(\"Unpublishing instant \" + instantToRollback);\n+      resolvedInstant = activeTimeline.revertToInflight(instantToRollback);\n+    }\n+\n+    // For Requested State (like failure during index lookup), there is nothing to do rollback other than\n+    // deleting the timeline file\n+    if (!resolvedInstant.isRequested()) {\n+      // delete all the data files for this commit\n+      LOG.info(\"Clean out all parquet files generated for commit: \" + resolvedInstant);\n+      List<RollbackRequest> rollbackRequests = generateRollbackRequests(resolvedInstant);\n+\n+      //TODO: We need to persist this as rollback workload and use it in case of partial failures\n+      stats = new RollbackHelper(table.getMetaClient(), config).performRollback(jsc, resolvedInstant, rollbackRequests);\n+    }\n+    // Delete Inflight instant if enabled\n+    deleteInflightAndRequestedInstant(deleteInstants, activeTimeline, resolvedInstant);\n+    LOG.info(\"Time(in ms) taken to finish rollback \" + (System.currentTimeMillis() - startTime));\n+    return stats;\n+  }\n+\n+  private List<RollbackRequest> generateRollbackRequests(HoodieInstant instantToRollback)\n+      throws IOException {\n+    return FSUtils.getAllPartitionPaths(table.getMetaClient().getFs(), table.getMetaClient().getBasePath(),\n+        config.shouldAssumeDatePartitioning()).stream()\n+        .map(partitionPath -> RollbackRequest.createRollbackRequestWithDeleteDataAndLogFilesAction(partitionPath, instantToRollback))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM0MjA1Mg=="}, "originalCommit": null, "originalPosition": 91}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4755, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}