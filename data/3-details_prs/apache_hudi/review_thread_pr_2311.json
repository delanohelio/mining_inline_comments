{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTM0OTgyNjU1", "number": 2311, "reviewThreads": {"totalCount": 19, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTowODozN1rOFC0BKA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoxNTowOFrOFFrX0g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDkzNzM2OnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/OverwriteWithLatestAvroPayloadV1.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOTowODozN1rOICJ60g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjoyNTowN1rOIDgEBg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzMDU3OA==", "bodyText": "should we use a string to save storage? Looks like this will create a map for every record.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r539130578", "createdAt": "2020-12-09T09:08:37Z", "author": {"login": "garyli1019"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/OverwriteWithLatestAvroPayloadV1.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field 2.\n+ * combineAndGetUpdateValue/getInsertValue - Simply overwrites storage with latest delta record\n+ */\n+public class OverwriteWithLatestAvroPayloadV1 extends BaseAvroPayload\n+    implements HoodieRecordPayload<OverwriteWithLatestAvroPayloadV1> {\n+\n+  private Map<String, String> props;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0MTk1OA==", "bodyText": "yeah. lets wait to hear from @vinothchandar . Previous impl was sending in this map as arg to combineAndGetUpdateValue rather than storing it as instance var. may be thats better in terms of storage cost. I thought we could avoid making changes to all callers of combineAndGetUpdateValue.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r540541958", "createdAt": "2020-12-10T22:25:07Z", "author": {"login": "nsivabalan"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/OverwriteWithLatestAvroPayloadV1.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field 2.\n+ * combineAndGetUpdateValue/getInsertValue - Simply overwrites storage with latest delta record\n+ */\n+public class OverwriteWithLatestAvroPayloadV1 extends BaseAvroPayload\n+    implements HoodieRecordPayload<OverwriteWithLatestAvroPayloadV1> {\n+\n+  private Map<String, String> props;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzMDU3OA=="}, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDk1NTY0OnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOToxMjoxOFrOICKFZA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOToxMjoxOFrOICKFZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzMzI4NA==", "bodyText": "Is there any reason we need a different config from the pre-combine field? IIUC we wanna make the merging logic consistent, so preCombine and combineAndGetUpdateValue should produce the same result?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r539133284", "createdAt": "2020-12-09T09:12:18Z", "author": {"login": "garyli1019"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -121,6 +121,10 @@\n   private static final String MERGE_DATA_VALIDATION_CHECK_ENABLED = \"hoodie.merge.data.validation.enabled\";\n   private static final String DEFAULT_MERGE_DATA_VALIDATION_CHECK_ENABLED = \"false\";\n \n+  // payload ordering field\n+  private static final String PAYLOAD_ORDERING_FIELD_PROP = \"hoodie.payload.ordering.field\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NDk3MjI2OnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/OverwriteWithLatestAvroPayloadV1.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOToxNTo1MlrOICKPRw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMFQyMjoyNjoxNVrOIDgGIQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzNTgxNQ==", "bodyText": "naming is hard... how about CombineWithLargestOrderingValPayload?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r539135815", "createdAt": "2020-12-09T09:15:52Z", "author": {"login": "garyli1019"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/OverwriteWithLatestAvroPayloadV1.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field 2.\n+ * combineAndGetUpdateValue/getInsertValue - Simply overwrites storage with latest delta record\n+ */\n+public class OverwriteWithLatestAvroPayloadV1 extends BaseAvroPayload", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU0MjQ5Nw==", "bodyText": "yeah. Ideally existing one should have been OverwriteWithIncomingAvroPayload and this new one should be OverwriteWithLatestAvroPayload.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r540542497", "createdAt": "2020-12-10T22:26:15Z", "author": {"login": "nsivabalan"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/OverwriteWithLatestAvroPayloadV1.java", "diffHunk": "@@ -0,0 +1,120 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field 2.\n+ * combineAndGetUpdateValue/getInsertValue - Simply overwrites storage with latest delta record\n+ */\n+public class OverwriteWithLatestAvroPayloadV1 extends BaseAvroPayload", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEzNTgxNQ=="}, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 40}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM4NTAzNDM3OnYy", "diffSide": "RIGHT", "path": "hudi-spark/src/main/scala/org/apache/hudi/DataSourceOptions.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOVQwOToyODoyNFrOICKz2A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoyNzozM1rOIDuFmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE0NTE3Ng==", "bodyText": "keep this true is more rational for me. From a new user perspective, I don't really understand the difference between preCombine and combineWithLatestValue. It took me a while to figure this out and originally I thought this is a bug. But we need to think about the impact of the existing user.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r539145176", "createdAt": "2020-12-09T09:28:24Z", "author": {"login": "garyli1019"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/DataSourceOptions.scala", "diffHunk": "@@ -205,6 +205,12 @@ object DataSourceWriteOptions {\n   val PRECOMBINE_FIELD_OPT_KEY = \"hoodie.datasource.write.precombine.field\"\n   val DEFAULT_PRECOMBINE_FIELD_OPT_VAL = \"ts\"\n \n+  /**\n+   * Field when set to true, will honor ordering while merging two records. If not, incoming record will overwrite\n+   * record in storage.\n+   */\n+  val HONOR_ORDERING_WHILE_MERGING_OPT_KEY = \"hoodie.datasource.honor.ordering.while.merging\"\n+  val DEFAULT_HONOR_ORDERING_WHILE_MERGING_OPT_VAL = \"false\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 9}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc3MTczNg==", "bodyText": "I really don't like having these payload specific configs, top level in datasource options.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r540771736", "createdAt": "2020-12-11T08:27:33Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/DataSourceOptions.scala", "diffHunk": "@@ -205,6 +205,12 @@ object DataSourceWriteOptions {\n   val PRECOMBINE_FIELD_OPT_KEY = \"hoodie.datasource.write.precombine.field\"\n   val DEFAULT_PRECOMBINE_FIELD_OPT_VAL = \"ts\"\n \n+  /**\n+   * Field when set to true, will honor ordering while merging two records. If not, incoming record will overwrite\n+   * record in storage.\n+   */\n+  val HONOR_ORDERING_WHILE_MERGING_OPT_KEY = \"hoodie.datasource.honor.ordering.while.merging\"\n+  val DEFAULT_HONOR_ORDERING_WHILE_MERGING_OPT_VAL = \"false\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTE0NTE3Ng=="}, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 9}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjAzMzgyOnYy", "diffSide": "RIGHT", "path": "hudi-spark/src/main/java/org/apache/hudi/DataSourceUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoyNjo0OFrOIDuD7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoyNjo0OFrOIDuD7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc3MTMwOQ==", "bodyText": "@nsivabalan  won't this break for an existing payloadClass (user defined), that does have this three member constructor?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r540771309", "createdAt": "2020-12-11T08:26:48Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/java/org/apache/hudi/DataSourceUtils.java", "diffHunk": "@@ -142,6 +142,20 @@ public static HoodieRecordPayload createPayload(String payloadClass, GenericReco\n     }\n   }\n \n+  /**\n+   * Create a payload class via reflection, passing in an ordering/precombine value.\n+   */\n+  public static HoodieRecordPayload createPayload(String payloadClass, GenericRecord record, Comparable orderingVal,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzM5NjA0MDEyOnYy", "diffSide": "RIGHT", "path": "hudi-spark/src/main/scala/org/apache/hudi/HoodieSparkSqlWriter.scala", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoyODoxNFrOIDuHag==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xMVQwODoyODoxNFrOIDuHag==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDc3MjIwMg==", "bodyText": "this is more and more overhead for the user to learn one more parameter when using one specific payload", "url": "https://github.com/apache/hudi/pull/2311#discussion_r540772202", "createdAt": "2020-12-11T08:28:14Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/HoodieSparkSqlWriter.scala", "diffHunk": "@@ -154,9 +154,16 @@ private[hudi] object HoodieSparkSqlWriter {\n             val hoodieRecord = if (shouldCombine) {\n               val orderingVal = HoodieAvroUtils.getNestedFieldVal(gr, parameters(PRECOMBINE_FIELD_OPT_KEY), false)\n                 .asInstanceOf[Comparable[_]]\n-              DataSourceUtils.createHoodieRecord(gr,\n-                orderingVal, keyGenerator.getKey(gr),\n-                parameters(PAYLOAD_CLASS_OPT_KEY))\n+              val honorOrderingWhileMerging = parameters(HONOR_ORDERING_WHILE_MERGING_OPT_KEY).toBoolean", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d637a728505792fdd5ca184877b12a918aeb3314"}, "originalPosition": 7}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDg2NTM4OnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo1NDowMVrOIGSiKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo1NDowMVrOIGSiKg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2NjAyNg==", "bodyText": "rename: getPayloadConfig()", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543466026", "createdAt": "2020-12-15T15:54:01Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -729,6 +731,10 @@ public FileSystemViewStorageConfig getClientSpecifiedViewStorageConfig() {\n     return clientSpecifiedViewStorageConfig;\n   }\n \n+  public HoodiePayloadConfig getHoodiePayloadConfig() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDg3MDQxOnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/BaseAvroPayload.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo1NDo1NlrOIGSlLA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo1NDo1NlrOIGSlLA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2Njc5Ng==", "bodyText": "nit: extra line", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543466796", "createdAt": "2020-12-15T15:54:56Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/BaseAvroPayload.java", "diffHunk": "@@ -29,6 +29,7 @@\n  * Base class for all AVRO record based payloads, that can be ordered based on a field.\n  */\n public abstract class BaseAvroPayload implements Serializable {\n+  ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDg3NzY3OnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodiePayloadProps.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo1NjoyOFrOIGSpvA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo1NjoyOFrOIGSpvA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2Nzk2NA==", "bodyText": "more descriptive doc?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543467964", "createdAt": "2020-12-15T15:56:28Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodiePayloadProps.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package org.apache.hudi.common.model;\n+\n+/**\n+ * Since both payload classes and HoodiePayloadConfig needs to access these props, storing it here.\n+ */\n+public class HoodiePayloadProps {\n+\n+  // payload ordering field", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDg5MjI5OnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo1ODo1M1rOIGSyUQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNTo1ODo1M1rOIGSyUQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3MDE2MQ==", "bodyText": "mark all deprecated methods with the right ApiMaturityLevel.DEPRECATED?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543470161", "createdAt": "2020-12-15T15:58:53Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "diffHunk": "@@ -29,47 +29,93 @@\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which\n- * depend on record specific logic.\n+ * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which depend on record specific logic.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.STABLE)\n public interface HoodieRecordPayload<T extends HoodieRecordPayload> extends Serializable {\n \n   /**\n-   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to\n-   * insert/upsert (if combining turned on in HoodieClientConfig).\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig).\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   T preCombine(T another);\n \n   /**\n-   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on\n-   * storage and whats contained in this object.\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig) by taking in a property map. Implementation can leverage the property to decide their business logic to do preCombine.\n+   * @param another instance of another {@link HoodieRecordPayload} to be combined with.\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return the combined value\n+   */\n+  @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n+  default T preCombine(T another, Properties properties) {\n+    return preCombine(another);\n+  }\n+\n+  /**\n+   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on storage and whats contained\n+   * in this object.\n    * <p>\n-   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You\n-   * may be reading DB redo logs, and merge them with current image for a database row on storage\n+   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You may be reading DB redo logs,\n+   * and merge them with current image for a database row on storage\n    *\n    * @param currentValue Current value in storage, to merge/combine this payload with\n    * @param schema Schema used for record\n    * @return new combined/merged value to be written back to storage. EMPTY to skip writing this record.\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 52}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDkwNTc4OnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowMToyNFrOIGS6tw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowMToyNFrOIGS6tw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3MjMxMQ==", "bodyText": "this is not just for delta streamer.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543472311", "createdAt": "2020-12-15T16:01:24Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Default payload used for delta streamer.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 36}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDkxNzg1OnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowMzo0NFrOIGTB-w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowMzo0NFrOIGTB-w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NDE3MQ==", "bodyText": "is this class pretty much a modified version of OverwriteWithLatestAvroPayload?  if so, can we reuse some code by having that extend from this, and override methods as needed?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543474171", "createdAt": "2020-12-15T16:03:44Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field\n+ * 2. combineAndGetUpdateValue/getInsertValue - Chooses the latest record based on ordering field value.\n+ */\n+public class DefaultHoodieRecordPayload extends BaseAvroPayload", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 41}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDkyNTk5OnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowNToxMlrOIGTG0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNToyMzo1NVrOIGxgrQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NTQxMA==", "bodyText": "just do the Comparable cast here itself?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543475410", "createdAt": "2020-12-15T16:05:12Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field\n+ * 2. combineAndGetUpdateValue/getInsertValue - Chooses the latest record based on ordering field value.\n+ */\n+public class DefaultHoodieRecordPayload extends BaseAvroPayload\n+    implements HoodieRecordPayload<DefaultHoodieRecordPayload> {\n+\n+  public DefaultHoodieRecordPayload(GenericRecord record, Comparable orderingVal) {\n+    super(record, orderingVal);\n+  }\n+\n+  public DefaultHoodieRecordPayload(Option<GenericRecord> record) {\n+    this(record.isPresent() ? record.get() : null, (record1) -> 0); // natural order\n+  }\n+\n+  @Override\n+  public DefaultHoodieRecordPayload preCombine(DefaultHoodieRecordPayload another) {\n+    // pick the payload with greatest ordering value\n+    if (another.orderingVal.compareTo(orderingVal) > 0) {\n+      return another;\n+    } else {\n+      return this;\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> getInsertValue(Schema schema) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    IndexedRecord indexedRecord = bytesToAvro(recordBytes, schema);\n+    if (isDeleteRecord((GenericRecord) indexedRecord)) {\n+      return Option.empty();\n+    } else {\n+      return Option.of(indexedRecord);\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema) throws IOException{\n+    return getInsertValue(schema);\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema, Properties properties) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    GenericRecord incomingRecord = bytesToAvro(recordBytes, schema);\n+    /*\n+     * Combining strategy here returns currentValue on disk if incoming record is older.\n+     * The incoming record can be either a delete (sent as an upsert with _hoodie_is_deleted set to true)\n+     * or an insert/update record. In any case, if it is older than the record in disk, the currentValue\n+     * in disk is returned (to be rewritten with new commit time).\n+     *\n+     * NOTE: Deletes sent via EmptyHoodieRecordPayload and/or Delete operation type do not hit this code path\n+     * and need to be dealt with separately.\n+     */\n+    Object persistedOrderingVal = getNestedFieldVal((GenericRecord) currentValue, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3Mjg4Mg==", "bodyText": "I thought you had already reviewed previous PR and hence just copied as is. Will fix it.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543972882", "createdAt": "2020-12-16T05:23:09Z", "author": {"login": "nsivabalan"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field\n+ * 2. combineAndGetUpdateValue/getInsertValue - Chooses the latest record based on ordering field value.\n+ */\n+public class DefaultHoodieRecordPayload extends BaseAvroPayload\n+    implements HoodieRecordPayload<DefaultHoodieRecordPayload> {\n+\n+  public DefaultHoodieRecordPayload(GenericRecord record, Comparable orderingVal) {\n+    super(record, orderingVal);\n+  }\n+\n+  public DefaultHoodieRecordPayload(Option<GenericRecord> record) {\n+    this(record.isPresent() ? record.get() : null, (record1) -> 0); // natural order\n+  }\n+\n+  @Override\n+  public DefaultHoodieRecordPayload preCombine(DefaultHoodieRecordPayload another) {\n+    // pick the payload with greatest ordering value\n+    if (another.orderingVal.compareTo(orderingVal) > 0) {\n+      return another;\n+    } else {\n+      return this;\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> getInsertValue(Schema schema) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    IndexedRecord indexedRecord = bytesToAvro(recordBytes, schema);\n+    if (isDeleteRecord((GenericRecord) indexedRecord)) {\n+      return Option.empty();\n+    } else {\n+      return Option.of(indexedRecord);\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema) throws IOException{\n+    return getInsertValue(schema);\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema, Properties properties) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    GenericRecord incomingRecord = bytesToAvro(recordBytes, schema);\n+    /*\n+     * Combining strategy here returns currentValue on disk if incoming record is older.\n+     * The incoming record can be either a delete (sent as an upsert with _hoodie_is_deleted set to true)\n+     * or an insert/update record. In any case, if it is older than the record in disk, the currentValue\n+     * in disk is returned (to be rewritten with new commit time).\n+     *\n+     * NOTE: Deletes sent via EmptyHoodieRecordPayload and/or Delete operation type do not hit this code path\n+     * and need to be dealt with separately.\n+     */\n+    Object persistedOrderingVal = getNestedFieldVal((GenericRecord) currentValue, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NTQxMA=="}, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3MzU0OQ==", "bodyText": "actually we can't do that. it could be null.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543973549", "createdAt": "2020-12-16T05:23:55Z", "author": {"login": "nsivabalan"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field\n+ * 2. combineAndGetUpdateValue/getInsertValue - Chooses the latest record based on ordering field value.\n+ */\n+public class DefaultHoodieRecordPayload extends BaseAvroPayload\n+    implements HoodieRecordPayload<DefaultHoodieRecordPayload> {\n+\n+  public DefaultHoodieRecordPayload(GenericRecord record, Comparable orderingVal) {\n+    super(record, orderingVal);\n+  }\n+\n+  public DefaultHoodieRecordPayload(Option<GenericRecord> record) {\n+    this(record.isPresent() ? record.get() : null, (record1) -> 0); // natural order\n+  }\n+\n+  @Override\n+  public DefaultHoodieRecordPayload preCombine(DefaultHoodieRecordPayload another) {\n+    // pick the payload with greatest ordering value\n+    if (another.orderingVal.compareTo(orderingVal) > 0) {\n+      return another;\n+    } else {\n+      return this;\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> getInsertValue(Schema schema) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    IndexedRecord indexedRecord = bytesToAvro(recordBytes, schema);\n+    if (isDeleteRecord((GenericRecord) indexedRecord)) {\n+      return Option.empty();\n+    } else {\n+      return Option.of(indexedRecord);\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema) throws IOException{\n+    return getInsertValue(schema);\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema, Properties properties) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    GenericRecord incomingRecord = bytesToAvro(recordBytes, schema);\n+    /*\n+     * Combining strategy here returns currentValue on disk if incoming record is older.\n+     * The incoming record can be either a delete (sent as an upsert with _hoodie_is_deleted set to true)\n+     * or an insert/update record. In any case, if it is older than the record in disk, the currentValue\n+     * in disk is returned (to be rewritten with new commit time).\n+     *\n+     * NOTE: Deletes sent via EmptyHoodieRecordPayload and/or Delete operation type do not hit this code path\n+     * and need to be dealt with separately.\n+     */\n+    Object persistedOrderingVal = getNestedFieldVal((GenericRecord) currentValue, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), true);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NTQxMA=="}, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDkzODMyOnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowNzoyOFrOIGTOHQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNlQwNToyNzo0MlrOIGxsSQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NzI3Nw==", "bodyText": "nts: the check means persistedOrderingVal > incomingOrderingVal i.e we should retain the value on disk", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543477277", "createdAt": "2020-12-15T16:07:28Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field\n+ * 2. combineAndGetUpdateValue/getInsertValue - Chooses the latest record based on ordering field value.\n+ */\n+public class DefaultHoodieRecordPayload extends BaseAvroPayload\n+    implements HoodieRecordPayload<DefaultHoodieRecordPayload> {\n+\n+  public DefaultHoodieRecordPayload(GenericRecord record, Comparable orderingVal) {\n+    super(record, orderingVal);\n+  }\n+\n+  public DefaultHoodieRecordPayload(Option<GenericRecord> record) {\n+    this(record.isPresent() ? record.get() : null, (record1) -> 0); // natural order\n+  }\n+\n+  @Override\n+  public DefaultHoodieRecordPayload preCombine(DefaultHoodieRecordPayload another) {\n+    // pick the payload with greatest ordering value\n+    if (another.orderingVal.compareTo(orderingVal) > 0) {\n+      return another;\n+    } else {\n+      return this;\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> getInsertValue(Schema schema) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    IndexedRecord indexedRecord = bytesToAvro(recordBytes, schema);\n+    if (isDeleteRecord((GenericRecord) indexedRecord)) {\n+      return Option.empty();\n+    } else {\n+      return Option.of(indexedRecord);\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema) throws IOException{\n+    return getInsertValue(schema);\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema, Properties properties) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    GenericRecord incomingRecord = bytesToAvro(recordBytes, schema);\n+    /*\n+     * Combining strategy here returns currentValue on disk if incoming record is older.\n+     * The incoming record can be either a delete (sent as an upsert with _hoodie_is_deleted set to true)\n+     * or an insert/update record. In any case, if it is older than the record in disk, the currentValue\n+     * in disk is returned (to be rewritten with new commit time).\n+     *\n+     * NOTE: Deletes sent via EmptyHoodieRecordPayload and/or Delete operation type do not hit this code path\n+     * and need to be dealt with separately.\n+     */\n+    Object persistedOrderingVal = getNestedFieldVal((GenericRecord) currentValue, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), true);\n+    Comparable incomingOrderingVal = (Comparable) getNestedFieldVal(incomingRecord, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), false);\n+\n+    // Null check is needed here to support schema evolution. The record in storage may be from old schema where\n+    // the new ordering column might not be present and hence returns null.\n+    if (persistedOrderingVal != null && ((Comparable) persistedOrderingVal).compareTo(incomingOrderingVal) > 0) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3NDA2Mg==", "bodyText": "sorry, you wanted to confirm this behavior? can you please clarify.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543974062", "createdAt": "2020-12-16T05:24:36Z", "author": {"login": "nsivabalan"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field\n+ * 2. combineAndGetUpdateValue/getInsertValue - Chooses the latest record based on ordering field value.\n+ */\n+public class DefaultHoodieRecordPayload extends BaseAvroPayload\n+    implements HoodieRecordPayload<DefaultHoodieRecordPayload> {\n+\n+  public DefaultHoodieRecordPayload(GenericRecord record, Comparable orderingVal) {\n+    super(record, orderingVal);\n+  }\n+\n+  public DefaultHoodieRecordPayload(Option<GenericRecord> record) {\n+    this(record.isPresent() ? record.get() : null, (record1) -> 0); // natural order\n+  }\n+\n+  @Override\n+  public DefaultHoodieRecordPayload preCombine(DefaultHoodieRecordPayload another) {\n+    // pick the payload with greatest ordering value\n+    if (another.orderingVal.compareTo(orderingVal) > 0) {\n+      return another;\n+    } else {\n+      return this;\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> getInsertValue(Schema schema) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    IndexedRecord indexedRecord = bytesToAvro(recordBytes, schema);\n+    if (isDeleteRecord((GenericRecord) indexedRecord)) {\n+      return Option.empty();\n+    } else {\n+      return Option.of(indexedRecord);\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema) throws IOException{\n+    return getInsertValue(schema);\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema, Properties properties) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    GenericRecord incomingRecord = bytesToAvro(recordBytes, schema);\n+    /*\n+     * Combining strategy here returns currentValue on disk if incoming record is older.\n+     * The incoming record can be either a delete (sent as an upsert with _hoodie_is_deleted set to true)\n+     * or an insert/update record. In any case, if it is older than the record in disk, the currentValue\n+     * in disk is returned (to be rewritten with new commit time).\n+     *\n+     * NOTE: Deletes sent via EmptyHoodieRecordPayload and/or Delete operation type do not hit this code path\n+     * and need to be dealt with separately.\n+     */\n+    Object persistedOrderingVal = getNestedFieldVal((GenericRecord) currentValue, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), true);\n+    Comparable incomingOrderingVal = (Comparable) getNestedFieldVal(incomingRecord, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), false);\n+\n+    // Null check is needed here to support schema evolution. The record in storage may be from old schema where\n+    // the new ordering column might not be present and hence returns null.\n+    if (persistedOrderingVal != null && ((Comparable) persistedOrderingVal).compareTo(incomingOrderingVal) > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NzI3Nw=="}, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzk3NjUyMQ==", "bodyText": "yes . nts = note to self. sorry :/", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543976521", "createdAt": "2020-12-16T05:27:42Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/DefaultHoodieRecordPayload.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+import static org.apache.hudi.avro.HoodieAvroUtils.bytesToAvro;\n+import static org.apache.hudi.avro.HoodieAvroUtils.getNestedFieldVal;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import org.apache.hudi.common.util.Option;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.avro.generic.IndexedRecord;\n+\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/**\n+ * Default payload used for delta streamer.\n+ * <p>\n+ * 1. preCombine - Picks the latest delta record for a key, based on an ordering field\n+ * 2. combineAndGetUpdateValue/getInsertValue - Chooses the latest record based on ordering field value.\n+ */\n+public class DefaultHoodieRecordPayload extends BaseAvroPayload\n+    implements HoodieRecordPayload<DefaultHoodieRecordPayload> {\n+\n+  public DefaultHoodieRecordPayload(GenericRecord record, Comparable orderingVal) {\n+    super(record, orderingVal);\n+  }\n+\n+  public DefaultHoodieRecordPayload(Option<GenericRecord> record) {\n+    this(record.isPresent() ? record.get() : null, (record1) -> 0); // natural order\n+  }\n+\n+  @Override\n+  public DefaultHoodieRecordPayload preCombine(DefaultHoodieRecordPayload another) {\n+    // pick the payload with greatest ordering value\n+    if (another.orderingVal.compareTo(orderingVal) > 0) {\n+      return another;\n+    } else {\n+      return this;\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> getInsertValue(Schema schema) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    IndexedRecord indexedRecord = bytesToAvro(recordBytes, schema);\n+    if (isDeleteRecord((GenericRecord) indexedRecord)) {\n+      return Option.empty();\n+    } else {\n+      return Option.of(indexedRecord);\n+    }\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema) throws IOException{\n+    return getInsertValue(schema);\n+  }\n+\n+  @Override\n+  public Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema, Properties properties) throws IOException {\n+    if (recordBytes.length == 0) {\n+      return Option.empty();\n+    }\n+    GenericRecord incomingRecord = bytesToAvro(recordBytes, schema);\n+    /*\n+     * Combining strategy here returns currentValue on disk if incoming record is older.\n+     * The incoming record can be either a delete (sent as an upsert with _hoodie_is_deleted set to true)\n+     * or an insert/update record. In any case, if it is older than the record in disk, the currentValue\n+     * in disk is returned (to be rewritten with new commit time).\n+     *\n+     * NOTE: Deletes sent via EmptyHoodieRecordPayload and/or Delete operation type do not hit this code path\n+     * and need to be dealt with separately.\n+     */\n+    Object persistedOrderingVal = getNestedFieldVal((GenericRecord) currentValue, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), true);\n+    Comparable incomingOrderingVal = (Comparable) getNestedFieldVal(incomingRecord, properties.getProperty(HoodiePayloadProps.PAYLOAD_ORDERING_FIELD_PROP), false);\n+\n+    // Null check is needed here to support schema evolution. The record in storage may be from old schema where\n+    // the new ordering column might not be present and hence returns null.\n+    if (persistedOrderingVal != null && ((Comparable) persistedOrderingVal).compareTo(incomingOrderingVal) > 0) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3NzI3Nw=="}, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 100}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDk0NjMxOnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowOToxMFrOIGTTOQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowOToxMFrOIGTTOQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3ODU4NQ==", "bodyText": "please remove \"if combinng turned on ...\" comment. we should ideally refrain from referring to higher level constructs from lower layers.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543478585", "createdAt": "2020-12-15T16:09:10Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "diffHunk": "@@ -29,47 +29,93 @@\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which\n- * depend on record specific logic.\n+ * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which depend on record specific logic.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.STABLE)\n public interface HoodieRecordPayload<T extends HoodieRecordPayload> extends Serializable {\n \n   /**\n-   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to\n-   * insert/upsert (if combining turned on in HoodieClientConfig).\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig).", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 18}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDk1MDIwOnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowOTo1MVrOIGTVew==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjowOTo1MVrOIGTVew==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3OTE2Mw==", "bodyText": "same here", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543479163", "createdAt": "2020-12-15T16:09:51Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "diffHunk": "@@ -29,47 +29,93 @@\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which\n- * depend on record specific logic.\n+ * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which depend on record specific logic.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.STABLE)\n public interface HoodieRecordPayload<T extends HoodieRecordPayload> extends Serializable {\n \n   /**\n-   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to\n-   * insert/upsert (if combining turned on in HoodieClientConfig).\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig).\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   T preCombine(T another);\n \n   /**\n-   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on\n-   * storage and whats contained in this object.\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 27}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDk1MjE0OnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoxMDoxOVrOIGTW0A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoxMjo1MlrOIGTeyA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3OTUwNA==", "bodyText": "place 2 on a newline?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543479504", "createdAt": "2020-12-15T16:10:19Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "diffHunk": "@@ -29,47 +29,93 @@\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which\n- * depend on record specific logic.\n+ * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which depend on record specific logic.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.STABLE)\n public interface HoodieRecordPayload<T extends HoodieRecordPayload> extends Serializable {\n \n   /**\n-   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to\n-   * insert/upsert (if combining turned on in HoodieClientConfig).\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig).\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   T preCombine(T another);\n \n   /**\n-   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on\n-   * storage and whats contained in this object.\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig) by taking in a property map. Implementation can leverage the property to decide their business logic to do preCombine.\n+   * @param another instance of another {@link HoodieRecordPayload} to be combined with.\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return the combined value\n+   */\n+  @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n+  default T preCombine(T another, Properties properties) {\n+    return preCombine(another);\n+  }\n+\n+  /**\n+   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on storage and whats contained\n+   * in this object.\n    * <p>\n-   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You\n-   * may be reading DB redo logs, and merge them with current image for a database row on storage\n+   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You may be reading DB redo logs,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3OTY4Mg==", "bodyText": "close the </p>", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543479682", "createdAt": "2020-12-15T16:10:34Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "diffHunk": "@@ -29,47 +29,93 @@\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which\n- * depend on record specific logic.\n+ * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which depend on record specific logic.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.STABLE)\n public interface HoodieRecordPayload<T extends HoodieRecordPayload> extends Serializable {\n \n   /**\n-   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to\n-   * insert/upsert (if combining turned on in HoodieClientConfig).\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig).\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   T preCombine(T another);\n \n   /**\n-   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on\n-   * storage and whats contained in this object.\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig) by taking in a property map. Implementation can leverage the property to decide their business logic to do preCombine.\n+   * @param another instance of another {@link HoodieRecordPayload} to be combined with.\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return the combined value\n+   */\n+  @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n+  default T preCombine(T another, Properties properties) {\n+    return preCombine(another);\n+  }\n+\n+  /**\n+   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on storage and whats contained\n+   * in this object.\n    * <p>\n-   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You\n-   * may be reading DB redo logs, and merge them with current image for a database row on storage\n+   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You may be reading DB redo logs,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3OTUwNA=="}, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 44}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4MTU0NA==", "bodyText": "I think we should just refer to the other method here in the javadoc, instead of repeating the entire description here again.", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543481544", "createdAt": "2020-12-15T16:12:52Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "diffHunk": "@@ -29,47 +29,93 @@\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which\n- * depend on record specific logic.\n+ * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which depend on record specific logic.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.STABLE)\n public interface HoodieRecordPayload<T extends HoodieRecordPayload> extends Serializable {\n \n   /**\n-   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to\n-   * insert/upsert (if combining turned on in HoodieClientConfig).\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig).\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   T preCombine(T another);\n \n   /**\n-   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on\n-   * storage and whats contained in this object.\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig) by taking in a property map. Implementation can leverage the property to decide their business logic to do preCombine.\n+   * @param another instance of another {@link HoodieRecordPayload} to be combined with.\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return the combined value\n+   */\n+  @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n+  default T preCombine(T another, Properties properties) {\n+    return preCombine(another);\n+  }\n+\n+  /**\n+   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on storage and whats contained\n+   * in this object.\n    * <p>\n-   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You\n-   * may be reading DB redo logs, and merge them with current image for a database row on storage\n+   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You may be reading DB redo logs,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ3OTUwNA=="}, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 44}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDk3NzAzOnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoxNDo1M1rOIGTlfw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoxNDo1M1rOIGTlfw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4MzI2Mw==", "bodyText": "this line can be bit pithy?", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543483263", "createdAt": "2020-12-15T16:14:53Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "diffHunk": "@@ -29,47 +29,93 @@\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which\n- * depend on record specific logic.\n+ * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which depend on record specific logic.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.STABLE)\n public interface HoodieRecordPayload<T extends HoodieRecordPayload> extends Serializable {\n \n   /**\n-   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to\n-   * insert/upsert (if combining turned on in HoodieClientConfig).\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig).\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   T preCombine(T another);\n \n   /**\n-   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on\n-   * storage and whats contained in this object.\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig) by taking in a property map. Implementation can leverage the property to decide their business logic to do preCombine.\n+   * @param another instance of another {@link HoodieRecordPayload} to be combined with.\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return the combined value\n+   */\n+  @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n+  default T preCombine(T another, Properties properties) {\n+    return preCombine(another);\n+  }\n+\n+  /**\n+   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on storage and whats contained\n+   * in this object.\n    * <p>\n-   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You\n-   * may be reading DB redo logs, and merge them with current image for a database row on storage\n+   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You may be reading DB redo logs,\n+   * and merge them with current image for a database row on storage\n    *\n    * @param currentValue Current value in storage, to merge/combine this payload with\n    * @param schema Schema used for record\n    * @return new combined/merged value to be written back to storage. EMPTY to skip writing this record.\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema) throws IOException;\n \n   /**\n-   * Generates an avro record out of the given HoodieRecordPayload, to be written out to storage. Called when writing a\n-   * new value for the given HoodieKey, wherein there is no existing record in storage to be combined against. (i.e\n-   * insert) Return EMPTY to skip writing this record.\n+   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on storage and whats contained\n+   * in this object. This method takes in a property map as an arg so that implementation can decide their business logic based\n+   *    * on some properties set.\n+   * <p>\n+   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You may be reading DB redo logs,\n+   * and merge them with current image for a database row on storage\n+   *\n+   * @param currentValue Current value in storage, to merge/combine this payload with\n+   * @param schema Schema used for record\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return new combined/merged value to be written back to storage. EMPTY to skip writing this record.\n    */\n+  default Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema, Properties properties) throws IOException {\n+    return combineAndGetUpdateValue(currentValue, schema);\n+  }\n+\n+  /**\n+   * Generates an avro record out of the given HoodieRecordPayload, to be written out to storage. Called when writing a new value for the given\n+   * HoodieKey, wherein there is no existing record in storage to be combined against. (i.e insert) Return EMPTY to skip writing this record.\n+   * @param schema Schema used for record\n+   * @return the {@link IndexedRecord} to be inserted.\n+   */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   Option<IndexedRecord> getInsertValue(Schema schema) throws IOException;\n \n   /**\n-   * This method can be used to extract some metadata from HoodieRecordPayload. The metadata is passed to\n-   * {@code WriteStatus.markSuccess()} and {@code WriteStatus.markFailure()} in order to compute some aggregate metrics\n-   * using the metadata in the context of a write success or failure.\n+   * Generates an avro record out of the given HoodieRecordPayload, to be written out to storage. Called when writing a new value for the given\n+   * HoodieKey, wherein there is no existing record in storage to be combined against. (i.e insert) Return EMPTY to skip writing this record.\n+   * This method takes in a property map as an arg so that implementation can decide their business logic based on some properties set.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 91}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQxNDk3ODEwOnYy", "diffSide": "RIGHT", "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoxNTowOFrOIGTmMA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0xNVQxNjoxNTowOFrOIGTmMA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ4MzQ0MA==", "bodyText": "thanks for fixing this", "url": "https://github.com/apache/hudi/pull/2311#discussion_r543483440", "createdAt": "2020-12-15T16:15:08Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecordPayload.java", "diffHunk": "@@ -29,47 +29,93 @@\n import java.io.IOException;\n import java.io.Serializable;\n import java.util.Map;\n+import java.util.Properties;\n \n /**\n- * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which\n- * depend on record specific logic.\n+ * Every Hoodie table has an implementation of the <code>HoodieRecordPayload</code> This abstracts out callbacks which depend on record specific logic.\n  */\n @PublicAPIClass(maturity = ApiMaturityLevel.STABLE)\n public interface HoodieRecordPayload<T extends HoodieRecordPayload> extends Serializable {\n \n   /**\n-   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to\n-   * insert/upsert (if combining turned on in HoodieClientConfig).\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig).\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   T preCombine(T another);\n \n   /**\n-   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on\n-   * storage and whats contained in this object.\n+   * When more than one HoodieRecord have the same HoodieKey, this function combines them before attempting to insert/upsert (if combining turned on\n+   * in HoodieClientConfig) by taking in a property map. Implementation can leverage the property to decide their business logic to do preCombine.\n+   * @param another instance of another {@link HoodieRecordPayload} to be combined with.\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return the combined value\n+   */\n+  @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n+  default T preCombine(T another, Properties properties) {\n+    return preCombine(another);\n+  }\n+\n+  /**\n+   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on storage and whats contained\n+   * in this object.\n    * <p>\n-   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You\n-   * may be reading DB redo logs, and merge them with current image for a database row on storage\n+   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You may be reading DB redo logs,\n+   * and merge them with current image for a database row on storage\n    *\n    * @param currentValue Current value in storage, to merge/combine this payload with\n    * @param schema Schema used for record\n    * @return new combined/merged value to be written back to storage. EMPTY to skip writing this record.\n    */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema) throws IOException;\n \n   /**\n-   * Generates an avro record out of the given HoodieRecordPayload, to be written out to storage. Called when writing a\n-   * new value for the given HoodieKey, wherein there is no existing record in storage to be combined against. (i.e\n-   * insert) Return EMPTY to skip writing this record.\n+   * This methods lets you write custom merging/combining logic to produce new values as a function of current value on storage and whats contained\n+   * in this object. This method takes in a property map as an arg so that implementation can decide their business logic based\n+   *    * on some properties set.\n+   * <p>\n+   * eg: 1) You are updating counters, you may want to add counts to currentValue and write back updated counts 2) You may be reading DB redo logs,\n+   * and merge them with current image for a database row on storage\n+   *\n+   * @param currentValue Current value in storage, to merge/combine this payload with\n+   * @param schema Schema used for record\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return new combined/merged value to be written back to storage. EMPTY to skip writing this record.\n    */\n+  default Option<IndexedRecord> combineAndGetUpdateValue(IndexedRecord currentValue, Schema schema, Properties properties) throws IOException {\n+    return combineAndGetUpdateValue(currentValue, schema);\n+  }\n+\n+  /**\n+   * Generates an avro record out of the given HoodieRecordPayload, to be written out to storage. Called when writing a new value for the given\n+   * HoodieKey, wherein there is no existing record in storage to be combined against. (i.e insert) Return EMPTY to skip writing this record.\n+   * @param schema Schema used for record\n+   * @return the {@link IndexedRecord} to be inserted.\n+   */\n+  @Deprecated\n   @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n   Option<IndexedRecord> getInsertValue(Schema schema) throws IOException;\n \n   /**\n-   * This method can be used to extract some metadata from HoodieRecordPayload. The metadata is passed to\n-   * {@code WriteStatus.markSuccess()} and {@code WriteStatus.markFailure()} in order to compute some aggregate metrics\n-   * using the metadata in the context of a write success or failure.\n+   * Generates an avro record out of the given HoodieRecordPayload, to be written out to storage. Called when writing a new value for the given\n+   * HoodieKey, wherein there is no existing record in storage to be combined against. (i.e insert) Return EMPTY to skip writing this record.\n+   * This method takes in a property map as an arg so that implementation can decide their business logic based on some properties set.\n+   * @param schema Schema used for record\n+   * @param properties Payload related properties. For example pass the ordering field(s) name to extract from value in storage.\n+   * @return the {@link IndexedRecord} to be inserted.\n+   */\n+  @PublicAPIMethod(maturity = ApiMaturityLevel.STABLE)\n+  default Option<IndexedRecord> getInsertValue(Schema schema, Properties properties) throws IOException {\n+    return getInsertValue(schema);\n+  }\n+\n+  /**\n+   * This method can be used to extract some metadata from HoodieRecordPayload. The metadata is passed to {@code WriteStatus.markSuccess()} and", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "13e1417ae2653aa649598bf539767f7cefef75e9"}, "originalPosition": 102}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4231, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}