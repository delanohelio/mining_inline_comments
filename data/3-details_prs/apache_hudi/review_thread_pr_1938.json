{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDY1MDg4NDg2", "number": 1938, "reviewThreads": {"totalCount": 11, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0MDozOVrOEeZxiQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo1MjoxOVrOFMO0bA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzE1MDE3OnYy", "diffSide": "RIGHT", "path": "hudi-spark/src/main/scala/org/apache/hudi/DataSourceOptions.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0MDozOVrOHKCO9g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNTozNDo1NVrOHONTGA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NDQwNg==", "bodyText": "we need to guard this with a flag. query types are fundamental to design. I prefer not to overload them", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480284406", "createdAt": "2020-08-31T17:40:39Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/DataSourceOptions.scala", "diffHunk": "@@ -49,6 +49,7 @@ object DataSourceReadOptions {\n   val QUERY_TYPE_SNAPSHOT_OPT_VAL = \"snapshot\"\n   val QUERY_TYPE_READ_OPTIMIZED_OPT_VAL = \"read_optimized\"\n   val QUERY_TYPE_INCREMENTAL_OPT_VAL = \"incremental\"\n+  val QUERY_TYPE_MOR_INCREMENTAL_OPT_VAL = \"mor_incremental\"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY1OTk5Mg==", "bodyText": "This option was supposed to distinguish when the user wants to run an incremental query on the MOR table but on the parquet files only. This was not really necessary because users can just define the timestamp range to achieve the same goal. So we can just use the tableType. If COW, use the old way, if MOR, use the new relation. Don't need an extra option anymore imo.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r484659992", "createdAt": "2020-09-08T05:34:55Z", "author": {"login": "garyli1019"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/DataSourceOptions.scala", "diffHunk": "@@ -49,6 +49,7 @@ object DataSourceReadOptions {\n   val QUERY_TYPE_SNAPSHOT_OPT_VAL = \"snapshot\"\n   val QUERY_TYPE_READ_OPTIMIZED_OPT_VAL = \"read_optimized\"\n   val QUERY_TYPE_INCREMENTAL_OPT_VAL = \"incremental\"\n+  val QUERY_TYPE_MOR_INCREMENTAL_OPT_VAL = \"mor_incremental\"", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NDQwNg=="}, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzE2MTI0OnYy", "diffSide": "RIGHT", "path": "hudi-spark/src/main/scala/org/apache/hudi/HoodieMergeOnReadRDD.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0Mzo1N1rOHKCWDA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNTozNjowMVrOHONUgg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NjIyMA==", "bodyText": "this does not seem to be indented correctly?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480286220", "createdAt": "2020-08-31T17:43:57Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/HoodieMergeOnReadRDD.scala", "diffHunk": "@@ -102,6 +104,44 @@ class HoodieMergeOnReadRDD(@transient sc: SparkContext,\n     rows\n   }\n \n+  private def logFileIterator(split: HoodieMergeOnReadFileSplit,\n+                             config: Configuration): Iterator[InternalRow] =\n+  new Iterator[InternalRow] {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 49}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY2MDM1NA==", "bodyText": "nice catch :)", "url": "https://github.com/apache/hudi/pull/1938#discussion_r484660354", "createdAt": "2020-09-08T05:36:01Z", "author": {"login": "garyli1019"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/HoodieMergeOnReadRDD.scala", "diffHunk": "@@ -102,6 +104,44 @@ class HoodieMergeOnReadRDD(@transient sc: SparkContext,\n     rows\n   }\n \n+  private def logFileIterator(split: HoodieMergeOnReadFileSplit,\n+                             config: Configuration): Iterator[InternalRow] =\n+  new Iterator[InternalRow] {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4NjIyMA=="}, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 49}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzE3NTIyOnYy", "diffSide": "RIGHT", "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo0ODoxM1rOHKCevw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wMVQwMTowNDoxM1rOHKRAsQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODQ0Nw==", "bodyText": "should these be left to the user on how sparkSession/sqlContext is configured instead?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480288447", "createdAt": "2020-08-31T17:48:13Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDUyNjUxMw==", "bodyText": "This is the tricky part of this PR. We need to force a filter on _hoodie_commit_time, like what we have https://github.com/apache/hudi/blob/master/hudi-spark/src/main/scala/org/apache/hudi/IncrementalRelation.scala#L165.\nCurrently, I couldn't find an elegant way to force the filter regardless of what query the user is running. Spark optimization sometimes will skip scanning the file and produce incorrect results(e.g. count()). If we add a filter in RDD, then we will get involved in an extra ser/deser step. The elegant way might be getting into the Spark planing, but at this point I have no idea about how to do it. The easiest way is to ask the user to add a .filter() when loading the dataset, but we definitely don't wanna do that :)\nMy approach here is to force Spark to always scan the Base file and always apply the filter:\n\nFor the Base file, force the pushdown filter and avoid using the default ParquetFileFormat reader(baseFileIterator), which will not scan the file when the user uses df.count() and will produce incorrect results.\nFor log file, no need to filter base on commit time.\n\nSo we need to make sure the pushdown filter was on in every run if we keep this approach, otherwise the result will be incorrect.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480526513", "createdAt": "2020-09-01T01:04:13Z", "author": {"login": "garyli1019"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI4ODQ0Nw=="}, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 95}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAwMzIwMzgzOnYy", "diffSide": "RIGHT", "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "isResolved": false, "comments": {"totalCount": 6, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOC0zMVQxNzo1NjoyOVrOHKCwbQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wNVQwMzo0OTozNlrOH_pOfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5Mjk3Mw==", "bodyText": "IIUC, your approach here is to find all the file groups impacted in commit range, then pull affected records from the latest file slice? the mergeOnReadRDD will handle the merging of such an file slice, with the commit filters applied.\nlet me know @garyli1019 if I am understanding this correctly. it will help me review the code.\nin the meantime, can we add a separate flag/option to turn on new.incremental.relation=true or sth, to control this and push the changes", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480292973", "createdAt": "2020-08-31T17:56:29Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {\n+      val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+      val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+      val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+      filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+    }\n+    var requiredStructSchema = StructType(Seq())\n+    requiredColumns.foreach(col => {\n+      val field = tableStructSchema.find(_.name == col)\n+      if (field.isDefined) {\n+        requiredStructSchema = requiredStructSchema.add(field.get)\n+      }\n+    })\n+    val requiredAvroSchema = AvroConversionUtils\n+      .convertStructTypeToAvroSchema(requiredStructSchema, tableAvroSchema.getName, tableAvroSchema.getNamespace)\n+    val hoodieTableState = HoodieMergeOnReadTableState(\n+      tableStructSchema,\n+      requiredStructSchema,\n+      tableAvroSchema.toString,\n+      requiredAvroSchema.toString,\n+      fileIndex\n+    )\n+    val fullSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = tableStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+    val requiredSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = requiredStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+\n+    // Follow the implementation of Spark internal HadoopRDD to handle the broadcast configuration.\n+    FileSystem.getLocal(jobConf)\n+    SparkHadoopUtil.get.addCredentials(jobConf)\n+    val rdd = new HoodieMergeOnReadRDD(\n+      sqlContext.sparkContext,\n+      jobConf,\n+      fullSchemaParquetReader,\n+      requiredSchemaParquetReader,\n+      hoodieTableState\n+    )\n+    rdd.asInstanceOf[RDD[Row]]\n+  }\n+\n+  def buildFileIndex(): List[HoodieMergeOnReadFileSplit] = {\n+    val affectedFileStatus = new ListBuffer[FileStatus]\n+    for (commit <- commitsToReturn) {\n+      val metadata: HoodieCommitMetadata = HoodieCommitMetadata.fromBytes(commitsTimelineToReturn.getInstantDetails(commit)\n+        .get, classOf[HoodieCommitMetadata])\n+      val idWithPath = metadata.getFileIdAndFullPaths(metaClient.getBasePath).toMap\n+      idWithPath.foreach(p => {\n+        val file = fs.getFileStatus(new Path(p._2))\n+        affectedFileStatus += file\n+      })\n+    }\n+    val fsView = new HoodieTableFileSystemView(metaClient,\n+      commitsTimelineToReturn, affectedFileStatus.toArray)\n+    val fileGroup = fsView.fetchAllStoredFileGroups().iterator().toList\n+    val latestCommit = fsView.getLastInstant.get().getTimestamp\n+    if (log.isDebugEnabled) {\n+      fileGroup.foreach(f => log.debug(s\"current file group id: \" +\n+        s\"${f.getFileGroupId} and file slices ${f.getLatestFileSlice.get().toString}\"))\n+    }\n+    val pathGlobPattern = optParams.getOrElse(\n+      DataSourceReadOptions.INCR_PATH_GLOB_OPT_KEY,\n+      DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)\n+    val filteredFileGroup = if(!pathGlobPattern\n+      .equals(DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)) {\n+      val globMatcher = new GlobPattern(\"*\" + pathGlobPattern)\n+      fileGroup.filter(f => {\n+        if (f.getLatestFileSlice.get().getBaseFile.isPresent) {\n+          globMatcher.matches(f.getLatestFileSlice.get().getBaseFile.get.getPath)\n+        } else {\n+          globMatcher.matches(f.getLatestFileSlice.get().getLatestLogFile.get().getPath.toString)\n+        }\n+      })\n+    } else {\n+      fileGroup\n+    }\n+\n+    filteredFileGroup.map(f => {\n+      val baseFile = f.getLatestDataFile", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDUyOTk3Mw==", "bodyText": "correct, that's what I was trying to do here.\nsure, keep only one incremental query type makes sense to me.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480529973", "createdAt": "2020-09-01T01:07:31Z", "author": {"login": "garyli1019"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {\n+      val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+      val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+      val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+      filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+    }\n+    var requiredStructSchema = StructType(Seq())\n+    requiredColumns.foreach(col => {\n+      val field = tableStructSchema.find(_.name == col)\n+      if (field.isDefined) {\n+        requiredStructSchema = requiredStructSchema.add(field.get)\n+      }\n+    })\n+    val requiredAvroSchema = AvroConversionUtils\n+      .convertStructTypeToAvroSchema(requiredStructSchema, tableAvroSchema.getName, tableAvroSchema.getNamespace)\n+    val hoodieTableState = HoodieMergeOnReadTableState(\n+      tableStructSchema,\n+      requiredStructSchema,\n+      tableAvroSchema.toString,\n+      requiredAvroSchema.toString,\n+      fileIndex\n+    )\n+    val fullSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = tableStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+    val requiredSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = requiredStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+\n+    // Follow the implementation of Spark internal HadoopRDD to handle the broadcast configuration.\n+    FileSystem.getLocal(jobConf)\n+    SparkHadoopUtil.get.addCredentials(jobConf)\n+    val rdd = new HoodieMergeOnReadRDD(\n+      sqlContext.sparkContext,\n+      jobConf,\n+      fullSchemaParquetReader,\n+      requiredSchemaParquetReader,\n+      hoodieTableState\n+    )\n+    rdd.asInstanceOf[RDD[Row]]\n+  }\n+\n+  def buildFileIndex(): List[HoodieMergeOnReadFileSplit] = {\n+    val affectedFileStatus = new ListBuffer[FileStatus]\n+    for (commit <- commitsToReturn) {\n+      val metadata: HoodieCommitMetadata = HoodieCommitMetadata.fromBytes(commitsTimelineToReturn.getInstantDetails(commit)\n+        .get, classOf[HoodieCommitMetadata])\n+      val idWithPath = metadata.getFileIdAndFullPaths(metaClient.getBasePath).toMap\n+      idWithPath.foreach(p => {\n+        val file = fs.getFileStatus(new Path(p._2))\n+        affectedFileStatus += file\n+      })\n+    }\n+    val fsView = new HoodieTableFileSystemView(metaClient,\n+      commitsTimelineToReturn, affectedFileStatus.toArray)\n+    val fileGroup = fsView.fetchAllStoredFileGroups().iterator().toList\n+    val latestCommit = fsView.getLastInstant.get().getTimestamp\n+    if (log.isDebugEnabled) {\n+      fileGroup.foreach(f => log.debug(s\"current file group id: \" +\n+        s\"${f.getFileGroupId} and file slices ${f.getLatestFileSlice.get().toString}\"))\n+    }\n+    val pathGlobPattern = optParams.getOrElse(\n+      DataSourceReadOptions.INCR_PATH_GLOB_OPT_KEY,\n+      DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)\n+    val filteredFileGroup = if(!pathGlobPattern\n+      .equals(DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)) {\n+      val globMatcher = new GlobPattern(\"*\" + pathGlobPattern)\n+      fileGroup.filter(f => {\n+        if (f.getLatestFileSlice.get().getBaseFile.isPresent) {\n+          globMatcher.matches(f.getLatestFileSlice.get().getBaseFile.get.getPath)\n+        } else {\n+          globMatcher.matches(f.getLatestFileSlice.get().getLatestLogFile.get().getPath.toString)\n+        }\n+      })\n+    } else {\n+      fileGroup\n+    }\n+\n+    filteredFileGroup.map(f => {\n+      val baseFile = f.getLatestDataFile", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5Mjk3Mw=="}, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDU4NDM3OQ==", "bodyText": "@garyli1019 one issue we need to make sure we handle is when the file group is pending compaction. when that happens, the base file is not present in the latest slice, but stitched together from the previous slice. @bhasudha is handling this in the Hive PR. worth taking a look and ensuring", "url": "https://github.com/apache/hudi/pull/1938#discussion_r480584379", "createdAt": "2020-09-01T01:58:06Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {\n+      val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+      val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+      val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+      filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+    }\n+    var requiredStructSchema = StructType(Seq())\n+    requiredColumns.foreach(col => {\n+      val field = tableStructSchema.find(_.name == col)\n+      if (field.isDefined) {\n+        requiredStructSchema = requiredStructSchema.add(field.get)\n+      }\n+    })\n+    val requiredAvroSchema = AvroConversionUtils\n+      .convertStructTypeToAvroSchema(requiredStructSchema, tableAvroSchema.getName, tableAvroSchema.getNamespace)\n+    val hoodieTableState = HoodieMergeOnReadTableState(\n+      tableStructSchema,\n+      requiredStructSchema,\n+      tableAvroSchema.toString,\n+      requiredAvroSchema.toString,\n+      fileIndex\n+    )\n+    val fullSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = tableStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+    val requiredSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = requiredStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+\n+    // Follow the implementation of Spark internal HadoopRDD to handle the broadcast configuration.\n+    FileSystem.getLocal(jobConf)\n+    SparkHadoopUtil.get.addCredentials(jobConf)\n+    val rdd = new HoodieMergeOnReadRDD(\n+      sqlContext.sparkContext,\n+      jobConf,\n+      fullSchemaParquetReader,\n+      requiredSchemaParquetReader,\n+      hoodieTableState\n+    )\n+    rdd.asInstanceOf[RDD[Row]]\n+  }\n+\n+  def buildFileIndex(): List[HoodieMergeOnReadFileSplit] = {\n+    val affectedFileStatus = new ListBuffer[FileStatus]\n+    for (commit <- commitsToReturn) {\n+      val metadata: HoodieCommitMetadata = HoodieCommitMetadata.fromBytes(commitsTimelineToReturn.getInstantDetails(commit)\n+        .get, classOf[HoodieCommitMetadata])\n+      val idWithPath = metadata.getFileIdAndFullPaths(metaClient.getBasePath).toMap\n+      idWithPath.foreach(p => {\n+        val file = fs.getFileStatus(new Path(p._2))\n+        affectedFileStatus += file\n+      })\n+    }\n+    val fsView = new HoodieTableFileSystemView(metaClient,\n+      commitsTimelineToReturn, affectedFileStatus.toArray)\n+    val fileGroup = fsView.fetchAllStoredFileGroups().iterator().toList\n+    val latestCommit = fsView.getLastInstant.get().getTimestamp\n+    if (log.isDebugEnabled) {\n+      fileGroup.foreach(f => log.debug(s\"current file group id: \" +\n+        s\"${f.getFileGroupId} and file slices ${f.getLatestFileSlice.get().toString}\"))\n+    }\n+    val pathGlobPattern = optParams.getOrElse(\n+      DataSourceReadOptions.INCR_PATH_GLOB_OPT_KEY,\n+      DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)\n+    val filteredFileGroup = if(!pathGlobPattern\n+      .equals(DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)) {\n+      val globMatcher = new GlobPattern(\"*\" + pathGlobPattern)\n+      fileGroup.filter(f => {\n+        if (f.getLatestFileSlice.get().getBaseFile.isPresent) {\n+          globMatcher.matches(f.getLatestFileSlice.get().getBaseFile.get.getPath)\n+        } else {\n+          globMatcher.matches(f.getLatestFileSlice.get().getLatestLogFile.get().getPath.toString)\n+        }\n+      })\n+    } else {\n+      fileGroup\n+    }\n+\n+    filteredFileGroup.map(f => {\n+      val baseFile = f.getLatestDataFile", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5Mjk3Mw=="}, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU1MTIyNA==", "bodyText": "I think we can share the implementation of this part for Hive and Spark. I will move this part to a util class.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r483551224", "createdAt": "2020-09-04T11:13:16Z", "author": {"login": "garyli1019"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {\n+      val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+      val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+      val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+      filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+    }\n+    var requiredStructSchema = StructType(Seq())\n+    requiredColumns.foreach(col => {\n+      val field = tableStructSchema.find(_.name == col)\n+      if (field.isDefined) {\n+        requiredStructSchema = requiredStructSchema.add(field.get)\n+      }\n+    })\n+    val requiredAvroSchema = AvroConversionUtils\n+      .convertStructTypeToAvroSchema(requiredStructSchema, tableAvroSchema.getName, tableAvroSchema.getNamespace)\n+    val hoodieTableState = HoodieMergeOnReadTableState(\n+      tableStructSchema,\n+      requiredStructSchema,\n+      tableAvroSchema.toString,\n+      requiredAvroSchema.toString,\n+      fileIndex\n+    )\n+    val fullSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = tableStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+    val requiredSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = requiredStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+\n+    // Follow the implementation of Spark internal HadoopRDD to handle the broadcast configuration.\n+    FileSystem.getLocal(jobConf)\n+    SparkHadoopUtil.get.addCredentials(jobConf)\n+    val rdd = new HoodieMergeOnReadRDD(\n+      sqlContext.sparkContext,\n+      jobConf,\n+      fullSchemaParquetReader,\n+      requiredSchemaParquetReader,\n+      hoodieTableState\n+    )\n+    rdd.asInstanceOf[RDD[Row]]\n+  }\n+\n+  def buildFileIndex(): List[HoodieMergeOnReadFileSplit] = {\n+    val affectedFileStatus = new ListBuffer[FileStatus]\n+    for (commit <- commitsToReturn) {\n+      val metadata: HoodieCommitMetadata = HoodieCommitMetadata.fromBytes(commitsTimelineToReturn.getInstantDetails(commit)\n+        .get, classOf[HoodieCommitMetadata])\n+      val idWithPath = metadata.getFileIdAndFullPaths(metaClient.getBasePath).toMap\n+      idWithPath.foreach(p => {\n+        val file = fs.getFileStatus(new Path(p._2))\n+        affectedFileStatus += file\n+      })\n+    }\n+    val fsView = new HoodieTableFileSystemView(metaClient,\n+      commitsTimelineToReturn, affectedFileStatus.toArray)\n+    val fileGroup = fsView.fetchAllStoredFileGroups().iterator().toList\n+    val latestCommit = fsView.getLastInstant.get().getTimestamp\n+    if (log.isDebugEnabled) {\n+      fileGroup.foreach(f => log.debug(s\"current file group id: \" +\n+        s\"${f.getFileGroupId} and file slices ${f.getLatestFileSlice.get().toString}\"))\n+    }\n+    val pathGlobPattern = optParams.getOrElse(\n+      DataSourceReadOptions.INCR_PATH_GLOB_OPT_KEY,\n+      DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)\n+    val filteredFileGroup = if(!pathGlobPattern\n+      .equals(DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)) {\n+      val globMatcher = new GlobPattern(\"*\" + pathGlobPattern)\n+      fileGroup.filter(f => {\n+        if (f.getLatestFileSlice.get().getBaseFile.isPresent) {\n+          globMatcher.matches(f.getLatestFileSlice.get().getBaseFile.get.getPath)\n+        } else {\n+          globMatcher.matches(f.getLatestFileSlice.get().getLatestLogFile.get().getPath.toString)\n+        }\n+      })\n+    } else {\n+      fileGroup\n+    }\n+\n+    filteredFileGroup.map(f => {\n+      val baseFile = f.getLatestDataFile", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5Mjk3Mw=="}, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDY3MjQxNA==", "bodyText": "Just to make sure. This only possible for the base file right? The latest log file will always be on the latest file slice?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r484672414", "createdAt": "2020-09-08T06:12:07Z", "author": {"login": "garyli1019"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {\n+      val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+      val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+      val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+      filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+    }\n+    var requiredStructSchema = StructType(Seq())\n+    requiredColumns.foreach(col => {\n+      val field = tableStructSchema.find(_.name == col)\n+      if (field.isDefined) {\n+        requiredStructSchema = requiredStructSchema.add(field.get)\n+      }\n+    })\n+    val requiredAvroSchema = AvroConversionUtils\n+      .convertStructTypeToAvroSchema(requiredStructSchema, tableAvroSchema.getName, tableAvroSchema.getNamespace)\n+    val hoodieTableState = HoodieMergeOnReadTableState(\n+      tableStructSchema,\n+      requiredStructSchema,\n+      tableAvroSchema.toString,\n+      requiredAvroSchema.toString,\n+      fileIndex\n+    )\n+    val fullSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = tableStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+    val requiredSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = requiredStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+\n+    // Follow the implementation of Spark internal HadoopRDD to handle the broadcast configuration.\n+    FileSystem.getLocal(jobConf)\n+    SparkHadoopUtil.get.addCredentials(jobConf)\n+    val rdd = new HoodieMergeOnReadRDD(\n+      sqlContext.sparkContext,\n+      jobConf,\n+      fullSchemaParquetReader,\n+      requiredSchemaParquetReader,\n+      hoodieTableState\n+    )\n+    rdd.asInstanceOf[RDD[Row]]\n+  }\n+\n+  def buildFileIndex(): List[HoodieMergeOnReadFileSplit] = {\n+    val affectedFileStatus = new ListBuffer[FileStatus]\n+    for (commit <- commitsToReturn) {\n+      val metadata: HoodieCommitMetadata = HoodieCommitMetadata.fromBytes(commitsTimelineToReturn.getInstantDetails(commit)\n+        .get, classOf[HoodieCommitMetadata])\n+      val idWithPath = metadata.getFileIdAndFullPaths(metaClient.getBasePath).toMap\n+      idWithPath.foreach(p => {\n+        val file = fs.getFileStatus(new Path(p._2))\n+        affectedFileStatus += file\n+      })\n+    }\n+    val fsView = new HoodieTableFileSystemView(metaClient,\n+      commitsTimelineToReturn, affectedFileStatus.toArray)\n+    val fileGroup = fsView.fetchAllStoredFileGroups().iterator().toList\n+    val latestCommit = fsView.getLastInstant.get().getTimestamp\n+    if (log.isDebugEnabled) {\n+      fileGroup.foreach(f => log.debug(s\"current file group id: \" +\n+        s\"${f.getFileGroupId} and file slices ${f.getLatestFileSlice.get().toString}\"))\n+    }\n+    val pathGlobPattern = optParams.getOrElse(\n+      DataSourceReadOptions.INCR_PATH_GLOB_OPT_KEY,\n+      DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)\n+    val filteredFileGroup = if(!pathGlobPattern\n+      .equals(DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)) {\n+      val globMatcher = new GlobPattern(\"*\" + pathGlobPattern)\n+      fileGroup.filter(f => {\n+        if (f.getLatestFileSlice.get().getBaseFile.isPresent) {\n+          globMatcher.matches(f.getLatestFileSlice.get().getBaseFile.get.getPath)\n+        } else {\n+          globMatcher.matches(f.getLatestFileSlice.get().getLatestLogFile.get().getPath.toString)\n+        }\n+      })\n+    } else {\n+      fileGroup\n+    }\n+\n+    filteredFileGroup.map(f => {\n+      val baseFile = f.getLatestDataFile", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5Mjk3Mw=="}, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 189}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjQ5Nzc5MA==", "bodyText": "@vinothchandar getting back to this PR... Now I get a little confused, so when we pull from a pending compaction commit, why should we care about the base file that was not in the range? We just read the log file right? From a user perspective, I don't expect to read commit earlier than the commit I defined as a starting point.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r536497790", "createdAt": "2020-12-05T03:49:36Z", "author": {"login": "garyli1019"}, "path": "hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,209 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hudi.common.model.{HoodieCommitMetadata, HoodieRecord, HoodieTableType}\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources.{BaseRelation, Filter, GreaterThanOrEqual, IsNotNull, LessThanOrEqual, PrunedFilteredScan, TableScan}\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {\n+      val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+      val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+      val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+      filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+    }\n+    var requiredStructSchema = StructType(Seq())\n+    requiredColumns.foreach(col => {\n+      val field = tableStructSchema.find(_.name == col)\n+      if (field.isDefined) {\n+        requiredStructSchema = requiredStructSchema.add(field.get)\n+      }\n+    })\n+    val requiredAvroSchema = AvroConversionUtils\n+      .convertStructTypeToAvroSchema(requiredStructSchema, tableAvroSchema.getName, tableAvroSchema.getNamespace)\n+    val hoodieTableState = HoodieMergeOnReadTableState(\n+      tableStructSchema,\n+      requiredStructSchema,\n+      tableAvroSchema.toString,\n+      requiredAvroSchema.toString,\n+      fileIndex\n+    )\n+    val fullSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = tableStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+    val requiredSchemaParquetReader = new ParquetFileFormat().buildReaderWithPartitionValues(\n+      sparkSession = sqlContext.sparkSession,\n+      dataSchema = tableStructSchema,\n+      partitionSchema = StructType(Nil),\n+      requiredSchema = requiredStructSchema,\n+      filters = pushDownFilter,\n+      options = optParams,\n+      hadoopConf = sqlContext.sparkSession.sessionState.newHadoopConf()\n+    )\n+\n+    // Follow the implementation of Spark internal HadoopRDD to handle the broadcast configuration.\n+    FileSystem.getLocal(jobConf)\n+    SparkHadoopUtil.get.addCredentials(jobConf)\n+    val rdd = new HoodieMergeOnReadRDD(\n+      sqlContext.sparkContext,\n+      jobConf,\n+      fullSchemaParquetReader,\n+      requiredSchemaParquetReader,\n+      hoodieTableState\n+    )\n+    rdd.asInstanceOf[RDD[Row]]\n+  }\n+\n+  def buildFileIndex(): List[HoodieMergeOnReadFileSplit] = {\n+    val affectedFileStatus = new ListBuffer[FileStatus]\n+    for (commit <- commitsToReturn) {\n+      val metadata: HoodieCommitMetadata = HoodieCommitMetadata.fromBytes(commitsTimelineToReturn.getInstantDetails(commit)\n+        .get, classOf[HoodieCommitMetadata])\n+      val idWithPath = metadata.getFileIdAndFullPaths(metaClient.getBasePath).toMap\n+      idWithPath.foreach(p => {\n+        val file = fs.getFileStatus(new Path(p._2))\n+        affectedFileStatus += file\n+      })\n+    }\n+    val fsView = new HoodieTableFileSystemView(metaClient,\n+      commitsTimelineToReturn, affectedFileStatus.toArray)\n+    val fileGroup = fsView.fetchAllStoredFileGroups().iterator().toList\n+    val latestCommit = fsView.getLastInstant.get().getTimestamp\n+    if (log.isDebugEnabled) {\n+      fileGroup.foreach(f => log.debug(s\"current file group id: \" +\n+        s\"${f.getFileGroupId} and file slices ${f.getLatestFileSlice.get().toString}\"))\n+    }\n+    val pathGlobPattern = optParams.getOrElse(\n+      DataSourceReadOptions.INCR_PATH_GLOB_OPT_KEY,\n+      DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)\n+    val filteredFileGroup = if(!pathGlobPattern\n+      .equals(DataSourceReadOptions.DEFAULT_INCR_PATH_GLOB_OPT_VAL)) {\n+      val globMatcher = new GlobPattern(\"*\" + pathGlobPattern)\n+      fileGroup.filter(f => {\n+        if (f.getLatestFileSlice.get().getBaseFile.isPresent) {\n+          globMatcher.matches(f.getLatestFileSlice.get().getBaseFile.get.getPath)\n+        } else {\n+          globMatcher.matches(f.getLatestFileSlice.get().getLatestLogFile.get().getPath.toString)\n+        }\n+      })\n+    } else {\n+      fileGroup\n+    }\n+\n+    filteredFileGroup.map(f => {\n+      val baseFile = f.getLatestDataFile", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDI5Mjk3Mw=="}, "originalCommit": {"oid": "44f571fee63a8deab642a3accb4410b99428895d"}, "originalPosition": 189}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzAzMTU3NTU1OnYy", "diffSide": "RIGHT", "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzoxODoyNFrOHOP27A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wOS0wOFQwNzoxODoyNFrOHOP27A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NDcwMTkzMg==", "bodyText": "Copied and changed this method from #1817 , will apply this change to that PR after merged.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r484701932", "createdAt": "2020-09-08T07:18:24Z", "author": {"login": "garyli1019"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -443,4 +444,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "eb251d8ecaa5fc9d926b5cfe3092b01353ca2f20"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MzY2Mzc2OnYy", "diffSide": "RIGHT", "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo0MTo0OVrOIP11PQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDo1Nzo1OVrOIQnSMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MTUzMw==", "bodyText": "can we just have this in hudi-spark for now. thats the only module that needs to call this.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553481533", "createdAt": "2021-01-07T17:41:49Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5MTc2MQ==", "bodyText": "This can be shared by other engines later. If we move this to spark we need to switch to scala code, then move it back later when supporting other engines. We could save some effort if we leave it here?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r554291761", "createdAt": "2021-01-09T04:57:59Z", "author": {"login": "garyli1019"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MTUzMw=="}, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 20}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MzY2NzA0OnYy", "diffSide": "RIGHT", "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo0Mjo1MlrOIP13Xg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDowNTozNlrOIQnAng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MjA3OA==", "bodyText": "Can we redo this such that it can use the metadata table for obtaining the listing? You can see how this is done in HoodieParquetInputFormat.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553482078", "createdAt": "2021-01-07T17:42:52Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(\n+      Path basePath, List<HoodieInstant> commitsToCheck, HoodieTimeline timeline) throws IOException {\n+    // Extract files touched by these commits.\n+    // TODO This might need to be done in parallel like listStatus parallelism ?", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI4NzI2Mg==", "bodyText": "Are you referring to RFC-15 that not being landed yet? The current implementation of HoodieParquetInputFormat is listing all files of affected partitions and then do the filtering later.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r554287262", "createdAt": "2021-01-09T04:05:36Z", "author": {"login": "garyli1019"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(\n+      Path basePath, List<HoodieInstant> commitsToCheck, HoodieTimeline timeline) throws IOException {\n+    // Extract files touched by these commits.\n+    // TODO This might need to be done in parallel like listStatus parallelism ?", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4MjA3OA=="}, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 23}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MzY3MTI4OnYy", "diffSide": "RIGHT", "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo0Mzo1OFrOIP15-g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo0Mzo1OFrOIP15-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4Mjc0Ng==", "bodyText": "a little bit more clearer doc? does this method obtain all the file status that were affected by the list of commits to check?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553482746", "createdAt": "2021-01-07T17:43:58Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 13}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MzY4MDYyOnYy", "diffSide": "RIGHT", "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo0NjozNlrOIP1_qQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDo1NToyNlrOIQnRMQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NDIwMQ==", "bodyText": "you can just pick the latest such file now. it will have the latest log size using getFileSizeInBytes(). No need to do the addition here.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553484201", "createdAt": "2021-01-07T17:46:36Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(\n+      Path basePath, List<HoodieInstant> commitsToCheck, HoodieTimeline timeline) throws IOException {\n+    // Extract files touched by these commits.\n+    // TODO This might need to be done in parallel like listStatus parallelism ?\n+    HashMap<String, HashMap<String, FileStatus>> partitionToFileStatusesMap = new HashMap<>();\n+    for (HoodieInstant commit: commitsToCheck) {\n+      HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(timeline.getInstantDetails(commit).get(),\n+          HoodieCommitMetadata.class);\n+      for (Map.Entry<String, List<HoodieWriteStat>> entry: commitMetadata.getPartitionToWriteStats().entrySet()) {\n+        if (!partitionToFileStatusesMap.containsKey(entry.getKey())) {\n+          partitionToFileStatusesMap.put(entry.getKey(), new HashMap<>());\n+        }\n+        for (HoodieWriteStat stat : entry.getValue()) {\n+          String relativeFilePath = stat.getPath();\n+          Path fullPath = relativeFilePath != null ? FSUtils.getPartitionPath(basePath, relativeFilePath) : null;\n+          if (fullPath != null) {\n+            if (partitionToFileStatusesMap.get(entry.getKey()).containsKey(fullPath.getName())) {\n+              // If filesystem support Append. Update the FileStatus of log file if being appended.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5MTUwNQ==", "bodyText": "fixed.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r554291505", "createdAt": "2021-01-09T04:55:26Z", "author": {"login": "garyli1019"}, "path": "hudi-hadoop-mr/src/main/java/org/apache/hudi/hadoop/utils/HoodieInputFormatUtils.java", "diffHunk": "@@ -470,4 +471,45 @@ private static HoodieBaseFile refreshFileStatus(Configuration conf, HoodieBaseFi\n     }\n   }\n \n+  /**\n+   * List affected file status based on given commits.\n+   * @param basePath\n+   * @param commitsToCheck\n+   * @param timeline\n+   * @return HashMap<partitionPath, HashMap<fileName, FileStatus>>\n+   * @throws IOException\n+   */\n+  public static HashMap<String, HashMap<String, FileStatus>> listStatusForAffectedPartitions(\n+      Path basePath, List<HoodieInstant> commitsToCheck, HoodieTimeline timeline) throws IOException {\n+    // Extract files touched by these commits.\n+    // TODO This might need to be done in parallel like listStatus parallelism ?\n+    HashMap<String, HashMap<String, FileStatus>> partitionToFileStatusesMap = new HashMap<>();\n+    for (HoodieInstant commit: commitsToCheck) {\n+      HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(timeline.getInstantDetails(commit).get(),\n+          HoodieCommitMetadata.class);\n+      for (Map.Entry<String, List<HoodieWriteStat>> entry: commitMetadata.getPartitionToWriteStats().entrySet()) {\n+        if (!partitionToFileStatusesMap.containsKey(entry.getKey())) {\n+          partitionToFileStatusesMap.put(entry.getKey(), new HashMap<>());\n+        }\n+        for (HoodieWriteStat stat : entry.getValue()) {\n+          String relativeFilePath = stat.getPath();\n+          Path fullPath = relativeFilePath != null ? FSUtils.getPartitionPath(basePath, relativeFilePath) : null;\n+          if (fullPath != null) {\n+            if (partitionToFileStatusesMap.get(entry.getKey()).containsKey(fullPath.getName())) {\n+              // If filesystem support Append. Update the FileStatus of log file if being appended.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NDIwMQ=="}, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 37}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MzY4OTQ0OnYy", "diffSide": "RIGHT", "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "isResolved": true, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo0ODo1OFrOIP2E4A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQxNjowMTozMlrOIQwd0w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NTUzNg==", "bodyText": "can we subclass IncrementalRelation and reuse some of the code esp lines 54-66 etc? worth it?", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553485536", "createdAt": "2021-01-07T17:48:58Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.model.HoodieRecord\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hudi.hadoop.utils.HoodieInputFormatUtils.listStatusForAffectedPartitions\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5MTMwNw==", "bodyText": "IncrementalRelation extends TablesScan and this extends PrunedFilteredScan so I think to keep them separate is better.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r554291307", "createdAt": "2021-01-09T04:53:34Z", "author": {"login": "garyli1019"}, "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.model.HoodieRecord\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hudi.hadoop.utils.HoodieInputFormatUtils.listStatusForAffectedPartitions\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NTUzNg=="}, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDQ0MjE5NQ==", "bodyText": "ack", "url": "https://github.com/apache/hudi/pull/1938#discussion_r554442195", "createdAt": "2021-01-09T16:01:32Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.model.HoodieRecord\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hudi.hadoop.utils.HoodieInputFormatUtils.listStatusForAffectedPartitions\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NTUzNg=="}, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 47}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzQ4MzcwMDI4OnYy", "diffSide": "RIGHT", "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wN1QxNzo1MjoxOVrOIP2LsQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wOVQwNDo1NDozM1rOIQnQ3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NzI4MQ==", "bodyText": "this is the secret sauce to do the filtering at the record level, I guess", "url": "https://github.com/apache/hudi/pull/1938#discussion_r553487281", "createdAt": "2021-01-07T17:52:19Z", "author": {"login": "vinothchandar"}, "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.model.HoodieRecord\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hudi.hadoop.utils.HoodieInputFormatUtils.listStatusForAffectedPartitions\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.filterPushdown\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 100}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDI5MTQyMQ==", "bodyText": "yes, if the filterPushdown was disabled then the record level filter will not work.", "url": "https://github.com/apache/hudi/pull/1938#discussion_r554291421", "createdAt": "2021-01-09T04:54:33Z", "author": {"login": "garyli1019"}, "path": "hudi-spark-datasource/hudi-spark/src/main/scala/org/apache/hudi/MergeOnReadIncrementalRelation.scala", "diffHunk": "@@ -0,0 +1,218 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi\n+\n+import org.apache.hadoop.fs.{FileStatus, FileSystem, GlobPattern, Path}\n+import org.apache.hadoop.mapred.JobConf\n+import org.apache.hudi.common.fs.FSUtils\n+import org.apache.hudi.common.model.HoodieRecord\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView\n+import org.apache.hudi.common.table.{HoodieTableMetaClient, TableSchemaResolver}\n+import org.apache.hudi.exception.HoodieException\n+import org.apache.hudi.hadoop.utils.HoodieInputFormatUtils.listStatusForAffectedPartitions\n+import org.apache.hudi.hadoop.utils.HoodieRealtimeRecordReaderUtils.getMaxCompactionMemoryInBytes\n+import org.apache.log4j.LogManager\n+import org.apache.spark.deploy.SparkHadoopUtil\n+import org.apache.spark.rdd.RDD\n+import org.apache.spark.sql.catalyst.InternalRow\n+import org.apache.spark.sql.execution.datasources.PartitionedFile\n+import org.apache.spark.sql.execution.datasources.parquet.ParquetFileFormat\n+import org.apache.spark.sql.sources._\n+import org.apache.spark.sql.types.StructType\n+import org.apache.spark.sql.{Row, SQLContext}\n+\n+import scala.collection.JavaConversions._\n+import scala.collection.mutable.ListBuffer\n+\n+/**\n+  * Experimental.\n+  * Relation, that implements the Hoodie incremental view for Merge On Read table.\n+  *\n+  */\n+class MergeOnReadIncrementalRelation(val sqlContext: SQLContext,\n+                                     val optParams: Map[String, String],\n+                                     val userSchema: StructType,\n+                                     val metaClient: HoodieTableMetaClient)\n+  extends BaseRelation with PrunedFilteredScan {\n+\n+  private val log = LogManager.getLogger(classOf[MergeOnReadIncrementalRelation])\n+  private val conf = sqlContext.sparkContext.hadoopConfiguration\n+  private val jobConf = new JobConf(conf)\n+  private val fs = FSUtils.getFs(metaClient.getBasePath, conf)\n+  private val commitTimeline = metaClient.getCommitsAndCompactionTimeline.filterCompletedInstants()\n+  if (commitTimeline.empty()) {\n+    throw new HoodieException(\"No instants to incrementally pull\")\n+  }\n+  if (!optParams.contains(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY)) {\n+    throw new HoodieException(s\"Specify the begin instant time to pull from using \" +\n+      s\"option ${DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY}\")\n+  }\n+\n+  private val lastInstant = commitTimeline.lastInstant().get()\n+  private val mergeType = optParams.getOrElse(\n+    DataSourceReadOptions.REALTIME_MERGE_OPT_KEY,\n+    DataSourceReadOptions.DEFAULT_REALTIME_MERGE_OPT_VAL)\n+\n+  private val commitsTimelineToReturn = commitTimeline.findInstantsInRange(\n+    optParams(DataSourceReadOptions.BEGIN_INSTANTTIME_OPT_KEY),\n+    optParams.getOrElse(DataSourceReadOptions.END_INSTANTTIME_OPT_KEY, lastInstant.getTimestamp))\n+  log.debug(s\"${commitsTimelineToReturn.getInstants.iterator().toList.map(f => f.toString).mkString(\",\")}\")\n+  private val commitsToReturn = commitsTimelineToReturn.getInstants.iterator().toList\n+  private val schemaUtil = new TableSchemaResolver(metaClient)\n+  private val tableAvroSchema = schemaUtil.getTableAvroSchema\n+  private val tableStructSchema = AvroConversionUtils.convertAvroSchemaToStructType(tableAvroSchema)\n+  private val maxCompactionMemoryInBytes = getMaxCompactionMemoryInBytes(jobConf)\n+  private val fileIndex = buildFileIndex()\n+\n+  override def schema: StructType = tableStructSchema\n+\n+  override def needConversion: Boolean = false\n+\n+  override def unhandledFilters(filters: Array[Filter]): Array[Filter] = {\n+    val isNotNullFilter = IsNotNull(HoodieRecord.COMMIT_TIME_METADATA_FIELD)\n+    val largerThanFilter = GreaterThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.head.getTimestamp)\n+    val lessThanFilter = LessThanOrEqual(HoodieRecord.COMMIT_TIME_METADATA_FIELD, commitsToReturn.last.getTimestamp)\n+    filters :+isNotNullFilter :+ largerThanFilter :+ lessThanFilter\n+  }\n+\n+  override def buildScan(requiredColumns: Array[String], filters: Array[Filter]): RDD[Row] = {\n+    log.debug(s\"buildScan requiredColumns = ${requiredColumns.mkString(\",\")}\")\n+    log.debug(s\"buildScan filters = ${filters.mkString(\",\")}\")\n+    // config to ensure the push down filter for parquet will be applied.\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.filterPushdown\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.recordLevelFilter.enabled\", \"true\")\n+    sqlContext.sparkSession.sessionState.conf.setConfString(\"spark.sql.parquet.enableVectorizedReader\", \"false\")\n+    val pushDownFilter = {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MzQ4NzI4MQ=="}, "originalCommit": {"oid": "452be51154c5b4302469e9810b5569884d61c238"}, "originalPosition": 100}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4412, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}