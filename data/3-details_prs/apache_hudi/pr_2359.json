{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTQzODYyMjQy", "number": 2359, "title": "[HUDI-1486] Remove inflight rollback in hoodie writer", "bodyText": "Refactor rollback and move cleaning failed commits logic into cleaner\nIntroduce hoodie heartbeat to ascertain failed commits\nFix test cases\n\nTips\n\nThank you very much for contributing to Apache Hudi.\nPlease review https://hudi.apache.org/contributing.html before opening a pull request.\n\nWhat is the purpose of the pull request\n(For example: This pull request adds quick-start document.)\nBrief change log\n(for example:)\n\nModify AnnotationLocation checkstyle rule in checkstyle.xml\n\nVerify this pull request\n(Please pick either of the following options)\nThis pull request is a trivial rework / code cleanup without any test coverage.\n(or)\nThis pull request is already covered by existing tests, such as (please describe tests).\n(or)\nThis change added tests and can be verified as follows:\n(example:)\n\nAdded integration tests for end-to-end.\nAdded HoodieClientWriteTest to verify the change.\nManually verified the change by running a job locally.\n\nCommitter checklist\n\n\n Has a corresponding JIRA in PR title & commit\n\n\n Commit message is descriptive of the change\n\n\n CI is green\n\n\n Necessary doc changes done or have another open PR\n\n\n For large changes, please consider breaking it into sub-tasks under an umbrella JIRA.", "createdAt": "2020-12-22T04:42:11Z", "url": "https://github.com/apache/hudi/pull/2359", "merged": true, "mergeCommit": {"oid": "ffcfb58bacab377bc72d20041baa54a3fd8fc812"}, "closed": true, "closedAt": "2021-02-20T04:12:22Z", "author": {"login": "n3nash"}, "timelineItems": {"totalCount": 32, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdojCp7gBqjQxMzg1NDc4MjQ=", "endCursor": "Y3Vyc29yOnYyOpPPAAABd72dfRgFqTU5NDcwNjUyNw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "879ba2c3507e4ca0f39d4f3f7c9712980e1a54f8", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/879ba2c3507e4ca0f39d4f3f7c9712980e1a54f8", "committedDate": "2020-12-22T04:21:43Z", "message": "[HUDI-1486] Remove inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "b8c9cb6d64689ca00f551c982a2707e3e09e340a", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/b8c9cb6d64689ca00f551c982a2707e3e09e340a", "committedDate": "2020-12-22T04:43:24Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9071832d6bbf6cb36e70468e0f111371b0164c8e", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/9071832d6bbf6cb36e70468e0f111371b0164c8e", "committedDate": "2020-12-25T17:20:30Z", "message": "Adding configs to make failed writes eager/lazy"}, "afterCommit": {"oid": "f858d5d192b5da3b171671f38c4b1f414e329c61", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/f858d5d192b5da3b171671f38c4b1f414e329c61", "committedDate": "2020-12-26T06:58:47Z", "message": "Adding configs to make failed writes eager/lazy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f858d5d192b5da3b171671f38c4b1f414e329c61", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/f858d5d192b5da3b171671f38c4b1f414e329c61", "committedDate": "2020-12-26T06:58:47Z", "message": "Adding configs to make failed writes eager/lazy"}, "afterCommit": {"oid": "e45bf61e837827cd737037c4e8fa80c73c272ba1", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/e45bf61e837827cd737037c4e8fa80c73c272ba1", "committedDate": "2020-12-26T07:14:34Z", "message": "Adding configs to make failed writes eager/lazy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e45bf61e837827cd737037c4e8fa80c73c272ba1", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/e45bf61e837827cd737037c4e8fa80c73c272ba1", "committedDate": "2020-12-26T07:14:34Z", "message": "Adding configs to make failed writes eager/lazy"}, "afterCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "committedDate": "2020-12-28T08:22:37Z", "message": "Adding configs to make failed writes eager/lazy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MjQyMDkz", "url": "https://github.com/apache/hudi/pull/2359#pullrequestreview-559242093", "createdAt": "2020-12-28T17:53:33Z", "commit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "state": "COMMENTED", "comments": {"totalCount": 37, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQxNzo1MzozM1rOIL-rVg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOFQyMzo1MzozNlrOIMEH7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMjE1MA==", "bodyText": "these seem like fixes we should make regardless? cc @satishkotha  ?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549432150", "createdAt": "2020-12-28T17:53:33Z", "author": {"login": "vinothchandar"}, "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/FileSystemViewCommand.java", "diffHunk": "@@ -249,7 +249,7 @@ private HoodieTableFileSystemView buildFileSystemView(String globRegex, String m\n     } else if (excludeCompaction) {\n       timeline = metaClient.getActiveTimeline().getCommitsTimeline();\n     } else {\n-      timeline = metaClient.getActiveTimeline().getCommitsAndCompactionTimeline();\n+      timeline = metaClient.getActiveTimeline().getCommitsCompactionAndReplaceTimeline();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMjU5Mg==", "bodyText": "nit: just heartbeatClient ?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549432592", "createdAt": "2020-12-28T17:54:47Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieClient.java", "diffHunk": "@@ -70,6 +72,7 @@ protected AbstractHoodieClient(HoodieEngineContext context, HoodieWriteConfig cl\n     this.config = clientConfig;\n     this.timelineServer = timelineServer;\n     shouldStopTimelineServer = !timelineServer.isPresent();\n+    this.hoodieHeartbeatClient = new HoodieHeartbeatClient(this.fs, this.basePath, clientConfig.getHoodieClientHeartbeatIntervalInSecs());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 20}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMjk5Nw==", "bodyText": "can we do this in postCommit(), so all these things are in one place.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549432997", "createdAt": "2020-12-28T17:56:14Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -160,7 +180,9 @@ public boolean commit(String instantTime, O writeStatuses) {\n   public boolean commit(String instantTime, O writeStatuses, Option<Map<String, String>> extraMetadata) {\n     HoodieTableMetaClient metaClient = createMetaClient(false);\n     String actionType = metaClient.getCommitActionType();\n-    return commit(instantTime, writeStatuses, extraMetadata, actionType, Collections.emptyMap());\n+    boolean isCommitted = commit(instantTime, writeStatuses, extraMetadata, actionType, Collections.emptyMap());\n+    this.hoodieHeartbeatClient.stop(instantTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 76}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMzEzMQ==", "bodyText": "bootstrap reattempt will do this IIRC", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549433131", "createdAt": "2020-12-28T17:56:39Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -232,17 +254,18 @@ void emitCommitMetrics(String instantTime, HoodieCommitMetadata metadata, String\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzMzU1Mg==", "bodyText": "may be pull HoodieFailedWritesCleaningPolicy into its own file? shorter read everywhere.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549433552", "createdAt": "2020-12-28T17:58:07Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -232,17 +254,18 @@ void emitCommitMetrics(String instantTime, HoodieCommitMetadata metadata, String\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later\n     HoodieTable<T, I, K, O> table = getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.EAGER) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 90}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNDYyMQ==", "bodyText": "this sort of block is repeated in many places. lets see if we can invest in some helpers?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549434621", "createdAt": "2020-12-28T18:02:05Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -615,6 +640,11 @@ public String startCommit() {\n    * @param instantTime Instant time to be generated\n    */\n   public void startCommitWithTime(String instantTime) {\n+    if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNDgwNw==", "bodyText": "why is this public now?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549434807", "createdAt": "2020-12-28T18:02:50Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -712,24 +742,43 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNTA1NA==", "bodyText": "rename: .close() or shutDown() to differentiate from the other usage", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549435054", "createdAt": "2020-12-28T18:03:35Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -875,5 +924,6 @@ public void close() {\n     // Calling this here releases any resources used by your index, so make sure to finish any related operations\n     // before this point\n     this.index.close();\n+    this.hoodieHeartbeatClient.stop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 264}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMDgwMg==", "bodyText": "nit. Collections.EMPTY_LIST?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549510802", "createdAt": "2020-12-28T22:52:59Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -712,24 +742,43 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n       }\n     }\n   }\n \n+  private List<String> getInstantsToRollback(HoodieTable<T, I, K, O> table) {\n+    if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.EAGER) {\n+      HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n+      return inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n+          .collect(Collectors.toList());\n+    } else if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY) {\n+      return table.getMetaClient().getActiveTimeline()\n+          .getCommitsTimeline().filterInflights().getReverseOrderedInstants().filter(instant -> {\n+            try {\n+              return !hoodieHeartbeatClient.checkIfConcurrentWriterRunning(instant.getTimestamp());\n+            } catch (IOException io) {\n+              throw new HoodieException(\"Failed to check heartbeat for instant \" + instant, io);\n+            }\n+          }).map(HoodieInstant::getTimestamp).collect(Collectors.toList());\n+    } else if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.NEVER) {\n+      return new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 251}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMDk2MA==", "bodyText": "please move the property closer to the default values", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549510960", "createdAt": "2020-12-28T22:53:50Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieCompactionConfig.java", "diffHunk": "@@ -39,6 +39,7 @@\n public class HoodieCompactionConfig extends DefaultHoodieConfig {\n \n   public static final String CLEANER_POLICY_PROP = \"hoodie.cleaner.policy\";\n+  public static final String FAILED_WRITES_CLEANER_POLICY_PROP = \"hoodie.failed.writes.cleaner.policy\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMTQ0NA==", "bodyText": "rename :  WRITER_CONCURRENCY_MODE, instead of model. its more understandable for users. MULTI seems redundant", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549511444", "createdAt": "2020-12-28T22:56:12Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -140,6 +144,10 @@\n   public static final String EXTERNAL_RECORD_AND_SCHEMA_TRANSFORMATION = AVRO_SCHEMA + \".externalTransformation\";\n   public static final String DEFAULT_EXTERNAL_RECORD_AND_SCHEMA_TRANSFORMATION = \"false\";\n \n+  public static final String MULTI_WRITER_CONCURRENCY_MODEL_PROP =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMjc3Mw==", "bodyText": "why not just keep the config at ms level. I think thats better to do .", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549512773", "createdAt": "2020-12-28T23:03:26Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 73}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzE2NQ==", "bodyText": "so this is assuming the single write client won't have multiple writers. i.e will issue start(instantTime) for only one instant at any time. Can we use a Map per instantTime and maintain state such that the heartbeatClient can handle multiple instant times at once", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549513165", "createdAt": "2020-12-28T23:05:21Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzM4OQ==", "bodyText": "can we use a TimerTask or TimerService. it can also support multiple of these schedules", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549513389", "createdAt": "2020-12-28T23:06:32Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 96}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzU2Mw==", "bodyText": "this is always true?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549513563", "createdAt": "2020-12-28T23:07:19Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 66}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxMzkwNQ==", "bodyText": "then all we need to is to cancel the timers", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549513905", "createdAt": "2020-12-28T23:09:07Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 109}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNDQ0Mw==", "bodyText": "this is leaking upper level context (multi writing) to a lower level class. We should just name this something around heartbeats. say isHeartbeatExpired()", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549514443", "createdAt": "2020-12-28T23:12:07Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;\n+    this.isHeatBeatStopped = false;\n+  }\n+\n+  public void stop(String instantTime) throws HoodieException {\n+    this.shutdownRequested = true;\n+    if (isHearbeatStarted && !isHeatBeatStopped && this.heartBeatFuture != null) {\n+      // TODO : Substract the amount of time it takes to execute updateHeartbeat from the sleep time to avoid race conditions\n+      boolean isCancelled = this.heartBeatFuture.cancel(true);\n+      if (!isCancelled) {\n+        throw new HoodieException(\"Could not stop heartbeat client\");\n+      }\n+      this.isHeatBeatStopped = true;\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  public void stop() throws HoodieException {\n+    if (this.currentInstantTime != null) {\n+      stop(this.currentInstantTime);\n+    }\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {\n+    // TODO ensure that we are not deleting the current instant heartbeat, this might need storing the instant time\n+    // and implementing another heartbeat utils class for everything else\n+    if (this.currentInstantTime == instantTime && !this.isHeatBeatStopped) {\n+      LOG.error(\"Cannot delete a currently running heartbeat, stop it first\");\n+      return false;\n+    } else {\n+      boolean deleted = this.fs.delete(new Path(heartBeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+      return deleted;\n+    }\n+  }\n+\n+  public static Long getLastHeartbeat(FileSystem fs, String basePath, String instantTime) throws IOException {\n+    Path heartBeatFilePath = new Path(HoodieTableMetaClient.getHeartbeatFolderPath(basePath) + File.separator + instantTime);\n+    if (fs.exists(heartBeatFilePath)) {\n+      return fs.getFileStatus(heartBeatFilePath).getModificationTime();\n+    } else {\n+      // NOTE : This can happen when a writer is upgraded to use lazy cleaning and the last write had failed\n+      return 0L;\n+    }\n+  }\n+\n+  public boolean checkIfConcurrentWriterRunning(String instantTime) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 157}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNDY5Nw==", "bodyText": "return this.heartbeatIntervalInMillis <= currentTime - lastHeartBeatForWriter ? single line", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549514697", "createdAt": "2020-12-28T23:13:42Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;\n+    this.isHeatBeatStopped = false;\n+  }\n+\n+  public void stop(String instantTime) throws HoodieException {\n+    this.shutdownRequested = true;\n+    if (isHearbeatStarted && !isHeatBeatStopped && this.heartBeatFuture != null) {\n+      // TODO : Substract the amount of time it takes to execute updateHeartbeat from the sleep time to avoid race conditions\n+      boolean isCancelled = this.heartBeatFuture.cancel(true);\n+      if (!isCancelled) {\n+        throw new HoodieException(\"Could not stop heartbeat client\");\n+      }\n+      this.isHeatBeatStopped = true;\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  public void stop() throws HoodieException {\n+    if (this.currentInstantTime != null) {\n+      stop(this.currentInstantTime);\n+    }\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {\n+    // TODO ensure that we are not deleting the current instant heartbeat, this might need storing the instant time\n+    // and implementing another heartbeat utils class for everything else\n+    if (this.currentInstantTime == instantTime && !this.isHeatBeatStopped) {\n+      LOG.error(\"Cannot delete a currently running heartbeat, stop it first\");\n+      return false;\n+    } else {\n+      boolean deleted = this.fs.delete(new Path(heartBeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+      return deleted;\n+    }\n+  }\n+\n+  public static Long getLastHeartbeat(FileSystem fs, String basePath, String instantTime) throws IOException {\n+    Path heartBeatFilePath = new Path(HoodieTableMetaClient.getHeartbeatFolderPath(basePath) + File.separator + instantTime);\n+    if (fs.exists(heartBeatFilePath)) {\n+      return fs.getFileStatus(heartBeatFilePath).getModificationTime();\n+    } else {\n+      // NOTE : This can happen when a writer is upgraded to use lazy cleaning and the last write had failed\n+      return 0L;\n+    }\n+  }\n+\n+  public boolean checkIfConcurrentWriterRunning(String instantTime) throws IOException {\n+    long lastHeartBeatForWriter = getLastHeartbeat(fs, basePath, instantTime);\n+    long currentTime = System.currentTimeMillis();\n+    if (currentTime - lastHeartBeatForWriter > this.heartbeatIntervalInMillis) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNTMyNw==", "bodyText": "So the heartbeats won't align correctly with the interval. Typically we add another config that multiplies with this.heartbeatIntervalInMillis , which should at least be 2. I am saying we should compared for currentTime - lastHeartBeatForWriter > this.numTolerableHeartbeatMisses * this.heartbeatIntervalInMillis.\nnumTolerableHeartbeatMisses should have another config, with default value 2", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549515327", "createdAt": "2020-12-28T23:17:01Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;\n+    this.isHeatBeatStopped = false;\n+  }\n+\n+  public void stop(String instantTime) throws HoodieException {\n+    this.shutdownRequested = true;\n+    if (isHearbeatStarted && !isHeatBeatStopped && this.heartBeatFuture != null) {\n+      // TODO : Substract the amount of time it takes to execute updateHeartbeat from the sleep time to avoid race conditions\n+      boolean isCancelled = this.heartBeatFuture.cancel(true);\n+      if (!isCancelled) {\n+        throw new HoodieException(\"Could not stop heartbeat client\");\n+      }\n+      this.isHeatBeatStopped = true;\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  public void stop() throws HoodieException {\n+    if (this.currentInstantTime != null) {\n+      stop(this.currentInstantTime);\n+    }\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {\n+    // TODO ensure that we are not deleting the current instant heartbeat, this might need storing the instant time\n+    // and implementing another heartbeat utils class for everything else\n+    if (this.currentInstantTime == instantTime && !this.isHeatBeatStopped) {\n+      LOG.error(\"Cannot delete a currently running heartbeat, stop it first\");\n+      return false;\n+    } else {\n+      boolean deleted = this.fs.delete(new Path(heartBeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+      return deleted;\n+    }\n+  }\n+\n+  public static Long getLastHeartbeat(FileSystem fs, String basePath, String instantTime) throws IOException {\n+    Path heartBeatFilePath = new Path(HoodieTableMetaClient.getHeartbeatFolderPath(basePath) + File.separator + instantTime);\n+    if (fs.exists(heartBeatFilePath)) {\n+      return fs.getFileStatus(heartBeatFilePath).getModificationTime();\n+    } else {\n+      // NOTE : This can happen when a writer is upgraded to use lazy cleaning and the last write had failed\n+      return 0L;\n+    }\n+  }\n+\n+  public boolean checkIfConcurrentWriterRunning(String instantTime) throws IOException {\n+    long lastHeartBeatForWriter = getLastHeartbeat(fs, basePath, instantTime);\n+    long currentTime = System.currentTimeMillis();\n+    if (currentTime - lastHeartBeatForWriter > this.heartbeatIntervalInMillis) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNDY5Nw=="}, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 160}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxNTQ2MQ==", "bodyText": "AFAIK, a new file creation should be atomic in both HDFS and cloud stores. but unsure how the overwrite part works.\nCan you clarify?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549515461", "createdAt": "2020-12-28T23:18:00Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,196 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InterruptedIOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.Future;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  // TODO : Throw new exception from thread\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the hearbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  private String currentInstantTime;\n+  private int numHeartBeatsForCurrentInstantTime;\n+  // heartbeat interval in millis\n+  private final long heartbeatIntervalInMillis;\n+  private final transient ExecutorService executorService = Executors.newSingleThreadExecutor();\n+  private volatile boolean shutdownRequested;\n+  private boolean isHearbeatStarted = false;\n+  private boolean isHeatBeatStopped = false;\n+  private transient Future<?> heartBeatFuture;\n+  private Long lastHeartBeatTime;\n+  // This is required for testing. Problem : if we set heartbeatIntervalInSeconds really large, test takes longer, if\n+  // we set it small and you are debugging with breakpoint, causes issues. Need to implement a Mock in tests\n+  private final Boolean skipHeartBeatCheck;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, long heartbeatIntervalInSeconds) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInSeconds >= 1, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMillis = heartbeatIntervalInSeconds * 1000L;\n+    this.skipHeartBeatCheck = true;\n+  }\n+\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    if (isHearbeatStarted && instantTime == currentInstantTime) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else if (instantTime != currentInstantTime) {\n+      if (this.currentInstantTime != null) {\n+        LOG.warn(\"Stopping heartbeat for previous instant time \" + this.currentInstantTime);\n+        this.stop(this.currentInstantTime);\n+      }\n+      this.currentInstantTime = instantTime;\n+      this.numHeartBeatsForCurrentInstantTime = 0;\n+      this.shutdownRequested = false;\n+    }\n+    try {\n+      updateHeartbeat(instantTime);\n+    } catch (Exception e) {\n+      throw new RuntimeException(\"Unable to generate heartbeat\");\n+    }\n+    this.heartBeatFuture = executorService.submit(() -> {\n+      while (!shutdownRequested) {\n+        try {\n+          Thread.sleep(this.heartbeatIntervalInMillis);\n+          updateHeartbeat(instantTime);\n+        } catch (InterruptedIOException | InterruptedException ioe) {\n+          LOG.warn(\"Thread controlling heartbeat was interrupted\");\n+        } catch (IOException ioe) {\n+          LOG.error(\"Unable to create heartbeat file\", ioe);\n+          throw new RuntimeException(ioe);\n+        }\n+      }\n+    });\n+    this.isHearbeatStarted = true;\n+    this.isHeatBeatStopped = false;\n+  }\n+\n+  public void stop(String instantTime) throws HoodieException {\n+    this.shutdownRequested = true;\n+    if (isHearbeatStarted && !isHeatBeatStopped && this.heartBeatFuture != null) {\n+      // TODO : Substract the amount of time it takes to execute updateHeartbeat from the sleep time to avoid race conditions\n+      boolean isCancelled = this.heartBeatFuture.cancel(true);\n+      if (!isCancelled) {\n+        throw new HoodieException(\"Could not stop heartbeat client\");\n+      }\n+      this.isHeatBeatStopped = true;\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  public void stop() throws HoodieException {\n+    if (this.currentInstantTime != null) {\n+      stop(this.currentInstantTime);\n+    }\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {\n+    // TODO ensure that we are not deleting the current instant heartbeat, this might need storing the instant time\n+    // and implementing another heartbeat utils class for everything else\n+    if (this.currentInstantTime == instantTime && !this.isHeatBeatStopped) {\n+      LOG.error(\"Cannot delete a currently running heartbeat, stop it first\");\n+      return false;\n+    } else {\n+      boolean deleted = this.fs.delete(new Path(heartBeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+      return deleted;\n+    }\n+  }\n+\n+  public static Long getLastHeartbeat(FileSystem fs, String basePath, String instantTime) throws IOException {\n+    Path heartBeatFilePath = new Path(HoodieTableMetaClient.getHeartbeatFolderPath(basePath) + File.separator + instantTime);\n+    if (fs.exists(heartBeatFilePath)) {\n+      return fs.getFileStatus(heartBeatFilePath).getModificationTime();\n+    } else {\n+      // NOTE : This can happen when a writer is upgraded to use lazy cleaning and the last write had failed\n+      return 0L;\n+    }\n+  }\n+\n+  public boolean checkIfConcurrentWriterRunning(String instantTime) throws IOException {\n+    long lastHeartBeatForWriter = getLastHeartbeat(fs, basePath, instantTime);\n+    long currentTime = System.currentTimeMillis();\n+    if (currentTime - lastHeartBeatForWriter > this.heartbeatIntervalInMillis) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private void updateHeartbeat(String instantTime) throws IOException {\n+    Long newHeartBeatTime = System.currentTimeMillis();\n+    OutputStream outputStream =", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 168}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODQyMg==", "bodyText": "No Thread.sleep in tests please. these make tests flaky. lets structure them, to wait till a condition X is reached with a timeout. essence is explained here. http://www.awaitility.org/", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549518422", "createdAt": "2020-12-28T23:35:22Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartBeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() throws IOException, InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    Long waitTimeInMs = 2000L;\n+    Thread.sleep(waitTimeInMs);\n+    assertTrue(hoodieHeartbeatClient.getNumHeartBeatsForCurrentInstantTime() > 0);\n+    Long lastHeartBeat = HoodieHeartbeatClient.getLastHeartbeat(metaClient.getFs(), basePath, instantTime1);\n+    assertTrue(System.currentTimeMillis() - lastHeartBeat >= waitTimeInMs);\n+  }\n+\n+  @Test\n+  public void testNumHeartbeatsGenerated() throws InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(\"100\");\n+    // wait 10 heartbeats\n+    Thread.sleep(10 * heartBeatInterval * 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODQ2MQ==", "bodyText": "log?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549518461", "createdAt": "2020-12-28T23:35:32Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,160 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartBeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() throws IOException, InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    Long waitTimeInMs = 2000L;\n+    Thread.sleep(waitTimeInMs);\n+    assertTrue(hoodieHeartbeatClient.getNumHeartBeatsForCurrentInstantTime() > 0);\n+    Long lastHeartBeat = HoodieHeartbeatClient.getLastHeartbeat(metaClient.getFs(), basePath, instantTime1);\n+    assertTrue(System.currentTimeMillis() - lastHeartBeat >= waitTimeInMs);\n+  }\n+\n+  @Test\n+  public void testNumHeartbeatsGenerated() throws InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(\"100\");\n+    // wait 10 heartbeats\n+    Thread.sleep(10 * heartBeatInterval * 1000);\n+    assertTrue(hoodieHeartbeatClient.getNumHeartBeatsForCurrentInstantTime() >= 10);\n+  }\n+\n+  @Test\n+  public void testLastHeartBeatTime() throws IOException, InterruptedException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(\"100\");\n+    // wait 10 heartbeats\n+    Thread.sleep(1 * heartBeatInterval * 1000);\n+    Long startHeartbeat = hoodieHeartbeatClient.getLastHeartbeat(metaClient.getFs(), basePath, \"100\");\n+    Thread.sleep(9 * heartBeatInterval * 1000);\n+    hoodieHeartbeatClient.stop(\"100\");\n+    Long endHeartbeat = HoodieHeartbeatClient.getLastHeartbeat(metaClient.getFs(), basePath, \"100\");\n+    // check if the heartbeat time is greater than start time + 10 heartbeat intervals\n+    assertTrue((endHeartbeat - startHeartbeat) >= (9 * heartBeatInterval * 1000));\n+  }\n+\n+  @Test\n+  public void testDeleteWrongHeartbeat() throws IOException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(hoodieHeartbeatClient.delete(instantTime2));\n+  }\n+\n+  @Test\n+  public void testDeleteRunningHeartbeat() throws IOException {\n+    int heartBeatInterval = 1;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    assertFalse(hoodieHeartbeatClient.delete(instantTime1));\n+  }\n+\n+  @Test\n+  public void testConcurrentReadsAndWritesToSameFile() throws InterruptedException {\n+    Thread th1 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          OutputStream outputStream = metaClient.getFs().create(new Path(metaClient.getBasePath() + \"/test\"), true);\n+          outputStream.write(\"testing\".getBytes());\n+          outputStream.close();\n+        }\n+      } catch (Exception e) {\n+        System.out.println(\"Caught Exception th1\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th2 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          FileStatus fs = metaClient.getFs().getFileStatus(new Path(metaClient.getBasePath() + \"/test\"));\n+          System.out.println(\"Modification Time => \" + fs.getModificationTime());\n+        }\n+      } catch (Exception e) {\n+        System.out.println(\"Caught Exception th2\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 136}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxODY2OQ==", "bodyText": "hmmm. we should probably do this only once at the super class level.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549518669", "createdAt": "2020-12-28T23:36:35Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java", "diffHunk": "@@ -100,7 +107,9 @@ public static SparkConf registerClasses(SparkConf conf) {\n   public boolean commit(String instantTime, JavaRDD<WriteStatus> writeStatuses, Option<Map<String, String>> extraMetadata,\n                         String commitActionType, Map<String, List<String>> partitionToReplacedFileIds) {\n     List<HoodieWriteStat> writeStats = writeStatuses.map(WriteStatus::getStat).collect();\n-    return commitStats(instantTime, writeStats, extraMetadata, commitActionType, partitionToReplacedFileIds);\n+    boolean isCommitted = commitStats(instantTime, writeStats, extraMetadata, commitActionType, partitionToReplacedFileIds);\n+    this.hoodieHeartbeatClient.stop(instantTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 29}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTMzNA==", "bodyText": "why can't we override this once for all tests. if we run everything with LAZY then we can have better confidence that no uncommitted data will ever be exposed", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549519334", "createdAt": "2020-12-28T23:40:36Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -437,7 +456,10 @@ private void testUpsertsInternal(HoodieWriteConfig config,\n    */\n   @Test\n   public void testDeletes() throws Exception {\n-    SparkRDDWriteClient client = getHoodieWriteClient(getConfig(), false);\n+    // Set cleaner to LAZY so no inflights are cleaned", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 87}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTYwNQ==", "bodyText": "We need to do something about the repeated line\ngetConfig().getProps().put(HoodieCompactionConfig.FAILED_WRITES_CLEANER_POLICY_PROP, HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY.name());\neven if you want to override only selectively. Can we add an override for getConfig(boolean) which decides whether or not we do lazy cleaning of failed writes.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549519605", "createdAt": "2020-12-28T23:42:21Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -546,7 +571,10 @@ private void testUpsertsUpdatePartitionPath(IndexType indexType, HoodieWriteConf\n     HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(),\n         metaClient.getTableType(), metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n         metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n-    SparkRDDWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+    // Set rollback to LAZY so no inflights are deleted\n+    hoodieWriteConfig.getProps().put(HoodieCompactionConfig.FAILED_WRITES_CLEANER_POLICY_PROP,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 112}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTc4MA==", "bodyText": "lets inline these variables . they can all be just constants, right", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549519780", "createdAt": "2020-12-28T23:43:31Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -1367,6 +1410,77 @@ public void testRollbackAfterConsistencyCheckFailureUsingMarkers(boolean enableO\n     testRollbackAfterConsistencyCheckFailureUsingFileList(true, enableOptimisticConsistencyGuard);\n   }\n \n+  @Test\n+  public void testParallelWriting() throws Exception {\n+    ExecutorService service = Executors.newFixedThreadPool(3);\n+    String instantTime1 = \"100\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 207}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUxOTk0Nw==", "bodyText": "should we upsert of the writes. so we get a better mix.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549519947", "createdAt": "2020-12-28T23:44:30Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -1367,6 +1410,77 @@ public void testRollbackAfterConsistencyCheckFailureUsingMarkers(boolean enableO\n     testRollbackAfterConsistencyCheckFailureUsingFileList(true, enableOptimisticConsistencyGuard);\n   }\n \n+  @Test\n+  public void testParallelWriting() throws Exception {\n+    ExecutorService service = Executors.newFixedThreadPool(3);\n+    String instantTime1 = \"100\";\n+    String instantTime2 = \"200\";\n+    String instantTime3 = \"300\";\n+    Boolean doCommit = true;\n+    Boolean doClean = false;\n+    HoodieTestUtils.init(hadoopConf, basePath);\n+    Future<Boolean> commit1 = service.submit(() -> doWritesToTable(instantTime1, doCommit, doClean));\n+    Future<Boolean> commit2 = service.submit(() -> doWritesToTable(instantTime2, doCommit, doClean));\n+    Future<Boolean> commit3 = service.submit(() -> doWritesToTable(instantTime3, doCommit, doClean));\n+    assertTrue(commit1.get() && commit2.get() && commit3.get());\n+    HoodieTableMetaClient metaClient = new HoodieTableMetaClient(hadoopConf, basePath);\n+    assertTrue(metaClient.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().countInstants() == 3);\n+  }\n+\n+  @Test\n+  public void testParallelWritingWhileCleaningPreviousFailedCommits() throws Exception {\n+    ExecutorService service = Executors.newFixedThreadPool(2);\n+    String instantTime1 = \"100\";\n+    String instantTime2 = \"200\";\n+    String instantTime3 = \"300\";\n+    String instantTime4 = \"400\";\n+    Boolean doCommit = false;\n+    Boolean doClean = false;\n+    HoodieTestUtils.init(hadoopConf, basePath);\n+    // Perform 2 failed writes to table\n+    doWritesToTable(instantTime1, doCommit, doClean);\n+    doWritesToTable(instantTime2, doCommit, doClean);\n+    Future<Boolean> commit3 = service.submit(() -> doWritesToTable(instantTime3, true, false));\n+    assertTrue(commit3.get());\n+    HoodieTableMetaClient metaClient = new HoodieTableMetaClient(hadoopConf, basePath);\n+    assertTrue(metaClient.getActiveTimeline().getTimelineOfActions(\n+        CollectionUtils.createSet(HoodieTimeline.ROLLBACK_ACTION)).countInstants() == 0);\n+    assertTrue(metaClient.getActiveTimeline().filterInflights().countInstants() == 2);\n+    // Sleep for 5 secs to allow for heart beat interval to pass\n+    Thread.sleep(5000);\n+    SparkRDDWriteClient client = new SparkRDDWriteClient(context, getParallelWritingWriteConfig());\n+    Future<Boolean> commit4 = service.submit(() -> doWritesToTable(instantTime4, true, false));\n+    Future<HoodieCleanMetadata> clean1 = service.submit(() -> client.clean());\n+    assertTrue(commit4.get());\n+    clean1.get();\n+    assertTrue(metaClient.getActiveTimeline().reload().getTimelineOfActions(\n+        CollectionUtils.createSet(HoodieTimeline.ROLLBACK_ACTION)).countInstants() == 2);\n+  }\n+\n+  private boolean doWritesToTable(String instantTime, Boolean doCommit, Boolean doClean) {\n+    HoodieWriteConfig cfg = getParallelWritingWriteConfig();\n+    // Create a new write client local to thread\n+    SparkRDDWriteClient client = new SparkRDDWriteClient(context, cfg);\n+\n+    client.startCommitWithTime(instantTime);\n+\n+    List<HoodieRecord> records0 = dataGen.generateInserts(instantTime, 200);\n+    JavaRDD<HoodieRecord> writeRecords0 = jsc.parallelize(records0, 1);\n+    JavaRDD<WriteStatus> result0 = client.bulkInsert(writeRecords0, instantTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 260}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDU0MQ==", "bodyText": "let's have as a top level enum/ unnested", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520541", "createdAt": "2020-12-28T23:47:31Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieCleaningPolicy.java", "diffHunk": "@@ -22,5 +22,8 @@\n  * Hoodie cleaning policies.\n  */\n public enum HoodieCleaningPolicy {\n-  KEEP_LATEST_FILE_VERSIONS, KEEP_LATEST_COMMITS\n+  KEEP_LATEST_FILE_VERSIONS, KEEP_LATEST_COMMITS;\n+  public enum HoodieFailedWritesCleaningPolicy {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDU2Ng==", "bodyText": "rename:WriteConcurrencyMode", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520566", "createdAt": "2020-12-28T23:47:49Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/MultiWriterConcurrencyModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+public enum MultiWriterConcurrencyModel {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDY0Ng==", "bodyText": "rename: SINGLE_WRITER, dropping the LEGACY. The model has its merits", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520646", "createdAt": "2020-12-28T23:48:12Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/MultiWriterConcurrencyModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+public enum MultiWriterConcurrencyModel {\n+  LEGACY_SINGLE_WRITER,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDc3OA==", "bodyText": "rename: just PARALLEL_NO_CONTENTION", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520778", "createdAt": "2020-12-28T23:48:55Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/MultiWriterConcurrencyModel.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+public enum MultiWriterConcurrencyModel {\n+  LEGACY_SINGLE_WRITER,\n+  EMBARRASSINGLY_PARALLEL,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 23}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDg4MA==", "bodyText": "should nt this be under the metaPath?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520880", "createdAt": "2020-12-28T23:49:43Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTableMetaClient.java", "diffHunk": "@@ -217,6 +218,13 @@ public String getMetaAuxiliaryPath() {\n     return basePath + File.separator + AUXILIARYFOLDER_NAME;\n   }\n \n+  /**\n+   * @return Heartbeat folder path.\n+   */\n+  public static String getHeartbeatFolderPath(String basePath) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMDk5Ng==", "bodyText": "this is not an invalid block right. this skipping an uncommitted block?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549520996", "createdAt": "2020-12-28T23:50:32Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/table/log/AbstractHoodieLogRecordScanner.java", "diffHunk": "@@ -145,6 +146,11 @@ public void scan() {\n           // hit a block with instant time greater than should be processed, stop processing further\n           break;\n         }\n+        if (r.getBlockType() != CORRUPT_BLOCK && r.getBlockType() != COMMAND_BLOCK\n+            && !timeline.containsOrBeforeTimelineStarts(r.getLogBlockHeader().get(INSTANT_TIME))) {\n+          // hit an invalid block possibly from a failed write, move to the next one and skip processing this one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 47}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTA4MA==", "bodyText": "got it. so this is a rename. discard my earlier comment.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549521080", "createdAt": "2020-12-28T23:51:06Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/table/timeline/HoodieDefaultTimeline.java", "diffHunk": "@@ -107,7 +107,7 @@ public HoodieTimeline filterCompletedAndCompactionInstants() {\n   }\n \n   @Override\n-  public HoodieDefaultTimeline getCommitsAndCompactionTimeline() {\n+  public HoodieDefaultTimeline getCommitsCompactionAndReplaceTimeline() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTEyOA==", "bodyText": "how about getWriteTimeline simply", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549521128", "createdAt": "2020-12-28T23:51:36Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/table/timeline/HoodieDefaultTimeline.java", "diffHunk": "@@ -107,7 +107,7 @@ public HoodieTimeline filterCompletedAndCompactionInstants() {\n   }\n \n   @Override\n-  public HoodieDefaultTimeline getCommitsAndCompactionTimeline() {\n+  public HoodieDefaultTimeline getCommitsCompactionAndReplaceTimeline() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTA4MA=="}, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM0Nw==", "bodyText": "dont we already have helpers that do these. cc @xushiyan", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549521347", "createdAt": "2020-12-28T23:53:11Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/testutils/FileCreateUtils.java", "diffHunk": "@@ -83,6 +83,17 @@ private static void createMetaFile(String basePath, String instantTime, String s\n     }\n   }\n \n+  private static void createMetaFile(FileSystem fs, String basePath, String instantTime, String suffix) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM5MQ==", "bodyText": "why removing the test?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549521391", "createdAt": "2020-12-28T23:53:36Z", "author": {"login": "vinothchandar"}, "path": "hudi-hadoop-mr/src/test/java/org/apache/hudi/hadoop/TestHoodieROTablePathFilter.java", "diffHunk": "@@ -84,7 +84,6 @@ public void testNonHoodiePaths() throws IOException {\n     assertTrue(pathFilter.accept(new Path(path2.toUri())));\n   }\n \n-  @Test\n   public void testPartitionPathsAsNonHoodiePaths() throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 5}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzU5Nzkz", "url": "https://github.com/apache/hudi/pull/2359#pullrequestreview-559359793", "createdAt": "2020-12-29T02:43:31Z", "commit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMjo0MzozMVrOIMFvtA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMjo0MzozMVrOIMFvtA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Nzk1Ng==", "bodyText": "is n't there an existing method to get this? Also should we include replacecommit here as well?  I understand the issue with compactions, since the retry will attempt to reuse the same instantTime. is that why you only have commit/deltacommit here?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549547956", "createdAt": "2020-12-29T02:43:31Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/HoodieTimelineArchiveLog.java", "diffHunk": "@@ -165,13 +167,17 @@ public boolean archiveIfRequired(HoodieEngineContext context) throws IOException\n     HoodieTimeline commitTimeline = table.getCompletedCommitsTimeline();\n     Option<HoodieInstant> oldestPendingCompactionInstant =\n         table.getActiveTimeline().filterPendingCompactionTimeline().firstInstant();\n+    Option<HoodieInstant> oldestInflightInstant =\n+        table.getActiveTimeline()\n+            .getTimelineOfActions(CollectionUtils.createSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION))", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 18}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU5MzYxMDQ0", "url": "https://github.com/apache/hudi/pull/2359#pullrequestreview-559361044", "createdAt": "2020-12-29T02:52:08Z", "commit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "state": "COMMENTED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMjo1MjowOFrOIMF0-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0yOVQwMjo1NjoyNlrOIMF3sw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0OTMwNA==", "bodyText": "do we need to guard this by config.getMultiWriterConcurrencyModel() != MultiWriterConcurrencyModel.LEGACY_SINGLE_WRITER ? it should technically work right? if so, best to keep just the one flag to fence", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549549304", "createdAt": "2020-12-29T02:52:08Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/HoodieTimelineArchiveLog.java", "diffHunk": "@@ -180,7 +186,14 @@ public boolean archiveIfRequired(HoodieEngineContext context) throws IOException\n             return oldestPendingCompactionInstant\n                 .map(instant -> HoodieTimeline.compareTimestamps(instant.getTimestamp(), GREATER_THAN, s.getTimestamp()))\n                 .orElse(true);\n-          }).limit(commitTimeline.countInstants() - minInstantsToKeep);\n+          });\n+      if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.LAZY\n+          && config.getMultiWriterConcurrencyModel() != MultiWriterConcurrencyModel.LEGACY_SINGLE_WRITER) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0OTQ1OA==", "bodyText": "just return if the policy is not EAGER?  easier to read that, than nested if blocks .", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549549458", "createdAt": "2020-12-29T02:53:16Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/action/rollback/BaseRollbackActionExecutor.java", "diffHunk": "@@ -130,23 +131,29 @@ private void validateSavepointRollbacks() {\n   }\n \n   private void validateRollbackCommitSequence() {\n-    final String instantTimeToRollback = instantToRollback.getTimestamp();\n-    HoodieTimeline commitTimeline = table.getCompletedCommitsTimeline();\n-    HoodieTimeline inflightAndRequestedCommitTimeline = table.getPendingCommitTimeline();\n-    // Make sure only the last n commits are being rolled back\n-    // If there is a commit in-between or after that is not rolled back, then abort\n-    if ((instantTimeToRollback != null) && !commitTimeline.empty()\n-        && !commitTimeline.findInstantsAfter(instantTimeToRollback, Integer.MAX_VALUE).empty()) {\n-      throw new HoodieRollbackException(\n-          \"Found commits after time :\" + instantTimeToRollback + \", please rollback greater commits first\");\n-    }\n+    // Continue to provide the same behavior if policy is EAGER (similar to pendingRollback logic). This is required\n+    // since with LAZY rollback we support parallel writing which can allow a new inflight while rollback is ongoing\n+    // Remove this once we support LAZY rollback of failed writes by default as parallel writing becomes the default\n+    // writer mode.\n+    if (config.getFailedWritesCleanPolicy() == HoodieCleaningPolicy.HoodieFailedWritesCleaningPolicy.EAGER) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 26}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0OTYwMw==", "bodyText": "+1", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549549603", "createdAt": "2020-12-29T02:54:14Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/testutils/FileCreateUtils.java", "diffHunk": "@@ -83,6 +83,17 @@ private static void createMetaFile(String basePath, String instantTime, String s\n     }\n   }\n \n+  private static void createMetaFile(FileSystem fs, String basePath, String instantTime, String suffix) throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTUyMTM0Nw=="}, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU1MDAwMw==", "bodyText": "I was expecting some changes in this file, to clean the failed writers for LAZY? Can you point me to the files that do this.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r549550003", "createdAt": "2020-12-29T02:56:26Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/clean/SparkCleanActionExecutor.java", "diffHunk": "@@ -23,9 +23,9 @@\n import org.apache.hudi.avro.model.HoodieActionInstant;\n import org.apache.hudi.avro.model.HoodieCleanerPlan;\n import org.apache.hudi.client.WriteStatus;\n-import org.apache.hudi.common.HoodieCleanStat;\n import org.apache.hudi.client.common.HoodieEngineContext;\n import org.apache.hudi.client.common.HoodieSparkEngineContext;\n+import org.apache.hudi.common.HoodieCleanStat;\n import org.apache.hudi.common.model.CleanFileInfo;\n import org.apache.hudi.common.model.HoodieKey;\n import org.apache.hudi.common.model.HoodieRecord;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 10}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/35a82c7f68c8bf0b381e47dc3f12374bec7081eb", "committedDate": "2020-12-28T08:22:37Z", "message": "Adding configs to make failed writes eager/lazy"}, "afterCommit": {"oid": "19d7cbc0c0685119742f116dc8c5d2dc5067727d", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/19d7cbc0c0685119742f116dc8c5d2dc5067727d", "committedDate": "2020-12-31T08:41:31Z", "message": "Adding configs to make failed writes eager/lazy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "19d7cbc0c0685119742f116dc8c5d2dc5067727d", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/19d7cbc0c0685119742f116dc8c5d2dc5067727d", "committedDate": "2020-12-31T08:41:31Z", "message": "Adding configs to make failed writes eager/lazy"}, "afterCommit": {"oid": "b21cb42fe0f6ce29e77ac1412defb54191b06d54", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/b21cb42fe0f6ce29e77ac1412defb54191b06d54", "committedDate": "2021-01-03T03:11:25Z", "message": "Adding configs to make failed writes eager/lazy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b21cb42fe0f6ce29e77ac1412defb54191b06d54", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/b21cb42fe0f6ce29e77ac1412defb54191b06d54", "committedDate": "2021-01-03T03:11:25Z", "message": "Adding configs to make failed writes eager/lazy"}, "afterCommit": {"oid": "2ec3746823cd8955318469fe81ae531b2100b299", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/2ec3746823cd8955318469fe81ae531b2100b299", "committedDate": "2021-01-03T03:17:40Z", "message": "Adding configs to make failed writes eager/lazy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "2ec3746823cd8955318469fe81ae531b2100b299", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/2ec3746823cd8955318469fe81ae531b2100b299", "committedDate": "2021-01-03T03:17:40Z", "message": "Adding configs to make failed writes eager/lazy"}, "afterCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/4718c03b3aeac528d6192fcd8cb5c3916bd08555", "committedDate": "2021-01-03T07:52:17Z", "message": "Adding configs to make failed writes eager/lazy"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/4718c03b3aeac528d6192fcd8cb5c3916bd08555", "committedDate": "2021-01-03T07:52:17Z", "message": "Adding configs to make failed writes eager/lazy"}, "afterCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/557bbd3d71e53f8306d0f1cae6ced16314204aee", "committedDate": "2021-01-05T08:21:21Z", "message": "Adding configs to make failed writes eager/lazy"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTYxNDA1OTQw", "url": "https://github.com/apache/hudi/pull/2359#pullrequestreview-561405940", "createdAt": "2021-01-04T22:57:36Z", "commit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "state": "COMMENTED", "comments": {"totalCount": 20, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNFQyMjo1NzozN1rOIOEFbg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMS0wNVQxNzozOTo0NFrOIOgvng==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxNzkwMg==", "bodyText": "rename to be shorter? drop the HoodieClient or Hoodie part in the names?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551617902", "createdAt": "2021-01-04T22:57:37Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieClient.java", "diffHunk": "@@ -70,6 +72,8 @@ protected AbstractHoodieClient(HoodieEngineContext context, HoodieWriteConfig cl\n     this.config = clientConfig;\n     this.timelineServer = timelineServer;\n     shouldStopTimelineServer = !timelineServer.isPresent();\n+    this.heartbeatClient = new HoodieHeartbeatClient(this.fs, this.basePath,\n+        clientConfig.getHoodieClientHeartbeatIntervalInMs(), clientConfig.getHoodieClientHeartbeatTolerableMisses());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxODcyOQ==", "bodyText": "config is a member variable right? why do we pass it in to the checks? Can we just do eagerCleanFailedWrites(), which does he if block and the call to rollbackFailedBootstrap()?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551618729", "createdAt": "2021-01-04T22:59:57Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -232,17 +250,18 @@ void emitCommitMetrics(String instantTime, HoodieCommitMetadata metadata, String\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later\n     HoodieTable<T, I, K, O> table = getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    if (isEager(config.getFailedWritesCleanPolicy())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 88}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTAxMA==", "bodyText": "should we just call getCommitsCompactionAndReplaceTimeline() -> getCompletedWriteTimeline() ? we use writes already for other things", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551619010", "createdAt": "2021-01-04T23:00:51Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -408,13 +426,14 @@ protected void postCommit(HoodieTable<T, I, K, O> table, HoodieCommitMetadata me\n       HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(config, table);\n       archiveLog.archiveIfRequired(context);\n       autoCleanOnCommit(instantTime);\n+      this.heartbeatClient.stop(instantTime);\n     } catch (IOException ioe) {\n       throw new HoodieIOException(ioe.getMessage(), ioe);\n     }\n   }\n \n   protected void runAnyPendingCompactions(HoodieTable<T, I, K, O> table) {\n-    table.getActiveTimeline().getCommitsAndCompactionTimeline().filterPendingCompactionTimeline().getInstants()\n+    table.getActiveTimeline().getCommitsCompactionAndReplaceTimeline().filterPendingCompactionTimeline().getInstants()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 123}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTI0OA==", "bodyText": "pull both lines into a method that takes 0 args?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551619248", "createdAt": "2021-01-04T23:01:30Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -580,6 +602,11 @@ public HoodieRestoreMetadata restoreToInstant(final String instantTime) throws H\n   public HoodieCleanMetadata clean(String cleanInstantTime) throws HoodieIOException {\n     LOG.info(\"Cleaner started\");\n     final Timer.Context timerContext = metrics.getCleanCtx();\n+    LOG.info(\"Cleaning failed attempts if any\");\n+    if (!isEager(config.getFailedWritesCleanPolicy())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 148}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTM3NQ==", "bodyText": "rename to rollbackFailedWrites()", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551619375", "createdAt": "2021-01-04T23:01:47Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -580,6 +602,11 @@ public HoodieRestoreMetadata restoreToInstant(final String instantTime) throws H\n   public HoodieCleanMetadata clean(String cleanInstantTime) throws HoodieIOException {\n     LOG.info(\"Cleaner started\");\n     final Timer.Context timerContext = metrics.getCleanCtx();\n+    LOG.info(\"Cleaning failed attempts if any\");\n+    if (!isEager(config.getFailedWritesCleanPolicy())) {\n+      rollbackFailedCommits();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 149}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxOTY3OA==", "bodyText": "okay makes sense.  left a comment above for renaming.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551619678", "createdAt": "2021-01-04T23:02:49Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -712,24 +742,43 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTQzNDgwNw=="}, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyMDg0OA==", "bodyText": "drop the second argument to isHeartbeatExpired() and have it get the current time epoch inside?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551620848", "createdAt": "2021-01-04T23:05:58Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n+      }\n+      // Delete the heartbeats from DFS\n+      if (!isEager(config.getFailedWritesCleanPolicy())) {\n+        try {\n+          this.heartbeatClient.delete(instant);\n+        } catch (IOException io) {\n+          LOG.error(io);\n+        }\n       }\n     }\n   }\n \n+  private List<String> getInstantsToRollback(HoodieTable<T, I, K, O> table) {\n+    if (isEager(config.getFailedWritesCleanPolicy())) {\n+      HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n+      return inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n+          .collect(Collectors.toList());\n+    } else if (!isEager(config.getFailedWritesCleanPolicy())) {\n+      return table.getMetaClient().getActiveTimeline()\n+          .getCommitsTimeline().filterInflights().getReverseOrderedInstants().filter(instant -> {\n+            try {\n+              return heartbeatClient.isHeartbeatExpired(instant.getTimestamp(), System.currentTimeMillis());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyOTg4OA==", "bodyText": "To confirm my understanding, this will log rollback blocks for a much older data block and as long as that instant is on the active timeline, the merging/reading part will continue to ignore the blocks/files corresponding to the failed write.\nIn terms of multiple writing, one of the writers has to be responsible for doing all \"table services\" (cleaning, compaction, clustering, failedwrite cleaning, archiving) and another writer could be writing a new data block into the file group, while this failed cleanup is happening? and we can handle this, right?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551629888", "createdAt": "2021-01-04T23:31:38Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYzMDUyNQ==", "bodyText": "some context on the error?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r551630525", "createdAt": "2021-01-04T23:33:45Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n+      }\n+      // Delete the heartbeats from DFS\n+      if (!isEager(config.getFailedWritesCleanPolicy())) {\n+        try {\n+          this.heartbeatClient.delete(instant);\n+        } catch (IOException io) {\n+          LOG.error(io);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 231}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3ODEwNg==", "bodyText": "how do we cleanup if we fail after rolling back, but before deleting the heartbeat?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552078106", "createdAt": "2021-01-05T17:24:02Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n+      }\n+      // Delete the heartbeats from DFS\n+      if (!isEager(config.getFailedWritesCleanPolicy())) {\n+        try {\n+          this.heartbeatClient.delete(instant);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 229}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3OTUwMw==", "bodyText": "Like I mentioned above, we can make turn this into eagerCleanFailedWrites() returning boolean, working off the member variable config ? In its current form, this should probably reside in HoodieFailedWritesCleaningPolicy itself", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552079503", "createdAt": "2021-01-05T17:26:15Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -859,6 +931,10 @@ protected void setWriteSchemaForDeletes(HoodieTableMetaClient metaClient) {\n     }\n   }\n \n+  private boolean isEager(HoodieFailedWritesCleaningPolicy cleaningPolicy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 285}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA3OTk4Ng==", "bodyText": "typo: interval", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552079986", "createdAt": "2021-01-05T17:26:59Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatInternalInMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 57}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MTE2Nw==", "bodyText": "just numHeartBeats?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552081167", "createdAt": "2021-01-05T17:28:45Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatInternalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatInternalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartBeatTime;\n+    private Integer numHeartBeatsForCurrentInstantTime = 0;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 78}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MTcxNA==", "bodyText": "is there a reason to make this map synchronzied/concurrent ?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552081714", "createdAt": "2021-01-05T17:29:39Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatInternalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatInternalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartBeatTime;\n+    private Integer numHeartBeatsForCurrentInstantTime = 0;\n+    private Timer timer = new Timer();\n+\n+    public String getInstantTime() {\n+      return instantTime;\n+    }\n+\n+    public void setInstantTime(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    public Boolean isHeartbeatStarted() {\n+      return isHeartbeatStarted;\n+    }\n+\n+    public void setHeartbeatStarted(Boolean heartbeatStarted) {\n+      isHeartbeatStarted = heartbeatStarted;\n+    }\n+\n+    public Boolean isHeartbeatStopped() {\n+      return isHeartbeatStopped;\n+    }\n+\n+    public void setHeartbeatStopped(Boolean heartbeatStopped) {\n+      isHeartbeatStopped = heartbeatStopped;\n+    }\n+\n+    public Long getLastHeartBeatTime() {\n+      return lastHeartBeatTime;\n+    }\n+\n+    public void setLastHeartBeatTime(Long lastHeartBeatTime) {\n+      this.lastHeartBeatTime = lastHeartBeatTime;\n+    }\n+\n+    public Integer getNumHeartBeatsForCurrentInstantTime() {\n+      return numHeartBeatsForCurrentInstantTime;\n+    }\n+\n+    public void setNumHeartBeatsForCurrentInstantTime(Integer numHeartBeatsForCurrentInstantTime) {\n+      this.numHeartBeatsForCurrentInstantTime = numHeartBeatsForCurrentInstantTime;\n+    }\n+\n+    public Timer getTimer() {\n+      return timer;\n+    }\n+\n+    public void setTimer(Timer timer) {\n+      this.timer = timer;\n+    }\n+  }\n+\n+  class HeartbeatTask extends TimerTask {\n+\n+    private final String instantTime;\n+\n+    HeartbeatTask(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+      updateHeartbeat(instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Start a new heartbeat for the specified instant. If there is already one running, this will be a NO_OP\n+   * @param instantTime\n+   */\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 150}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4MjQzOA==", "bodyText": "I find this a bit odd, for heartBeat to have a delete() method? can this clean up be done as part of stop() ? esp given delete() requires a stop first", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552082438", "createdAt": "2021-01-05T17:31:04Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartBeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatInternalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartBeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatInternalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartBeatTime;\n+    private Integer numHeartBeatsForCurrentInstantTime = 0;\n+    private Timer timer = new Timer();\n+\n+    public String getInstantTime() {\n+      return instantTime;\n+    }\n+\n+    public void setInstantTime(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    public Boolean isHeartbeatStarted() {\n+      return isHeartbeatStarted;\n+    }\n+\n+    public void setHeartbeatStarted(Boolean heartbeatStarted) {\n+      isHeartbeatStarted = heartbeatStarted;\n+    }\n+\n+    public Boolean isHeartbeatStopped() {\n+      return isHeartbeatStopped;\n+    }\n+\n+    public void setHeartbeatStopped(Boolean heartbeatStopped) {\n+      isHeartbeatStopped = heartbeatStopped;\n+    }\n+\n+    public Long getLastHeartBeatTime() {\n+      return lastHeartBeatTime;\n+    }\n+\n+    public void setLastHeartBeatTime(Long lastHeartBeatTime) {\n+      this.lastHeartBeatTime = lastHeartBeatTime;\n+    }\n+\n+    public Integer getNumHeartBeatsForCurrentInstantTime() {\n+      return numHeartBeatsForCurrentInstantTime;\n+    }\n+\n+    public void setNumHeartBeatsForCurrentInstantTime(Integer numHeartBeatsForCurrentInstantTime) {\n+      this.numHeartBeatsForCurrentInstantTime = numHeartBeatsForCurrentInstantTime;\n+    }\n+\n+    public Timer getTimer() {\n+      return timer;\n+    }\n+\n+    public void setTimer(Timer timer) {\n+      this.timer = timer;\n+    }\n+  }\n+\n+  class HeartbeatTask extends TimerTask {\n+\n+    private final String instantTime;\n+\n+    HeartbeatTask(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+      updateHeartbeat(instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Start a new heartbeat for the specified instant. If there is already one running, this will be a NO_OP\n+   * @param instantTime\n+   */\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);\n+    ValidationUtils.checkArgument(heartbeat == null || !heartbeat.isHeartbeatStopped(), \"Cannot restart a stopped heartbeat for \" + instantTime);\n+    if (heartbeat != null && heartbeat.isHeartbeatStarted()) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else {\n+      Heartbeat newHeartBeat = new Heartbeat();\n+      newHeartBeat.setHeartbeatStarted(true);\n+      instantToHeartbeatMap.putIfAbsent(instantTime, newHeartBeat);\n+      // Ensure heartbeat is generated for the first time with this blocking call.\n+      // Since timer submits the task to a thread, no guarantee when that thread will get CPU\n+      // cycles to generate the first heartbeat.\n+      updateHeartbeat(instantTime);\n+      newHeartBeat.getTimer().scheduleAtFixedRate(new HeartbeatTask(instantTime), this.heartbeatIntervalInMs,\n+          this.heartbeatIntervalInMs);\n+    }\n+  }\n+\n+  /**\n+   * Stops the heartbeat for the specified instant.\n+   * @param instantTime\n+   * @throws HoodieException\n+   */\n+  public void stop(String instantTime) throws HoodieException {\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);\n+    if (heartbeat != null && heartbeat.isHeartbeatStarted() && !heartbeat.isHeartbeatStopped()) {\n+      heartbeat.getTimer().cancel();\n+      heartbeat.setHeartbeatStopped(true);\n+      LOG.info(\"Stopping heartbeat for instant \" + instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Stops all heartbeats started via this instance of the client.\n+   * @throws HoodieException\n+   */\n+  public void stop() throws HoodieException {\n+    instantToHeartbeatMap.values().stream().forEach(heartbeat -> stop(heartbeat.getInstantTime()));\n+  }\n+\n+  public boolean delete(String instantTime) throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 190}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4Mzg5NQ==", "bodyText": "withFailedWritesCleaningPolicy(). can we make this consistent everywhere.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552083895", "createdAt": "2021-01-05T17:33:34Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieCompactionConfig.java", "diffHunk": "@@ -260,6 +264,11 @@ public Builder withCleanBootstrapBaseFileEnabled(Boolean cleanBootstrapSourceFil\n       return this;\n     }\n \n+    public Builder withCleanFailedWritesPolicy(HoodieFailedWritesCleaningPolicy failedWritesPolicy) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 22}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NDg0MQ==", "bodyText": "makes sense to have the lazy cleaning for just the true write actiosn.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552084841", "createdAt": "2021-01-05T17:35:08Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/table/HoodieTimelineArchiveLog.java", "diffHunk": "@@ -165,13 +167,17 @@ public boolean archiveIfRequired(HoodieEngineContext context) throws IOException\n     HoodieTimeline commitTimeline = table.getCompletedCommitsTimeline();\n     Option<HoodieInstant> oldestPendingCompactionInstant =\n         table.getActiveTimeline().filterPendingCompactionTimeline().firstInstant();\n+    Option<HoodieInstant> oldestInflightInstant =\n+        table.getActiveTimeline()\n+            .getTimelineOfActions(CollectionUtils.createSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION))", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTU0Nzk1Ng=="}, "originalCommit": {"oid": "35a82c7f68c8bf0b381e47dc3f12374bec7081eb"}, "originalPosition": 18}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NjA5OA==", "bodyText": "the 2 second limit is a bit tight. the test jvm can gc etc. can we make this longer.  same check for other time based tests here.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552086098", "createdAt": "2021-01-05T17:37:18Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static final Logger LOG = LogManager.getLogger(TestHoodieHeartbeatClient.class);\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+  private static Long heartBeatInterval = 1000L;\n+  private static int numTolerableMisses = 1;\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartBeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    await().atMost(2, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartBeatsForCurrentInstantTime() > 0);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 68}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4Njk1OQ==", "bodyText": "can we pull this into parent pom, introduce a property for the version and just use this without the <version> tag here. just like other deps/", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552086959", "createdAt": "2021-01-05T17:38:50Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/pom.xml", "diffHunk": "@@ -127,6 +127,14 @@\n       <scope>test</scope>\n     </dependency>\n \n+    <!-- Other Utils -->", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MjA4NzQ1NA==", "bodyText": "docs for all these three modes please.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r552087454", "createdAt": "2021-01-05T17:39:44Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/model/HoodieFailedWritesCleaningPolicy.java", "diffHunk": "@@ -0,0 +1,23 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.model;\n+\n+public enum HoodieFailedWritesCleaningPolicy {\n+  EAGER, LAZY, NEVER", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "557bbd3d71e53f8306d0f1cae6ced16314204aee"}, "originalPosition": 22}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "641358637d02a65a982e3ae3ae0d1090c4be3363", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/641358637d02a65a982e3ae3ae0d1090c4be3363", "committedDate": "2021-01-08T08:07:07Z", "message": "Refactored code, removed parallel writing capability"}, "afterCommit": {"oid": "868fbaba7f5a778dc6248b6a4c2b25362b8a8d6b", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/868fbaba7f5a778dc6248b6a4c2b25362b8a8d6b", "committedDate": "2021-01-19T00:46:14Z", "message": "Refactored code, removed parallel writing capability"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "868fbaba7f5a778dc6248b6a4c2b25362b8a8d6b", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/868fbaba7f5a778dc6248b6a4c2b25362b8a8d6b", "committedDate": "2021-01-19T00:46:14Z", "message": "Refactored code, removed parallel writing capability"}, "afterCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/b702eb16f9bfcba66e69036514b5b96c898074e8", "committedDate": "2021-01-20T09:08:04Z", "message": "Refactored code, removed parallel writing capability"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgwNzg4MDU3", "url": "https://github.com/apache/hudi/pull/2359#pullrequestreview-580788057", "createdAt": "2021-02-01T21:37:23Z", "commit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQyMTozNzoyM1rOId1jXQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMVQyMTozNzoyM1rOId1jXQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODE1NzAyMQ==", "bodyText": "@n3nash spent sometime thinking about this. the tradeoffs are pretty clear in the sense, this helps us reclaim the storage used by failed writes much sooner than say deleting the files, during archival process (which by itself is not a guarantee actually).\nIf we want to implement some schema to pre-emptively take away compute resources used by a pending job or storage space, then I don't see a way to do this without heartbeats of some kind.\nWe could just keep this simpler in this PR, if you like and just clean up once during archival. (again, the case of a long deletion job running for say 12 hrs, comes to mind. and That needs some kind of heartbeat mechanism, so that even archival does not clean up).\nOrthogonal question : for such long running concurrent writes, should n't they just abort early if they detect more commits have happened since it began?  i.e if it figures out after 1 hr of runtime, that some writes have changed the same filegroups, then why should it even run? its going to fail anyway", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568157021", "createdAt": "2021-02-01T21:37:23Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.HeartbeatUtils;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 46}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgxNjI0NDU0", "url": "https://github.com/apache/hudi/pull/2359#pullrequestreview-581624454", "createdAt": "2021-02-02T17:59:56Z", "commit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "state": "COMMENTED", "comments": {"totalCount": 14, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxNzo1OTo1NlrOIedsKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0wMlQxODoyMToyM1rOIeelvw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxNDYzNA==", "bodyText": "is rollbackPending being used anymore? remove?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568814634", "createdAt": "2021-02-02T17:59:56Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -128,11 +133,26 @@ public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig\n    * @param rollbackPending whether need to cleanup pending commits\n    * @param timelineService Timeline Service that runs as part of write client.\n    */\n+  @Deprecated\n   public AbstractHoodieWriteClient(HoodieEngineContext context, HoodieWriteConfig writeConfig, boolean rollbackPending,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 56}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxNTA3OQ==", "bodyText": "remote isCommitted and return directly?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568815079", "createdAt": "2021-02-02T18:00:33Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -160,7 +180,8 @@ public boolean commit(String instantTime, O writeStatuses) {\n   public boolean commit(String instantTime, O writeStatuses, Option<Map<String, String>> extraMetadata) {\n     HoodieTableMetaClient metaClient = createMetaClient(false);\n     String actionType = metaClient.getCommitActionType();\n-    return commit(instantTime, writeStatuses, extraMetadata, actionType, Collections.emptyMap());\n+    boolean isCommitted = commit(instantTime, writeStatuses, extraMetadata, actionType, Collections.emptyMap());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxODIxOA==", "bodyText": "this seems like remnant of merge conficts? can you please make a full pass and ensure no temp debugging changes/ or remnants like this are removed?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568818218", "createdAt": "2021-02-02T18:05:09Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -732,6 +746,9 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n+<<<<<<< 1e1a9a5ba5907efb5dd8cb1e0ae830aa78725dd1", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 234}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgxODMwMQ==", "bodyText": "same here", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568818301", "createdAt": "2021-02-02T18:05:18Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -750,24 +767,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Clean up all failed commits.\n+=======", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 246}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMDg0Mg==", "bodyText": "can you comment again on whether this changes the answer to my question above?\n\nI have also added a check in the merging of log blocks where if the instant is not on the active timeline, that block will be ignored\n\nThe concern I had was the part 2 where, a committed write could have been archived and we may end up skipping it. Can you please clarify again how we guard that? By ensuring the archival will wait for the cleaner to log this block?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568820842", "createdAt": "2021-02-02T18:09:02Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -707,24 +739,51 @@ public void rollbackInflightCompaction(HoodieInstant inflightInstant, HoodieTabl\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed commits.\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedCommits() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYyOTg4OA=="}, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 215}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMTg3Mg==", "bodyText": "would nt HoodieFailedWritesCleaningPolicy.NEVER also pass the check for !eager ?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568821872", "createdAt": "2021-02-02T18:10:26Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -750,24 +767,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Clean up all failed commits.\n+=======\n+   * Rollback all failed commits.\n+>>>>>>> Adding configs to make failed writes eager/lazy\n+=======\n+   * Rollback all failed writes.\n+>>>>>>> Refactored code, removed parallel writing capability\n    */\n-  private void rollbackPendingCommits() {\n+  public void rollbackFailedWrites() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = getInflightTimelineExcludeCompactionAndClustering(table);\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n       }\n     }\n   }\n \n+  private List<String> getInstantsToRollback(HoodieTable<T, I, K, O> table) {\n+    if (config.getFailedWritesCleanPolicy().isEager()) {\n+      HoodieTimeline inflightTimeline = table.getMetaClient().getCommitsTimeline().filterPendingExcludingCompaction();\n+      return inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n+          .collect(Collectors.toList());\n+    } else if (!config.getFailedWritesCleanPolicy().isEager()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 280}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyMzA3Mg==", "bodyText": "lets move this to HeartbeatUtils", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568823072", "createdAt": "2021-02-02T18:12:18Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -859,6 +901,19 @@ protected void finalizeWrite(HoodieTable<T, I, K, O> table, String instantTime,\n     }\n   }\n \n+  protected void checkHeartbeatExpired(String instantTime, HoodieTable table) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 303}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNTcxMg==", "bodyText": "will review this class again, pending this discussion here.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568825712", "createdAt": "2021-02-02T18:16:01Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,265 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.HeartbeatUtils;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODE1NzAyMQ=="}, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 46}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNjUwMg==", "bodyText": "nit: tolerable.misses", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568826502", "createdAt": "2021-02-02T18:17:12Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/config/HoodieWriteConfig.java", "diffHunk": "@@ -133,6 +134,12 @@\n   private static final String MERGE_DATA_VALIDATION_CHECK_ENABLED = \"hoodie.merge.data.validation.enabled\";\n   private static final String DEFAULT_MERGE_DATA_VALIDATION_CHECK_ENABLED = \"false\";\n \n+  public static final String CLIENT_HEARTBEAT_INTERVAL_IN_MS_PROP = \"hoodie.client.heartbeat.interval_in_ms\";\n+  public static final Integer DEFAULT_CLIENT_HEARTBEAT_INTERVAL_IN_MS = 60 * 1000;\n+\n+  public static final String CLIENT_HEARTBEAT_NUM_TOLERABLE_MISSES_PROP = \"hoodie.client.heartbeat.tolerable_misses\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 15}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNzUwMw==", "bodyText": "was wondering how these threads actually stop?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568827503", "createdAt": "2021-02-02T18:18:36Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.apache.hudi.common.util.HeartbeatUtils;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static final Logger LOG = LogManager.getLogger(TestHoodieHeartbeatClient.class);\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+  private static Long heartBeatInterval = 1000L;\n+  private static int numTolerableMisses = 1;\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartbeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    await().atMost(5, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats() > 0);\n+    Integer numHeartBeats = hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats();\n+    assertTrue(numHeartBeats == 1);\n+  }\n+\n+  @Test\n+  public void testIsHeartbeatExpired() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(hoodieHeartbeatClient.isHeartbeatExpired(instantTime1));\n+  }\n+\n+  @Test\n+  public void testNumHeartbeatsGenerated() {\n+    Long heartBeatInterval = 5000L;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(\"100\");\n+    await().atMost(5, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats() >= 1);\n+  }\n+\n+  @Test\n+  public void testDeleteWrongHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(HeartbeatUtils.deleteHeartbeatFile(metaClient.getFs(), basePath, instantTime2));\n+  }\n+\n+  @Disabled\n+  public void testConcurrentReadsAndWritesToSameFile() throws InterruptedException {\n+    Thread th1 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          OutputStream outputStream = metaClient.getFs().create(new Path(metaClient.getBasePath() + \"/test\"), true);\n+          outputStream.write(\"testing\".getBytes());\n+          outputStream.close();\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th1\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th2 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          FileStatus fs = metaClient.getFs().getFileStatus(new Path(metaClient.getBasePath() + \"/test\"));\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th2\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th3 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          String heartbeat = org.apache.commons.io.IOUtils.toString(metaClient.getFs().open(new Path(metaClient.getBasePath() + \"/test\")));\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th3\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    th1.start();\n+    Thread.sleep(100);\n+    th2.start();\n+    th3.start();\n+\n+    // To simulate the issues of race conditions when creating & reading file, simply do th1.join; th2.join; th3.join;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 143}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyNzczMA==", "bodyText": "LOG.error() and get rid of printing stack trace?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568827730", "createdAt": "2021-02-02T18:18:55Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/test/java/org/apache/hudi/client/heartbeat/TestHoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.testutils.HoodieCommonTestHarness;\n+import org.apache.hudi.common.util.HeartbeatUtils;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.junit.jupiter.api.BeforeEach;\n+import org.junit.jupiter.api.Disabled;\n+import org.junit.jupiter.api.Test;\n+\n+import java.io.IOException;\n+import java.io.OutputStream;\n+\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+import static org.awaitility.Awaitility.await;\n+import static org.junit.jupiter.api.Assertions.assertFalse;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+\n+public class TestHoodieHeartbeatClient extends HoodieCommonTestHarness {\n+\n+  private static final Logger LOG = LogManager.getLogger(TestHoodieHeartbeatClient.class);\n+\n+  private static String instantTime1 = \"100\";\n+  private static String instantTime2 = \"101\";\n+  private static Long heartBeatInterval = 1000L;\n+  private static int numTolerableMisses = 1;\n+\n+  @BeforeEach\n+  public void init() throws IOException {\n+    initMetaClient();\n+  }\n+\n+  @Test\n+  public void testStartHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    FileStatus [] fs = metaClient.getFs().listStatus(new Path(hoodieHeartbeatClient.getHeartbeatFolderPath()));\n+    assertTrue(fs.length == 1);\n+    assertTrue(fs[0].getPath().toString().contains(instantTime1));\n+  }\n+\n+  @Test\n+  public void testStopHeartbeat() {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    await().atMost(5, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats() > 0);\n+    Integer numHeartBeats = hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats();\n+    assertTrue(numHeartBeats == 1);\n+  }\n+\n+  @Test\n+  public void testIsHeartbeatExpired() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(hoodieHeartbeatClient.isHeartbeatExpired(instantTime1));\n+  }\n+\n+  @Test\n+  public void testNumHeartbeatsGenerated() {\n+    Long heartBeatInterval = 5000L;\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(\"100\");\n+    await().atMost(5, SECONDS).until(() -> hoodieHeartbeatClient.getHeartbeat(instantTime1).getNumHeartbeats() >= 1);\n+  }\n+\n+  @Test\n+  public void testDeleteWrongHeartbeat() throws IOException {\n+    HoodieHeartbeatClient hoodieHeartbeatClient =\n+        new HoodieHeartbeatClient(metaClient.getFs(), metaClient.getBasePath(), heartBeatInterval, numTolerableMisses);\n+    hoodieHeartbeatClient.start(instantTime1);\n+    hoodieHeartbeatClient.stop(instantTime1);\n+    assertFalse(HeartbeatUtils.deleteHeartbeatFile(metaClient.getFs(), basePath, instantTime2));\n+  }\n+\n+  @Disabled\n+  public void testConcurrentReadsAndWritesToSameFile() throws InterruptedException {\n+    Thread th1 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          OutputStream outputStream = metaClient.getFs().create(new Path(metaClient.getBasePath() + \"/test\"), true);\n+          outputStream.write(\"testing\".getBytes());\n+          outputStream.close();\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th1\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th2 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          FileStatus fs = metaClient.getFs().getFileStatus(new Path(metaClient.getBasePath() + \"/test\"));\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th2\");\n+        e.printStackTrace();\n+      }\n+    });\n+\n+    Thread th3 = new Thread(() -> {\n+      try {\n+        while (true) {\n+          String heartbeat = org.apache.commons.io.IOUtils.toString(metaClient.getFs().open(new Path(metaClient.getBasePath() + \"/test\")));\n+        }\n+      } catch (Exception e) {\n+        LOG.info(\"Caught Exception th3\");\n+        e.printStackTrace();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyODA4OQ==", "bodyText": "same. lets remove the temp variable", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568828089", "createdAt": "2021-02-02T18:19:33Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/client/SparkRDDWriteClient.java", "diffHunk": "@@ -105,7 +112,8 @@ public static SparkConf registerClasses(SparkConf conf) {\n   public boolean commit(String instantTime, JavaRDD<WriteStatus> writeStatuses, Option<Map<String, String>> extraMetadata,\n                         String commitActionType, Map<String, List<String>> partitionToReplacedFileIds) {\n     List<HoodieWriteStat> writeStats = writeStatuses.map(WriteStatus::getStat).collect();\n-    return commitStats(instantTime, writeStats, extraMetadata, commitActionType, partitionToReplacedFileIds);\n+    boolean isCommitted = commitStats(instantTime, writeStats, extraMetadata, commitActionType, partitionToReplacedFileIds);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyODY1Mg==", "bodyText": "is there a reason why this should be in hudi-common?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568828652", "createdAt": "2021-02-02T18:20:20Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/util/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 37}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODgyOTM3NQ==", "bodyText": "rename by dropping  the Files suffix? is there any special handling for expired vs orphaned? why not just call it cleanExpiredHearbeats", "url": "https://github.com/apache/hudi/pull/2359#discussion_r568829375", "createdAt": "2021-02-02T18:21:23Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/util/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.common.util;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats or orphaned heartbeats without any active instant.\n+   * @param existingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanUpExpiredOrOrphanHeartbeatFiles(List<String> existingHeartbeatInstants,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8"}, "originalPosition": 68}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b702eb16f9bfcba66e69036514b5b96c898074e8", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/b702eb16f9bfcba66e69036514b5b96c898074e8", "committedDate": "2021-01-20T09:08:04Z", "message": "Refactored code, removed parallel writing capability"}, "afterCommit": {"oid": "fddf048834bf3b40b70c2d128cdcc18a49cfb91f", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/fddf048834bf3b40b70c2d128cdcc18a49cfb91f", "committedDate": "2021-02-03T07:33:28Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fddf048834bf3b40b70c2d128cdcc18a49cfb91f", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/fddf048834bf3b40b70c2d128cdcc18a49cfb91f", "committedDate": "2021-02-03T07:33:28Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "0764dd5a5931f798d37914dfafef0e2aaae7c873", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/0764dd5a5931f798d37914dfafef0e2aaae7c873", "committedDate": "2021-02-06T07:50:11Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "0764dd5a5931f798d37914dfafef0e2aaae7c873", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/0764dd5a5931f798d37914dfafef0e2aaae7c873", "committedDate": "2021-02-06T07:50:11Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "87b002a1569b225b90e63f720b9c2f8277c5971c", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/87b002a1569b225b90e63f720b9c2f8277c5971c", "committedDate": "2021-02-06T08:20:07Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "87b002a1569b225b90e63f720b9c2f8277c5971c", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/87b002a1569b225b90e63f720b9c2f8277c5971c", "committedDate": "2021-02-06T08:20:07Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "6d2391d4aad1025fc31090384e473d0685f31c82", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/6d2391d4aad1025fc31090384e473d0685f31c82", "committedDate": "2021-02-08T03:36:59Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "6d2391d4aad1025fc31090384e473d0685f31c82", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/6d2391d4aad1025fc31090384e473d0685f31c82", "committedDate": "2021-02-08T03:36:59Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "4a0cc16e25ca645396daf482088a6c36925d260b", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/4a0cc16e25ca645396daf482088a6c36925d260b", "committedDate": "2021-02-08T05:04:05Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "4a0cc16e25ca645396daf482088a6c36925d260b", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/4a0cc16e25ca645396daf482088a6c36925d260b", "committedDate": "2021-02-08T05:04:05Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "a100eaf17763ac7ddf50a53f9890922c54c7312f", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/a100eaf17763ac7ddf50a53f9890922c54c7312f", "committedDate": "2021-02-12T02:12:16Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "a100eaf17763ac7ddf50a53f9890922c54c7312f", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/a100eaf17763ac7ddf50a53f9890922c54c7312f", "committedDate": "2021-02-12T02:12:16Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "37ad1ec4cf340095dbc5585a842842a3df54e328", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/37ad1ec4cf340095dbc5585a842842a3df54e328", "committedDate": "2021-02-15T03:17:19Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "37ad1ec4cf340095dbc5585a842842a3df54e328", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/37ad1ec4cf340095dbc5585a842842a3df54e328", "committedDate": "2021-02-15T03:17:19Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/fd7e2e55e94491109046f9eb14386ccb180d27c3", "committedDate": "2021-02-17T07:50:16Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyMjIzMTE1", "url": "https://github.com/apache/hudi/pull/2359#pullrequestreview-592223115", "createdAt": "2021-02-17T14:01:32Z", "commit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "state": "COMMENTED", "comments": {"totalCount": 23, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxNDowMTozM1rOIm39Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0xN1QxNjo1NTo1M1rOInA1lQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzMzU5NA==", "bodyText": "why not final ?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577633594", "createdAt": "2021-02-17T14:01:33Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieClient.java", "diffHunk": "@@ -48,6 +49,7 @@\n   protected final transient Configuration hadoopConf;\n   protected final HoodieWriteConfig config;\n   protected final String basePath;\n+  protected HoodieHeartbeatClient heartbeatClient;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzNTIzMg==", "bodyText": "+1", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577635232", "createdAt": "2021-02-17T14:03:47Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieClient.java", "diffHunk": "@@ -70,6 +72,8 @@ protected AbstractHoodieClient(HoodieEngineContext context, HoodieWriteConfig cl\n     this.config = clientConfig;\n     this.timelineServer = timelineServer;\n     shouldStopTimelineServer = !timelineServer.isPresent();\n+    this.heartbeatClient = new HoodieHeartbeatClient(this.fs, this.basePath,\n+        clientConfig.getHoodieClientHeartbeatIntervalInMs(), clientConfig.getHoodieClientHeartbeatTolerableMisses());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxNzkwMg=="}, "originalCommit": {"oid": "4718c03b3aeac528d6192fcd8cb5c3916bd08555"}, "originalPosition": 21}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzNjA4MA==", "bodyText": "I see you have a public getter. so, wondering why have it as protected here? bcoz, inherited classes could re-initialize?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577636080", "createdAt": "2021-02-17T14:04:53Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieClient.java", "diffHunk": "@@ -48,6 +49,7 @@\n   protected final transient Configuration hadoopConf;\n   protected final HoodieWriteConfig config;\n   protected final String basePath;\n+  protected HoodieHeartbeatClient heartbeatClient;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzYzMzU5NA=="}, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 12}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY0Mjg0Ng==", "bodyText": "@vinothchandar @n3nash : what's a good programming practice here or is it more of developers choice.\nHere I see two approaches\nApproach1: // what's in this patch.\nHeartbeatUtils.abortIfHeartbea.... // this will throw exception if need to be aborted.\nactiveTimeline.saveAsComplete.... // so the assumption is that if no exception is thrown, heart beat is successful sort of \nproceed further...\n\nApproach 2: // make HeartbeatUtils.abortIfHeart.... return a boolean whether abort or not.\nif(HeartbeatUtils.hasHeartBeatExpired ....)\n    // abort steps\n    // may be throw an exception here\nelse \n   activeTimeline.saveAsComplete\n   proceed further \n\n2nd approach is more explicit. do you have any good suggestions on this.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577642846", "createdAt": "2021-02-17T14:13:25Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -181,7 +171,7 @@ public boolean commitStats(String instantTime, List<HoodieWriteStat> stats, Opti\n     HoodieCommitMetadata metadata = CommitUtils.buildMetadata(stats, partitionToReplaceFileIds, extraMetadata, operationType, config.getSchema(), commitActionType);\n     // Finalize write\n     finalizeWrite(table, instantTime, stats);\n-\n+    HeartbeatUtils.abortIfHeartbeatExpired(instantTime, table, heartbeatClient, config);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY1NDk4NA==", "bodyText": "if someone has set rollbackPending = false, prior to this patch, we will not rollback and now we are rolling back right. So is that intentional ? or its a TODO to be fixed in a later patch?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577654984", "createdAt": "2021-02-17T14:28:22Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -236,17 +226,16 @@ protected void syncTableMetadata() {\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later\n     HoodieTable<T, I, K, O> table = getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    rollbackFailedBootstrap();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY3NjA5OA==", "bodyText": "why required to be public?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577676098", "createdAt": "2021-02-17T14:53:23Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -236,17 +226,16 @@ protected void syncTableMetadata() {\n    * Main API to run bootstrap to hudi.\n    */\n   public void bootstrap(Option<Map<String, String>> extraMetadata) {\n-    if (rollbackPending) {\n-      rollBackInflightBootstrap();\n-    }\n+    // TODO : MULTIWRITER -> check if failed bootstrap files can be cleaned later\n     HoodieTable<T, I, K, O> table = getTableAndInitCtx(WriteOperationType.UPSERT, HoodieTimeline.METADATA_BOOTSTRAP_INSTANT_TS);\n+    rollbackFailedBootstrap();\n     table.bootstrap(context, extraMetadata);\n   }\n \n   /**\n-   * Main API to rollback pending bootstrap.\n+   * Main API to rollback failed bootstrap.\n    */\n-  protected void rollBackInflightBootstrap() {\n+  public void rollbackFailedBootstrap() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 104}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY3ODkyMg==", "bodyText": "should we do this within finally? or is it intentional to do it here.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577678922", "createdAt": "2021-02-17T14:56:38Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -424,15 +411,15 @@ protected void postCommit(HoodieTable<T, I, K, O> table, HoodieCommitMetadata me\n       HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(config, table);\n       archiveLog.archiveIfRequired(context);\n       autoCleanOnCommit();\n-\n       syncTableMetadata();\n+      this.heartbeatClient.stop(instantTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY4NjQ1Mw==", "bodyText": "Can you confirm that when some customer moves from eager to lazy in successive launches, this should handle it. ie. lazy code path will clean any leftovers (if any), if in previous launch partial files were cleaned up eagerly, but before cleaning up fully, the process crashed.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577686453", "createdAt": "2021-02-17T15:05:12Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -598,6 +588,9 @@ public HoodieRestoreMetadata restoreToInstant(final String instantTime) throws H\n   public HoodieCleanMetadata clean(String cleanInstantTime) throws HoodieIOException {\n     LOG.info(\"Cleaner started\");\n     final Timer.Context timerContext = metrics.getCleanCtx();\n+    LOG.info(\"Cleaned failed attempts if any\");\n+    CleanerUtils.rollbackFailedWrites(config.getFailedWritesCleanPolicy(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 167}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY4ODM0OQ==", "bodyText": "not part of this patch. but just curious. Why this method(startCommit) in turn does not call into startCommitWithTime() ?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577688349", "createdAt": "2021-02-17T15:07:25Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -617,11 +610,8 @@ public HoodieCleanMetadata clean() {\n    * Provides a new commit time for a write operation (insert/update/delete).\n    */\n   public String startCommit() {\n-    // NOTE : Need to ensure that rollback is done before a new commit is started\n-    if (rollbackPending) {\n-      // Only rollback pending commit/delta-commits. Do not touch compaction commits\n-      rollbackPendingCommits();\n-    }\n+    CleanerUtils.rollbackFailedWrites(config.getFailedWritesCleanPolicy(),\n+        HoodieTimeline.COMMIT_ACTION, () -> rollbackFailedWrites());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY5MDE3NA==", "bodyText": "if we do that, we don't need to call CleanerUtils.rollbackFailedWrites at two diff places(613, 643). Guess you might have ran into some issues. Interested to understand the reasoning.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577690174", "createdAt": "2021-02-17T15:09:33Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -617,11 +610,8 @@ public HoodieCleanMetadata clean() {\n    * Provides a new commit time for a write operation (insert/update/delete).\n    */\n   public String startCommit() {\n-    // NOTE : Need to ensure that rollback is done before a new commit is started\n-    if (rollbackPending) {\n-      // Only rollback pending commit/delta-commits. Do not touch compaction commits\n-      rollbackPendingCommits();\n-    }\n+    CleanerUtils.rollbackFailedWrites(config.getFailedWritesCleanPolicy(),\n+        HoodieTimeline.COMMIT_ACTION, () -> rollbackFailedWrites());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY4ODM0OQ=="}, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 182}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY5Mjg5OQ==", "bodyText": "can we do switch case instead of multiple if else.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577692899", "createdAt": "2021-02-17T15:12:48Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -749,22 +739,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed writes.\n    */\n-  private void rollbackPendingCommits() {\n+  public Boolean rollbackFailedWrites() {\n     HoodieTable<T, I, K, O> table = createTable(config, hadoopConf);\n-    HoodieTimeline inflightTimeline = getInflightTimelineExcludeCompactionAndClustering(table);\n-    List<String> commits = inflightTimeline.getReverseOrderedInstants().map(HoodieInstant::getTimestamp)\n-        .collect(Collectors.toList());\n-    for (String commit : commits) {\n-      if (HoodieTimeline.compareTimestamps(commit, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n+    List<String> instantsToRollback = getInstantsToRollback(table);\n+    for (String instant : instantsToRollback) {\n+      if (HoodieTimeline.compareTimestamps(instant, HoodieTimeline.LESSER_THAN_OR_EQUALS,\n           HoodieTimeline.FULL_BOOTSTRAP_INSTANT_TS)) {\n-        rollBackInflightBootstrap();\n+        rollbackFailedBootstrap();\n         break;\n       } else {\n-        rollback(commit);\n+        rollback(instant);\n       }\n     }\n+    // Delete any heartbeat files for already rolled back commits\n+    try {\n+      HeartbeatUtils.cleanExpiredHeartbeats(this.heartbeatClient.getExistingHeartbeatInstantFileNames(),\n+          createMetaClient(true), basePath);\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat files\", io);\n+    }\n+    return true;\n+  }\n+\n+  private List<String> getInstantsToRollback(HoodieTable<T, I, K, O> table) {\n+    if (config.getFailedWritesCleanPolicy().isEager()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 257}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY5NzQxOQ==", "bodyText": "minor: activeHeartbeatInstants", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577697419", "createdAt": "2021-02-17T15:18:00Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats without any active instant.\n+   * @param existingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanExpiredHeartbeats(List<String> existingHeartbeatInstants,\n+                                            HoodieTableMetaClient metaClient, String basePath) {\n+    Set<String> heartbeatInstants = metaClient.getActiveTimeline()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 74}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNDc4Mg==", "bodyText": "do we make use of the return value somewhere? also, I don't see we return false anywhere. exceptions will be thrown anyways. so not sure if the return value is of much value.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577734782", "createdAt": "2021-02-17T16:01:15Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -749,22 +739,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed writes.\n    */\n-  private void rollbackPendingCommits() {\n+  public Boolean rollbackFailedWrites() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNTE4Nw==", "bodyText": "do we need to move this to finally block ?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577735187", "createdAt": "2021-02-17T16:01:47Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -912,5 +929,6 @@ public void close() {\n     // Calling this here releases any resources used by your index, so make sure to finish any related operations\n     // before this point\n     this.index.close();\n+    this.heartbeatClient.stop();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 282}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNjUxOQ==", "bodyText": "sorry, shouldn't we throw here?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577736519", "createdAt": "2021-02-17T16:03:31Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNzI3Nw==", "bodyText": "is this referring to this case.\ndeleting an already deleted or non existent heartbeatFile?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577737277", "createdAt": "2021-02-17T16:04:27Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczODA1OQ==", "bodyText": "java docs", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577738059", "createdAt": "2021-02-17T16:05:29Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats without any active instant.\n+   * @param existingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanExpiredHeartbeats(List<String> existingHeartbeatInstants,\n+                                            HoodieTableMetaClient metaClient, String basePath) {\n+    Set<String> heartbeatInstants = metaClient.getActiveTimeline()\n+        .filterCompletedInstants().getInstants().map(HoodieInstant::getTimestamp).collect(Collectors.toSet());\n+    existingHeartbeatInstants.stream().forEach(instant -> {\n+      if (!heartbeatInstants.contains(instant)) {\n+        deleteHeartbeatFile(metaClient.getFs(), basePath, instant);\n+      }\n+    });\n+  }\n+\n+  public static void abortIfHeartbeatExpired(String instantTime, HoodieTable table,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 83}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc0MDE4Ng==", "bodyText": "guess you need to move this comment to 2 lines below", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577740186", "createdAt": "2021-02-17T16:07:57Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 54}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc0MTg2Ng==", "bodyText": "minor. may be we could name \"heartBeatTimeoutInMs\". feel free to take a call.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577741866", "createdAt": "2021-02-17T16:09:51Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,284 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  private String heartbeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatIntervalInMs;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 61}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3MTk5Nw==", "bodyText": "can we revert this.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577771997", "createdAt": "2021-02-17T16:47:00Z", "author": {"login": "nsivabalan"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/table/action/clean/SparkCleanActionExecutor.java", "diffHunk": "@@ -131,4 +131,5 @@ public SparkCleanActionExecutor(HoodieSparkEngineContext context,\n           .build();\n     }).collect(Collectors.toList());\n   }\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3NjYwNQ==", "bodyText": "java docs", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577776605", "createdAt": "2021-02-17T16:52:56Z", "author": {"login": "nsivabalan"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/util/CleanerUtils.java", "diffHunk": "@@ -112,4 +114,25 @@ public static HoodieCleanerPlan getCleanerPlan(HoodieTableMetaClient metaClient,\n   public static List<HoodieCleanFileInfo> convertToHoodieCleanFileInfoList(List<CleanFileInfo> cleanFileInfoList) {\n     return cleanFileInfoList.stream().map(CleanFileInfo::toHoodieFileCleanInfo).collect(Collectors.toList());\n   }\n+\n+  public static void rollbackFailedWrites(HoodieFailedWritesCleaningPolicy cleaningPolicy, String actionType,", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3ODU3Ng==", "bodyText": "why keeping this loose. why not just do it only for COMMIT_ACTION only. I see callers only for these 2 action types. For any other action types, shouldn't we throw or leave it a no-op ?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577778576", "createdAt": "2021-02-17T16:55:16Z", "author": {"login": "nsivabalan"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/util/CleanerUtils.java", "diffHunk": "@@ -112,4 +114,25 @@ public static HoodieCleanerPlan getCleanerPlan(HoodieTableMetaClient metaClient,\n   public static List<HoodieCleanFileInfo> convertToHoodieCleanFileInfoList(List<CleanFileInfo> cleanFileInfoList) {\n     return cleanFileInfoList.stream().map(CleanFileInfo::toHoodieFileCleanInfo).collect(Collectors.toList());\n   }\n+\n+  public static void rollbackFailedWrites(HoodieFailedWritesCleaningPolicy cleaningPolicy, String actionType,\n+                                          Functions.Function0<Boolean> rollbackFailedWritesFunc) {\n+    switch (actionType) {\n+      case HoodieTimeline.CLEAN_ACTION:\n+        if (cleaningPolicy.isEager()) {\n+          // No need to do any special cleanup for failed operations during clean, compact etc\n+          return;\n+        }\n+        else if (cleaningPolicy.isLazy()) {\n+          rollbackFailedWritesFunc.apply();\n+        }\n+        break;\n+      default:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 28}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3OTA5Mw==", "bodyText": "basically, why we execute lines 131 to 135 for all action types except CLEAN_ACTION", "url": "https://github.com/apache/hudi/pull/2359#discussion_r577779093", "createdAt": "2021-02-17T16:55:53Z", "author": {"login": "nsivabalan"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/util/CleanerUtils.java", "diffHunk": "@@ -112,4 +114,25 @@ public static HoodieCleanerPlan getCleanerPlan(HoodieTableMetaClient metaClient,\n   public static List<HoodieCleanFileInfo> convertToHoodieCleanFileInfoList(List<CleanFileInfo> cleanFileInfoList) {\n     return cleanFileInfoList.stream().map(CleanFileInfo::toHoodieFileCleanInfo).collect(Collectors.toList());\n   }\n+\n+  public static void rollbackFailedWrites(HoodieFailedWritesCleaningPolicy cleaningPolicy, String actionType,\n+                                          Functions.Function0<Boolean> rollbackFailedWritesFunc) {\n+    switch (actionType) {\n+      case HoodieTimeline.CLEAN_ACTION:\n+        if (cleaningPolicy.isEager()) {\n+          // No need to do any special cleanup for failed operations during clean, compact etc\n+          return;\n+        }\n+        else if (cleaningPolicy.isLazy()) {\n+          rollbackFailedWritesFunc.apply();\n+        }\n+        break;\n+      default:", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Nzc3ODU3Ng=="}, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 28}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/fd7e2e55e94491109046f9eb14386ccb180d27c3", "committedDate": "2021-02-17T07:50:16Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "ce950df02ff5c73937236be1bb04f493727ab3f7", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/ce950df02ff5c73937236be1bb04f493727ab3f7", "committedDate": "2021-02-18T01:56:43Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ce950df02ff5c73937236be1bb04f493727ab3f7", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/ce950df02ff5c73937236be1bb04f493727ab3f7", "committedDate": "2021-02-18T01:56:43Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "ab25ff9deee0ea13df0f24a5e98f2b1c3f7271d1", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/ab25ff9deee0ea13df0f24a5e98f2b1c3f7271d1", "committedDate": "2021-02-18T02:33:22Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ab25ff9deee0ea13df0f24a5e98f2b1c3f7271d1", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/ab25ff9deee0ea13df0f24a5e98f2b1c3f7271d1", "committedDate": "2021-02-18T02:33:22Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "ff7149d58bd0f1a2f4aadf1a3c88ef44f9d48b37", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/ff7149d58bd0f1a2f4aadf1a3c88ef44f9d48b37", "committedDate": "2021-02-18T08:21:11Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/93572f23e81bb9b79284c6e84164101e0a5b942c", "committedDate": "2021-02-20T03:25:22Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "ff7149d58bd0f1a2f4aadf1a3c88ef44f9d48b37", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/ff7149d58bd0f1a2f4aadf1a3c88ef44f9d48b37", "committedDate": "2021-02-18T08:21:11Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}, "afterCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c", "author": {"user": {"login": "n3nash", "name": null}}, "url": "https://github.com/apache/hudi/commit/93572f23e81bb9b79284c6e84164101e0a5b942c", "committedDate": "2021-02-20T03:25:22Z", "message": "[HUDI-1486] Remove inline inflight rollback in hoodie writer\n1. Refactor rollback and move cleaning failed commits logic into cleaner\n2. Introduce hoodie heartbeat to ascertain failed commits\n3. Fix test cases"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NzA2NTI3", "url": "https://github.com/apache/hudi/pull/2359#pullrequestreview-594706527", "createdAt": "2021-02-20T03:41:23Z", "commit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "state": "APPROVED", "comments": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMFQwMzo0MToyM1rOIovQQw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMS0wMi0yMFQwNDowMjozNVrOIovZZA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4ODE2Mw==", "bodyText": "as long as the exception is clear, throwing runtime exceptions is actually better. (source: clean code book)", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579588163", "createdAt": "2021-02-20T03:41:23Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -181,7 +171,7 @@ public boolean commitStats(String instantTime, List<HoodieWriteStat> stats, Opti\n     HoodieCommitMetadata metadata = CommitUtils.buildMetadata(stats, partitionToReplaceFileIds, extraMetadata, operationType, config.getSchema(), commitActionType);\n     // Finalize write\n     finalizeWrite(table, instantTime, stats);\n-\n+    HeartbeatUtils.abortIfHeartbeatExpired(instantTime, table, heartbeatClient, config);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzY0Mjg0Ng=="}, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4ODg4MA==", "bodyText": "to @nsivabalan 's point. can't the return type be void and use Void for the function.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579588880", "createdAt": "2021-02-20T03:47:57Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/AbstractHoodieWriteClient.java", "diffHunk": "@@ -749,22 +739,49 @@ private HoodieTimeline getInflightTimelineExcludeCompactionAndClustering(HoodieT\n   }\n \n   /**\n-   * Cleanup all pending commits.\n+   * Rollback all failed writes.\n    */\n-  private void rollbackPendingCommits() {\n+  public Boolean rollbackFailedWrites() {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzczNDc4Mg=="}, "originalCommit": {"oid": "fd7e2e55e94491109046f9eb14386ccb180d27c3"}, "originalPosition": 227}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTI2Nw==", "bodyText": "to our discussion today, can you add a TestHeartbeatUtils in a subsequent PR?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589267", "createdAt": "2021-02-20T03:51:13Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTM5Nw==", "bodyText": "this deserves its own Exception class.", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589397", "createdAt": "2021-02-20T03:52:37Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats without any active instant.\n+   * @param allExistingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanExpiredHeartbeats(List<String> allExistingHeartbeatInstants,\n+                                            HoodieTableMetaClient metaClient, String basePath) {\n+    Set<String> nonExpiredHeartbeatInstants = metaClient.getActiveTimeline()\n+        .filterCompletedInstants().getInstants().map(HoodieInstant::getTimestamp).collect(Collectors.toSet());\n+    allExistingHeartbeatInstants.stream().forEach(instant -> {\n+      if (!nonExpiredHeartbeatInstants.contains(instant)) {\n+        deleteHeartbeatFile(metaClient.getFs(), basePath, instant);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Check if the heartbeat corresponding to instantTime has expired. If yes, abort by throwing an exception.\n+   * @param instantTime\n+   * @param table\n+   * @param heartbeatClient\n+   * @param config\n+   */\n+  public static void abortIfHeartbeatExpired(String instantTime, HoodieTable table,\n+                                             HoodieHeartbeatClient heartbeatClient, HoodieWriteConfig config) {\n+    ValidationUtils.checkArgument(heartbeatClient != null);\n+    try {\n+      if (config.getFailedWritesCleanPolicy().isLazy() && heartbeatClient.isHeartbeatExpired(instantTime)) {\n+        throw new HoodieException(\"Heartbeat for instant \" + instantTime + \" has expired, last heartbeat \"", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "originalPosition": 95}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTQyOQ==", "bodyText": "Pleas throw HoodieIOException whenever there is an IOException being rethrown", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589429", "createdAt": "2021-02-20T03:53:02Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HeartbeatUtils.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.table.HoodieTable;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Helper class to delete heartbeat for completed or failed instants with expired heartbeats.\n+ */\n+public class HeartbeatUtils {\n+\n+  private static final Logger LOG = LogManager.getLogger(HeartbeatUtils.class);\n+\n+  /**\n+   * Deletes the heartbeat file for the specified instant.\n+   * @param fs\n+   * @param basePath\n+   * @param instantTime\n+   * @return\n+   */\n+  public static boolean deleteHeartbeatFile(FileSystem fs, String basePath, String instantTime) {\n+    boolean deleted = false;\n+    try {\n+      String heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+      deleted = fs.delete(new Path(heartbeatFolderPath + File.separator + instantTime), false);\n+      if (!deleted) {\n+        LOG.error(\"Failed to delete heartbeat for instant \" + instantTime);\n+      }\n+    } catch (IOException io) {\n+      LOG.error(\"Unable to delete heartbeat for instant \" + instantTime, io);\n+    }\n+    return deleted;\n+  }\n+\n+  /**\n+   * Deletes the heartbeat files for instants with expired heartbeats without any active instant.\n+   * @param allExistingHeartbeatInstants\n+   * @param metaClient\n+   * @param basePath\n+   */\n+  public static void cleanExpiredHeartbeats(List<String> allExistingHeartbeatInstants,\n+                                            HoodieTableMetaClient metaClient, String basePath) {\n+    Set<String> nonExpiredHeartbeatInstants = metaClient.getActiveTimeline()\n+        .filterCompletedInstants().getInstants().map(HoodieInstant::getTimestamp).collect(Collectors.toSet());\n+    allExistingHeartbeatInstants.stream().forEach(instant -> {\n+      if (!nonExpiredHeartbeatInstants.contains(instant)) {\n+        deleteHeartbeatFile(metaClient.getFs(), basePath, instant);\n+      }\n+    });\n+  }\n+\n+  /**\n+   * Check if the heartbeat corresponding to instantTime has expired. If yes, abort by throwing an exception.\n+   * @param instantTime\n+   * @param table\n+   * @param heartbeatClient\n+   * @param config\n+   */\n+  public static void abortIfHeartbeatExpired(String instantTime, HoodieTable table,\n+                                             HoodieHeartbeatClient heartbeatClient, HoodieWriteConfig config) {\n+    ValidationUtils.checkArgument(heartbeatClient != null);\n+    try {\n+      if (config.getFailedWritesCleanPolicy().isLazy() && heartbeatClient.isHeartbeatExpired(instantTime)) {\n+        throw new HoodieException(\"Heartbeat for instant \" + instantTime + \" has expired, last heartbeat \"\n+            + heartbeatClient.getLastHeartbeatTime(table.getMetaClient().getFs(), config.getBasePath(), instantTime));\n+      }\n+    } catch (IOException io) {\n+      throw new HoodieException(\"Unable to read heartbeat\", io);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "originalPosition": 99}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTU2MQ==", "bodyText": "invert the condition?  and avoid the return ;", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589561", "createdAt": "2021-02-20T03:54:36Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private String heartbeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatIntervalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatIntervalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartbeatTime;\n+    private Integer numHeartbeats = 0;\n+    private Timer timer = new Timer();\n+\n+    public String getInstantTime() {\n+      return instantTime;\n+    }\n+\n+    public void setInstantTime(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    public Boolean isHeartbeatStarted() {\n+      return isHeartbeatStarted;\n+    }\n+\n+    public void setHeartbeatStarted(Boolean heartbeatStarted) {\n+      isHeartbeatStarted = heartbeatStarted;\n+    }\n+\n+    public Boolean isHeartbeatStopped() {\n+      return isHeartbeatStopped;\n+    }\n+\n+    public void setHeartbeatStopped(Boolean heartbeatStopped) {\n+      isHeartbeatStopped = heartbeatStopped;\n+    }\n+\n+    public Long getLastHeartbeatTime() {\n+      return lastHeartbeatTime;\n+    }\n+\n+    public void setLastHeartbeatTime(Long lastHeartbeatTime) {\n+      this.lastHeartbeatTime = lastHeartbeatTime;\n+    }\n+\n+    public Integer getNumHeartbeats() {\n+      return numHeartbeats;\n+    }\n+\n+    public void setNumHeartbeats(Integer numHeartbeats) {\n+      this.numHeartbeats = numHeartbeats;\n+    }\n+\n+    public Timer getTimer() {\n+      return timer;\n+    }\n+\n+    public void setTimer(Timer timer) {\n+      this.timer = timer;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Heartbeat{\"\n+              + \"instantTime='\" + instantTime + '\\''\n+              + \", isHeartbeatStarted=\" + isHeartbeatStarted\n+              + \", isHeartbeatStopped=\" + isHeartbeatStopped\n+              + \", lastHeartbeatTime=\" + lastHeartbeatTime\n+              + \", numHeartbeats=\" + numHeartbeats\n+              + \", timer=\" + timer\n+              + '}';\n+    }\n+  }\n+\n+  class HeartbeatTask extends TimerTask {\n+\n+    private final String instantTime;\n+\n+    HeartbeatTask(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+      updateHeartbeat(instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Start a new heartbeat for the specified instant. If there is already one running, this will be a NO_OP\n+   * @param instantTime\n+   */\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);\n+    ValidationUtils.checkArgument(heartbeat == null || !heartbeat.isHeartbeatStopped(), \"Cannot restart a stopped heartbeat for \" + instantTime);\n+    if (heartbeat != null && heartbeat.isHeartbeatStarted()) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "originalPosition": 169}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU4OTYzMg==", "bodyText": "shuld the Heartbeat() constructor do this?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579589632", "createdAt": "2021-02-20T03:55:12Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/client/heartbeat/HoodieHeartbeatClient.java", "diffHunk": "@@ -0,0 +1,289 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.client.heartbeat;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.util.ValidationUtils;\n+import org.apache.hudi.exception.HoodieException;\n+import org.apache.hudi.exception.HoodieHeartbeatException;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+\n+import javax.annotation.concurrent.NotThreadSafe;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.OutputStream;\n+import java.io.Serializable;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import java.util.Timer;\n+import java.util.TimerTask;\n+\n+/**\n+ * This class creates heartbeat for hudi client. This heartbeat is used to ascertain whether the running job is or not.\n+ * NOTE: Due to CPU contention on the driver/client node, the heartbeats could be delayed, hence it's important to set\n+ *       the value high enough to avoid that possibility.\n+ */\n+@NotThreadSafe\n+public class HoodieHeartbeatClient implements AutoCloseable, Serializable {\n+\n+  private static final Logger LOG = LogManager.getLogger(HoodieHeartbeatClient.class);\n+\n+  private final transient FileSystem fs;\n+  private final String basePath;\n+  // path to the heartbeat folder where all writers are updating their heartbeats\n+  private String heartbeatFolderPath;\n+  // heartbeat interval in millis\n+  private final Long heartbeatIntervalInMs;\n+  private Integer numTolerableHeartbeatMisses;\n+  private final Long maxAllowableHeartbeatIntervalInMs;\n+  private Map<String, Heartbeat> instantToHeartbeatMap;\n+\n+  public HoodieHeartbeatClient(FileSystem fs, String basePath, Long heartbeatIntervalInMs,\n+                               Integer numTolerableHeartbeatMisses) {\n+    ValidationUtils.checkArgument(heartbeatIntervalInMs >= 1000, \"Cannot set heartbeat lower than 1 second\");\n+    this.fs = fs;\n+    this.basePath = basePath;\n+    this.heartbeatFolderPath = HoodieTableMetaClient.getHeartbeatFolderPath(basePath);\n+    this.heartbeatIntervalInMs = heartbeatIntervalInMs;\n+    this.numTolerableHeartbeatMisses = numTolerableHeartbeatMisses;\n+    this.maxAllowableHeartbeatIntervalInMs = this.heartbeatIntervalInMs * this.numTolerableHeartbeatMisses;\n+    this.instantToHeartbeatMap = new HashMap<>();\n+  }\n+\n+  class Heartbeat {\n+\n+    private String instantTime;\n+    private Boolean isHeartbeatStarted = false;\n+    private Boolean isHeartbeatStopped = false;\n+    private Long lastHeartbeatTime;\n+    private Integer numHeartbeats = 0;\n+    private Timer timer = new Timer();\n+\n+    public String getInstantTime() {\n+      return instantTime;\n+    }\n+\n+    public void setInstantTime(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    public Boolean isHeartbeatStarted() {\n+      return isHeartbeatStarted;\n+    }\n+\n+    public void setHeartbeatStarted(Boolean heartbeatStarted) {\n+      isHeartbeatStarted = heartbeatStarted;\n+    }\n+\n+    public Boolean isHeartbeatStopped() {\n+      return isHeartbeatStopped;\n+    }\n+\n+    public void setHeartbeatStopped(Boolean heartbeatStopped) {\n+      isHeartbeatStopped = heartbeatStopped;\n+    }\n+\n+    public Long getLastHeartbeatTime() {\n+      return lastHeartbeatTime;\n+    }\n+\n+    public void setLastHeartbeatTime(Long lastHeartbeatTime) {\n+      this.lastHeartbeatTime = lastHeartbeatTime;\n+    }\n+\n+    public Integer getNumHeartbeats() {\n+      return numHeartbeats;\n+    }\n+\n+    public void setNumHeartbeats(Integer numHeartbeats) {\n+      this.numHeartbeats = numHeartbeats;\n+    }\n+\n+    public Timer getTimer() {\n+      return timer;\n+    }\n+\n+    public void setTimer(Timer timer) {\n+      this.timer = timer;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Heartbeat{\"\n+              + \"instantTime='\" + instantTime + '\\''\n+              + \", isHeartbeatStarted=\" + isHeartbeatStarted\n+              + \", isHeartbeatStopped=\" + isHeartbeatStopped\n+              + \", lastHeartbeatTime=\" + lastHeartbeatTime\n+              + \", numHeartbeats=\" + numHeartbeats\n+              + \", timer=\" + timer\n+              + '}';\n+    }\n+  }\n+\n+  class HeartbeatTask extends TimerTask {\n+\n+    private final String instantTime;\n+\n+    HeartbeatTask(String instantTime) {\n+      this.instantTime = instantTime;\n+    }\n+\n+    @Override\n+    public void run() {\n+      updateHeartbeat(instantTime);\n+    }\n+  }\n+\n+  /**\n+   * Start a new heartbeat for the specified instant. If there is already one running, this will be a NO_OP\n+   * @param instantTime\n+   */\n+  public void start(String instantTime) {\n+    LOG.info(\"Received request to start heartbeat for instant time \" + instantTime);\n+    Heartbeat heartbeat = instantToHeartbeatMap.get(instantTime);\n+    ValidationUtils.checkArgument(heartbeat == null || !heartbeat.isHeartbeatStopped(), \"Cannot restart a stopped heartbeat for \" + instantTime);\n+    if (heartbeat != null && heartbeat.isHeartbeatStarted()) {\n+      // heartbeat already started, NO_OP\n+      return;\n+    } else {\n+      Heartbeat newHeartbeat = new Heartbeat();\n+      newHeartbeat.setHeartbeatStarted(true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "originalPosition": 174}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU5MDI5MQ==", "bodyText": "can we add a test case for archiving with inflight instants and lazy cleaning?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579590291", "createdAt": "2021-02-20T04:00:17Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/test/java/org/apache/hudi/io/TestHoodieTimelineArchiveLog.java", "diffHunk": "@@ -408,11 +408,11 @@ public void testArchiveCommitCompactionNoHole() throws IOException {\n     HoodieTable table = HoodieSparkTable.create(cfg, context, metaClient);\n     HoodieTimelineArchiveLog archiveLog = new HoodieTimelineArchiveLog(cfg, table);\n \n-    HoodieTimeline timeline = metaClient.getActiveTimeline().getCommitsAndCompactionTimeline();\n+    HoodieTimeline timeline = metaClient.getActiveTimeline().getWriteTimeline();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU5MDM3Nw==", "bodyText": "why this change?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579590377", "createdAt": "2021-02-20T04:01:15Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTableMetaClient.java", "diffHunk": "@@ -71,10 +72,10 @@\n   private static final long serialVersionUID = 1L;\n   private static final Logger LOG = LogManager.getLogger(HoodieTableMetaClient.class);\n   public static final String METAFOLDER_NAME = \".hoodie\";\n-  public static final String TEMPFOLDER_NAME = METAFOLDER_NAME + Path.SEPARATOR + \".temp\";\n-  public static final String AUXILIARYFOLDER_NAME = METAFOLDER_NAME + Path.SEPARATOR + \".aux\";\n-  public static final String BOOTSTRAP_INDEX_ROOT_FOLDER_PATH = AUXILIARYFOLDER_NAME + Path.SEPARATOR + \".bootstrap\";\n-\n+  public static final String TEMPFOLDER_NAME = METAFOLDER_NAME + File.separator + \".temp\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTU5MDUwMA==", "bodyText": "test case for this?", "url": "https://github.com/apache/hudi/pull/2359#discussion_r579590500", "createdAt": "2021-02-20T04:02:35Z", "author": {"login": "vinothchandar"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/table/log/AbstractHoodieLogRecordScanner.java", "diffHunk": "@@ -145,6 +148,14 @@ public void scan() {\n           // hit a block with instant time greater than should be processed, stop processing further\n           break;\n         }\n+        if (r.getBlockType() != CORRUPT_BLOCK && r.getBlockType() != COMMAND_BLOCK) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "93572f23e81bb9b79284c6e84164101e0a5b942c"}, "originalPosition": 47}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4060, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}