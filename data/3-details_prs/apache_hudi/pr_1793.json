{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDQ0MzIzMDc1", "number": 1793, "title": "[HUDI-1068] Fixing deletes in global bloom", "bodyText": "What is the purpose of the pull request\n\nWhen updating partition path to an existing record in global bloom, the location is set to empty. So, this in turn results in latest file id to be picked up. But we want the same fileId where actual record is found to be tagged.\n\nBrief change log\n\nFix Global bloom to ensure HoodieRecordLocation is set in record that needs to be deleted when partition path is getting updated.\n\nVerify this pull request\n(Please pick either of the following options)\nThis change added tests and can be verified as follows:\n\nAdded tests in TestHoodieClientOnCopyOnWriteStorage to verify the change.\n\nCommitter checklist\n\n\n Has a corresponding JIRA in PR title & commit\n\n\n Commit message is descriptive of the change\n\n\n CI is green\n\n\n Necessary doc changes done or have another open PR\n\n\n For large changes, please consider breaking it into sub-tasks under an umbrella JIRA.", "createdAt": "2020-07-04T20:04:48Z", "url": "https://github.com/apache/hudi/pull/1793", "merged": true, "mergeCommit": {"oid": "21bb1b505a0a433bdbe367f7f252afdddafafc96"}, "closed": true, "closedAt": "2020-07-14T02:34:08Z", "author": {"login": "nsivabalan"}, "timelineItems": {"totalCount": 10, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcxyPSDgFqTQ0MjYzOTAyNg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABc0skxgAFqTQ0Nzc0MDEzMw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyNjM5MDI2", "url": "https://github.com/apache/hudi/pull/1793#pullrequestreview-442639026", "createdAt": "2020-07-05T01:18:23Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQwMToxODoyM1rOGs-0BQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNVQwMToxOToxOVrOGs-0GA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgxOTY1Mw==", "bodyText": "It seems that we don't need to unseal() as the sealed is false when using\n\n  \n    \n      hudi/hudi-common/src/main/java/org/apache/hudi/common/model/HoodieRecord.java\n    \n    \n        Lines 67 to 73\n      in\n      574dcf9\n    \n    \n    \n    \n\n        \n          \n            \n        \n\n        \n          \n           public HoodieRecord(HoodieKey key, T data) { \n        \n\n        \n          \n             this.key = key; \n        \n\n        \n          \n             this.data = data; \n        \n\n        \n          \n             this.currentLocation = null; \n        \n\n        \n          \n             this.newLocation = null; \n        \n\n        \n          \n             this.sealed = false;", "url": "https://github.com/apache/hudi/pull/1793#discussion_r449819653", "createdAt": "2020-07-05T01:18:23Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/HoodieGlobalBloomIndex.java", "diffHunk": "@@ -125,6 +125,9 @@ public HoodieGlobalBloomIndex(HoodieWriteConfig config) {\n           // Create an empty record to delete the record in the old partition\n           HoodieRecord<T> emptyRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,\n               new EmptyHoodieRecordPayload());\n+          emptyRecord.unseal();\n+          emptyRecord.setCurrentLocation(recordLocationHoodieKeyPair.get()._1());\n+          emptyRecord.seal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgxOTY1NQ==", "bodyText": "ditto", "url": "https://github.com/apache/hudi/pull/1793#discussion_r449819655", "createdAt": "2020-07-05T01:18:36Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/main/java/org/apache/hudi/index/simple/HoodieGlobalSimpleIndex.java", "diffHunk": "@@ -131,6 +131,9 @@ public HoodieGlobalSimpleIndex(HoodieWriteConfig config) {\n             if (config.getGlobalSimpleIndexUpdatePartitionPath() && !(inputRecord.getPartitionPath().equals(partitionPath))) {\n               // Create an empty record to delete the record in the old partition\n               HoodieRecord<T> emptyRecord = new HoodieRecord(new HoodieKey(inputRecord.getRecordKey(), partitionPath), new EmptyHoodieRecordPayload());\n+              emptyRecord.unseal();\n+              emptyRecord.setCurrentLocation(location);\n+              emptyRecord.seal();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTgxOTY3Mg==", "bodyText": "minor: @throws Exception looks redundant without further info", "url": "https://github.com/apache/hudi/pull/1793#discussion_r449819672", "createdAt": "2020-07-05T01:19:19Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,173 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition\n+   * is deleted appropriately.\n+   * @throws Exception", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 34}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQyOTk2MzU1", "url": "https://github.com/apache/hudi/pull/1793#pullrequestreview-442996355", "createdAt": "2020-07-06T11:34:37Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 5, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTozNDozN1rOGtTnoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0wNlQxMTozODoxNFrOGtTt_g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDU0NQ==", "bodyText": "lets rename this to deleteRecord", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450160545", "createdAt": "2020-07-06T11:34:37Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/HoodieGlobalBloomIndex.java", "diffHunk": "@@ -125,6 +125,9 @@ public HoodieGlobalBloomIndex(HoodieWriteConfig config) {\n           // Create an empty record to delete the record in the old partition\n           HoodieRecord<T> emptyRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDgwOQ==", "bodyText": "and taggedRecord to insert..  this makes what this block is doing clearer..", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450160809", "createdAt": "2020-07-06T11:35:13Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/HoodieGlobalBloomIndex.java", "diffHunk": "@@ -125,6 +125,9 @@ public HoodieGlobalBloomIndex(HoodieWriteConfig config) {\n           // Create an empty record to delete the record in the old partition\n           HoodieRecord<T> emptyRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MDU0NQ=="}, "originalCommit": null, "originalPosition": 2}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTI3NA==", "bodyText": "why is this relevant for this test?", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450161274", "createdAt": "2020-07-06T11:36:10Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,173 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition\n+   * is deleted appropriately.\n+   * @throws Exception\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in\n+   * old partition is deleted appropriately.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType,\n+      HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // Force using older timeline layout", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTk0NA==", "bodyText": "can. we explicitly check for duplicates?", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450161944", "createdAt": "2020-07-06T11:37:42Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,173 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition\n+   * is deleted appropriately.\n+   * @throws Exception\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in\n+   * old partition is deleted appropriately.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType,\n+      HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // Force using older timeline layout\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true).build())\n+        .withTimelineLayoutVersion(\n+            VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(),\n+        metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n \n     // Write 1 (only inserts)\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n+    // Check the entire dataset has all records still\n     String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n     for (int i = 0; i < fullPartitionPaths.length; i++) {\n       fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n+    Dataset<Row> rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    List<Pair<String, String>> actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // verify all partitionpath, record key matches\n+    assertEquals(expectedPartitionPathRecKeyPairs.size(), actualPartitionPathRecKeyPairs.size());\n+    for (Pair<String, String> entry : actualPartitionPathRecKeyPairs) {\n+      assertTrue(expectedPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    for (Pair<String, String> entry : expectedPartitionPathRecKeyPairs) {\n+      assertTrue(actualPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n+\n+    // Check the entire dataset has all records still\n+    fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n+    for (int i = 0; i < fullPartitionPaths.length; i++) {\n+      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    }\n+\n+    rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // verify all partitionpath, record key matches\n+    assertEquals(expectedPartitionPathRecKeyPairs.size(), actualPartitionPathRecKeyPairs.size());\n+    for (Pair<String, String> entry : actualPartitionPathRecKeyPairs) {\n+      assertTrue(expectedPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    for (Pair<String, String> entry : expectedPartitionPathRecKeyPairs) {\n+      assertTrue(actualPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    // Write 2 (updates)\n+    newCommitTime = \"003\";\n+    records = records.subList(5, 10);\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+      String partitionPath = rec.getPartitionPath();\n+      String newPartitionPath = null;\n+      if (partitionPath.equalsIgnoreCase(DEFAULT_FIRST_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_SECOND_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_SECOND_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_THIRD_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_THIRD_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_FIRST_PARTITION_PATH;\n+      } else {\n+        throw new IllegalStateException(\"Unknown partition path \" + rec.getPartitionPath());\n+      }\n+      recordsToUpsert.add(\n+          new HoodieRecord(new HoodieKey(rec.getRecordKey(), newPartitionPath),\n+              rec.getData()));\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(newPartitionPath, rec.getRecordKey()));\n+    }\n+\n+    writeRecords = jsc.parallelize(recordsToUpsert, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    statuses = result.collect();\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(updates1, fs);\n     // Check the entire dataset has all records still\n     fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n     for (int i = 0; i < fullPartitionPaths.length; i++) {\n       fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n+\n+    rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n+\n+    // verify all partitionpath, record key matches", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 217}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MjE3NA==", "bodyText": "and also atleast two files being present before triggering the update of the partition path", "url": "https://github.com/apache/hudi/pull/1793#discussion_r450162174", "createdAt": "2020-07-06T11:38:14Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,173 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition\n+   * is deleted appropriately.\n+   * @throws Exception\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in\n+   * old partition is deleted appropriately.\n+   * @throws Exception\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType,\n+      HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // Force using older timeline layout\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true).build())\n+        .withTimelineLayoutVersion(\n+            VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(),\n+        metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n \n     // Write 1 (only inserts)\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n+    // Check the entire dataset has all records still\n     String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n     for (int i = 0; i < fullPartitionPaths.length; i++) {\n       fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n+    Dataset<Row> rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    List<Pair<String, String>> actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // verify all partitionpath, record key matches\n+    assertEquals(expectedPartitionPathRecKeyPairs.size(), actualPartitionPathRecKeyPairs.size());\n+    for (Pair<String, String> entry : actualPartitionPathRecKeyPairs) {\n+      assertTrue(expectedPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    for (Pair<String, String> entry : expectedPartitionPathRecKeyPairs) {\n+      assertTrue(actualPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n+\n+    // Check the entire dataset has all records still\n+    fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n+    for (int i = 0; i < fullPartitionPaths.length; i++) {\n+      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    }\n+\n+    rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // verify all partitionpath, record key matches\n+    assertEquals(expectedPartitionPathRecKeyPairs.size(), actualPartitionPathRecKeyPairs.size());\n+    for (Pair<String, String> entry : actualPartitionPathRecKeyPairs) {\n+      assertTrue(expectedPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    for (Pair<String, String> entry : expectedPartitionPathRecKeyPairs) {\n+      assertTrue(actualPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    // Write 2 (updates)\n+    newCommitTime = \"003\";\n+    records = records.subList(5, 10);\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+      String partitionPath = rec.getPartitionPath();\n+      String newPartitionPath = null;\n+      if (partitionPath.equalsIgnoreCase(DEFAULT_FIRST_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_SECOND_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_SECOND_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_THIRD_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_THIRD_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_FIRST_PARTITION_PATH;\n+      } else {\n+        throw new IllegalStateException(\"Unknown partition path \" + rec.getPartitionPath());\n+      }\n+      recordsToUpsert.add(\n+          new HoodieRecord(new HoodieKey(rec.getRecordKey(), newPartitionPath),\n+              rec.getData()));\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(newPartitionPath, rec.getRecordKey()));\n+    }\n+\n+    writeRecords = jsc.parallelize(recordsToUpsert, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    statuses = result.collect();\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(updates1, fs);\n     // Check the entire dataset has all records still\n     fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n     for (int i = 0; i < fullPartitionPaths.length; i++) {\n       fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n+\n+    rows = HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+    actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n+\n+    // verify all partitionpath, record key matches", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDE2MTk0NA=="}, "originalCommit": null, "originalPosition": 217}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzODIyNjgy", "url": "https://github.com/apache/hudi/pull/1793#pullrequestreview-443822682", "createdAt": "2020-07-07T12:02:15Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2NDk5NDkx", "url": "https://github.com/apache/hudi/pull/1793#pullrequestreview-446499491", "createdAt": "2020-07-10T15:34:31Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ2ODE2NjIx", "url": "https://github.com/apache/hudi/pull/1793#pullrequestreview-446816621", "createdAt": "2020-07-11T17:21:44Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQxNzoyMTo0NFrOGwOFmw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNy0xMVQxODowMTo1M1rOGwOT1Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNTY0Mw==", "bodyText": "nit: typo insertRecord", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453215643", "createdAt": "2020-07-11T17:21:44Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/HoodieGlobalBloomIndex.java", "diffHunk": "@@ -123,11 +123,13 @@ public HoodieGlobalBloomIndex(HoodieWriteConfig config) {\n         if (config.getBloomIndexUpdatePartitionPath()\n             && !recordLocationHoodieKeyPair.get()._2.getPartitionPath().equals(hoodieRecord.getPartitionPath())) {\n           // Create an empty record to delete the record in the old partition\n-          HoodieRecord<T> emptyRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,\n+          HoodieRecord<T> deleteRecord = new HoodieRecord(recordLocationHoodieKeyPair.get()._2,\n               new EmptyHoodieRecordPayload());\n+          deleteRecord.setCurrentLocation(recordLocationHoodieKeyPair.get()._1());\n+          deleteRecord.seal();\n           // Tag the incoming record for inserting to the new partition\n-          HoodieRecord<T> taggedRecord = HoodieIndexUtils.getTaggedRecord(hoodieRecord, Option.empty());\n-          return Arrays.asList(emptyRecord, taggedRecord).iterator();\n+          HoodieRecord<T> insetRecord = HoodieIndexUtils.getTaggedRecord(hoodieRecord, Option.empty());\n+          return Arrays.asList(deleteRecord, insetRecord).iterator();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 13}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNTc0Ng==", "bodyText": "these 2 can be combined into a @ParameterizedTest with IndexType as argument", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453215746", "createdAt": "2020-07-11T17:23:11Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 79}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNjk0Mw==", "bodyText": "assertAll() works better for iterating assertions", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453216943", "createdAt": "2020-07-11T17:35:53Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 144}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNzA4NQ==", "bodyText": "result.collect() return value not used?", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453217085", "createdAt": "2020-07-11T17:38:01Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 166}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxNzg1Mg==", "bodyText": "these lines can be simplified to assertTrue(entrySet().stream().filter().count()>=1)", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453217852", "createdAt": "2020-07-11T17:45:46Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify that there are more than 1 basefiles per partition\n+    // we can't guarantee randomness in partitions where records are distributed. So, verify atleast one partition has more than 1 basefile.\n+    baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    boolean hasMoreThanOneBaseFile = false;\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      if (entry.getValue() > 1) {\n+        hasMoreThanOneBaseFile = true;\n+        break;\n+      }\n+    }\n+    assertTrue(hasMoreThanOneBaseFile, \"Atleast one partition should have more than 1 base file after 2nd batch of writes\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 185}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxODQ0OQ==", "bodyText": "can this be replaced by using a new variable for expectedPartitionPathRecKeyPairs? a bit hard to track what is contained.", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453218449", "createdAt": "2020-07-11T17:52:12Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify that there are more than 1 basefiles per partition\n+    // we can't guarantee randomness in partitions where records are distributed. So, verify atleast one partition has more than 1 basefile.\n+    baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    boolean hasMoreThanOneBaseFile = false;\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      if (entry.getValue() > 1) {\n+        hasMoreThanOneBaseFile = true;\n+        break;\n+      }\n+    }\n+    assertTrue(hasMoreThanOneBaseFile, \"Atleast one partition should have more than 1 base file after 2nd batch of writes\");\n+\n+    // Write 3 (upserts to records from batch 1 with diff partition path)\n+    newCommitTime = \"003\";\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      // remove older entry from expected partition path record key pairs\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 195}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxOTAwOQ==", "bodyText": "Looks like Set<Pair<String, String>> is better suited for expectedPartitionPathRecKeyPairs? so these can be simplified as assertEquals(expected, actual);", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453219009", "createdAt": "2020-07-11T17:58:28Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify that there are more than 1 basefiles per partition\n+    // we can't guarantee randomness in partitions where records are distributed. So, verify atleast one partition has more than 1 basefile.\n+    baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    boolean hasMoreThanOneBaseFile = false;\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      if (entry.getValue() > 1) {\n+        hasMoreThanOneBaseFile = true;\n+        break;\n+      }\n+    }\n+    assertTrue(hasMoreThanOneBaseFile, \"Atleast one partition should have more than 1 base file after 2nd batch of writes\");\n+\n+    // Write 3 (upserts to records from batch 1 with diff partition path)\n+    newCommitTime = \"003\";\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      // remove older entry from expected partition path record key pairs\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+      String partitionPath = rec.getPartitionPath();\n+      String newPartitionPath = null;\n+      if (partitionPath.equalsIgnoreCase(DEFAULT_FIRST_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_SECOND_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_SECOND_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_THIRD_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_THIRD_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_FIRST_PARTITION_PATH;\n+      } else {\n+        throw new IllegalStateException(\"Unknown partition path \" + rec.getPartitionPath());\n+      }\n+      recordsToUpsert.add(\n+          new HoodieRecord(new HoodieKey(rec.getRecordKey(), newPartitionPath),\n+              rec.getData()));\n+      // populate expected partition path and record keys\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(newPartitionPath, rec.getRecordKey()));\n+    }\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(updates1, fs);\n-    // Check the entire dataset has all records still\n-    fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n+    writeRecords = jsc.parallelize(recordsToUpsert, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    statuses = result.collect();\n+\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+  }\n+\n+  private void assertPartitionPathRecordKeys(String[] fullPartitionPaths, List<Pair<String, String>> expectedPartitionPathRecKeyPairs) {\n+    Dataset<Row> rows = getAllRows(fullPartitionPaths);\n+    List<Pair<String, String>> actualPartitionPathRecKeyPairs = getActualPartitionPathAndRecordKeys(rows);\n+    // verify all partitionpath, record key matches\n+    assertActualAndExpectedPartitionPathRecordKeyMatches(expectedPartitionPathRecKeyPairs, actualPartitionPathRecKeyPairs);\n+  }\n+\n+  private List<Pair<String, String>> getActualPartitionPathAndRecordKeys(Dataset<org.apache.spark.sql.Row> rows) {\n+    List<Pair<String, String>> actualPartitionPathRecKeyPairs = new ArrayList<>();\n+    for (Row row : rows.collectAsList()) {\n+      actualPartitionPathRecKeyPairs\n+          .add(Pair.of(row.getAs(\"_hoodie_partition_path\"), row.getAs(\"_row_key\")));\n+    }\n+    return actualPartitionPathRecKeyPairs;\n+  }\n+\n+  private Dataset<org.apache.spark.sql.Row> getAllRows(String[] fullPartitionPaths) {\n+    return HoodieClientTestUtils\n+        .read(jsc, basePath, sqlContext, fs, fullPartitionPaths);\n+  }\n+\n+  private String[] getFullPartitionPaths() {\n+    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n     for (int i = 0; i < fullPartitionPaths.length; i++) {\n       fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n+    return fullPartitionPaths;\n+  }\n+\n+  private Map<String, Integer> getBaseFileCounts(String[] fullPartitionPaths) {\n+    return HoodieClientTestUtils.getBaseFileCountForPaths(basePath, fs, fullPartitionPaths);\n+  }\n+\n+  private void assertActualAndExpectedPartitionPathRecordKeyMatches(List<Pair<String, String>> expectedPartitionPathRecKeyPairs,\n+      List<Pair<String, String>> actualPartitionPathRecKeyPairs) {\n+    // verify all partitionpath, record key matches\n+    assertEquals(expectedPartitionPathRecKeyPairs.size(), actualPartitionPathRecKeyPairs.size());\n+    for (Pair<String, String> entry : actualPartitionPathRecKeyPairs) {\n+      assertTrue(expectedPartitionPathRecKeyPairs.contains(entry));\n+    }\n+\n+    for (Pair<String, String> entry : expectedPartitionPathRecKeyPairs) {\n+      assertTrue(actualPartitionPathRecKeyPairs.contains(entry));\n+    }", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 272}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzIxOTI4NQ==", "bodyText": "to align with junit assertions, can we make the expected variable 1st argument?", "url": "https://github.com/apache/hudi/pull/1793#discussion_r453219285", "createdAt": "2020-07-11T18:01:53Z", "author": {"login": "xushiyan"}, "path": "hudi-client/src/test/java/org/apache/hudi/client/TestHoodieClientOnCopyOnWriteStorage.java", "diffHunk": "@@ -399,56 +405,190 @@ public void testDeletes() throws Exception {\n   }\n \n   /**\n-   * Test update of a record to different partition with Global Index.\n+   * Tests when update partition path is set in global bloom, existing record in old partition is deleted appropriately.\n    */\n   @Test\n-  public void testUpsertToDiffPartitionGlobalIndex() throws Exception {\n-    HoodieWriteClient client = getHoodieWriteClient(getConfig(IndexType.GLOBAL_BLOOM), false);\n-    /**\n-     * Write 1 (inserts and deletes) Write actual 200 insert records and ignore 100 delete records\n-     */\n-    String newCommitTime = \"001\";\n-    List<HoodieRecord> inserts1 = dataGen.generateInserts(newCommitTime, 100);\n+  public void testUpsertsUpdatePartitionPathRegularGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_BLOOM, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n \n-    // Write 1 (only inserts)\n+  /**\n+   * Tests when update partition path is set in simple global bloom, existing record in old partition is deleted appropriately.\n+   */\n+  @Test\n+  public void testUpsertsUpdatePartitionPathSimpleGlobalBloom() throws Exception {\n+    testUpsertsUpdatePartitionPathGlobalBloom(IndexType.GLOBAL_SIMPLE, getConfig(),\n+        HoodieWriteClient::upsert);\n+  }\n+\n+  /**\n+   * This test ensures in a global bloom when update partition path is set to true in config, if an incoming record has mismatched partition\n+   * compared to whats in storage, then appropriate actions are taken. i.e. old record is deleted in old partition and new one is inserted\n+   * in the new partition.\n+   * test structure:\n+   * 1. insert 1 batch\n+   * 2. insert 2nd batch with larger no of records so that a new file group is created for partitions\n+   * 3. issue upserts to records from batch 1 with different partition path. This should ensure records from batch 1 are deleted and new\n+   * records are upserted to the new partition\n+   *\n+   * @param indexType index type to be tested for\n+   * @param config instance of {@link HoodieWriteConfig} to use\n+   * @param writeFn write function to be used for testing\n+   */\n+  private void testUpsertsUpdatePartitionPathGlobalBloom(IndexType indexType, HoodieWriteConfig config,\n+      Function3<JavaRDD<WriteStatus>, HoodieWriteClient, JavaRDD<HoodieRecord>, String> writeFn)\n+      throws Exception {\n+    // instantiate client\n+\n+    HoodieWriteConfig hoodieWriteConfig = getConfigBuilder()\n+        .withProps(config.getProps())\n+        .withCompactionConfig(\n+            HoodieCompactionConfig.newBuilder().compactionSmallFileSize(10000).build())\n+        .withIndexConfig(HoodieIndexConfig.newBuilder().withIndexType(indexType)\n+            .withBloomIndexUpdatePartitionPath(true)\n+            .withGlobalSimpleIndexUpdatePartitionPath(true)\n+            .build()).withTimelineLayoutVersion(VERSION_0).build();\n+    HoodieTableMetaClient.initTableType(metaClient.getHadoopConf(), metaClient.getBasePath(), metaClient.getTableType(),\n+        metaClient.getTableConfig().getTableName(), metaClient.getArchivePath(),\n+        metaClient.getTableConfig().getPayloadClass(), VERSION_0);\n+    HoodieWriteClient client = getHoodieWriteClient(hoodieWriteConfig, false);\n+\n+    // Write 1\n+    String newCommitTime = \"001\";\n+    int numRecords = 10;\n     client.startCommitWithTime(newCommitTime);\n-    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(inserts1, 1);\n \n-    JavaRDD<WriteStatus> result = client.insert(writeRecords, newCommitTime);\n+    List<HoodieRecord> records = dataGen.generateInserts(newCommitTime, numRecords);\n+    List<Pair<String, String>> expectedPartitionPathRecKeyPairs = new ArrayList<>();\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : records) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    JavaRDD<HoodieRecord> writeRecords = jsc.parallelize(records, 1);\n+    JavaRDD<WriteStatus> result = writeFn.apply(client, writeRecords, newCommitTime);\n     List<WriteStatus> statuses = result.collect();\n-    assertNoWriteErrors(statuses);\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(inserts1, fs);\n-    String[] fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n-    for (int i = 0; i < fullPartitionPaths.length; i++) {\n-      fullPartitionPaths[i] = String.format(\"%s/%s/*\", basePath, dataGen.getPartitionPaths()[i]);\n+    // Check the entire dataset has all records\n+    String[] fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify one basefile per partition\n+    Map<String, Integer> baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      assertEquals(1, entry.getValue());\n     }\n-    assertEquals(100, HoodieClientTestUtils.read(jsc, basePath, sqlContext, fs, fullPartitionPaths).count(),\n-        \"Must contain 100 records\");\n \n-    /**\n-     * Write 2. Updates with different partition\n-     */\n-    newCommitTime = \"004\";\n+    // Write 2\n+    newCommitTime = \"002\";\n+    numRecords = 20; // so that a new file id is created\n     client.startCommitWithTime(newCommitTime);\n \n-    List<HoodieRecord> updates1 = dataGen.generateUpdatesWithDiffPartition(newCommitTime, inserts1);\n-    JavaRDD<HoodieRecord> updateRecords = jsc.parallelize(updates1, 1);\n+    List<HoodieRecord> recordsSecondBatch = dataGen.generateInserts(newCommitTime, numRecords);\n+    // populate expected partition path and record keys\n+    for (HoodieRecord rec : recordsSecondBatch) {\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+    }\n+    writeRecords = jsc.parallelize(recordsSecondBatch, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    result.collect();\n \n-    JavaRDD<WriteStatus> result1 = client.upsert(updateRecords, newCommitTime);\n-    List<WriteStatus> statuses1 = result1.collect();\n-    assertNoWriteErrors(statuses1);\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+\n+    // verify that there are more than 1 basefiles per partition\n+    // we can't guarantee randomness in partitions where records are distributed. So, verify atleast one partition has more than 1 basefile.\n+    baseFileCounts = getBaseFileCounts(fullPartitionPaths);\n+    boolean hasMoreThanOneBaseFile = false;\n+    for (Map.Entry<String, Integer> entry : baseFileCounts.entrySet()) {\n+      if (entry.getValue() > 1) {\n+        hasMoreThanOneBaseFile = true;\n+        break;\n+      }\n+    }\n+    assertTrue(hasMoreThanOneBaseFile, \"Atleast one partition should have more than 1 base file after 2nd batch of writes\");\n+\n+    // Write 3 (upserts to records from batch 1 with diff partition path)\n+    newCommitTime = \"003\";\n+\n+    // update to diff partition paths\n+    List<HoodieRecord> recordsToUpsert = new ArrayList<>();\n+    for (HoodieRecord rec : records) {\n+      // remove older entry from expected partition path record key pairs\n+      expectedPartitionPathRecKeyPairs\n+          .remove(Pair.of(rec.getPartitionPath(), rec.getRecordKey()));\n+      String partitionPath = rec.getPartitionPath();\n+      String newPartitionPath = null;\n+      if (partitionPath.equalsIgnoreCase(DEFAULT_FIRST_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_SECOND_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_SECOND_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_THIRD_PARTITION_PATH;\n+      } else if (partitionPath.equalsIgnoreCase(DEFAULT_THIRD_PARTITION_PATH)) {\n+        newPartitionPath = DEFAULT_FIRST_PARTITION_PATH;\n+      } else {\n+        throw new IllegalStateException(\"Unknown partition path \" + rec.getPartitionPath());\n+      }\n+      recordsToUpsert.add(\n+          new HoodieRecord(new HoodieKey(rec.getRecordKey(), newPartitionPath),\n+              rec.getData()));\n+      // populate expected partition path and record keys\n+      expectedPartitionPathRecKeyPairs.add(Pair.of(newPartitionPath, rec.getRecordKey()));\n+    }\n \n-    // check the partition metadata is written out\n-    assertPartitionMetadataForRecords(updates1, fs);\n-    // Check the entire dataset has all records still\n-    fullPartitionPaths = new String[dataGen.getPartitionPaths().length];\n+    writeRecords = jsc.parallelize(recordsToUpsert, 1);\n+    result = writeFn.apply(client, writeRecords, newCommitTime);\n+    statuses = result.collect();\n+\n+    // Check the entire dataset has all records\n+    fullPartitionPaths = getFullPartitionPaths();\n+    assertPartitionPathRecordKeys(fullPartitionPaths, expectedPartitionPathRecKeyPairs);\n+  }\n+\n+  private void assertPartitionPathRecordKeys(String[] fullPartitionPaths, List<Pair<String, String>> expectedPartitionPathRecKeyPairs) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 227}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestCommit", "commit": {"oid": "95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc", "committedDate": "2020-07-13T17:52:20Z", "message": "Fixing deletes in global bloom"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc", "committedDate": "2020-07-13T17:52:20Z", "message": "Fixing deletes in global bloom"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ3NzQwMTMz", "url": "https://github.com/apache/hudi/pull/1793#pullrequestreview-447740133", "createdAt": "2020-07-14T02:26:08Z", "commit": {"oid": "95b70dbb32d1b17e9327fb2c5c5dfc35260a93fc"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 2905, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}