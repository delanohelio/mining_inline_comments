{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMjYxNTI0", "number": 1576, "reviewThreads": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToxODoxOFrOD4Fu7g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNzowNDoxMVrOD4bG-g==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTQwNzgyOnYy", "diffSide": "RIGHT", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToxODoxOFrOGOuIvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxNDo0NVrOGO03tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4OTE1MA==", "bodyText": "Collections.emptyList()?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418089150", "createdAt": "2020-04-30T15:18:18Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTQ3Nw==", "bodyText": "Done", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199477", "createdAt": "2020-04-30T18:14:45Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4OTE1MA=="}, "originalCommit": null, "originalPosition": 8}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTQxMzc0OnYy", "diffSide": "RIGHT", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToxOTo0NFrOGOuMhg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxNDo0M1rOGO03og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDExOA==", "bodyText": "can we break this method up into two, based on the policy? it feels very overloaded now..", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418090118", "createdAt": "2020-04-30T15:19:44Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTQ1OA==", "bodyText": "Done", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199458", "createdAt": "2020-04-30T18:14:43Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDExOA=="}, "originalCommit": null, "originalPosition": 6}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwMTQxNTc0OnYy", "diffSide": "RIGHT", "path": "hudi-client/src/test/java/org/apache/hudi/table/TestCleaner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToyMDowOFrOGOuNqw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxNDozNFrOGO03Og==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDQxMQ==", "bodyText": "do we have enough tests that now test when a valid cleaner plan?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418090411", "createdAt": "2020-04-30T15:20:08Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/test/java/org/apache/hudi/table/TestCleaner.java", "diffHunk": "@@ -128,10 +128,8 @@ private void insertFirstBigBatchForClientCleanerTest(HoodieWriteConfig cfg, Hood\n \n     assertFalse(table.getCompletedCommitsTimeline().empty());\n     String instantTime = table.getCompletedCommitsTimeline().getInstants().findFirst().get().getTimestamp();\n+    // We no longer write empty cleaner plans when there are not enough commits present", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTM1NA==", "bodyText": "Yes, this particular check is when inserting first batch of data. There are other checks present which validates the effect of valid clean operations", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199354", "createdAt": "2020-04-30T18:14:34Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/test/java/org/apache/hudi/table/TestCleaner.java", "diffHunk": "@@ -128,10 +128,8 @@ private void insertFirstBigBatchForClientCleanerTest(HoodieWriteConfig cfg, Hood\n \n     assertFalse(table.getCompletedCommitsTimeline().empty());\n     String instantTime = table.getCompletedCommitsTimeline().getInstants().findFirst().get().getTimestamp();\n+    // We no longer write empty cleaner plans when there are not enough commits present", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDQxMQ=="}, "originalCommit": null, "originalPosition": 4}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDg5MjQ2OnYy", "diffSide": "RIGHT", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjo1ODoxMFrOGPPSoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowMTo1NFrOGPeJSA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjM1Mw==", "bodyText": "move to separate lines?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418632353", "createdAt": "2020-05-01T16:58:10Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTcyMA==", "bodyText": "done", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418875720", "createdAt": "2020-05-02T04:01:54Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjM1Mw=="}, "originalCommit": null, "originalPosition": 25}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDg5NDkzOnYy", "diffSide": "RIGHT", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjo1OTowMVrOGPPUKg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowMToyOVrOGPeIqA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjc0Ng==", "bodyText": "we don't need the second check anymore , due to the switch above?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418632746", "createdAt": "2020-05-01T16:59:01Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTU2MA==", "bodyText": "Fixed", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418875560", "createdAt": "2020-05-02T04:01:29Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjc0Ng=="}, "originalCommit": null, "originalPosition": 38}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDkwNzA2OnYy", "diffSide": "RIGHT", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNzowMzoxNlrOGPPb3g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowMTo0N1rOGPeJGg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNDcxOA==", "bodyText": "rename: getPartitionPathsForIncrementalCleaning() ?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418634718", "createdAt": "2020-05-01T17:03:16Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return Collections.emptyList();\n+    }\n+\n+    if (config.incrementalCleanerModeEnabled()) {\n+      Option<HoodieInstant> lastClean = hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n       if (lastClean.isPresent()) {\n         HoodieCleanMetadata cleanMetadata = TimelineMetadataUtils\n             .deserializeHoodieCleanMetadata(hoodieTable.getActiveTimeline().getInstantDetails(lastClean.get()).get());\n         if ((cleanMetadata.getEarliestCommitToRetain() != null)\n             && (cleanMetadata.getEarliestCommitToRetain().length() > 0)) {\n-          LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n-              + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n-              + \". New Instant to retain : \" + newInstantToRetain);\n-          return hoodieTable.getCompletedCommitsTimeline().getInstants()\n-              .filter(instant ->\n-                  HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS, cleanMetadata.getEarliestCommitToRetain())\n-                  && HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())\n-              ).flatMap(instant -> {\n-                try {\n-                  HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(), HoodieCommitMetadata.class);\n-                  return commitMetadata.getPartitionToWriteStats().keySet().stream();\n-                } catch (IOException e) {\n-                  throw new HoodieIOException(e.getMessage(), e);\n-                }\n-              }).distinct().collect(Collectors.toList());\n+          return getPartitionPathsForCleaningUsingIncrementalMode(cleanMetadata, instantToRetain);\n         }\n       }\n     }\n-    // Otherwise go to brute force mode of scanning all partitions\n-    return FSUtils.getAllPartitionPaths(hoodieTable.getMetaClient().getFs(),\n-        hoodieTable.getMetaClient().getBasePath(), config.shouldAssumeDatePartitioning());\n+    return scanAllPartitionsForCleaning();\n+  }\n+\n+  /**\n+   * Use Incremental Mode for finding partition paths.\n+   * @param cleanMetadata\n+   * @param newInstantToRetain\n+   * @return\n+   */\n+  private List<String> getPartitionPathsForCleaningUsingIncrementalMode(HoodieCleanMetadata cleanMetadata,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTY3NA==", "bodyText": "done", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418875674", "createdAt": "2020-05-02T04:01:47Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return Collections.emptyList();\n+    }\n+\n+    if (config.incrementalCleanerModeEnabled()) {\n+      Option<HoodieInstant> lastClean = hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n       if (lastClean.isPresent()) {\n         HoodieCleanMetadata cleanMetadata = TimelineMetadataUtils\n             .deserializeHoodieCleanMetadata(hoodieTable.getActiveTimeline().getInstantDetails(lastClean.get()).get());\n         if ((cleanMetadata.getEarliestCommitToRetain() != null)\n             && (cleanMetadata.getEarliestCommitToRetain().length() > 0)) {\n-          LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n-              + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n-              + \". New Instant to retain : \" + newInstantToRetain);\n-          return hoodieTable.getCompletedCommitsTimeline().getInstants()\n-              .filter(instant ->\n-                  HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS, cleanMetadata.getEarliestCommitToRetain())\n-                  && HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())\n-              ).flatMap(instant -> {\n-                try {\n-                  HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(), HoodieCommitMetadata.class);\n-                  return commitMetadata.getPartitionToWriteStats().keySet().stream();\n-                } catch (IOException e) {\n-                  throw new HoodieIOException(e.getMessage(), e);\n-                }\n-              }).distinct().collect(Collectors.toList());\n+          return getPartitionPathsForCleaningUsingIncrementalMode(cleanMetadata, instantToRetain);\n         }\n       }\n     }\n-    // Otherwise go to brute force mode of scanning all partitions\n-    return FSUtils.getAllPartitionPaths(hoodieTable.getMetaClient().getFs(),\n-        hoodieTable.getMetaClient().getBasePath(), config.shouldAssumeDatePartitioning());\n+    return scanAllPartitionsForCleaning();\n+  }\n+\n+  /**\n+   * Use Incremental Mode for finding partition paths.\n+   * @param cleanMetadata\n+   * @param newInstantToRetain\n+   * @return\n+   */\n+  private List<String> getPartitionPathsForCleaningUsingIncrementalMode(HoodieCleanMetadata cleanMetadata,", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNDcxOA=="}, "originalCommit": null, "originalPosition": 81}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjYwNDkxMDAyOnYy", "diffSide": "RIGHT", "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNzowNDoxMVrOGPPdmA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMlQwNDowMTozOFrOGPeI3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNTE2MA==", "bodyText": "rename: getPartitionPathsForFullCleaning()", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418635160", "createdAt": "2020-05-01T17:04:11Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return Collections.emptyList();\n+    }\n+\n+    if (config.incrementalCleanerModeEnabled()) {\n+      Option<HoodieInstant> lastClean = hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n       if (lastClean.isPresent()) {\n         HoodieCleanMetadata cleanMetadata = TimelineMetadataUtils\n             .deserializeHoodieCleanMetadata(hoodieTable.getActiveTimeline().getInstantDetails(lastClean.get()).get());\n         if ((cleanMetadata.getEarliestCommitToRetain() != null)\n             && (cleanMetadata.getEarliestCommitToRetain().length() > 0)) {\n-          LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n-              + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n-              + \". New Instant to retain : \" + newInstantToRetain);\n-          return hoodieTable.getCompletedCommitsTimeline().getInstants()\n-              .filter(instant ->\n-                  HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS, cleanMetadata.getEarliestCommitToRetain())\n-                  && HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())\n-              ).flatMap(instant -> {\n-                try {\n-                  HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(), HoodieCommitMetadata.class);\n-                  return commitMetadata.getPartitionToWriteStats().keySet().stream();\n-                } catch (IOException e) {\n-                  throw new HoodieIOException(e.getMessage(), e);\n-                }\n-              }).distinct().collect(Collectors.toList());\n+          return getPartitionPathsForCleaningUsingIncrementalMode(cleanMetadata, instantToRetain);\n         }\n       }\n     }\n-    // Otherwise go to brute force mode of scanning all partitions\n-    return FSUtils.getAllPartitionPaths(hoodieTable.getMetaClient().getFs(),\n-        hoodieTable.getMetaClient().getBasePath(), config.shouldAssumeDatePartitioning());\n+    return scanAllPartitionsForCleaning();\n+  }\n+\n+  /**\n+   * Use Incremental Mode for finding partition paths.\n+   * @param cleanMetadata\n+   * @param newInstantToRetain\n+   * @return\n+   */\n+  private List<String> getPartitionPathsForCleaningUsingIncrementalMode(HoodieCleanMetadata cleanMetadata,\n+      Option<HoodieInstant> newInstantToRetain) {\n+    LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n+        + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n+        + \". New Instant to retain : \" + newInstantToRetain);\n+    return hoodieTable.getCompletedCommitsTimeline().getInstants().filter(\n+        instant -> HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS,\n+            cleanMetadata.getEarliestCommitToRetain()) && HoodieTimeline.compareTimestamps(instant.getTimestamp(),\n+            HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())).flatMap(instant -> {\n+              try {\n+                HoodieCommitMetadata commitMetadata = HoodieCommitMetadata\n+                    .fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(),\n+                        HoodieCommitMetadata.class);\n+                return commitMetadata.getPartitionToWriteStats().keySet().stream();\n+              } catch (IOException e) {\n+                throw new HoodieIOException(e.getMessage(), e);\n+              }\n+            }).distinct().collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Scan and list all paritions for cleaning.\n+   * @return all partitions paths for the dataset.\n+   * @throws IOException\n+   */\n+  private List<String> scanAllPartitionsForCleaning() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 106}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODg3NTYxMw==", "bodyText": "Done", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418875613", "createdAt": "2020-05-02T04:01:38Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return Collections.emptyList();\n+    }\n+\n+    if (config.incrementalCleanerModeEnabled()) {\n+      Option<HoodieInstant> lastClean = hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n       if (lastClean.isPresent()) {\n         HoodieCleanMetadata cleanMetadata = TimelineMetadataUtils\n             .deserializeHoodieCleanMetadata(hoodieTable.getActiveTimeline().getInstantDetails(lastClean.get()).get());\n         if ((cleanMetadata.getEarliestCommitToRetain() != null)\n             && (cleanMetadata.getEarliestCommitToRetain().length() > 0)) {\n-          LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n-              + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n-              + \". New Instant to retain : \" + newInstantToRetain);\n-          return hoodieTable.getCompletedCommitsTimeline().getInstants()\n-              .filter(instant ->\n-                  HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS, cleanMetadata.getEarliestCommitToRetain())\n-                  && HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())\n-              ).flatMap(instant -> {\n-                try {\n-                  HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(), HoodieCommitMetadata.class);\n-                  return commitMetadata.getPartitionToWriteStats().keySet().stream();\n-                } catch (IOException e) {\n-                  throw new HoodieIOException(e.getMessage(), e);\n-                }\n-              }).distinct().collect(Collectors.toList());\n+          return getPartitionPathsForCleaningUsingIncrementalMode(cleanMetadata, instantToRetain);\n         }\n       }\n     }\n-    // Otherwise go to brute force mode of scanning all partitions\n-    return FSUtils.getAllPartitionPaths(hoodieTable.getMetaClient().getFs(),\n-        hoodieTable.getMetaClient().getBasePath(), config.shouldAssumeDatePartitioning());\n+    return scanAllPartitionsForCleaning();\n+  }\n+\n+  /**\n+   * Use Incremental Mode for finding partition paths.\n+   * @param cleanMetadata\n+   * @param newInstantToRetain\n+   * @return\n+   */\n+  private List<String> getPartitionPathsForCleaningUsingIncrementalMode(HoodieCleanMetadata cleanMetadata,\n+      Option<HoodieInstant> newInstantToRetain) {\n+    LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n+        + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n+        + \". New Instant to retain : \" + newInstantToRetain);\n+    return hoodieTable.getCompletedCommitsTimeline().getInstants().filter(\n+        instant -> HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS,\n+            cleanMetadata.getEarliestCommitToRetain()) && HoodieTimeline.compareTimestamps(instant.getTimestamp(),\n+            HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())).flatMap(instant -> {\n+              try {\n+                HoodieCommitMetadata commitMetadata = HoodieCommitMetadata\n+                    .fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(),\n+                        HoodieCommitMetadata.class);\n+                return commitMetadata.getPartitionToWriteStats().keySet().stream();\n+              } catch (IOException e) {\n+                throw new HoodieIOException(e.getMessage(), e);\n+              }\n+            }).distinct().collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Scan and list all paritions for cleaning.\n+   * @return all partitions paths for the dataset.\n+   * @throws IOException\n+   */\n+  private List<String> scanAllPartitionsForCleaning() throws IOException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNTE2MA=="}, "originalCommit": null, "originalPosition": 106}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4603, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}