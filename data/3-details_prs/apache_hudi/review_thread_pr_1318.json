{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzczMjkyNjQ5", "number": 1318, "reviewThreads": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODozMzoxMVrODfSaRA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODozMzoxMVrODfSaRA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjM0MTM0MDg0OnYy", "diffSide": "RIGHT", "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/CommitsCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxODozMzoxMVrOFo54mA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0xMlQxOTo0MToxOFrOFo8E7w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQzNTczNg==", "bodyText": "Do we add names in snake_case in other header commands ?", "url": "https://github.com/apache/hudi/pull/1318#discussion_r378435736", "createdAt": "2020-02-12T18:33:11Z", "author": {"login": "n3nash"}, "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/CommitsCommand.java", "diffHunk": "@@ -100,8 +100,58 @@ private String printCommits(HoodieDefaultTimeline timeline,\n     return HoodiePrintHelper.print(header, fieldNameToConverterMap, sortByField, descending, limit, headerOnly, rows);\n   }\n \n+  private String printCommitsWithMetadata(HoodieDefaultTimeline timeline,\n+                              final Integer limit, final String sortByField,\n+                              final boolean descending,\n+                              final boolean headerOnly) throws IOException {\n+    final List<Comparable[]> rows = new ArrayList<>();\n+\n+    final List<HoodieInstant> commits = timeline.getCommitsTimeline().filterCompletedInstants()\n+            .getInstants().collect(Collectors.toList());\n+    // timeline can be read from multiple files. So sort is needed instead of reversing the collection\n+    Collections.sort(commits, HoodieInstant.COMPARATOR.reversed());\n+\n+    for (int i = 0; i < commits.size(); i++) {\n+      final HoodieInstant commit = commits.get(i);\n+      final HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(\n+              timeline.getInstantDetails(commit).get(),\n+              HoodieCommitMetadata.class);\n+\n+      for (Map.Entry<String, List<HoodieWriteStat>> partitionWriteStat :\n+              commitMetadata.getPartitionToWriteStats().entrySet()) {\n+        for (HoodieWriteStat hoodieWriteStat : partitionWriteStat.getValue()) {\n+          rows.add(new Comparable[]{ commit.getAction(), commit.getTimestamp(), hoodieWriteStat.getPartitionPath(),\n+                  hoodieWriteStat.getFileId(), hoodieWriteStat.getPrevCommit(), hoodieWriteStat.getNumWrites(),\n+                  hoodieWriteStat.getNumInserts(), hoodieWriteStat.getNumDeletes(),\n+                  hoodieWriteStat.getNumUpdateWrites(), hoodieWriteStat.getTotalWriteErrors(),\n+                  hoodieWriteStat.getTotalLogBlocks(), hoodieWriteStat.getTotalCorruptLogBlock(),\n+                  hoodieWriteStat.getTotalRollbackBlocks(), hoodieWriteStat.getTotalLogRecords(),\n+                  hoodieWriteStat.getTotalUpdatedRecordsCompacted(), hoodieWriteStat.getTotalWriteBytes()\n+          });\n+        }\n+      }\n+    }\n+\n+    final Map<String, Function<Object, String>> fieldNameToConverterMap = new HashMap<>();\n+    fieldNameToConverterMap.put(\"Total Bytes Written\", entry -> {\n+      return NumericUtils.humanReadableByteCount((Double.valueOf(entry.toString())));\n+    });\n+\n+    TableHeader header = new TableHeader().addTableHeaderField(\"action\").addTableHeaderField(\"instant\")\n+            .addTableHeaderField(\"partition\").addTableHeaderField(\"file_id\").addTableHeaderField(\"prev_instant\")\n+            .addTableHeaderField(\"num_writes\").addTableHeaderField(\"num_inserts\").addTableHeaderField(\"num_deletes\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQ3MTY2Mw==", "bodyText": "Good point. converted to camel case to be consistent", "url": "https://github.com/apache/hudi/pull/1318#discussion_r378471663", "createdAt": "2020-02-12T19:41:18Z", "author": {"login": "satishkotha"}, "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/CommitsCommand.java", "diffHunk": "@@ -100,8 +100,58 @@ private String printCommits(HoodieDefaultTimeline timeline,\n     return HoodiePrintHelper.print(header, fieldNameToConverterMap, sortByField, descending, limit, headerOnly, rows);\n   }\n \n+  private String printCommitsWithMetadata(HoodieDefaultTimeline timeline,\n+                              final Integer limit, final String sortByField,\n+                              final boolean descending,\n+                              final boolean headerOnly) throws IOException {\n+    final List<Comparable[]> rows = new ArrayList<>();\n+\n+    final List<HoodieInstant> commits = timeline.getCommitsTimeline().filterCompletedInstants()\n+            .getInstants().collect(Collectors.toList());\n+    // timeline can be read from multiple files. So sort is needed instead of reversing the collection\n+    Collections.sort(commits, HoodieInstant.COMPARATOR.reversed());\n+\n+    for (int i = 0; i < commits.size(); i++) {\n+      final HoodieInstant commit = commits.get(i);\n+      final HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(\n+              timeline.getInstantDetails(commit).get(),\n+              HoodieCommitMetadata.class);\n+\n+      for (Map.Entry<String, List<HoodieWriteStat>> partitionWriteStat :\n+              commitMetadata.getPartitionToWriteStats().entrySet()) {\n+        for (HoodieWriteStat hoodieWriteStat : partitionWriteStat.getValue()) {\n+          rows.add(new Comparable[]{ commit.getAction(), commit.getTimestamp(), hoodieWriteStat.getPartitionPath(),\n+                  hoodieWriteStat.getFileId(), hoodieWriteStat.getPrevCommit(), hoodieWriteStat.getNumWrites(),\n+                  hoodieWriteStat.getNumInserts(), hoodieWriteStat.getNumDeletes(),\n+                  hoodieWriteStat.getNumUpdateWrites(), hoodieWriteStat.getTotalWriteErrors(),\n+                  hoodieWriteStat.getTotalLogBlocks(), hoodieWriteStat.getTotalCorruptLogBlock(),\n+                  hoodieWriteStat.getTotalRollbackBlocks(), hoodieWriteStat.getTotalLogRecords(),\n+                  hoodieWriteStat.getTotalUpdatedRecordsCompacted(), hoodieWriteStat.getTotalWriteBytes()\n+          });\n+        }\n+      }\n+    }\n+\n+    final Map<String, Function<Object, String>> fieldNameToConverterMap = new HashMap<>();\n+    fieldNameToConverterMap.put(\"Total Bytes Written\", entry -> {\n+      return NumericUtils.humanReadableByteCount((Double.valueOf(entry.toString())));\n+    });\n+\n+    TableHeader header = new TableHeader().addTableHeaderField(\"action\").addTableHeaderField(\"instant\")\n+            .addTableHeaderField(\"partition\").addTableHeaderField(\"file_id\").addTableHeaderField(\"prev_instant\")\n+            .addTableHeaderField(\"num_writes\").addTableHeaderField(\"num_inserts\").addTableHeaderField(\"num_deletes\")", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODQzNTczNg=="}, "originalCommit": null, "originalPosition": 43}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4821, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}