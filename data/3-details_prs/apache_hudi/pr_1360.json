{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzgwNjI5NjY2", "number": 1360, "title": "[HUDI-344][RFC-09] Hudi Dataset Snapshot Exporter", "bodyText": "What is the purpose of the pull request\nAccording to the relevant description of RFC-09 in the wiki, I refer to the org.apache.hudi.utilities.TestHoodieSnapshotCopier class to implement the HoodieSnapshotExporter class and provide test cases. Most of the functions have been implemented, but the output-partitioner in the document (A class to facilitate custom repartitioning), in my code, it is not necessary to create a PairRDD<K,V> or RDD<K,V> and use a custom Partitioner. I hope you can get your opinions.\nwiki: https://cwiki.apache.org/confluence/display/HUDI/RFC+-+09+%3A+Hudi+Dataset+Snapshot+Exporter\njira: https://issues.apache.org/jira/browse/HUDI-344\nthere is a result of converting hudi dataset to json:", "createdAt": "2020-02-27T04:23:51Z", "url": "https://github.com/apache/hudi/pull/1360", "merged": true, "mergeCommit": {"oid": "44700d531a74f24762903df2729577a0d96e4ec0"}, "closed": true, "closedAt": "2020-03-10T01:17:52Z", "author": {"login": "OpenOpened"}, "timelineItems": {"totalCount": 16, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABcITcAoAH2gAyMzgwNjI5NjY2OmU5OGYyZTFlYjA3YjZhNjY5ZjVmYjNmMzVhMzdjNmMzNTgwZTI3YmM=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcMID1SAFqTM3MTYyNDk5MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestCommit", "commit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc", "author": {"user": {"login": "OpenOpened", "name": "openopen2"}}, "url": "https://github.com/apache/hudi/commit/e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc", "committedDate": "2020-02-27T04:16:16Z", "message": "first commit"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2NzgyMDE1", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-366782015", "createdAt": "2020-02-29T06:50:00Z", "commit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 8, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNjo1MDowMFrOFwIB0g==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0yOVQwNzozMDoxNFrOFwIJKQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwNzUwNg==", "bodyText": "Suggested change", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386007506", "createdAt": "2020-02-29T06:50:00Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwNzY5OQ==", "bodyText": "I think we can omit the short param like -opf as it would create confusion due to the uncommonly recognized acronyms. The full names will work really well.", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386007699", "createdAt": "2020-02-29T06:53:56Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\", \"-sbp\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String basePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\", \"-tbp\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String outputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\", \"-sp\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\", \"-of\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\", \"-opf\"}, description = \"A field to be used by Spark repartitioning\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "originalPosition": 75}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwODE3NQ==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String basePath = null;\n          \n          \n            \n                String sourceBasePath = null;", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386008175", "createdAt": "2020-02-29T07:04:40Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\", \"-sbp\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String basePath = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "originalPosition": 64}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwODE4MA==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String outputPath = null;\n          \n          \n            \n                String targetBasePath = null;", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386008180", "createdAt": "2020-02-29T07:04:56Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\", \"-sbp\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String basePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\", \"-tbp\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String outputPath = null;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "originalPosition": 67}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwODM2Ng==", "bodyText": "You may take the call but I would say without these local vars using the cfg variable directly to refer to those params looks quite readable", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386008366", "createdAt": "2020-02-29T07:08:47Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\", \"-sbp\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String basePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\", \"-tbp\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String outputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\", \"-sp\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\", \"-of\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\", \"-opf\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public void export(SparkSession spark, Config cfg) throws IOException {\n+    String sourceBasePath = cfg.basePath;\n+    String targetBasePath = cfg.outputPath;\n+    String snapshotPrefix = cfg.snapshotPrefix;\n+    String outputFormat = cfg.outputFormat;\n+    String outputPartitionField = cfg.outputPartitionField;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "originalPosition": 84}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwODczMQ==", "bodyText": "you can invoke .parquet() to be specific", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386008731", "createdAt": "2020-02-29T07:16:02Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\", \"-sbp\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String basePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\", \"-tbp\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String outputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\", \"-sp\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\", \"-of\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\", \"-opf\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public void export(SparkSession spark, Config cfg) throws IOException {\n+    String sourceBasePath = cfg.basePath;\n+    String targetBasePath = cfg.outputPath;\n+    String snapshotPrefix = cfg.snapshotPrefix;\n+    String outputFormat = cfg.outputFormat;\n+    String outputPartitionField = cfg.outputPartitionField;\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.warn(\"No commits present. Nothing to snapshot\");\n+      return;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();\n+    LOG.info(String.format(\"Starting to snapshot latest version files which are also no-late-than %s.\",\n+        latestCommitTimestamp));\n+\n+    List<String> partitions = FSUtils.getAllPartitionPaths(fs, sourceBasePath, false);\n+    if (partitions.size() > 0) {\n+      List<String> dataFiles = new ArrayList<>();\n+\n+      if (!StringUtils.isNullOrEmpty(snapshotPrefix)) {\n+        for (String partition : partitions) {\n+          if (partition.contains(snapshotPrefix)) {\n+            dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+          }\n+        }\n+      } else {\n+        for (String partition : partitions) {\n+          dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+        }\n+      }\n+\n+      if (!outputFormat.equalsIgnoreCase(\"hudi\")) {\n+        // Do transformation\n+        if (!StringUtils.isNullOrEmpty(outputPartitionField)) {\n+          // A field to do simple Spark repartitioning\n+          spark.read().parquet(JavaConversions.asScalaIterator(dataFiles.iterator()).toSeq())\n+              .repartition(new Column(outputPartitionField))\n+              .write()\n+              .format(outputFormat)\n+              .mode(SaveMode.Overwrite)\n+              .save(targetBasePath);\n+        } else {\n+          spark.read().parquet(JavaConversions.asScalaIterator(dataFiles.iterator()).toSeq())\n+              .write()\n+              .format(outputFormat)\n+              .mode(SaveMode.Overwrite)\n+              .save(targetBasePath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "originalPosition": 134}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwOTI4Mw==", "bodyText": "I think you'd also need to partition the output dir\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                          .write()\n          \n          \n            \n                          .write()\n          \n          \n            \n                          .partitionBy(outputPartitionField)", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386009283", "createdAt": "2020-02-29T07:27:52Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\", \"-sbp\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String basePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\", \"-tbp\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String outputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\", \"-sp\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\", \"-of\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\", \"-opf\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public void export(SparkSession spark, Config cfg) throws IOException {\n+    String sourceBasePath = cfg.basePath;\n+    String targetBasePath = cfg.outputPath;\n+    String snapshotPrefix = cfg.snapshotPrefix;\n+    String outputFormat = cfg.outputFormat;\n+    String outputPartitionField = cfg.outputPartitionField;\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.warn(\"No commits present. Nothing to snapshot\");\n+      return;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();\n+    LOG.info(String.format(\"Starting to snapshot latest version files which are also no-late-than %s.\",\n+        latestCommitTimestamp));\n+\n+    List<String> partitions = FSUtils.getAllPartitionPaths(fs, sourceBasePath, false);\n+    if (partitions.size() > 0) {\n+      List<String> dataFiles = new ArrayList<>();\n+\n+      if (!StringUtils.isNullOrEmpty(snapshotPrefix)) {\n+        for (String partition : partitions) {\n+          if (partition.contains(snapshotPrefix)) {\n+            dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+          }\n+        }\n+      } else {\n+        for (String partition : partitions) {\n+          dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+        }\n+      }\n+\n+      if (!outputFormat.equalsIgnoreCase(\"hudi\")) {\n+        // Do transformation\n+        if (!StringUtils.isNullOrEmpty(outputPartitionField)) {\n+          // A field to do simple Spark repartitioning\n+          spark.read().parquet(JavaConversions.asScalaIterator(dataFiles.iterator()).toSeq())\n+              .repartition(new Column(outputPartitionField))\n+              .write()", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "originalPosition": 125}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjAwOTM4NQ==", "bodyText": "it would be good to have a switch to differentiate the cases and refactor each case to different methods for readability.\nNote that though we only have 'hudi' and 'parquet' for now, there could be more cases in future when needs rise.", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386009385", "createdAt": "2020-02-29T07:30:14Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\", \"-sbp\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String basePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\", \"-tbp\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String outputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\", \"-sp\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\", \"-of\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\", \"-opf\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public void export(SparkSession spark, Config cfg) throws IOException {\n+    String sourceBasePath = cfg.basePath;\n+    String targetBasePath = cfg.outputPath;\n+    String snapshotPrefix = cfg.snapshotPrefix;\n+    String outputFormat = cfg.outputFormat;\n+    String outputPartitionField = cfg.outputPartitionField;\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.warn(\"No commits present. Nothing to snapshot\");\n+      return;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();\n+    LOG.info(String.format(\"Starting to snapshot latest version files which are also no-late-than %s.\",\n+        latestCommitTimestamp));\n+\n+    List<String> partitions = FSUtils.getAllPartitionPaths(fs, sourceBasePath, false);\n+    if (partitions.size() > 0) {\n+      List<String> dataFiles = new ArrayList<>();\n+\n+      if (!StringUtils.isNullOrEmpty(snapshotPrefix)) {\n+        for (String partition : partitions) {\n+          if (partition.contains(snapshotPrefix)) {\n+            dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+          }\n+        }\n+      } else {\n+        for (String partition : partitions) {\n+          dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+        }\n+      }\n+\n+      if (!outputFormat.equalsIgnoreCase(\"hudi\")) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e98f2e1eb07b6a669f5fb3f35a37c6c3580e27bc"}, "originalPosition": 119}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff", "author": {"user": {"login": "JasonPeng93", "name": "Parkin Zhang"}}, "url": "https://github.com/apache/hudi/commit/d6ffad986b20067b2708e212d00575345a039dff", "committedDate": "2020-03-01T03:38:10Z", "message": "code optimize"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY2ODQ3NjU5", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-366847659", "createdAt": "2020-03-01T09:56:17Z", "commit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff"}, "state": "COMMENTED", "comments": {"totalCount": 7, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQwOTo1NjoxN1rOFwNTKw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wMVQxMDozOToxMFrOFwNeCA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5Mzg2Nw==", "bodyText": "When we export for non-hudi case, I think we should remove the _hoodie_* metadata columns.", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386093867", "createdAt": "2020-03-01T09:56:17Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.DataFrameWriter;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String sourceBasePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String targetOutputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public void export(SparkSession spark, Config cfg) throws IOException {\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(cfg.sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), cfg.sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.warn(\"No commits present. Nothing to snapshot\");\n+      return;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();\n+    LOG.info(String.format(\"Starting to snapshot latest version files which are also no-late-than %s.\",\n+        latestCommitTimestamp));\n+\n+    List<String> partitions = FSUtils.getAllPartitionPaths(fs, cfg.sourceBasePath, false);\n+    if (partitions.size() > 0) {\n+      List<String> dataFiles = new ArrayList<>();\n+\n+      if (!StringUtils.isNullOrEmpty(cfg.snapshotPrefix)) {\n+        for (String partition : partitions) {\n+          if (partition.contains(cfg.snapshotPrefix)) {\n+            dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+          }\n+        }\n+      } else {\n+        for (String partition : partitions) {\n+          dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+        }\n+      }\n+\n+      if (!cfg.outputFormat.equalsIgnoreCase(\"hudi\")) {\n+        // Do transformation\n+        DataFrameWriter<Row> write = spark.read().parquet(JavaConversions.asScalaIterator(dataFiles.iterator()).toSeq())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5NDk1Nw==", "bodyText": "With partitionBy() I think you left out the repartition() before write", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386094957", "createdAt": "2020-03-01T10:13:11Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.DataFrameWriter;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String sourceBasePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String targetOutputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public void export(SparkSession spark, Config cfg) throws IOException {\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(cfg.sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), cfg.sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.warn(\"No commits present. Nothing to snapshot\");\n+      return;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();\n+    LOG.info(String.format(\"Starting to snapshot latest version files which are also no-late-than %s.\",\n+        latestCommitTimestamp));\n+\n+    List<String> partitions = FSUtils.getAllPartitionPaths(fs, cfg.sourceBasePath, false);\n+    if (partitions.size() > 0) {\n+      List<String> dataFiles = new ArrayList<>();\n+\n+      if (!StringUtils.isNullOrEmpty(cfg.snapshotPrefix)) {\n+        for (String partition : partitions) {\n+          if (partition.contains(cfg.snapshotPrefix)) {\n+            dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+          }\n+        }\n+      } else {\n+        for (String partition : partitions) {\n+          dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+        }\n+      }\n+\n+      if (!cfg.outputFormat.equalsIgnoreCase(\"hudi\")) {\n+        // Do transformation\n+        DataFrameWriter<Row> write = spark.read().parquet(JavaConversions.asScalaIterator(dataFiles.iterator()).toSeq())", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5Mzg2Nw=="}, "originalCommit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff"}, "originalPosition": 117}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5NTI3Mg==", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                SparkSession spark = SparkSession.builder().appName(\"Hoodie-snapshot-exporter\").master(\"local[2]\")\n          \n          \n            \n                SparkSession spark = SparkSession.builder().appName(\"Hoodie-snapshot-exporter\")", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386095272", "createdAt": "2020-03-01T10:17:50Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,213 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.DataFrameWriter;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String sourceBasePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String targetOutputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public void export(SparkSession spark, Config cfg) throws IOException {\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(cfg.sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), cfg.sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.warn(\"No commits present. Nothing to snapshot\");\n+      return;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();\n+    LOG.info(String.format(\"Starting to snapshot latest version files which are also no-late-than %s.\",\n+        latestCommitTimestamp));\n+\n+    List<String> partitions = FSUtils.getAllPartitionPaths(fs, cfg.sourceBasePath, false);\n+    if (partitions.size() > 0) {\n+      List<String> dataFiles = new ArrayList<>();\n+\n+      if (!StringUtils.isNullOrEmpty(cfg.snapshotPrefix)) {\n+        for (String partition : partitions) {\n+          if (partition.contains(cfg.snapshotPrefix)) {\n+            dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+          }\n+        }\n+      } else {\n+        for (String partition : partitions) {\n+          dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+        }\n+      }\n+\n+      if (!cfg.outputFormat.equalsIgnoreCase(\"hudi\")) {\n+        // Do transformation\n+        DataFrameWriter<Row> write = spark.read().parquet(JavaConversions.asScalaIterator(dataFiles.iterator()).toSeq())\n+                .write();\n+        if (!StringUtils.isNullOrEmpty(cfg.outputPartitionField)) {\n+          // A field to do simple Spark repartitioning\n+          write.partitionBy(cfg.outputPartitionField)\n+              .format(cfg.outputFormat)\n+              .mode(SaveMode.Overwrite)\n+              .save(cfg.targetOutputPath);\n+        } else {\n+          write.format(cfg.outputFormat)\n+              .mode(SaveMode.Overwrite)\n+              .save(cfg.targetOutputPath);\n+        }\n+      } else {\n+        // No transformation is needed for output format \"HUDI\", just copy the original files.\n+\n+        // Make sure the output directory is empty\n+        Path outputPath = new Path(cfg.targetOutputPath);\n+        if (fs.exists(outputPath)) {\n+          LOG.warn(String.format(\"The output path %s targetBasePath already exists, deleting\", outputPath));\n+          fs.delete(new Path(cfg.targetOutputPath), true);\n+        }\n+\n+        jsc.parallelize(partitions, partitions.size()).flatMap(partition -> {\n+          // Only take latest version files <= latestCommit.\n+          FileSystem fs1 = FSUtils.getFs(cfg.sourceBasePath, serConf.newCopy());\n+          List<Tuple2<String, String>> filePaths = new ArrayList<>();\n+          dataFiles.forEach(hoodieDataFile -> filePaths.add(new Tuple2<>(partition, hoodieDataFile)));\n+\n+          // also need to copy over partition metadata\n+          Path partitionMetaFile =\n+              new Path(new Path(cfg.sourceBasePath, partition), HoodiePartitionMetadata.HOODIE_PARTITION_METAFILE);\n+          if (fs1.exists(partitionMetaFile)) {\n+            filePaths.add(new Tuple2<>(partition, partitionMetaFile.toString()));\n+          }\n+\n+          return filePaths.iterator();\n+        }).foreach(tuple -> {\n+          String partition = tuple._1();\n+          Path sourceFilePath = new Path(tuple._2());\n+          Path toPartitionPath = new Path(cfg.targetOutputPath, partition);\n+          FileSystem ifs = FSUtils.getFs(cfg.targetOutputPath, serConf.newCopy());\n+\n+          if (!ifs.exists(toPartitionPath)) {\n+            ifs.mkdirs(toPartitionPath);\n+          }\n+          FileUtil.copy(ifs, sourceFilePath, ifs, new Path(toPartitionPath, sourceFilePath.getName()), false,\n+              ifs.getConf());\n+        });\n+\n+        // Also copy the .commit files\n+        LOG.info(String.format(\"Copying .commit files which are no-late-than %s.\", latestCommitTimestamp));\n+        FileStatus[] commitFilesToCopy =\n+            fs.listStatus(new Path(cfg.sourceBasePath + \"/\" + HoodieTableMetaClient.METAFOLDER_NAME), (commitFilePath) -> {\n+              if (commitFilePath.getName().equals(HoodieTableConfig.HOODIE_PROPERTIES_FILE)) {\n+                return true;\n+              } else {\n+                String commitTime = FSUtils.getCommitFromCommitFile(commitFilePath.getName());\n+                return HoodieTimeline.compareTimestamps(commitTime, latestCommitTimestamp,\n+                    HoodieTimeline.LESSER_OR_EQUAL);\n+              }\n+            });\n+        for (FileStatus commitStatus : commitFilesToCopy) {\n+          Path targetFilePath =\n+              new Path(cfg.targetOutputPath + \"/\" + HoodieTableMetaClient.METAFOLDER_NAME + \"/\" + commitStatus.getPath().getName());\n+          if (!fs.exists(targetFilePath.getParent())) {\n+            fs.mkdirs(targetFilePath.getParent());\n+          }\n+          if (fs.exists(targetFilePath)) {\n+            LOG.error(\n+                String.format(\"The target output commit file (%s targetBasePath) already exists.\", targetFilePath));\n+          }\n+          FileUtil.copy(fs, commitStatus.getPath(), fs, targetFilePath, false, fs.getConf());\n+        }\n+      }\n+    } else {\n+      LOG.info(\"The job has 0 partition to copy.\");\n+    }\n+  }\n+\n+  public static void main(String[] args) throws IOException {\n+    // Take input configs\n+    final Config cfg = new Config();\n+    new JCommander(cfg, null, args);\n+\n+    // Create a spark job to do the snapshot export\n+    SparkSession spark = SparkSession.builder().appName(\"Hoodie-snapshot-exporter\").master(\"local[2]\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff"}, "originalPosition": 203}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5NTM4OA==", "bodyText": "This seems not used", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386095388", "createdAt": "2020-03-01T10:19:31Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/test/java/org/apache/hudi/utilities/DataSourceTestUtils.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import org.apache.hudi.common.TestRawTripPayload;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.util.Option;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Test utils for data source tests.\n+ */\n+public class DataSourceTestUtils {\n+\n+  public static Option<String> convertToString(HoodieRecord record) {\n+    try {\n+      String str = ((TestRawTripPayload) record.getData()).getJsonData();\n+      str = \"{\" + str.substring(str.indexOf(\"\\\"timestamp\\\":\"));\n+      // Remove the last } bracket\n+      str = str.substring(0, str.length() - 1);\n+      return Option.of(str + \", \\\"partition\\\": \\\"\" + record.getPartitionPath() + \"\\\"}\");\n+    } catch (IOException e) {\n+      return Option.empty();\n+    }\n+  }\n+\n+  public static List<String> convertToStringList(List<HoodieRecord> records) {\n+    return records.stream().map(DataSourceTestUtils::convertToString).filter(Option::isPresent).map(Option::get)\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static List<String> convertKeysToStringList(List<HoodieKey> keys) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff"}, "originalPosition": 52}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5NTkyNw==", "bodyText": "Any reason of not extending HoodieCommonTestHarness ?", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386095927", "createdAt": "2020-03-01T10:28:21Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/test/java/org/apache/hudi/utilities/TestHoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.HoodieTestDataGenerator;\n+import org.apache.hudi.common.model.HoodieTestUtils;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestHoodieSnapshotExporter {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff"}, "originalPosition": 50}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5NjE4Mg==", "bodyText": "This assumes what data column exists in TestRawTripPayload, which may easily break. I would suggest\n\nmaking this a private test utils to the Exporter test class as it is very specific to it (not generic enough to be a standalone test utils) and\ntry to make the source data work for the case instead of wrangling with json string representation", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386096182", "createdAt": "2020-03-01T10:32:13Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/test/java/org/apache/hudi/utilities/DataSourceTestUtils.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import org.apache.hudi.common.TestRawTripPayload;\n+import org.apache.hudi.common.model.HoodieKey;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.common.util.Option;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Test utils for data source tests.\n+ */\n+public class DataSourceTestUtils {\n+\n+  public static Option<String> convertToString(HoodieRecord record) {\n+    try {\n+      String str = ((TestRawTripPayload) record.getData()).getJsonData();\n+      str = \"{\" + str.substring(str.indexOf(\"\\\"timestamp\\\":\"));\n+      // Remove the last } bracket\n+      str = str.substring(0, str.length() - 1);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff"}, "originalPosition": 40}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjA5NjY0OA==", "bodyText": "Notice this is from original test for Snapshot copier, not sure about the historical issue for skipping it. I would slightly favor fixing it while you're at this stage so that we can claim the new \"Exporter\" is better tested than the old \"Copier\" :)", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386096648", "createdAt": "2020-03-01T10:39:10Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/test/java/org/apache/hudi/utilities/TestHoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,227 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import org.apache.hadoop.conf.Configuration;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.HoodieTestDataGenerator;\n+import org.apache.hudi.common.model.HoodieTestUtils;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.config.HoodieWriteConfig;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+\n+import org.junit.After;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.rules.TemporaryFolder;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class TestHoodieSnapshotExporter {\n+  private static String TEST_WRITE_TOKEN = \"1-0-1\";\n+\n+  private SparkSession spark = null;\n+  private HoodieTestDataGenerator dataGen = null;\n+  private String basePath = null;\n+  private String outputPath = null;\n+  private String rootPath = null;\n+  private FileSystem fs = null;\n+  private Map commonOpts;\n+  private HoodieSnapshotExporter.Config cfg;\n+  private JavaSparkContext jsc = null;\n+\n+  @Before\n+  public void initialize() throws IOException {\n+    spark = SparkSession.builder()\n+        .appName(\"Hoodie Datasource test\")\n+        .master(\"local[2]\")\n+        .config(\"spark.serializer\", \"org.apache.spark.serializer.KryoSerializer\")\n+        .getOrCreate();\n+    jsc = new JavaSparkContext(spark.sparkContext());\n+    dataGen = new HoodieTestDataGenerator();\n+    TemporaryFolder folder = new TemporaryFolder();\n+    folder.create();\n+    basePath = folder.getRoot().getAbsolutePath();\n+    fs = FSUtils.getFs(basePath, spark.sparkContext().hadoopConfiguration());\n+    commonOpts = new HashMap();\n+\n+    commonOpts.put(\"hoodie.insert.shuffle.parallelism\", \"4\");\n+    commonOpts.put(\"hoodie.upsert.shuffle.parallelism\", \"4\");\n+    commonOpts.put(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(), \"_row_key\");\n+    commonOpts.put(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY(), \"partition\");\n+    commonOpts.put(DataSourceWriteOptions.PRECOMBINE_FIELD_OPT_KEY(), \"timestamp\");\n+    commonOpts.put(HoodieWriteConfig.TABLE_NAME, \"hoodie_test\");\n+\n+\n+    cfg = new HoodieSnapshotExporter.Config();\n+\n+    cfg.sourceBasePath = basePath;\n+    cfg.targetOutputPath = outputPath = basePath + \"/target\";\n+    cfg.outputFormat = \"json\";\n+    cfg.outputPartitionField = \"partition\";\n+\n+  }\n+\n+  @After\n+  public void cleanup() throws Exception {\n+    if (spark != null) {\n+      spark.stop();\n+    }\n+  }\n+\n+  @Test\n+  public void testSnapshotExporter() throws IOException {\n+    // Insert Operation\n+    List<String> records = DataSourceTestUtils.convertToStringList(dataGen.generateInserts(\"000\", 100));\n+    Dataset<Row> inputDF = spark.read().json(new JavaSparkContext(spark.sparkContext()).parallelize(records, 2));\n+    inputDF.write().format(\"hudi\")\n+        .options(commonOpts)\n+        .option(DataSourceWriteOptions.OPERATION_OPT_KEY(), DataSourceWriteOptions.INSERT_OPERATION_OPT_VAL())\n+        .mode(SaveMode.Overwrite)\n+        .save(basePath);\n+    long sourceCount = inputDF.count();\n+\n+    HoodieSnapshotExporter hoodieSnapshotExporter = new HoodieSnapshotExporter();\n+    hoodieSnapshotExporter.export(spark, cfg);\n+\n+    long targetCount = spark.read().json(outputPath).count();\n+\n+    assertTrue(sourceCount == targetCount);\n+\n+    // Test snapshotPrefix\n+    long filterCount = inputDF.where(\"partition == '2015/03/16'\").count();\n+    cfg.snapshotPrefix = \"2015/03/16\";\n+    hoodieSnapshotExporter.export(spark, cfg);\n+    long targetFilterCount = spark.read().json(outputPath).count();\n+    assertTrue(filterCount == targetFilterCount);\n+\n+  }\n+\n+  // for testEmptySnapshotCopy\n+  public void init() throws IOException {\n+    TemporaryFolder folder = new TemporaryFolder();\n+    folder.create();\n+    rootPath = \"file://\" + folder.getRoot().getAbsolutePath();\n+    basePath = rootPath + \"/\" + HoodieTestUtils.RAW_TRIPS_TEST_NAME;\n+    outputPath = rootPath + \"/output\";\n+\n+    final Configuration hadoopConf = HoodieTestUtils.getDefaultHadoopConf();\n+    fs = FSUtils.getFs(basePath, hadoopConf);\n+    HoodieTestUtils.init(hadoopConf, basePath);\n+  }\n+\n+  @Test\n+  public void testEmptySnapshotCopy() throws IOException {\n+    init();\n+    // There is no real data (only .hoodie directory)\n+    assertEquals(fs.listStatus(new Path(basePath)).length, 1);\n+    assertFalse(fs.exists(new Path(outputPath)));\n+\n+    // Do the snapshot\n+    HoodieSnapshotCopier copier = new HoodieSnapshotCopier();\n+    copier.snapshot(jsc, basePath, outputPath, true);\n+\n+    // Nothing changed; we just bail out\n+    assertEquals(fs.listStatus(new Path(basePath)).length, 1);\n+    assertFalse(fs.exists(new Path(outputPath + \"/_SUCCESS\")));\n+  }\n+\n+  // TODO - uncomment this after fixing test failures\n+  // @Test", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "d6ffad986b20067b2708e212d00575345a039dff"}, "originalPosition": 160}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e917358edc3c65252a2783b761c24a74b7aa04f3", "author": {"user": {"login": "OpenOpened", "name": "openopen2"}}, "url": "https://github.com/apache/hudi/commit/e917358edc3c65252a2783b761c24a74b7aa04f3", "committedDate": "2020-03-02T09:14:16Z", "message": "code optimize"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3Njg4NDA4", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-367688408", "createdAt": "2020-03-03T03:55:53Z", "commit": {"oid": "e917358edc3c65252a2783b761c24a74b7aa04f3"}, "state": "COMMENTED", "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMzo1NTo1M1rOFw3lyw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wM1QwMzo1NjowMVrOFw3l4w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4Njc2Mw==", "bodyText": "you need startswith() to be safe. There could be a column named \"total_hoodie_counts\"", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386786763", "createdAt": "2020-03-03T03:55:53Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.DataFrameWriter;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.execution.datasources.DataSource;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String sourceBasePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String targetOutputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public int export(SparkSession spark, Config cfg) throws IOException {\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(cfg.sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), cfg.sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.error(\"No commits present. Nothing to snapshot\");\n+      return -1;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();\n+    LOG.info(String.format(\"Starting to snapshot latest version files which are also no-late-than %s.\",\n+        latestCommitTimestamp));\n+\n+    List<String> partitions = FSUtils.getAllPartitionPaths(fs, cfg.sourceBasePath, false);\n+    if (partitions.size() > 0) {\n+      List<String> dataFiles = new ArrayList<>();\n+\n+      if (!StringUtils.isNullOrEmpty(cfg.snapshotPrefix)) {\n+        for (String partition : partitions) {\n+          if (partition.contains(cfg.snapshotPrefix)) {\n+            dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+          }\n+        }\n+      } else {\n+        for (String partition : partitions) {\n+          dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+        }\n+      }\n+      try {\n+        DataSource.lookupDataSource(cfg.outputFormat, spark.sessionState().conf());\n+      } catch (Exception e) {\n+        LOG.error(String.format(\"The %s output format is not supported! \", cfg.outputFormat));\n+        return -1;\n+      }\n+      if (!cfg.outputFormat.equalsIgnoreCase(\"hudi\")) {\n+        // Do transformation\n+        // A field to do simple Spark repartitioning\n+        DataFrameWriter<Row> write = null;\n+        Dataset<Row> original = spark.read().parquet(JavaConversions.asScalaIterator(dataFiles.iterator()).toSeq());\n+        List<Column> needColumns = Arrays.asList(original.columns()).stream().filter(col -> !col.contains(\"_hoodie_\")).map(col -> new Column(col)).collect(Collectors.toList());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e917358edc3c65252a2783b761c24a74b7aa04f3"}, "originalPosition": 129}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc4Njc4Nw==", "bodyText": "i think you need both repartition() and partitionBy()", "url": "https://github.com/apache/hudi/pull/1360#discussion_r386786787", "createdAt": "2020-03-03T03:56:01Z", "author": {"login": "xushiyan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.DataFrameWriter;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.execution.datasources.DataSource;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String sourceBasePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String targetOutputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public int export(SparkSession spark, Config cfg) throws IOException {\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(cfg.sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), cfg.sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.error(\"No commits present. Nothing to snapshot\");\n+      return -1;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();\n+    LOG.info(String.format(\"Starting to snapshot latest version files which are also no-late-than %s.\",\n+        latestCommitTimestamp));\n+\n+    List<String> partitions = FSUtils.getAllPartitionPaths(fs, cfg.sourceBasePath, false);\n+    if (partitions.size() > 0) {\n+      List<String> dataFiles = new ArrayList<>();\n+\n+      if (!StringUtils.isNullOrEmpty(cfg.snapshotPrefix)) {\n+        for (String partition : partitions) {\n+          if (partition.contains(cfg.snapshotPrefix)) {\n+            dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+          }\n+        }\n+      } else {\n+        for (String partition : partitions) {\n+          dataFiles.addAll(fsView.getLatestBaseFilesBeforeOrOn(partition, latestCommitTimestamp).map(f -> f.getPath()).collect(Collectors.toList()));\n+        }\n+      }\n+      try {\n+        DataSource.lookupDataSource(cfg.outputFormat, spark.sessionState().conf());\n+      } catch (Exception e) {\n+        LOG.error(String.format(\"The %s output format is not supported! \", cfg.outputFormat));\n+        return -1;\n+      }\n+      if (!cfg.outputFormat.equalsIgnoreCase(\"hudi\")) {\n+        // Do transformation\n+        // A field to do simple Spark repartitioning\n+        DataFrameWriter<Row> write = null;\n+        Dataset<Row> original = spark.read().parquet(JavaConversions.asScalaIterator(dataFiles.iterator()).toSeq());\n+        List<Column> needColumns = Arrays.asList(original.columns()).stream().filter(col -> !col.contains(\"_hoodie_\")).map(col -> new Column(col)).collect(Collectors.toList());\n+        Dataset<Row> reader = original.select(JavaConversions.asScalaIterator(needColumns.iterator()).toSeq());\n+        if (!StringUtils.isNullOrEmpty(cfg.outputPartitionField)) {\n+          write = reader.repartition(new Column(cfg.outputPartitionField))\n+              .write();\n+        } else {\n+          write = reader.write();\n+        }\n+        write.format(cfg.outputFormat)\n+            .mode(SaveMode.Overwrite)\n+            .save(cfg.targetOutputPath);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "e917358edc3c65252a2783b761c24a74b7aa04f3"}, "originalPosition": 139}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "76133ce9788df7bc57406066811fb5e14d40a17c", "author": {"user": {"login": "OpenOpened", "name": "openopen2"}}, "url": "https://github.com/apache/hudi/commit/76133ce9788df7bc57406066811fb5e14d40a17c", "committedDate": "2020-03-05T14:13:22Z", "message": "code optimize"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwNTc0MzIx", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-370574321", "createdAt": "2020-03-06T19:33:12Z", "commit": {"oid": "76133ce9788df7bc57406066811fb5e14d40a17c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODAwMzE0", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-370800314", "createdAt": "2020-03-08T02:27:03Z", "commit": {"oid": "76133ce9788df7bc57406066811fb5e14d40a17c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQwMjoyNzowM1rOFzSveA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQwMjoyNzowM1rOFzSveA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyODc2MA==", "bodyText": "the description here, I feel a little bit wierd after reading the code below, it means only export source Hudi dataset which contains the snapshotPrefix? would be changed to Snapshot prefix or directory under the source Hudi dataset to be exported? cc @OpenOpened @xushiyan", "url": "https://github.com/apache/hudi/pull/1360#discussion_r389328760", "createdAt": "2020-03-08T02:27:03Z", "author": {"login": "leesf"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.DataFrameWriter;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.execution.datasources.DataSource;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String sourceBasePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String targetOutputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76133ce9788df7bc57406066811fb5e14d40a17c"}, "originalPosition": 74}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwODAwNDA5", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-370800409", "createdAt": "2020-03-08T02:30:26Z", "commit": {"oid": "76133ce9788df7bc57406066811fb5e14d40a17c"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQwMjozMDoyNlrOFzSwAg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOFQwMjozMDoyNlrOFzSwAg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTMyODg5OA==", "bodyText": "one minor question, would we support config commit time ? it is optional, and get lastest commit by default or get the specified commit time. cc @xushiyan @OpenOpened", "url": "https://github.com/apache/hudi/pull/1360#discussion_r389328898", "createdAt": "2020-03-08T02:30:26Z", "author": {"login": "leesf"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotExporter.java", "diffHunk": "@@ -0,0 +1,233 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.utilities;\n+\n+import com.beust.jcommander.JCommander;\n+import com.beust.jcommander.Parameter;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.FileUtil;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.hudi.common.util.StringUtils;\n+import org.apache.hudi.common.SerializableConfiguration;\n+import org.apache.hudi.common.model.HoodiePartitionMetadata;\n+import org.apache.hudi.common.table.HoodieTableConfig;\n+import org.apache.hudi.common.table.HoodieTableMetaClient;\n+import org.apache.hudi.common.table.HoodieTimeline;\n+import org.apache.hudi.common.table.TableFileSystemView;\n+import org.apache.hudi.common.table.timeline.HoodieInstant;\n+import org.apache.hudi.common.table.view.HoodieTableFileSystemView;\n+import org.apache.hudi.common.util.FSUtils;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+import org.apache.spark.sql.Column;\n+import org.apache.spark.sql.DataFrameWriter;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SaveMode;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.execution.datasources.DataSource;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * Export the latest records of Hudi dataset to a set of external files (e.g., plain parquet files).\n+ */\n+\n+public class HoodieSnapshotExporter {\n+  private static final Logger LOG = LogManager.getLogger(HoodieSnapshotExporter.class);\n+\n+  public static class Config implements Serializable {\n+    @Parameter(names = {\"--source-base-path\"}, description = \"Base path for the source Hudi dataset to be snapshotted\", required = true)\n+    String sourceBasePath = null;\n+\n+    @Parameter(names = {\"--target-base-path\"}, description = \"Base path for the target output files (snapshots)\", required = true)\n+    String targetOutputPath = null;\n+\n+    @Parameter(names = {\"--snapshot-prefix\"}, description = \"Snapshot prefix or directory under the target base path in order to segregate different snapshots\")\n+    String snapshotPrefix;\n+\n+    @Parameter(names = {\"--output-format\"}, description = \"e.g. Hudi or Parquet\", required = true)\n+    String outputFormat;\n+\n+    @Parameter(names = {\"--output-partition-field\"}, description = \"A field to be used by Spark repartitioning\")\n+    String outputPartitionField;\n+  }\n+\n+  public int export(SparkSession spark, Config cfg) throws IOException {\n+    JavaSparkContext jsc = new JavaSparkContext(spark.sparkContext());\n+    FileSystem fs = FSUtils.getFs(cfg.sourceBasePath, jsc.hadoopConfiguration());\n+\n+    final SerializableConfiguration serConf = new SerializableConfiguration(jsc.hadoopConfiguration());\n+    final HoodieTableMetaClient tableMetadata = new HoodieTableMetaClient(fs.getConf(), cfg.sourceBasePath);\n+    final TableFileSystemView.BaseFileOnlyView fsView = new HoodieTableFileSystemView(tableMetadata,\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants());\n+    // Get the latest commit\n+    Option<HoodieInstant> latestCommit =\n+        tableMetadata.getActiveTimeline().getCommitsTimeline().filterCompletedInstants().lastInstant();\n+    if (!latestCommit.isPresent()) {\n+      LOG.error(\"No commits present. Nothing to snapshot\");\n+      return -1;\n+    }\n+    final String latestCommitTimestamp = latestCommit.get().getTimestamp();", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "76133ce9788df7bc57406066811fb5e14d40a17c"}, "originalPosition": 99}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8cd7d0b8e81cc19cdc4d8b3fb00bb5f7de074d73", "author": {"user": {"login": "OpenOpened", "name": "openopen2"}}, "url": "https://github.com/apache/hudi/commit/8cd7d0b8e81cc19cdc4d8b3fb00bb5f7de074d73", "committedDate": "2020-03-09T03:08:10Z", "message": "code optimize"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "aa5e7798322ce0701776d8b44b608d601f61f0a7", "author": {"user": {"login": "OpenOpened", "name": "openopen2"}}, "url": "https://github.com/apache/hudi/commit/aa5e7798322ce0701776d8b44b608d601f61f0a7", "committedDate": "2020-03-09T05:58:37Z", "message": "remove --snapshot-prefix flag"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTM3Mzcx", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-370937371", "createdAt": "2020-03-09T06:25:50Z", "commit": {"oid": "aa5e7798322ce0701776d8b44b608d601f61f0a7"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTM5NDgx", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-370939481", "createdAt": "2020-03-09T06:33:48Z", "commit": {"oid": "aa5e7798322ce0701776d8b44b608d601f61f0a7"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwNjozMzo0OVrOFzcG2w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0wOVQwNjozMzo0OVrOFzcG2w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ4MjIwMw==", "bodyText": "nit: remove extra line?", "url": "https://github.com/apache/hudi/pull/1360#discussion_r389482203", "createdAt": "2020-03-09T06:33:49Z", "author": {"login": "vinothchandar"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/HoodieSnapshotCopier.java", "diffHunk": "@@ -52,6 +52,7 @@\n /**\n  * Hoodie snapshot copy job which copies latest files from all partitions to another place, for snapshot backup.\n  */\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "aa5e7798322ce0701776d8b44b608d601f61f0a7"}, "originalPosition": 4}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45c0872ce680ad54312cfdeb4c8dd6f70525513c", "author": {"user": {"login": "OpenOpened", "name": "openopen2"}}, "url": "https://github.com/apache/hudi/commit/45c0872ce680ad54312cfdeb4c8dd6f70525513c", "committedDate": "2020-03-09T06:42:11Z", "message": "remove extra line"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcxNjI0OTkw", "url": "https://github.com/apache/hudi/pull/1360#pullrequestreview-371624990", "createdAt": "2020-03-10T01:16:36Z", "commit": {"oid": "45c0872ce680ad54312cfdeb4c8dd6f70525513c"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3714, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}