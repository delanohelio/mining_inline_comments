{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0Mzk1MzU0ODA1", "number": 1466, "reviewThreads": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNDozMzoyOFrODsgdig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMToxMDo0OFrODs6McA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ3OTk1Nzg2OnYy", "diffSide": "RIGHT", "path": "hudi-client/src/test/java/org/apache/hudi/index/bloom/TestBucketizedBloomCheckPartitioner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQwNDozMzoyOFrOF9ZTIg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxMzoyNjozOFrOF9pmHg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkyMTk1NA==", "bodyText": "IMO, 94 is unstable, the value depends on different hash methods. I think we can check the partition range, for example. WDYT?\n@Test\npublic void testGetPartitions() {\n  Map<String, Long> comparisons1 = new HashMap<String, Long>() {\n    {\n      IntStream.range(0, 100000).forEach(f -> put(\"f\" + f, 100L));\n    }\n  };\n  BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(1000, comparisons1, 10);\n\n  IntStream.range(0, 100000).forEach(f -> {\n    int partition = p.getPartition(Pair.of(\"f\" + f, \"value\"));\n    assertTrue(\"partition is out of range: \" + partition, 0 <= partition && partition <= 1000);\n  });\n\n}", "url": "https://github.com/apache/hudi/pull/1466#discussion_r399921954", "createdAt": "2020-03-30T04:33:28Z", "author": {"login": "lamberken"}, "path": "hudi-client/src/test/java/org/apache/hudi/index/bloom/TestBucketizedBloomCheckPartitioner.java", "diffHunk": "@@ -79,4 +79,17 @@ public void testNumPartitions() {\n     BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(10000, comparisons1, 10);\n     assertEquals(\"num partitions must equal total buckets\", 100, p.numPartitions());\n   }\n+\n+  @Test\n+  public void testGetPartitions() {\n+    Map<String, Long> comparisons1 = new HashMap<String, Long>() {\n+      {\n+        IntStream.range(0, 10).forEach(f -> put(\"f\" + f, 100L));\n+      }\n+    };\n+    BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(10000, comparisons1, 10);\n+    Object key = Pair.of(\"f0\", \"value0\");\n+    assertEquals(\"candidatePartitions must be a posive number: \", 94, p.getPartition(key));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 14}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDE4ODk1OA==", "bodyText": "Make sense. Updated.  Thanks @lamber-ken", "url": "https://github.com/apache/hudi/pull/1466#discussion_r400188958", "createdAt": "2020-03-30T13:26:38Z", "author": {"login": "EdwinGuo"}, "path": "hudi-client/src/test/java/org/apache/hudi/index/bloom/TestBucketizedBloomCheckPartitioner.java", "diffHunk": "@@ -79,4 +79,17 @@ public void testNumPartitions() {\n     BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(10000, comparisons1, 10);\n     assertEquals(\"num partitions must equal total buckets\", 100, p.numPartitions());\n   }\n+\n+  @Test\n+  public void testGetPartitions() {\n+    Map<String, Long> comparisons1 = new HashMap<String, Long>() {\n+      {\n+        IntStream.range(0, 10).forEach(f -> put(\"f\" + f, 100L));\n+      }\n+    };\n+    BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(10000, comparisons1, 10);\n+    Object key = Pair.of(\"f0\", \"value0\");\n+    assertEquals(\"candidatePartitions must be a posive number: \", 94, p.getPartition(key));", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5OTkyMTk1NA=="}, "originalCommit": null, "originalPosition": 14}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4MTk4OTM1OnYy", "diffSide": "RIGHT", "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/BucketizedBloomCheckPartitioner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNDozMToxOVrOF9sn7A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMFQxNDo1OToxN1rOF9t-FQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzODU3Mg==", "bodyText": "is the cast to (int) necessary still before assigning to idx", "url": "https://github.com/apache/hudi/pull/1466#discussion_r400238572", "createdAt": "2020-03-30T14:31:19Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/BucketizedBloomCheckPartitioner.java", "diffHunk": "@@ -145,7 +145,7 @@ public int getPartition(Object key) {\n     final Pair<String, String> parts = (Pair<String, String>) key;\n     final long hashOfKey = NumericUtils.getMessageDigestHash(\"MD5\", parts.getRight());\n     final List<Integer> candidatePartitions = fileGroupToPartitions.get(parts.getLeft());\n-    final int idx = (int) Math.floorMod(hashOfKey, candidatePartitions.size());\n+    final int idx = (int) Math.floorMod((int) hashOfKey, candidatePartitions.size());", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDI2MDYyOQ==", "bodyText": "Hey @vinothchandar  If you take a look at the original discussion #1455, there are different interface in java8 and other versions of java. The consolidate that difference, cast both to int or long will make less room for runtime error.", "url": "https://github.com/apache/hudi/pull/1466#discussion_r400260629", "createdAt": "2020-03-30T14:59:17Z", "author": {"login": "EdwinGuo"}, "path": "hudi-client/src/main/java/org/apache/hudi/index/bloom/BucketizedBloomCheckPartitioner.java", "diffHunk": "@@ -145,7 +145,7 @@ public int getPartition(Object key) {\n     final Pair<String, String> parts = (Pair<String, String>) key;\n     final long hashOfKey = NumericUtils.getMessageDigestHash(\"MD5\", parts.getRight());\n     final List<Integer> candidatePartitions = fileGroupToPartitions.get(parts.getLeft());\n-    final int idx = (int) Math.floorMod(hashOfKey, candidatePartitions.size());\n+    final int idx = (int) Math.floorMod((int) hashOfKey, candidatePartitions.size());", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDIzODU3Mg=="}, "originalCommit": null, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMjQ4NDE3MzkyOnYy", "diffSide": "RIGHT", "path": "hudi-client/src/test/java/org/apache/hudi/index/bloom/TestBucketizedBloomCheckPartitioner.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMToxMDo0OFrOF-Bw8w==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMy0zMVQwMjowMTozMFrOF-CnBw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4NDk0Nw==", "bodyText": "nit: partition is within of range -> partition is out of range ?", "url": "https://github.com/apache/hudi/pull/1466#discussion_r400584947", "createdAt": "2020-03-31T01:10:48Z", "author": {"login": "leesf"}, "path": "hudi-client/src/test/java/org/apache/hudi/index/bloom/TestBucketizedBloomCheckPartitioner.java", "diffHunk": "@@ -79,4 +80,20 @@ public void testNumPartitions() {\n     BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(10000, comparisons1, 10);\n     assertEquals(\"num partitions must equal total buckets\", 100, p.numPartitions());\n   }\n+\n+  @Test\n+  public void testGetPartitions() {\n+    Map<String, Long> comparisons1 = new HashMap<String, Long>() {\n+      {\n+        IntStream.range(0, 100000).forEach(f -> put(\"f\" + f, 100L));\n+      }\n+    };\n+    BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(1000, comparisons1, 10);\n+\n+    IntStream.range(0, 100000).forEach(f -> {\n+      int partition = p.getPartition(Pair.of(\"f\" + f, \"value\"));\n+      assertTrue(\"partition is within of range: \" + partition, 0 <= partition && partition <= 1000);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU5ODc5MQ==", "bodyText": "updated. Thanks", "url": "https://github.com/apache/hudi/pull/1466#discussion_r400598791", "createdAt": "2020-03-31T02:01:30Z", "author": {"login": "EdwinGuo"}, "path": "hudi-client/src/test/java/org/apache/hudi/index/bloom/TestBucketizedBloomCheckPartitioner.java", "diffHunk": "@@ -79,4 +80,20 @@ public void testNumPartitions() {\n     BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(10000, comparisons1, 10);\n     assertEquals(\"num partitions must equal total buckets\", 100, p.numPartitions());\n   }\n+\n+  @Test\n+  public void testGetPartitions() {\n+    Map<String, Long> comparisons1 = new HashMap<String, Long>() {\n+      {\n+        IntStream.range(0, 100000).forEach(f -> put(\"f\" + f, 100L));\n+      }\n+    };\n+    BucketizedBloomCheckPartitioner p = new BucketizedBloomCheckPartitioner(1000, comparisons1, 10);\n+\n+    IntStream.range(0, 100000).forEach(f -> {\n+      int partition = p.getPartition(Pair.of(\"f\" + f, \"value\"));\n+      assertTrue(\"partition is within of range: \" + partition, 0 <= partition && partition <= 1000);", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU4NDk0Nw=="}, "originalCommit": null, "originalPosition": 24}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4727, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}