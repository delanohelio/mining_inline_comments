{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NDExMjYxNTI0", "number": 1576, "title": "[HUDI-850] Avoid unnecessary listings in incremental cleaning mode", "bodyText": "We are unnecessarily scanning partitions for cleans_by_commit mode when there are no sufficient commits accumulated for cleaning.", "createdAt": "2020-04-30T08:47:29Z", "url": "https://github.com/apache/hudi/pull/1576", "merged": true, "mergeCommit": {"oid": "506447fd4fde4cd922f7aa8f4e17a7f06666dc97"}, "closed": true, "closedAt": "2020-05-02T04:37:22Z", "author": {"login": "bvaradar"}, "timelineItems": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABccpxZ9ABqjMyODg0MjMxMTI=", "endCursor": "Y3Vyc29yOnYyOpPPAAABcdOLi3ABqjMyOTQ5NjkxMjc=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNjIzMTUw", "url": "https://github.com/apache/hudi/pull/1576#pullrequestreview-403623150", "createdAt": "2020-04-30T15:18:17Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToxODoxOFrOGOuIvg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxNToyMDowOFrOGOuNqw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4OTE1MA==", "bodyText": "Collections.emptyList()?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418089150", "createdAt": "2020-04-30T15:18:18Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return new ArrayList<>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 8}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDExOA==", "bodyText": "can we break this method up into two, based on the policy? it feels very overloaded now..", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418090118", "createdAt": "2020-04-30T15:19:44Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDQxMQ==", "bodyText": "do we have enough tests that now test when a valid cleaner plan?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418090411", "createdAt": "2020-04-30T15:20:08Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/test/java/org/apache/hudi/table/TestCleaner.java", "diffHunk": "@@ -128,10 +128,8 @@ private void insertFirstBigBatchForClientCleanerTest(HoodieWriteConfig cfg, Hood\n \n     assertFalse(table.getCompletedCommitsTimeline().empty());\n     String instantTime = table.getCompletedCommitsTimeline().getInstants().findFirst().get().getTimestamp();\n+    // We no longer write empty cleaner plans when there are not enough commits present", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAzNzYzNzMx", "url": "https://github.com/apache/hudi/pull/1576#pullrequestreview-403763731", "createdAt": "2020-04-30T18:14:34Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxNDozNFrOGO03Og==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNC0zMFQxODoxNDo0NVrOGO03tQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTM1NA==", "bodyText": "Yes, this particular check is when inserting first batch of data. There are other checks present which validates the effect of valid clean operations", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199354", "createdAt": "2020-04-30T18:14:34Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/test/java/org/apache/hudi/table/TestCleaner.java", "diffHunk": "@@ -128,10 +128,8 @@ private void insertFirstBigBatchForClientCleanerTest(HoodieWriteConfig cfg, Hood\n \n     assertFalse(table.getCompletedCommitsTimeline().empty());\n     String instantTime = table.getCompletedCommitsTimeline().getInstants().findFirst().get().getTimestamp();\n+    // We no longer write empty cleaner plans when there are not enough commits present", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDQxMQ=="}, "originalCommit": null, "originalPosition": 4}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTQ1OA==", "bodyText": "Done", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199458", "createdAt": "2020-04-30T18:14:43Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA5MDExOA=="}, "originalCommit": null, "originalPosition": 6}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE5OTQ3Nw==", "bodyText": "Done", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418199477", "createdAt": "2020-04-30T18:14:45Z", "author": {"login": "bvaradar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,10 +111,15 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n+\n+    if (!newInstantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return new ArrayList<>();", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODA4OTE1MA=="}, "originalCommit": null, "originalPosition": 8}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": null}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA0MjcyNzUy", "url": "https://github.com/apache/hudi/pull/1576#pullrequestreview-404272752", "createdAt": "2020-05-01T16:58:10Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 4, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNjo1ODoxMFrOGPPSoQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wNS0wMVQxNzowNDoxMVrOGPPdmA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjM1Mw==", "bodyText": "move to separate lines?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418632353", "createdAt": "2020-05-01T16:58:10Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 25}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzMjc0Ng==", "bodyText": "we don't need the second check anymore , due to the switch above?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418632746", "createdAt": "2020-05-01T16:59:01Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 38}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNDcxOA==", "bodyText": "rename: getPartitionPathsForIncrementalCleaning() ?", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418634718", "createdAt": "2020-05-01T17:03:16Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return Collections.emptyList();\n+    }\n+\n+    if (config.incrementalCleanerModeEnabled()) {\n+      Option<HoodieInstant> lastClean = hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n       if (lastClean.isPresent()) {\n         HoodieCleanMetadata cleanMetadata = TimelineMetadataUtils\n             .deserializeHoodieCleanMetadata(hoodieTable.getActiveTimeline().getInstantDetails(lastClean.get()).get());\n         if ((cleanMetadata.getEarliestCommitToRetain() != null)\n             && (cleanMetadata.getEarliestCommitToRetain().length() > 0)) {\n-          LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n-              + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n-              + \". New Instant to retain : \" + newInstantToRetain);\n-          return hoodieTable.getCompletedCommitsTimeline().getInstants()\n-              .filter(instant ->\n-                  HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS, cleanMetadata.getEarliestCommitToRetain())\n-                  && HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())\n-              ).flatMap(instant -> {\n-                try {\n-                  HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(), HoodieCommitMetadata.class);\n-                  return commitMetadata.getPartitionToWriteStats().keySet().stream();\n-                } catch (IOException e) {\n-                  throw new HoodieIOException(e.getMessage(), e);\n-                }\n-              }).distinct().collect(Collectors.toList());\n+          return getPartitionPathsForCleaningUsingIncrementalMode(cleanMetadata, instantToRetain);\n         }\n       }\n     }\n-    // Otherwise go to brute force mode of scanning all partitions\n-    return FSUtils.getAllPartitionPaths(hoodieTable.getMetaClient().getFs(),\n-        hoodieTable.getMetaClient().getBasePath(), config.shouldAssumeDatePartitioning());\n+    return scanAllPartitionsForCleaning();\n+  }\n+\n+  /**\n+   * Use Incremental Mode for finding partition paths.\n+   * @param cleanMetadata\n+   * @param newInstantToRetain\n+   * @return\n+   */\n+  private List<String> getPartitionPathsForCleaningUsingIncrementalMode(HoodieCleanMetadata cleanMetadata,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 81}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODYzNTE2MA==", "bodyText": "rename: getPartitionPathsForFullCleaning()", "url": "https://github.com/apache/hudi/pull/1576#discussion_r418635160", "createdAt": "2020-05-01T17:04:11Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/src/main/java/org/apache/hudi/table/action/clean/CleanPlanner.java", "diffHunk": "@@ -111,36 +111,74 @@ public CleanPlanner(HoodieTable<T> hoodieTable, HoodieWriteConfig config) {\n    * @throws IOException when underlying file-system throws this exception\n    */\n   public List<String> getPartitionPathsToClean(Option<HoodieInstant> newInstantToRetain) throws IOException {\n-    if (config.incrementalCleanerModeEnabled() && newInstantToRetain.isPresent()\n-        && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n-      Option<HoodieInstant> lastClean =\n-          hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n+    switch (config.getCleanerPolicy()) {\n+      case KEEP_LATEST_COMMITS: return getPartitionPathsForCleanByCommits(newInstantToRetain);\n+      case KEEP_LATEST_FILE_VERSIONS: return scanAllPartitionsForCleaning();\n+      default: throw new IllegalStateException(\"Unknown Cleaner Policy\");\n+    }\n+  }\n+\n+  /**\n+   * Return partition paths for cleaning by commits mode.\n+   * @param instantToRetain Earliest Instant to retain\n+   * @return list of partitions\n+   * @throws IOException\n+   */\n+  private List<String> getPartitionPathsForCleanByCommits(Option<HoodieInstant> instantToRetain) throws IOException {\n+    if (!instantToRetain.isPresent() && (HoodieCleaningPolicy.KEEP_LATEST_COMMITS == config.getCleanerPolicy())) {\n+      LOG.info(\"No earliest commit to retain. No need to scan partitions !!\");\n+      return Collections.emptyList();\n+    }\n+\n+    if (config.incrementalCleanerModeEnabled()) {\n+      Option<HoodieInstant> lastClean = hoodieTable.getCleanTimeline().filterCompletedInstants().lastInstant();\n       if (lastClean.isPresent()) {\n         HoodieCleanMetadata cleanMetadata = TimelineMetadataUtils\n             .deserializeHoodieCleanMetadata(hoodieTable.getActiveTimeline().getInstantDetails(lastClean.get()).get());\n         if ((cleanMetadata.getEarliestCommitToRetain() != null)\n             && (cleanMetadata.getEarliestCommitToRetain().length() > 0)) {\n-          LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n-              + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n-              + \". New Instant to retain : \" + newInstantToRetain);\n-          return hoodieTable.getCompletedCommitsTimeline().getInstants()\n-              .filter(instant ->\n-                  HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS, cleanMetadata.getEarliestCommitToRetain())\n-                  && HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())\n-              ).flatMap(instant -> {\n-                try {\n-                  HoodieCommitMetadata commitMetadata = HoodieCommitMetadata.fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(), HoodieCommitMetadata.class);\n-                  return commitMetadata.getPartitionToWriteStats().keySet().stream();\n-                } catch (IOException e) {\n-                  throw new HoodieIOException(e.getMessage(), e);\n-                }\n-              }).distinct().collect(Collectors.toList());\n+          return getPartitionPathsForCleaningUsingIncrementalMode(cleanMetadata, instantToRetain);\n         }\n       }\n     }\n-    // Otherwise go to brute force mode of scanning all partitions\n-    return FSUtils.getAllPartitionPaths(hoodieTable.getMetaClient().getFs(),\n-        hoodieTable.getMetaClient().getBasePath(), config.shouldAssumeDatePartitioning());\n+    return scanAllPartitionsForCleaning();\n+  }\n+\n+  /**\n+   * Use Incremental Mode for finding partition paths.\n+   * @param cleanMetadata\n+   * @param newInstantToRetain\n+   * @return\n+   */\n+  private List<String> getPartitionPathsForCleaningUsingIncrementalMode(HoodieCleanMetadata cleanMetadata,\n+      Option<HoodieInstant> newInstantToRetain) {\n+    LOG.warn(\"Incremental Cleaning mode is enabled. Looking up partition-paths that have since changed \"\n+        + \"since last cleaned at \" + cleanMetadata.getEarliestCommitToRetain()\n+        + \". New Instant to retain : \" + newInstantToRetain);\n+    return hoodieTable.getCompletedCommitsTimeline().getInstants().filter(\n+        instant -> HoodieTimeline.compareTimestamps(instant.getTimestamp(), HoodieTimeline.GREATER_THAN_OR_EQUALS,\n+            cleanMetadata.getEarliestCommitToRetain()) && HoodieTimeline.compareTimestamps(instant.getTimestamp(),\n+            HoodieTimeline.LESSER_THAN, newInstantToRetain.get().getTimestamp())).flatMap(instant -> {\n+              try {\n+                HoodieCommitMetadata commitMetadata = HoodieCommitMetadata\n+                    .fromBytes(hoodieTable.getActiveTimeline().getInstantDetails(instant).get(),\n+                        HoodieCommitMetadata.class);\n+                return commitMetadata.getPartitionToWriteStats().keySet().stream();\n+              } catch (IOException e) {\n+                throw new HoodieIOException(e.getMessage(), e);\n+              }\n+            }).distinct().collect(Collectors.toList());\n+  }\n+\n+  /**\n+   * Scan and list all paritions for cleaning.\n+   * @return all partitions paths for the dataset.\n+   * @throws IOException\n+   */\n+  private List<String> scanAllPartitionsForCleaning() throws IOException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 106}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "641532c28daa1ba530550b6b0588cd71d7fa7b90", "author": {"user": {"login": "bvaradar", "name": "Balaji Varadarajan"}}, "url": "https://github.com/apache/hudi/commit/641532c28daa1ba530550b6b0588cd71d7fa7b90", "committedDate": "2020-05-02T04:00:46Z", "message": "[HUDI-850] Avoid unnecessary listings in incremental cleaning mode"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "641532c28daa1ba530550b6b0588cd71d7fa7b90", "author": {"user": {"login": "bvaradar", "name": "Balaji Varadarajan"}}, "url": "https://github.com/apache/hudi/commit/641532c28daa1ba530550b6b0588cd71d7fa7b90", "committedDate": "2020-05-02T04:00:46Z", "message": "[HUDI-850] Avoid unnecessary listings in incremental cleaning mode"}}]}}}, "rateLimit": {"limit": 5000, "remaining": 3050, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}