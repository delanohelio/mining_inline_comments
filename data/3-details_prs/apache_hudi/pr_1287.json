{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0MzY3NzU5MjMx", "number": 1287, "title": "[HUDI-566] Added new test cases for class HoodieTimeline, HoodieDefaultTimeline and HoodieActiveTimeline.", "bodyText": "What is the purpose of the pull request\nAdded new test cases for class HoodieTimeline, HoodieDefaultTimeline and HoodieActiveTimeline.\nVerify this pull request\nThis change added tests and can be verified as follows:\nmvn test --also-make -DfailIfNoTests=false -Dtest=TestHoodieActiveTimeline -pl hudi-common\nCommitter checklist\n\n\n Has a corresponding JIRA in PR title & commit\n\n\n Commit message is descriptive of the change\n\n\n CI is green\n\n\n Necessary doc changes done or have another open PR\n\n\n For large changes, please consider breaking it into sub-tasks under an umbrella JIRA.", "createdAt": "2020-01-27T23:41:41Z", "url": "https://github.com/apache/hudi/pull/1287", "merged": true, "mergeCommit": {"oid": "4de0fcfcb54ac76ed3b6852917588c32fec9bea8"}, "closed": true, "closedAt": "2020-02-05T02:55:05Z", "author": {"login": "prashantwason"}, "timelineItems": {"totalCount": 18, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABb_KV26gFqTM1MDMzMjk4MA==", "endCursor": "Y3Vyc29yOnYyOpPPAAABcBMT3dABqjMwMDgzNzMwNTY=", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzMyOTgw", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350332980", "createdAt": "2020-01-29T18:35:04Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozNTowNFrOFjTJhw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozNTowNFrOFjTJhw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1ODIxNQ==", "bodyText": "What is the reason for this change ? Is this related to test cases ?", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372558215", "createdAt": "2020-01-29T18:35:04Z", "author": {"login": "n3nash"}, "path": "pom.xml", "diffHunk": "@@ -257,11 +257,6 @@\n               <configuration>\n                 <!-- Sets the path to the file which contains the execution data. -->\n                 <destFile>${project.build.directory}/coverage-reports/jacoco-ut.exec</destFile>\n-                <!--", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 20}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzMzNDM3", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350333437", "createdAt": "2020-01-29T18:35:47Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozNTo0N1rOFjTK3Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozNTo0N1rOFjTK3Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1ODU1Nw==", "bodyText": "We need more memory only for integration tests, any reason to increase memory here ?", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372558557", "createdAt": "2020-01-29T18:35:47Z", "author": {"login": "n3nash"}, "path": "pom.xml", "diffHunk": "@@ -110,6 +110,7 @@\n     <spark.bundle.hive.shade.prefix></spark.bundle.hive.shade.prefix>\n     <utilities.bundle.hive.scope>provided</utilities.bundle.hive.scope>\n     <utilities.bundle.hive.shade.prefix></utilities.bundle.hive.shade.prefix>\n+    <argLine>-Xmx1024m -XX:MaxPermSize=256m</argLine>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzM1MjAz", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350335203", "createdAt": "2020-01-29T18:38:35Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozODozNVrOFjTQPw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozODozNVrOFjTQPw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU1OTkzNQ==", "bodyText": "In all other parts of the code we use junit Assert, what is the reason to choose a different way of asserting the value of these get operations ? Also, if one of them fails, what is the exception expected ?", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372559935", "createdAt": "2020-01-29T18:38:35Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 43}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzM1NDM3", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350335437", "createdAt": "2020-01-29T18:38:56Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozODo1NlrOFjTQ-A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODozODo1NlrOFjTQ-A==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDEyMA==", "bodyText": "What is the need to use a Vector here ? Does list not suffice ?", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372560120", "createdAt": "2020-01-29T18:38:56Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 31}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzM2NDA4", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350336408", "createdAt": "2020-01-29T18:40:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0MDozNlrOFjTUHw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0MDozNlrOFjTUHw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MDkyNw==", "bodyText": "Again, what is the use of vector here ?", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372560927", "createdAt": "2020-01-29T18:40:36Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 162}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzM3NDM2", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350337436", "createdAt": "2020-01-29T18:42:10Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0MjoxMFrOFjTXOw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0MjoxMFrOFjTXOw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MTcyMw==", "bodyText": "In general, if you're not checking against the \"commitTime\" of the hoodie instant, can you simply use the ActiveTime.getInstant() to get a valid commit time instead of passing \"1\", \"2\" etc. One of the reasons is to standardize this across all tests - all other tests use commit times in the following format -> \"000\", \"001\" if they want to check against a deterministic commit time in the test..", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372561723", "createdAt": "2020-01-29T18:42:10Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 69}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzM4MTY4", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350338168", "createdAt": "2020-01-29T18:43:18Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0MzoxOVrOFjTZnQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0MzoxOVrOFjTZnQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MjMzMw==", "bodyText": "Are these following lines testing anything ?", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372562333", "createdAt": "2020-01-29T18:43:19Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+\n+    // Etc.\n+    timeline.getInstantDetails(clean);", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 174}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzM5MTM4", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350339138", "createdAt": "2020-01-29T18:44:48Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0NDo0OVrOFjTcfg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0NDo0OVrOFjTcfg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MzA3MA==", "bodyText": "Generally, for any test, you want to have an evaluation function, if you want to test createInstants for eg, then get the number of instants from getAllInstants() and check against the number provided by       timeline.createNewInstant(instant by asserting they are equal.", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372563070", "createdAt": "2020-01-29T18:44:49Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+\n+    // Etc.\n+    timeline.getInstantDetails(clean);\n+    timeline.toString();\n+    clean.toString();\n+  }\n+\n+  @Test\n+  public void testCreateInstants() {", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 180}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzM5ODgw", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350339880", "createdAt": "2020-01-29T18:45:58Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0NTo1OFrOFjTe9Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0NTo1OFrOFjTe9Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2MzcwMQ==", "bodyText": "Please use a valid commitTime here or standardize with \"000\", \"001\" used in other tests.", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372563701", "createdAt": "2020-01-29T18:45:58Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+\n+    // Etc.\n+    timeline.getInstantDetails(clean);\n+    timeline.toString();\n+    clean.toString();\n+  }\n+\n+  @Test\n+  public void testCreateInstants() {\n+    for (HoodieInstant instant : getAllInstants()) {\n+      timeline.createNewInstant(instant);\n+    }\n+  }\n+\n+  @Test\n+  public void testInstantFilenameOperations() {\n+    HoodieInstant instantRequested = new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantInflight = new HoodieInstant(State.INFLIGHT, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantComplete = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantRequested.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantInflight.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantComplete.getFileName()), \"5\");\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsComplete(instantInflight.getFileName()),\n+            instantComplete.getFileName());\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsInflight(instantComplete.getFileName()),\n+            instantInflight.getFileName());\n+  }\n+\n+  @Test\n+  public void testFiltering() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    timeline.setInstants(allInstants);\n+\n+    // getReverseOrderedInstants\n+    Stream<HoodieInstant> instants = timeline.getReverseOrderedInstants();\n+    List<HoodieInstant> v1 = instants.collect(Collectors.toList());\n+    List<HoodieInstant> v2 = sup.get().collect(Collectors.toList());\n+    Collections.reverse(v2);\n+    assertEquals(v1, v2);\n+\n+    BiConsumer<HoodieTimeline, Set<State>> checkFilter = (HoodieTimeline timeline, Set<State> states) -> {\n+      sup.get().filter(i -> states.contains(i.getState())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !states.contains(i.getState())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    checkFilter.accept(timeline.filter(i -> false), Sets.newHashSet());\n+    checkFilter.accept(timeline.filterInflights(), Sets.newHashSet(State.INFLIGHT));\n+    checkFilter.accept(timeline.filterInflightsAndRequested(),\n+            Sets.newHashSet(State.INFLIGHT, State.REQUESTED));\n+\n+    // filterCompletedAndCompactionInstants\n+    // This cannot be done using checkFilter as it involves both states and actions\n+    final HoodieTimeline t1 = timeline.filterCompletedAndCompactionInstants();\n+    final Set<State> states = Sets.newHashSet(State.REQUESTED, State.COMPLETED);\n+    final Set<String> actions = Sets.newHashSet(HoodieTimeline.COMPACTION_ACTION);\n+    sup.get().filter(i -> states.contains(i.getState()) || actions.contains(i.getAction()))\n+        .forEach(i -> assertTrue(t1.containsInstant(i)));\n+    sup.get().filter(i -> !(states.contains(i.getState()) || actions.contains(i.getAction())))\n+        .forEach(i -> assertFalse(t1.containsInstant(i)));\n+\n+    // filterPendingCompactionTimeline\n+    final HoodieTimeline t2 = timeline.filterPendingCompactionTimeline();\n+    sup.get().filter(i -> i.getAction() == HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertTrue(t2.containsInstant(i)));\n+    sup.get().filter(i -> i.getAction() != HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertFalse(t2.containsInstant(i)));\n+  }\n+\n+  private Vector<HoodieInstant> getAllInstants() {\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    Vector<HoodieInstant> allInstants = new Vector<HoodieInstant>();\n+    long startTime = System.currentTimeMillis();\n+    for (State state : State.values()) {\n+      if (state == State.INVALID) {\n+        continue;\n+      }\n+      for (String action : new String[] {HoodieTimeline.COMMIT_ACTION,\n+                                         HoodieTimeline.DELTA_COMMIT_ACTION,\n+                                         HoodieTimeline.CLEAN_ACTION,\n+                                         HoodieTimeline.SAVEPOINT_ACTION,\n+                                         HoodieTimeline.RESTORE_ACTION,\n+                                         HoodieTimeline.ROLLBACK_ACTION,\n+                                         HoodieTimeline.COMPACTION_ACTION,\n+          }) {\n+        allInstants.add(new HoodieInstant(state, action, String.valueOf(startTime++)));", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 261}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzQyMDY1", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350342065", "createdAt": "2020-01-29T18:49:21Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0OToyMVrOFjTlcA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMS0yOVQxODo0OToyMVrOFjTlcA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjU2NTM2MA==", "bodyText": "May be introduce a variable VALID_ACTION_IN_TIMELINE which is a set in the HoodieActiveTimeline class. Tomorrow, if a new action is added, it might be easier to evolve the test ?", "url": "https://github.com/apache/hudi/pull/1287#discussion_r372565360", "createdAt": "2020-01-29T18:49:21Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,242 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+\n+    // Etc.\n+    timeline.getInstantDetails(clean);\n+    timeline.toString();\n+    clean.toString();\n+  }\n+\n+  @Test\n+  public void testCreateInstants() {\n+    for (HoodieInstant instant : getAllInstants()) {\n+      timeline.createNewInstant(instant);\n+    }\n+  }\n+\n+  @Test\n+  public void testInstantFilenameOperations() {\n+    HoodieInstant instantRequested = new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantInflight = new HoodieInstant(State.INFLIGHT, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantComplete = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantRequested.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantInflight.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantComplete.getFileName()), \"5\");\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsComplete(instantInflight.getFileName()),\n+            instantComplete.getFileName());\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsInflight(instantComplete.getFileName()),\n+            instantInflight.getFileName());\n+  }\n+\n+  @Test\n+  public void testFiltering() {\n+    Vector<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    timeline.setInstants(allInstants);\n+\n+    // getReverseOrderedInstants\n+    Stream<HoodieInstant> instants = timeline.getReverseOrderedInstants();\n+    List<HoodieInstant> v1 = instants.collect(Collectors.toList());\n+    List<HoodieInstant> v2 = sup.get().collect(Collectors.toList());\n+    Collections.reverse(v2);\n+    assertEquals(v1, v2);\n+\n+    BiConsumer<HoodieTimeline, Set<State>> checkFilter = (HoodieTimeline timeline, Set<State> states) -> {\n+      sup.get().filter(i -> states.contains(i.getState())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !states.contains(i.getState())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    checkFilter.accept(timeline.filter(i -> false), Sets.newHashSet());\n+    checkFilter.accept(timeline.filterInflights(), Sets.newHashSet(State.INFLIGHT));\n+    checkFilter.accept(timeline.filterInflightsAndRequested(),\n+            Sets.newHashSet(State.INFLIGHT, State.REQUESTED));\n+\n+    // filterCompletedAndCompactionInstants\n+    // This cannot be done using checkFilter as it involves both states and actions\n+    final HoodieTimeline t1 = timeline.filterCompletedAndCompactionInstants();\n+    final Set<State> states = Sets.newHashSet(State.REQUESTED, State.COMPLETED);\n+    final Set<String> actions = Sets.newHashSet(HoodieTimeline.COMPACTION_ACTION);\n+    sup.get().filter(i -> states.contains(i.getState()) || actions.contains(i.getAction()))\n+        .forEach(i -> assertTrue(t1.containsInstant(i)));\n+    sup.get().filter(i -> !(states.contains(i.getState()) || actions.contains(i.getAction())))\n+        .forEach(i -> assertFalse(t1.containsInstant(i)));\n+\n+    // filterPendingCompactionTimeline\n+    final HoodieTimeline t2 = timeline.filterPendingCompactionTimeline();\n+    sup.get().filter(i -> i.getAction() == HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertTrue(t2.containsInstant(i)));\n+    sup.get().filter(i -> i.getAction() != HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertFalse(t2.containsInstant(i)));\n+  }\n+\n+  private Vector<HoodieInstant> getAllInstants() {\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    Vector<HoodieInstant> allInstants = new Vector<HoodieInstant>();\n+    long startTime = System.currentTimeMillis();\n+    for (State state : State.values()) {\n+      if (state == State.INVALID) {\n+        continue;\n+      }\n+      for (String action : new String[] {HoodieTimeline.COMMIT_ACTION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 253}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUwMzQyMjI4", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-350342228", "createdAt": "2020-01-29T18:49:36Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjg3NDU1", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-352687455", "createdAt": "2020-02-04T02:16:06Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjoxNjowN1rOFlGMZw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjoxNjowN1rOFlGMZw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzExMQ==", "bodyText": "nit : s/VALID_ACTION_IN_TIMELINE/VALID_ACTIONS_IN_TIMELINE/", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374443111", "createdAt": "2020-02-04T02:16:07Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTimeline.java", "diffHunk": "@@ -56,6 +56,10 @@\n   String REQUESTED_EXTENSION = \".requested\";\n   String RESTORE_ACTION = \"restore\";\n \n+  String[] VALID_ACTION_IN_TIMELINE = {COMMIT_ACTION, DELTA_COMMIT_ACTION,", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjg3NjAx", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-352687601", "createdAt": "2020-02-04T02:16:38Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjoxNjozOVrOFlGM7Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjoxNjozOVrOFlGM7Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0MzI0NQ==", "bodyText": "Can we avoid these changes ? Might be due to your intellij setup, please check", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374443245", "createdAt": "2020-02-04T02:16:39Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/main/java/org/apache/hudi/common/table/HoodieTimeline.java", "diffHunk": "@@ -111,21 +115,21 @@\n    * view is constructed with this timeline so that file-slice after pending compaction-requested instant-time is also\n    * considered valid. A RT file-system view for reading must then merge the file-slices before and after pending\n    * compaction instant so that all delta-commits are read.\n-   * \n+   *", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 16}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjg5MTM4", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-352689138", "createdAt": "2020-02-04T02:22:42Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjoyMjo0MlrOFlGSJQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjoyMjo0MlrOFlGSJQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDU4MQ==", "bodyText": "Please move this to a different PR", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374444581", "createdAt": "2020-02-04T02:22:42Z", "author": {"login": "n3nash"}, "path": "hudi-hadoop-mr/pom.xml", "diffHunk": "@@ -114,6 +114,10 @@\n         <groupId>org.apache.rat</groupId>\n         <artifactId>apache-rat-plugin</artifactId>\n       </plugin>\n+      <plugin>", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 4}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjg5MjQ2", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-352689246", "createdAt": "2020-02-04T02:23:12Z", "commit": null, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjoyMzoxMlrOFlGSig==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0wMi0wNFQwMjoyMzoxMlrOFlGSig==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQ0NDY4Mg==", "bodyText": "Can we just use List since that's consistently used across the project ? (unless there is a need for vector)", "url": "https://github.com/apache/hudi/pull/1287#discussion_r374444682", "createdAt": "2020-02-04T02:23:12Z", "author": {"login": "n3nash"}, "path": "hudi-common/src/test/java/org/apache/hudi/common/table/string/TestHoodieActiveTimeline.java", "diffHunk": "@@ -164,4 +173,269 @@ public void testTimelineOperations() {\n     assertFalse(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"02\"));\n     assertTrue(\"\", activeCommitTimeline.isBeforeTimelineStarts(\"00\"));\n   }\n+\n+  @Test\n+  public void testTimelineGetOperations() {\n+    List<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    /**\n+     * Helper function to check HoodieTimeline only contains some type of Instant actions.\n+     * @param timeline The HoodieTimeline to check\n+     * @param actions The actions that should be present in the timeline being checked\n+     */\n+    BiConsumer<HoodieTimeline, Set<String>> checkTimeline = (HoodieTimeline timeline, Set<String> actions) -> {\n+      sup.get().filter(i -> actions.contains(i.getAction())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !actions.contains(i.getAction())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    // Test that various types of getXXX operations from HoodieActiveTimeline\n+    // return the correct set of Instant\n+    checkTimeline.accept(timeline.getCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCommitsAndCompactionTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION, HoodieTimeline.COMPACTION_ACTION));\n+    checkTimeline.accept(timeline.getCommitTimeline(), Sets.newHashSet(HoodieTimeline.COMMIT_ACTION));\n+\n+    checkTimeline.accept(timeline.getDeltaCommitTimeline(), Sets.newHashSet(HoodieTimeline.DELTA_COMMIT_ACTION));\n+    checkTimeline.accept(timeline.getCleanerTimeline(), Sets.newHashSet(HoodieTimeline.CLEAN_ACTION));\n+    checkTimeline.accept(timeline.getRollbackTimeline(), Sets.newHashSet(HoodieTimeline.ROLLBACK_ACTION));\n+    checkTimeline.accept(timeline.getRestoreTimeline(), Sets.newHashSet(HoodieTimeline.RESTORE_ACTION));\n+    checkTimeline.accept(timeline.getSavePointTimeline(), Sets.newHashSet(HoodieTimeline.SAVEPOINT_ACTION));\n+    checkTimeline.accept(timeline.getAllCommitsTimeline(),\n+            Sets.newHashSet(HoodieTimeline.COMMIT_ACTION, HoodieTimeline.DELTA_COMMIT_ACTION,\n+                    HoodieTimeline.CLEAN_ACTION, HoodieTimeline.COMPACTION_ACTION,\n+                    HoodieTimeline.SAVEPOINT_ACTION, HoodieTimeline.ROLLBACK_ACTION));\n+\n+    // Get some random Instants\n+    Random rand = new Random();\n+    Set<String> randomInstants = sup.get().filter(i -> rand.nextBoolean())\n+                                          .map(i -> i.getAction())\n+                                          .collect(Collectors.toSet());\n+    checkTimeline.accept(timeline.getTimelineOfActions(randomInstants), randomInstants);\n+  }\n+\n+  @Test\n+  public void testTimelineInstantOperations() {\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    assertEquals(\"No instant present\", timeline.countInstants(), 0);\n+\n+    // revertToInflight\n+    HoodieInstant commit = new HoodieInstant(State.COMPLETED, HoodieTimeline.COMMIT_ACTION, \"1\");\n+    timeline.createNewInstant(commit);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(commit));\n+    HoodieInstant inflight = timeline.revertToInflight(commit);\n+    // revert creates the .requested file\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertTrue(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deleteInflight\n+    timeline.deleteInflight(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(commit));\n+\n+    // deletePending\n+    timeline.createNewInstant(commit);\n+    timeline.createNewInstant(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    timeline.deletePending(inflight);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // deleteCompactionRequested\n+    HoodieInstant compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"2\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 2);\n+    timeline.deleteCompactionRequested(compaction);\n+    timeline = timeline.reload();\n+    assertEquals(timeline.countInstants(), 1);\n+    assertFalse(timeline.containsInstant(inflight));\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(commit));\n+\n+    // transitionCompactionXXXtoYYY and revertCompactionXXXtoYYY\n+    compaction = new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"3\");\n+    timeline.createNewInstant(compaction);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(compaction));\n+    assertTrue(timeline.containsInstant(inflight));\n+    compaction = timeline.revertCompactionInflightToRequested(inflight);\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+    inflight = timeline.transitionCompactionRequestedToInflight(compaction);\n+    compaction = timeline.transitionCompactionInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(compaction));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // transitionCleanXXXtoYYY\n+    HoodieInstant clean = new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"4\");\n+    timeline.saveToCleanRequested(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    inflight = timeline.transitionCleanRequestedToInflight(clean, Option.empty());\n+    timeline = timeline.reload();\n+    assertFalse(timeline.containsInstant(clean));\n+    assertTrue(timeline.containsInstant(inflight));\n+    clean = timeline.transitionCleanInflightToComplete(inflight, Option.empty());\n+    timeline = timeline.reload();\n+    assertTrue(timeline.containsInstant(clean));\n+    assertFalse(timeline.containsInstant(inflight));\n+\n+    // Various states of Instants\n+    HoodieInstant srcInstant = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant otherInstant = HoodieTimeline.getRequestedInstant(srcInstant);\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCleanInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.CLEAN_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionRequestedInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.REQUESTED, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+    otherInstant = HoodieTimeline.getCompactionInflightInstant(\"5\");\n+    assertEquals(otherInstant, new HoodieInstant(State.INFLIGHT, HoodieTimeline.COMPACTION_ACTION, \"5\"));\n+\n+    // containsOrBeforeTimelineStarts\n+    List<HoodieInstant> allInstants = getAllInstants();\n+    timeline = new HoodieActiveTimeline(metaClient, true);\n+    timeline.setInstants(allInstants);\n+\n+    timeline.setInstants(allInstants);\n+    timeline.createNewInstant(new HoodieInstant(State.REQUESTED, HoodieTimeline.COMMIT_ACTION, \"2\"));\n+    allInstants.stream().map(i -> i.getTimestamp()).forEach(s -> assertTrue(timeline.containsOrBeforeTimelineStarts(s)));\n+    assertTrue(timeline.containsOrBeforeTimelineStarts(\"0\"));\n+    assertFalse(timeline.containsOrBeforeTimelineStarts(String.valueOf(System.currentTimeMillis() + 1000)));\n+    assertFalse(timeline.getTimelineHash().isEmpty());\n+  }\n+\n+  @Test\n+  public void testCreateInstants() {\n+    List<HoodieInstant> allInstants = getAllInstants();\n+    for (HoodieInstant instant : allInstants) {\n+      timeline.createNewInstant(instant);\n+    }\n+\n+    timeline = timeline.reload();\n+    for (HoodieInstant instant : allInstants) {\n+      assertTrue(timeline.containsInstant(instant));\n+    }\n+  }\n+\n+  @Test\n+  public void testInstantFilenameOperations() {\n+    HoodieInstant instantRequested = new HoodieInstant(State.REQUESTED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantInflight = new HoodieInstant(State.INFLIGHT, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    HoodieInstant instantComplete = new HoodieInstant(State.COMPLETED, HoodieTimeline.RESTORE_ACTION, \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantRequested.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantInflight.getFileName()), \"5\");\n+    assertEquals(HoodieTimeline.getCommitFromCommitFile(instantComplete.getFileName()), \"5\");\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsComplete(instantInflight.getFileName()),\n+            instantComplete.getFileName());\n+\n+    assertEquals(HoodieTimeline.makeFileNameAsInflight(instantComplete.getFileName()),\n+            instantInflight.getFileName());\n+  }\n+\n+  @Test\n+  public void testFiltering() {\n+    List<HoodieInstant> allInstants = getAllInstants();\n+    Supplier<Stream<HoodieInstant>> sup = () -> allInstants.stream();\n+\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    timeline.setInstants(allInstants);\n+\n+    // getReverseOrderedInstants\n+    Stream<HoodieInstant> instants = timeline.getReverseOrderedInstants();\n+    List<HoodieInstant> v1 = instants.collect(Collectors.toList());\n+    List<HoodieInstant> v2 = sup.get().collect(Collectors.toList());\n+    Collections.reverse(v2);\n+    assertEquals(v1, v2);\n+\n+    /**\n+     * Helper function to check HoodieTimeline only contains some type of Instant states.\n+     * @param timeline The HoodieTimeline to check\n+     * @param states The states that should be present in the timeline being checked\n+     */\n+    BiConsumer<HoodieTimeline, Set<State>> checkFilter = (HoodieTimeline timeline, Set<State> states) -> {\n+      sup.get().filter(i -> states.contains(i.getState())).forEach(i -> assertTrue(timeline.containsInstant(i)));\n+      sup.get().filter(i -> !states.contains(i.getState())).forEach(i -> assertFalse(timeline.containsInstant(i)));\n+    };\n+\n+    checkFilter.accept(timeline.filter(i -> false), Sets.newHashSet());\n+    checkFilter.accept(timeline.filterInflights(), Sets.newHashSet(State.INFLIGHT));\n+    checkFilter.accept(timeline.filterInflightsAndRequested(),\n+            Sets.newHashSet(State.INFLIGHT, State.REQUESTED));\n+\n+    // filterCompletedAndCompactionInstants\n+    // This cannot be done using checkFilter as it involves both states and actions\n+    final HoodieTimeline t1 = timeline.filterCompletedAndCompactionInstants();\n+    final Set<State> states = Sets.newHashSet(State.REQUESTED, State.COMPLETED);\n+    final Set<String> actions = Sets.newHashSet(HoodieTimeline.COMPACTION_ACTION);\n+    sup.get().filter(i -> states.contains(i.getState()) || actions.contains(i.getAction()))\n+        .forEach(i -> assertTrue(t1.containsInstant(i)));\n+    sup.get().filter(i -> !(states.contains(i.getState()) || actions.contains(i.getAction())))\n+        .forEach(i -> assertFalse(t1.containsInstant(i)));\n+\n+    // filterPendingCompactionTimeline\n+    final HoodieTimeline t2 = timeline.filterPendingCompactionTimeline();\n+    sup.get().filter(i -> i.getAction() == HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertTrue(t2.containsInstant(i)));\n+    sup.get().filter(i -> i.getAction() != HoodieTimeline.COMPACTION_ACTION)\n+        .forEach(i -> assertFalse(t2.containsInstant(i)));\n+  }\n+\n+  /**\n+   * Returns an exhaustive list of all possible HoodieInstant.\n+   * @return list of HoodieInstant\n+   */\n+  private List<HoodieInstant> getAllInstants() {\n+    timeline = new HoodieActiveTimeline(metaClient);\n+    Vector<HoodieInstant> allInstants = new Vector<HoodieInstant>();", "state": "SUBMITTED", "replyTo": null, "originalCommit": null, "originalPosition": 269}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUyNjg5MzY1", "url": "https://github.com/apache/hudi/pull/1287#pullrequestreview-352689365", "createdAt": "2020-02-04T02:23:41Z", "commit": null, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "PullRequestCommit", "commit": {"oid": "952391dee72c7bb8747c0096ac399edc09b92f2a", "author": {"user": {"login": "prashantwason", "name": "Prashant Wason"}}, "url": "https://github.com/apache/hudi/commit/952391dee72c7bb8747c0096ac399edc09b92f2a", "committedDate": "2020-02-05T01:53:31Z", "message": "[HUDI-566] Added new test cases for class HoodieTimeline, HoodieDefaultTimeline and HoodieActiveTimeline."}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": null, "afterCommit": {"oid": "952391dee72c7bb8747c0096ac399edc09b92f2a", "author": {"user": {"login": "prashantwason", "name": "Prashant Wason"}}, "url": "https://github.com/apache/hudi/commit/952391dee72c7bb8747c0096ac399edc09b92f2a", "committedDate": "2020-02-05T01:53:31Z", "message": "[HUDI-566] Added new test cases for class HoodieTimeline, HoodieDefaultTimeline and HoodieActiveTimeline."}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4158, "cost": 1, "resetAt": "2021-10-28T16:48:13Z"}}}