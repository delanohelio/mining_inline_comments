{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTA4MzA4NDU5", "number": 2200, "reviewThreads": {"totalCount": 9, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoxODoyMFrOEy1ZwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMTo0MzowOFrOEz-IzQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzM5MjAxOnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "isResolved": true, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoxODoyMFrOHpsWxw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoxODoyMFrOHpsWxw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MDM5MQ==", "bodyText": "would this change the above behavior? above would also get row.get", "url": "https://github.com/apache/hudi/pull/2200#discussion_r513480391", "createdAt": "2020-10-28T14:18:20Z", "author": {"login": "leesf"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CustomKeyGenerator.java", "diffHunk": "@@ -94,27 +82,18 @@ private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n       PartitionKeyType keyType = PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n       switch (keyType) {\n         case SIMPLE:\n-          if (record.isPresent()) {\n-            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n-          } else {\n-            partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n-          }\n+          partitionPath.append(new SimpleKeyGenerator(config, partitionPathField).getPartitionPath(record));", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9edd7ea4edde76b31e61ec44d75401d939d4275f"}, "originalPosition": 50}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzQwNjQ0OnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-spark-client/pom.xml", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoyMToxN1rOHpsf_A==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMToyMTo1M1rOHqDSSw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mjc0OA==", "bodyText": "does it exist before\uff1f", "url": "https://github.com/apache/hudi/pull/2200#discussion_r513482748", "createdAt": "2020-10-28T14:21:17Z", "author": {"login": "leesf"}, "path": "hudi-client/hudi-spark-client/pom.xml", "diffHunk": "@@ -31,6 +31,13 @@\n   <packaging>jar</packaging>\n \n   <dependencies>\n+    <!-- Scala -->\n+    <dependency>\n+      <groupId>org.scala-lang</groupId>\n+      <artifactId>scala-library</artifactId>\n+      <version>${scala.version}</version>\n+    </dependency>\n+", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9edd7ea4edde76b31e61ec44d75401d939d4275f"}, "originalPosition": 10}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg1NjA3NQ==", "bodyText": "does it exist before\uff1f\nno, I moved some utils(AvroConversionHelper,AvroConversionUtils) from hudi-spark, they are implemented in scala.", "url": "https://github.com/apache/hudi/pull/2200#discussion_r513856075", "createdAt": "2020-10-29T01:21:53Z", "author": {"login": "wangxianghu"}, "path": "hudi-client/hudi-spark-client/pom.xml", "diffHunk": "@@ -31,6 +31,13 @@\n   <packaging>jar</packaging>\n \n   <dependencies>\n+    <!-- Scala -->\n+    <dependency>\n+      <groupId>org.scala-lang</groupId>\n+      <artifactId>scala-library</artifactId>\n+      <version>${scala.version}</version>\n+    </dependency>\n+", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4Mjc0OA=="}, "originalCommit": {"oid": "9edd7ea4edde76b31e61ec44d75401d939d4275f"}, "originalPosition": 10}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIxNzQxMzQxOnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/SparkCustomKeyGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOFQxNDoyMjo0MVrOHpskgA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0yOVQwMToyMzowNFrOHqDUuQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MzkwNA==", "bodyText": "looks like the above logic move to this place.", "url": "https://github.com/apache/hudi/pull/2200#discussion_r513483904", "createdAt": "2020-10-28T14:22:41Z", "author": {"login": "leesf"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/SparkCustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+import org.apache.hudi.keygen.common.KeyGeneratorOptions;\n+import org.apache.spark.sql.Row;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields. Similarly partition path can be configured to have multiple\n+ * fields or only one field. This class expects value for prop \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider: 1. If you want to customize some partition path field on a timestamp basis, you can use field1:timestampBased 2. If you simply want to have the value of your configured\n+ * field in the partition path, use field1:simple 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class SparkCustomKeyGenerator extends BaseSparkKeyGenerator {\n+\n+  private CustomKeyGenerator customKeyGenerator;\n+\n+  public SparkCustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.recordKeyFields = Arrays.stream(props.getString(KeyGeneratorOptions.RECORDKEY_FIELD_OPT_KEY).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields = Arrays.stream(props.getString(KeyGeneratorOptions.PARTITIONPATH_FIELD_OPT_KEY).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    customKeyGenerator = new CustomKeyGenerator(props);\n+  }\n+\n+  @Override\n+  public String getRecordKey(GenericRecord record) {\n+    return customKeyGenerator.getRecordKey(record);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record) {\n+    return customKeyGenerator.getPartitionPath(record);\n+  }\n+\n+  @Override\n+  public String getRecordKey(Row row) {\n+    validateRecordKeyFields();\n+    return getRecordKeyFields().size() == 1\n+        ? new SparkSimpleKeyGenerator(config).getRecordKey(row)\n+        : new SparkComplexKeyGenerator(config).getRecordKey(row);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(Row row) {\n+    return getPartitionPath(Option.empty(), Option.of(row));\n+  }\n+\n+  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n+    if (getPartitionPathFields() == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n+      return \"\";\n+    }\n+    for (String field : getPartitionPathFields()) {\n+      String[] fieldWithType = field.split(customKeyGenerator.getSplitRegex());\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      CustomKeyGenerator.PartitionKeyType keyType = CustomKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n+      switch (keyType) {\n+        case SIMPLE:\n+          if (record.isPresent()) {\n+            partitionPath.append(new SparkSimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n+          } else {\n+            partitionPath.append(new SparkSimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n+          }\n+          break;\n+        case TIMESTAMP:\n+          try {\n+            if (record.isPresent()) {\n+              partitionPath.append(new SparkTimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n+            } else {\n+              partitionPath.append(new SparkTimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n+            }", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9edd7ea4edde76b31e61ec44d75401d939d4275f"}, "originalPosition": 114}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzg1NjY5Nw==", "bodyText": "looks like the above logic move to this place.\n\nyes, moved here", "url": "https://github.com/apache/hudi/pull/2200#discussion_r513856697", "createdAt": "2020-10-29T01:23:04Z", "author": {"login": "wangxianghu"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/SparkCustomKeyGenerator.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.keygen;\n+\n+import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.common.util.Option;\n+import org.apache.hudi.exception.HoodieDeltaStreamerException;\n+import org.apache.hudi.exception.HoodieKeyException;\n+import org.apache.hudi.keygen.common.KeyGeneratorOptions;\n+import org.apache.spark.sql.Row;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * This is a generic implementation of KeyGenerator where users can configure record key as a single field or a combination of fields. Similarly partition path can be configured to have multiple\n+ * fields or only one field. This class expects value for prop \"hoodie.datasource.write.partitionpath.field\" in a specific format. For example:\n+ *\n+ * properties.put(\"hoodie.datasource.write.partitionpath.field\", \"field1:PartitionKeyType1,field2:PartitionKeyType2\").\n+ *\n+ * The complete partition path is created as <value for field1 basis PartitionKeyType1>/<value for field2 basis PartitionKeyType2> and so on.\n+ *\n+ * Few points to consider: 1. If you want to customize some partition path field on a timestamp basis, you can use field1:timestampBased 2. If you simply want to have the value of your configured\n+ * field in the partition path, use field1:simple 3. If you want your table to be non partitioned, simply leave it as blank.\n+ *\n+ * RecordKey is internally generated using either SimpleKeyGenerator or ComplexKeyGenerator.\n+ */\n+public class SparkCustomKeyGenerator extends BaseSparkKeyGenerator {\n+\n+  private CustomKeyGenerator customKeyGenerator;\n+\n+  public SparkCustomKeyGenerator(TypedProperties props) {\n+    super(props);\n+    this.recordKeyFields = Arrays.stream(props.getString(KeyGeneratorOptions.RECORDKEY_FIELD_OPT_KEY).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    this.partitionPathFields = Arrays.stream(props.getString(KeyGeneratorOptions.PARTITIONPATH_FIELD_OPT_KEY).split(\",\")).map(String::trim).collect(Collectors.toList());\n+    customKeyGenerator = new CustomKeyGenerator(props);\n+  }\n+\n+  @Override\n+  public String getRecordKey(GenericRecord record) {\n+    return customKeyGenerator.getRecordKey(record);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(GenericRecord record) {\n+    return customKeyGenerator.getPartitionPath(record);\n+  }\n+\n+  @Override\n+  public String getRecordKey(Row row) {\n+    validateRecordKeyFields();\n+    return getRecordKeyFields().size() == 1\n+        ? new SparkSimpleKeyGenerator(config).getRecordKey(row)\n+        : new SparkComplexKeyGenerator(config).getRecordKey(row);\n+  }\n+\n+  @Override\n+  public String getPartitionPath(Row row) {\n+    return getPartitionPath(Option.empty(), Option.of(row));\n+  }\n+\n+  private String getPartitionPath(Option<GenericRecord> record, Option<Row> row) {\n+    if (getPartitionPathFields() == null) {\n+      throw new HoodieKeyException(\"Unable to find field names for partition path in cfg\");\n+    }\n+\n+    String partitionPathField;\n+    StringBuilder partitionPath = new StringBuilder();\n+\n+    //Corresponds to no partition case\n+    if (getPartitionPathFields().size() == 1 && getPartitionPathFields().get(0).isEmpty()) {\n+      return \"\";\n+    }\n+    for (String field : getPartitionPathFields()) {\n+      String[] fieldWithType = field.split(customKeyGenerator.getSplitRegex());\n+      if (fieldWithType.length != 2) {\n+        throw new HoodieKeyException(\"Unable to find field names for partition path in proper format\");\n+      }\n+\n+      partitionPathField = fieldWithType[0];\n+      CustomKeyGenerator.PartitionKeyType keyType = CustomKeyGenerator.PartitionKeyType.valueOf(fieldWithType[1].toUpperCase());\n+      switch (keyType) {\n+        case SIMPLE:\n+          if (record.isPresent()) {\n+            partitionPath.append(new SparkSimpleKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n+          } else {\n+            partitionPath.append(new SparkSimpleKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n+          }\n+          break;\n+        case TIMESTAMP:\n+          try {\n+            if (record.isPresent()) {\n+              partitionPath.append(new SparkTimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(record.get()));\n+            } else {\n+              partitionPath.append(new SparkTimestampBasedKeyGenerator(config, partitionPathField).getPartitionPath(row.get()));\n+            }", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ4MzkwNA=="}, "originalCommit": {"oid": "9edd7ea4edde76b31e61ec44d75401d939d4275f"}, "originalPosition": 114}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNTM2OTI2OnYy", "diffSide": "RIGHT", "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/BootstrapCommand.java", "isResolved": false, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzoxMzozN1rOHq6spg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwMzozMjozM1rOHq71Tg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc2Mzk0Mg==", "bodyText": "This is what I meant in the first comment. we have to be backwards compatible with existing clients. It will be disruptive change for everyone to reconfigure all their jobs. Can we avoid renaming of keygenerator classes or changing their package names", "url": "https://github.com/apache/hudi/pull/2200#discussion_r514763942", "createdAt": "2020-10-30T03:13:37Z", "author": {"login": "vinothchandar"}, "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/BootstrapCommand.java", "diffHunk": "@@ -68,7 +68,7 @@ public String bootstrap(\n           help = \"Bootstrap Index Class\") final String bootstrapIndexClass,\n       @CliOption(key = {\"selectorClass\"}, unspecifiedDefaultValue = \"org.apache.hudi.client.bootstrap.selector.MetadataOnlyBootstrapModeSelector\",\n           help = \"Selector class for bootstrap\") final String selectorClass,\n-      @CliOption(key = {\"keyGeneratorClass\"}, unspecifiedDefaultValue = \"org.apache.hudi.keygen.SimpleKeyGenerator\",\n+      @CliOption(key = {\"keyGeneratorClass\"}, unspecifiedDefaultValue = \"org.apache.hudi.keygen.SparkSimpleKeyGenerator\",", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "9a9c9d2b26863b4165d93f9ffc85f61a80ec21f9"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc4MjU0Mg==", "bodyText": "This is what I meant in the first comment. we have to be backwards compatible with existing clients. It will be disruptive change for everyone to reconfigure all their jobs. Can we avoid renaming of keygenerator classes or changing their package names\n\ngot it.\nfor speak, we leave the ket generator names untouched and rename it for other engines.", "url": "https://github.com/apache/hudi/pull/2200#discussion_r514782542", "createdAt": "2020-10-30T03:32:33Z", "author": {"login": "wangxianghu"}, "path": "hudi-cli/src/main/java/org/apache/hudi/cli/commands/BootstrapCommand.java", "diffHunk": "@@ -68,7 +68,7 @@ public String bootstrap(\n           help = \"Bootstrap Index Class\") final String bootstrapIndexClass,\n       @CliOption(key = {\"selectorClass\"}, unspecifiedDefaultValue = \"org.apache.hudi.client.bootstrap.selector.MetadataOnlyBootstrapModeSelector\",\n           help = \"Selector class for bootstrap\") final String selectorClass,\n-      @CliOption(key = {\"keyGeneratorClass\"}, unspecifiedDefaultValue = \"org.apache.hudi.keygen.SimpleKeyGenerator\",\n+      @CliOption(key = {\"keyGeneratorClass\"}, unspecifiedDefaultValue = \"org.apache.hudi.keygen.SparkSimpleKeyGenerator\",", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc2Mzk0Mg=="}, "originalCommit": {"oid": "9a9c9d2b26863b4165d93f9ffc85f61a80ec21f9"}, "originalPosition": 5}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyNjQ3ODIxOnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CommonComplexKeyGenerator.java", "isResolved": false, "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODo1Mzo1NFrOHrGEwQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQwODo1Mzo1NFrOHrGEwQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDk1MDMzNw==", "bodyText": "Those CommonKeyGenerators can be used for both flink and java engine.\nI will add some flink specific KeyGenerators  when flink implementation(#2176) is  landed", "url": "https://github.com/apache/hudi/pull/2200#discussion_r514950337", "createdAt": "2020-10-30T08:53:54Z", "author": {"login": "wangxianghu"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CommonComplexKeyGenerator.java", "diffHunk": "@@ -0,0 +1,50 @@\n+/*", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 1}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyODI5ODE5OnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/exception/HoodieKeyGenerateException.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQxNjo0ODoyN1rOHrXdQA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMzo0MToxNFrOHrjC5w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNTEzNg==", "bodyText": "rename: HoodieKeyGeneratorException", "url": "https://github.com/apache/hudi/pull/2200#discussion_r515235136", "createdAt": "2020-10-30T16:48:27Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/exception/HoodieKeyGenerateException.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.exception;\n+\n+/**\n+ * Exception thrown for any higher level errors when {@link org.apache.hudi.keygen.KeyGeneratorInterface} is generating\n+ * a {@link org.apache.hudi.common.model.HoodieKey}.\n+ */\n+public class HoodieKeyGenerateException extends HoodieException {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 24}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNDk5OQ==", "bodyText": "rename: HoodieKeyGeneratorException\n\ndone", "url": "https://github.com/apache/hudi/pull/2200#discussion_r515424999", "createdAt": "2020-10-30T23:41:14Z", "author": {"login": "wangxianghu"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/exception/HoodieKeyGenerateException.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.exception;\n+\n+/**\n+ * Exception thrown for any higher level errors when {@link org.apache.hudi.keygen.KeyGeneratorInterface} is generating\n+ * a {@link org.apache.hudi.common.model.HoodieKey}.\n+ */\n+public class HoodieKeyGenerateException extends HoodieException {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTIzNTEzNg=="}, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 24}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTMwMzQ4OnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "isResolved": false, "comments": {"totalCount": 3, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMTo0MDo0NFrOHrhNqg==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wMlQyMToxMjowN1rOHsVy8w==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5NDk4Ng==", "bodyText": "what the user sets is is actually DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(). So might be good to avoid duplicating this in KeyGeneratorOptions.RECORDKEY_FIELD_OPT_KEY . can we revert?", "url": "https://github.com/apache/hudi/pull/2200#discussion_r515394986", "createdAt": "2020-10-30T21:40:44Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -18,38 +17,38 @@\n \n package org.apache.hudi.keygen;\n \n-import org.apache.hudi.DataSourceWriteOptions;\n-import org.apache.hudi.common.config.TypedProperties;\n-\n import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.keygen.constant.KeyGeneratorOptions;\n+import org.apache.spark.sql.Row;\n \n import java.util.Arrays;\n import java.util.stream.Collectors;\n-import org.apache.spark.sql.Row;\n \n /**\n  * Complex key generator, which takes names of fields to be used for recordKey and partitionPath as configs.\n  */\n public class ComplexKeyGenerator extends BuiltinKeyGenerator {\n \n-  public static final String DEFAULT_RECORD_KEY_SEPARATOR = \":\";\n+  private CommonComplexKeyGenerator commonComplexKeyGenerator;\n \n   public ComplexKeyGenerator(TypedProperties props) {\n     super(props);\n-    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY())\n+    this.recordKeyFields = Arrays.stream(props.getString(KeyGeneratorOptions.RECORDKEY_FIELD_OPT_KEY)", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNjg1NQ==", "bodyText": "what the user sets is is actually DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY(). So might be good to avoid duplicating this in KeyGeneratorOptions.RECORDKEY_FIELD_OPT_KEY . can we revert?\n\nDataSourceWriteOptions has some hive and spark references in it.  it is a little inconvenient to move to hudi-client-common. should I refactor DataSourceWriteOptions ?", "url": "https://github.com/apache/hudi/pull/2200#discussion_r515426855", "createdAt": "2020-10-30T23:51:25Z", "author": {"login": "wangxianghu"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -18,38 +17,38 @@\n \n package org.apache.hudi.keygen;\n \n-import org.apache.hudi.DataSourceWriteOptions;\n-import org.apache.hudi.common.config.TypedProperties;\n-\n import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.keygen.constant.KeyGeneratorOptions;\n+import org.apache.spark.sql.Row;\n \n import java.util.Arrays;\n import java.util.stream.Collectors;\n-import org.apache.spark.sql.Row;\n \n /**\n  * Complex key generator, which takes names of fields to be used for recordKey and partitionPath as configs.\n  */\n public class ComplexKeyGenerator extends BuiltinKeyGenerator {\n \n-  public static final String DEFAULT_RECORD_KEY_SEPARATOR = \":\";\n+  private CommonComplexKeyGenerator commonComplexKeyGenerator;\n \n   public ComplexKeyGenerator(TypedProperties props) {\n     super(props);\n-    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY())\n+    this.recordKeyFields = Arrays.stream(props.getString(KeyGeneratorOptions.RECORDKEY_FIELD_OPT_KEY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5NDk4Ng=="}, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 48}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjI1NjQ5OQ==", "bodyText": "ah ok. no problem. this makes sense", "url": "https://github.com/apache/hudi/pull/2200#discussion_r516256499", "createdAt": "2020-11-02T21:12:07Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -18,38 +17,38 @@\n \n package org.apache.hudi.keygen;\n \n-import org.apache.hudi.DataSourceWriteOptions;\n-import org.apache.hudi.common.config.TypedProperties;\n-\n import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.keygen.constant.KeyGeneratorOptions;\n+import org.apache.spark.sql.Row;\n \n import java.util.Arrays;\n import java.util.stream.Collectors;\n-import org.apache.spark.sql.Row;\n \n /**\n  * Complex key generator, which takes names of fields to be used for recordKey and partitionPath as configs.\n  */\n public class ComplexKeyGenerator extends BuiltinKeyGenerator {\n \n-  public static final String DEFAULT_RECORD_KEY_SEPARATOR = \":\";\n+  private CommonComplexKeyGenerator commonComplexKeyGenerator;\n \n   public ComplexKeyGenerator(TypedProperties props) {\n     super(props);\n-    this.recordKeyFields = Arrays.stream(props.getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY())\n+    this.recordKeyFields = Arrays.stream(props.getString(KeyGeneratorOptions.RECORDKEY_FIELD_OPT_KEY)", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5NDk4Ng=="}, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 48}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTMwNDE2OnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMTo0MTowMVrOHrhOEA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMzo0MToyNlrOHrjDDA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5NTA4OA==", "bodyText": "can all these members be final (intellij tip)", "url": "https://github.com/apache/hudi/pull/2200#discussion_r515395088", "createdAt": "2020-10-30T21:41:01Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -18,38 +17,38 @@\n \n package org.apache.hudi.keygen;\n \n-import org.apache.hudi.DataSourceWriteOptions;\n-import org.apache.hudi.common.config.TypedProperties;\n-\n import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.keygen.constant.KeyGeneratorOptions;\n+import org.apache.spark.sql.Row;\n \n import java.util.Arrays;\n import java.util.stream.Collectors;\n-import org.apache.spark.sql.Row;\n \n /**\n  * Complex key generator, which takes names of fields to be used for recordKey and partitionPath as configs.\n  */\n public class ComplexKeyGenerator extends BuiltinKeyGenerator {\n \n-  public static final String DEFAULT_RECORD_KEY_SEPARATOR = \":\";\n+  private CommonComplexKeyGenerator commonComplexKeyGenerator;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 43}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNTAzNg==", "bodyText": "can all these members be final (intellij tip)\n\ndone", "url": "https://github.com/apache/hudi/pull/2200#discussion_r515425036", "createdAt": "2020-10-30T23:41:26Z", "author": {"login": "wangxianghu"}, "path": "hudi-client/hudi-spark-client/src/main/java/org/apache/hudi/keygen/ComplexKeyGenerator.java", "diffHunk": "@@ -18,38 +17,38 @@\n \n package org.apache.hudi.keygen;\n \n-import org.apache.hudi.DataSourceWriteOptions;\n-import org.apache.hudi.common.config.TypedProperties;\n-\n import org.apache.avro.generic.GenericRecord;\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.keygen.constant.KeyGeneratorOptions;\n+import org.apache.spark.sql.Row;\n \n import java.util.Arrays;\n import java.util.stream.Collectors;\n-import org.apache.spark.sql.Row;\n \n /**\n  * Complex key generator, which takes names of fields to be used for recordKey and partitionPath as configs.\n  */\n public class ComplexKeyGenerator extends BuiltinKeyGenerator {\n \n-  public static final String DEFAULT_RECORD_KEY_SEPARATOR = \":\";\n+  private CommonComplexKeyGenerator commonComplexKeyGenerator;", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5NTA4OA=="}, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 43}]}}, {"id": "MDIzOlB1bGxSZXF1ZXN0UmV2aWV3VGhyZWFkMzIyOTMwODkzOnYy", "diffSide": "RIGHT", "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CommonTimestampBasedKeyGenerator.java", "isResolved": true, "comments": {"totalCount": 2, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMTo0MzowOFrOHrhREA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0zMFQyMzo0MTozNVrOHrjDKA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5NTg1Ng==", "bodyText": "all the Common generators. are avro based. So let's name them like SimpleAvroKeyGenerator , TimestampBasedAvroKeyGenerator ?", "url": "https://github.com/apache/hudi/pull/2200#discussion_r515395856", "createdAt": "2020-10-30T21:43:08Z", "author": {"login": "vinothchandar"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CommonTimestampBasedKeyGenerator.java", "diffHunk": "@@ -46,15 +42,11 @@\n \n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.SECONDS;\n-import static org.apache.hudi.keygen.KeyGenUtils.DEFAULT_PARTITION_PATH;\n-import static org.apache.hudi.keygen.KeyGenUtils.EMPTY_RECORDKEY_PLACEHOLDER;\n-import static org.apache.hudi.keygen.KeyGenUtils.NULL_RECORDKEY_PLACEHOLDER;\n \n /**\n- * Key generator, that relies on timestamps for partitioning field. Still picks record key by name.\n+ * Common Key generator, that relies on timestamps for partitioning field. Still picks record key by name.\n  */\n-public class TimestampBasedKeyGenerator extends SimpleKeyGenerator {\n-\n+public class CommonTimestampBasedKeyGenerator extends CommonSimpleKeyGenerator {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 58}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQyNTA2NA==", "bodyText": "all the Common generators. are avro based. So let's name them like SimpleAvroKeyGenerator , TimestampBasedAvroKeyGenerator ?\n\ndone", "url": "https://github.com/apache/hudi/pull/2200#discussion_r515425064", "createdAt": "2020-10-30T23:41:35Z", "author": {"login": "wangxianghu"}, "path": "hudi-client/hudi-client-common/src/main/java/org/apache/hudi/keygen/CommonTimestampBasedKeyGenerator.java", "diffHunk": "@@ -46,15 +42,11 @@\n \n import static java.util.concurrent.TimeUnit.MILLISECONDS;\n import static java.util.concurrent.TimeUnit.SECONDS;\n-import static org.apache.hudi.keygen.KeyGenUtils.DEFAULT_PARTITION_PATH;\n-import static org.apache.hudi.keygen.KeyGenUtils.EMPTY_RECORDKEY_PLACEHOLDER;\n-import static org.apache.hudi.keygen.KeyGenUtils.NULL_RECORDKEY_PLACEHOLDER;\n \n /**\n- * Key generator, that relies on timestamps for partitioning field. Still picks record key by name.\n+ * Common Key generator, that relies on timestamps for partitioning field. Still picks record key by name.\n  */\n-public class TimestampBasedKeyGenerator extends SimpleKeyGenerator {\n-\n+public class CommonTimestampBasedKeyGenerator extends CommonSimpleKeyGenerator {", "state": "SUBMITTED", "replyTo": {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTM5NTg1Ng=="}, "originalCommit": {"oid": "6be7a546e1c4ef26be51602c1ce9a08d88250d74"}, "originalPosition": 58}]}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4124, "cost": 1, "resetAt": "2021-11-12T09:44:50Z"}}}