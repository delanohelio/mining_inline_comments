{"data": {"repository": {"pullRequest": {"id": "MDExOlB1bGxSZXF1ZXN0NTAxMDc1MTA3", "number": 2168, "title": "[HUDI-1331] Adding support for validating entire dataset and long running tests in test suite framework", "bodyText": "What is the purpose of the pull request\n\nAdding support for validating entire dataset and long running tests in test suite framework. The entire dag declared can be run repeatedly for N no of times. Two config params can be set for repeated test runs, namely --num-rounds and --delay-between-rounds-mins. So, lets say your dag looks like this\n\ninsert 1000\nupdate 200\nvalidate\n\nand the configs are set as follows.\n--num-rounds = 5\n--delay-between-rounds-mins = 10\nThis will essentially run the (insert, update) for every 10 mins for 5 times.\nSince validation can't be statically defined for no of expected records, a new validation node is introduced.\nValidateDatasetNode: will read entire input batch and compare w/ hudi contents. (row equality comparison).\nNo config needs to be set by default. But there is an optional config called \"delete_input_data\". If set, after validation is complete, input data will be deleted. This will come in handy when running long running tests.\nAn example for validation w/ delete_input_data set.\nRound1: \n    insert => inputPath/batch1\n    upsert -> inputPath/batch2\n    Validate with delete_input_data = true\n              Validates contents from batch1 and batch2 are in hudi and ensures Row equality\n              Since \"delete_input_data\" is set, deletes contents from batch1 and batch2.\nRound2:    \n    insert => inputPath/batch3\n    upsert -> inputPath/batch4\n    Validate with delete_input_data = true\n              Validates contents from batch3 and batch4 are in hudi and ensures Row equality\n              Since \"delete_input_data\" is set, deletes contents from batch3 and batch4.\nRound3:    \n    insert => inputPath/batch5\n    upsert -> inputPath/batch6\n    Validate with delete_input_data = true\n              Validates contents from batch5 and batch6 are in hudi and ensures Row equality\n              Since \"delete_input_data\" is set, deletes contents from batch5 and batch6.   \n.\n.\n\nDeleting input after reach round will keep the input size in control if we are trying a long running job along w/ validation.\nAn example for validation w/o any delete flag set.\nRound1: \n    insert => inputPath/batch1\n    upsert -> inputPath/batch2\n    Validate: validates contents from batch1 and batch2 are in hudi and ensures Row equality\nRound2:    \n    insert => inputPath/batch3\n    upsert -> inputPath/batch4\n    Validate: validates contents from batch1 to batch4 are in hudi and ensures Row equality\nRound3:    \n    insert => inputPath/batch5\n    upsert -> inputPath/batch6\n    Validate: validates contents from batch1 and batch6 are in hudi and ensures Row equality\n.\n.\n\nYou could also have validations in the middle of your dag and not set the \"delete_input_data\". But set it only in the\nlast node in the dag so that at the end of every round data is cleaned up.\nRound1: \n    insert => inputPath/batch1\n    upsert -> inputPath/batch2\n    Validate: validates contents from batch1 and batch2 are in hudi and ensures Row equality\n    insert => inputPath/batch3\n    upsert -> inputPath/batch4\n    Validate with delete_input_data = true\n             Validates contents from batch1 to batch4 are in hudi and ensures Row equality\n             since \"delete_input_data\" is set to true, this node deletes contents from batch1 and batch4.\nRound2: \n    insert => inputPath/batch5\n    upsert -> inputPath/batch6\n    Validate: validates contents from batch5 and batch6 are in hudi and ensures Row equality\n    insert => inputPath/batch7\n    upsert -> inputPath/batch8\n    Validate: validates contents from batch5 to batch8 are in hudi and ensures Row equality\n             since \"delete_input_data\" is set to true, this node deletes contents from batch5 to batch8.\nRound3: \n    insert => inputPath/batch9\n    upsert -> inputPath/batch10\n    Validate: validates contents from batch9 and batch10 are in hudi and ensures Row equality\n    insert => inputPath/batch11\n    upsert -> inputPath/batch12\n     Validate with delete_input_data = true\n             Validates contents from batch9 to batch12 are in hudi and ensures Row equality\n             Set \"delete_input_data\" to true. so this node deletes contents from batch9 to batch12. \n.\n.\n\nMore info can be found here: https://docs.google.com/document/d/1LrYx_WwaimWyd3gfAg2rrQQsTH3wPkqkbp3_-PpmgEo/edit?usp=sharing\n\nAll existing dags had misspelled num_partitions_insert/upsert config. Have fixed it.\nIn all sample dags and config, \"timestamp\" is used as the partition path. But there was no field for source ordering. Infact same field \"timestamp\" was set as source ordering field. But for updates, we need a different field as source ordering field. so have introduced a new field called \"ts\" in source.avsc and have fixed config values appropriately.\nHave added some demo dag yamls for understanding ValidateDatasetNodes (cow-per-round-validate-once.yaml, cow-validate-cumulative-multiple-rounds.yaml, cow-per-round-mixed-validate.yaml)\nAdded preCombine field (set to \"ts\") in configs to be used while generating insert/update records. test suite sets this field's value to batchId. Since this will be used as source ordering field, we leverage batchId for monotonically increasing, so that its easy to reason about updates vs inserts(rather than generating random values).\nFixed TestSuitePathSelector which was comparing input directors as string rather than integers. And so, after batch9, batch10 wasn't getting returned from path selector.\n\nBrief change log\n\nAdded \"ValidateDatasetNode\" to compare entire input dataset to hudi content for equality.\nAdded two new configs to assist in long running test suite(--num-rounds, --delay-between-rounds-mins)\nAll existing dags had misspelled num_partitions_insert/upsert config. Have fixed it.\nIn all sample dags and config, \"timestamp\" is used as the partition path. But there was no field for source ordering. Infact same field \"timestamp\" was set as source ordering field. But for updates, we need a different field as source ordering field as we can't update the partition path. so have introduced a new field called \"ts\" in source.avsc and have fixed config values appropriately to be used as source ordering field.\nHave added some demo dag yamls for understanding ValidateDatasetNodes(cow-per-round-validate-once.yaml, cow-validate-cumulative-multiple-rounds.yaml, cow-per-round-mixed-validate.yaml)\nAdded preCombine field (set to \"ts\") in configs to be used while generating insert/update records. test suite sets this field's value to batchId. Since this will be used as source ordering field, we leverage batchId for monotonically increasing, so that its easy to reason about updates vs inserts(rather than generating random values).\nFixed TestSuitePathSelector which was comparing input directors as string rather than integers. And so, after batch9, batch10 wasn't getting returned from path selector.\n\nVerify this pull request\n(Please pick either of the following options)\n\nTested locally w/ test inputs in docker setup. These are the test variants verified.\nAll tests are done for both COW and MOR(real time). Validation is done by both spark datasource and hive table via spark sql engine.\na. one round\nb. multiple rounds by validating all data so far.\nc. multiple rounds w/ validation per round\n\nCommitter checklist\n\n\n[ x] Has a corresponding JIRA in PR title & commit\n\n\n Commit message is descriptive of the change\n\n\n CI is green\n\n\n[ x] Necessary doc changes done or have another open PR\n\n\n For large changes, please consider breaking it into sub-tasks under an umbrella JIRA.", "createdAt": "2020-10-11T04:05:07Z", "url": "https://github.com/apache/hudi/pull/2168", "merged": true, "mergeCommit": {"oid": "8cf6a7223f5fa6c2014a7351198ac6d1ebd26621"}, "closed": true, "closedAt": "2020-12-26T17:29:24Z", "author": {"login": "nsivabalan"}, "timelineItems": {"totalCount": 31, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpPPAAABdRXdwcAFqTUwNjE0MjI5Mg==", "endCursor": "Y3Vyc29yOnYyOpPPAAABdqAXINgFqTU1ODg4MzgzOA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTA2MTQyMjky", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-506142292", "createdAt": "2020-10-11T04:14:16Z", "commit": {"oid": "f7ba49cc8652da0c77da6af506af715740c127d5"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNDoxNDoxNlrOHfkURw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMC0xMVQwNDoxNDoxNlrOHfkURw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjg2MjkxOQ==", "bodyText": "as of now, I have kept it simple with thread.sleep. but open to ideas on how to add delays. Initially I thought we could schedule testsuitejob every time, but haven't thought through completely on whether we need a single test suite job to run and manage delays on its own or can we initiate a test suite job everytime from cron job kind of thing.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r502862919", "createdAt": "2020-10-11T04:14:16Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/DelayNode.java", "diffHunk": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Delay Node to add delays between each group of test runs.\n+ */\n+public class DelayNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+  private int delayMins;\n+\n+  public DelayNode(int delayMins) {\n+    this.delayMins = delayMins;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+    log.warn(\"Waiting for \"+ delayMins+\" mins before going for next test run\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f7ba49cc8652da0c77da6af506af715740c127d5"}, "originalPosition": 40}]}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "658f6e6a0c6466c60ebf717825568202d0786cab", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/658f6e6a0c6466c60ebf717825568202d0786cab", "committedDate": "2020-10-28T12:54:24Z", "message": "Adding hive table validation to ValidateDatasetNode"}, "afterCommit": {"oid": "9e50d66861aa789edc66507517386f63c011feaa", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/9e50d66861aa789edc66507517386f63c011feaa", "committedDate": "2020-10-28T13:01:31Z", "message": "Adding hive table validation to ValidateDatasetNode"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "9e50d66861aa789edc66507517386f63c011feaa", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/9e50d66861aa789edc66507517386f63c011feaa", "committedDate": "2020-10-28T13:01:31Z", "message": "Adding hive table validation to ValidateDatasetNode"}, "afterCommit": {"oid": "33d41db7ded16a4af924127b656ce80722bd7bf4", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/33d41db7ded16a4af924127b656ce80722bd7bf4", "committedDate": "2020-10-28T13:02:07Z", "message": "Adding hive table validation to ValidateDatasetNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "58227327470dac31c48430997dcc2e9a2d0a0291", "author": {"user": {"login": "lamberken", "name": "lamberken"}}, "url": "https://github.com/apache/hudi/commit/58227327470dac31c48430997dcc2e9a2d0a0291", "committedDate": "2020-11-03T23:54:46Z", "message": "trigger rebuild"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "1ed56f5d3b64debbca7397b2d5037cf6787a6cb0", "author": {"user": {"login": "linshan-ma", "name": null}}, "url": "https://github.com/apache/hudi/commit/1ed56f5d3b64debbca7397b2d5037cf6787a6cb0", "committedDate": "2020-11-03T23:54:46Z", "message": "[HUDI-1156] Remove unused dependencies from HoodieDeltaStreamerWrapper Class (#1927)"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "f8e4bba5b0a6bf35140463ba8271002083a04cee", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/f8e4bba5b0a6bf35140463ba8271002083a04cee", "committedDate": "2020-11-04T00:26:09Z", "message": "Adding support for validating records and long running tests in test sutie framework"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "45fd1bf484a5f556b87797bb611c21b26dea21b2", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/45fd1bf484a5f556b87797bb611c21b26dea21b2", "committedDate": "2020-11-04T00:26:13Z", "message": "Adding partial validate node"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "a4e765e48e99944dd495cea1e42f5a31ff7dd71e", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/a4e765e48e99944dd495cea1e42f5a31ff7dd71e", "committedDate": "2020-11-04T00:26:14Z", "message": "Fixing spark session initiation in Validate nodes"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8e3a63883c778b38b5f1cb16d042357118a3bb12", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/8e3a63883c778b38b5f1cb16d042357118a3bb12", "committedDate": "2020-11-04T01:21:28Z", "message": "Fixing validation"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "e4cd457cae554d5b4e84b1a481a79085320905a0", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/e4cd457cae554d5b4e84b1a481a79085320905a0", "committedDate": "2020-11-04T01:21:32Z", "message": "Adding hive table validation to ValidateDatasetNode"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "committedDate": "2020-11-04T05:17:31Z", "message": "Rebasing with latest commits from master"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "33d41db7ded16a4af924127b656ce80722bd7bf4", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/33d41db7ded16a4af924127b656ce80722bd7bf4", "committedDate": "2020-10-28T13:02:07Z", "message": "Adding hive table validation to ValidateDatasetNode"}, "afterCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b", "committedDate": "2020-11-04T05:17:31Z", "message": "Rebasing with latest commits from master"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NjYyMDc3", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526662077", "createdAt": "2020-11-09T21:18:34Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMToxODozNVrOHwB_MA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMToxODozNVrOHwB_MA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEyNjI1Ng==", "bodyText": "@nsivabalan why do we need 2 same yaml dags one for once and one for multiple ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520126256", "createdAt": "2020-11-09T21:18:35Z", "author": {"login": "n3nash"}, "path": "docker/demo/config/test-suite/cow-validate-cumulative-multiple-rounds.yaml", "diffHunk": "@@ -0,0 +1,59 @@\n+# Licensed to the Apache Software Foundation (ASF) under one", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 1}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NjYzMjky", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526663292", "createdAt": "2020-11-09T21:20:24Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMToyMDoyNFrOHwCDBA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMToyMDoyNFrOHwCDBA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEyNzIzNg==", "bodyText": "spark sql engine works with hive 1.x ? Have we tested it out ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520127236", "createdAt": "2020-11-09T21:20:24Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/README.md", "diffHunk": "@@ -267,3 +269,170 @@ spark-submit \\\n --table-type MERGE_ON_READ \\\n --compact-scheduling-minshare 1\n ``` \n+\n+For long running test suite, validation has to be done differently. Idea is to run same dag in a repeated manner. \n+Hence \"ValidateDatasetNode\" is introduced which will read entire input data and compare it with hudi contents both via \n+spark datasource and hive table via spark sql engine.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 36}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NjYzOTAy", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526663902", "createdAt": "2020-11-09T21:21:26Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMToyMToyN1rOHwCE2Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMToyMToyN1rOHwCE2Q==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEyNzcwNQ==", "bodyText": "What happens if the execution of one round takes more than 10 mins ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520127705", "createdAt": "2020-11-09T21:21:27Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/README.md", "diffHunk": "@@ -267,3 +269,170 @@ spark-submit \\\n --table-type MERGE_ON_READ \\\n --compact-scheduling-minshare 1\n ``` \n+\n+For long running test suite, validation has to be done differently. Idea is to run same dag in a repeated manner. \n+Hence \"ValidateDatasetNode\" is introduced which will read entire input data and compare it with hudi contents both via \n+spark datasource and hive table via spark sql engine.\n+\n+If you have \"ValidateDatasetNode\" in your dag, do not replace hive jars as instructed above. Spark sql engine does not \n+go well w/ hive2* jars. So, after running docker setup, just copy test.properties and your dag of interest and you are \n+good to go ahead. \n+\n+For repeated runs, two additional configs need to be set. \"--num-rounds N\" and \"--delay-between-rounds-mins Y\". \n+This means that your dag will be repeated for N times w/ a delay of Y mins between each round.\n+\n+Also, ValidateDatasetNode can be configured in two ways. Either with \"delete_input_data: true\" set or not set. \n+When \"delete_input_data\" is set for ValidateDatasetNode, once validation is complete, entire input data will be deleted. \n+So, suggestion is to use this ValidateDatasetNode as the last node in the dag with \"delete_input_data\". \n+Example dag: \n+```\n+     Insert\n+     Upsert\n+     ValidateDatasetNode with delete_input_data = true\n+```\n+\n+If above dag is run with \"--num-rounds 10 --delay-between-rounds-mins 10\", then this dag will run for 10 times with 10 ", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 55}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NjcwOTky", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526670992", "createdAt": "2020-11-09T21:32:04Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMTozMjowNFrOHwCbPA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMTozMjowNFrOHwCbPA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEzMzQzNg==", "bodyText": "@nsivabalan\nCan we avoid introducing these high level arguments numRound and delayMins to the dagScheduler ? This messes with a simpler design and adds unnecessary overloading to the constructor.\nInstead, we could do something like this\nIntroduce a top level yaml change around this\ndag_name:\ndag_rounds:\ndag_intermittent_delay:\ndag_props:\ndag_content:\ninsert_node:\n...\nupsert_node:\n...\nYou can then introduce a concept called RuntimeComposableDagNode that basically wraps this concept.\nLet me know.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520133436", "createdAt": "2020-11-09T21:32:04Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/HoodieTestSuiteJob.java", "diffHunk": "@@ -147,7 +147,7 @@ public void runTestSuite() {\n       long startTime = System.currentTimeMillis();\n       WriterContext writerContext = new WriterContext(jsc, props, cfg, keyGenerator, sparkSession);\n       writerContext.initContext(jsc);\n-      DagScheduler dagScheduler = new DagScheduler(workflowDag, writerContext);\n+      DagScheduler dagScheduler = new DagScheduler(workflowDag, writerContext, jsc, cfg.numRounds, cfg.delayMins);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 70}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NjcxNjc4", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526671678", "createdAt": "2020-11-09T21:33:07Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMTozMzowN1rOHwCdWQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMTozMzowN1rOHwCdWQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDEzMzk3Nw==", "bodyText": "Can you explain why we need to introduce these 2 fields ? Also, please comment why the preCombineFieldValue is \"int\" ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520133977", "createdAt": "2020-11-09T21:33:07Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/converter/UpdateConverter.java", "diffHunk": "@@ -35,19 +37,23 @@\n   private final List<String> partitionPathFields;\n   private final List<String> recordKeyFields;\n   private final int minPayloadSize;\n+  private final String preCombineField;\n+  private final int preCombineFieldValue;\n \n-  public UpdateConverter(String schemaStr, int minPayloadSize, List<String> partitionPathFields,\n-      List<String> recordKeyFields) {\n+  public  UpdateConverter(String schemaStr, int minPayloadSize, List<String> partitionPathFields,\n+      List<String> recordKeyFields, String preCombineField, int preCombineFieldValue) {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 27}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzA1NTU0", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526705554", "createdAt": "2020-11-09T22:27:02Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyNzowMlrOHwEGiA==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyNzowMlrOHwEGiA==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MDkwNA==", "bodyText": "This is problematic since we cannot test other types of partitioning. It's OK for now, can you add a TODO here ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520160904", "createdAt": "2020-11-09T22:27:02Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 68}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzA1Nzcx", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526705771", "createdAt": "2020-11-09T22:27:23Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyNzoyM1rOHwEHRQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyNzoyM1rOHwEHRQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MTA5Mw==", "bodyText": "There should be a config for inputBasePath ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520161093", "createdAt": "2020-11-09T22:27:23Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 71}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzA2MjAx", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526706201", "createdAt": "2020-11-09T22:28:04Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyODowNVrOHwEIlQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyODowNVrOHwEIlQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MTQyOQ==", "bodyText": "Can you make this \"TODO\" ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520161429", "createdAt": "2020-11-09T22:28:05Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    // fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 80}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzA2OTY1", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526706965", "createdAt": "2020-11-09T22:29:30Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyOTozMFrOHwELCQ==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyOTozMFrOHwELCQ==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MjA1Nw==", "bodyText": "Can we take the database names and table names from config ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520162057", "createdAt": "2020-11-09T22:29:30Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    // fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.\n+    Dataset<Row> inputDf = session.read().format(\"avro\").load(inputPath);\n+    ExpressionEncoder encoder = getEncoder(inputDf.schema());\n+    Dataset<Row> inputSnapshotDf = inputDf.groupByKey(\n+        (MapFunction<Row, String>) value -> value.getAs(\"timestamp\") + \"+\" + value.getAs(\"_row_key\"), Encoders.STRING())\n+        .reduceGroups((ReduceFunction<Row>) (v1, v2) -> {\n+          long ts1 = v1.getAs(\"ts\");\n+          long ts2 = v2.getAs(\"ts\");\n+          if (ts1 > ts2) {\n+            return v1;\n+          } else {\n+            return v2;\n+          }\n+        })\n+        .map((MapFunction<Tuple2<String, Row>, Row>) value -> value._2, encoder);\n+\n+    // read from hudi and remove meta columns.\n+    Dataset<Row> hudiDf = session.read().format(\"hudi\").load(hudiPath);\n+    Dataset<Row> trimmedDf = hudiDf.drop(HoodieRecord.COMMIT_TIME_METADATA_FIELD).drop(HoodieRecord.COMMIT_SEQNO_METADATA_FIELD).drop(HoodieRecord.RECORD_KEY_METADATA_FIELD)\n+        .drop(HoodieRecord.PARTITION_PATH_METADATA_FIELD).drop(HoodieRecord.FILENAME_METADATA_FIELD);\n+\n+    Dataset<Row> intersectionDf = inputSnapshotDf.intersect(trimmedDf);\n+    // the intersected df should be same as inputDf. if not, there is some mismatch.\n+    if (inputSnapshotDf.except(intersectionDf).count() != 0) {\n+      log.error(\"Data set validation failed. Total count in hudi \" + trimmedDf.count() + \", input df count \" + inputSnapshotDf.count());\n+      throw new AssertionError(\"Hudi contents does not match contents input data. \");\n+    } \n+\n+    log.warn(\"Validating hive table \");\n+    Dataset<Row> cowDf = session.sql(\"SELECT * FROM testdb.table1\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 109}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzA3MDUx", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526707051", "createdAt": "2020-11-09T22:29:41Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyOTo0MVrOHwELUw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0wOVQyMjoyOTo0MVrOHwELUw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDE2MjEzMQ==", "bodyText": "Same comment here", "url": "https://github.com/apache/hudi/pull/2168#discussion_r520162131", "createdAt": "2020-11-09T22:29:41Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    // fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.\n+    Dataset<Row> inputDf = session.read().format(\"avro\").load(inputPath);\n+    ExpressionEncoder encoder = getEncoder(inputDf.schema());\n+    Dataset<Row> inputSnapshotDf = inputDf.groupByKey(\n+        (MapFunction<Row, String>) value -> value.getAs(\"timestamp\") + \"+\" + value.getAs(\"_row_key\"), Encoders.STRING())\n+        .reduceGroups((ReduceFunction<Row>) (v1, v2) -> {\n+          long ts1 = v1.getAs(\"ts\");\n+          long ts2 = v2.getAs(\"ts\");\n+          if (ts1 > ts2) {\n+            return v1;\n+          } else {\n+            return v2;\n+          }\n+        })\n+        .map((MapFunction<Tuple2<String, Row>, Row>) value -> value._2, encoder);\n+\n+    // read from hudi and remove meta columns.\n+    Dataset<Row> hudiDf = session.read().format(\"hudi\").load(hudiPath);\n+    Dataset<Row> trimmedDf = hudiDf.drop(HoodieRecord.COMMIT_TIME_METADATA_FIELD).drop(HoodieRecord.COMMIT_SEQNO_METADATA_FIELD).drop(HoodieRecord.RECORD_KEY_METADATA_FIELD)\n+        .drop(HoodieRecord.PARTITION_PATH_METADATA_FIELD).drop(HoodieRecord.FILENAME_METADATA_FIELD);\n+\n+    Dataset<Row> intersectionDf = inputSnapshotDf.intersect(trimmedDf);\n+    // the intersected df should be same as inputDf. if not, there is some mismatch.\n+    if (inputSnapshotDf.except(intersectionDf).count() != 0) {\n+      log.error(\"Data set validation failed. Total count in hudi \" + trimmedDf.count() + \", input df count \" + inputSnapshotDf.count());\n+      throw new AssertionError(\"Hudi contents does not match contents input data. \");\n+    } \n+\n+    log.warn(\"Validating hive table \");\n+    Dataset<Row> cowDf = session.sql(\"SELECT * FROM testdb.table1\");\n+    Dataset<Row> trimmedCowDf = cowDf.drop(HoodieRecord.COMMIT_TIME_METADATA_FIELD).drop(HoodieRecord.COMMIT_SEQNO_METADATA_FIELD).drop(HoodieRecord.RECORD_KEY_METADATA_FIELD)\n+        .drop(HoodieRecord.PARTITION_PATH_METADATA_FIELD).drop(HoodieRecord.FILENAME_METADATA_FIELD);\n+    intersectionDf = inputSnapshotDf.intersect(trimmedDf);\n+    // the intersected df should be same as inputDf. if not, there is some mismatch.\n+    if (inputSnapshotDf.except(intersectionDf).count() != 0) {\n+      log.error(\"Data set validation failed for COW hive table. Total count in hudi \" + trimmedCowDf.count() + \", input df count \" + inputSnapshotDf.count());\n+      throw new AssertionError(\"Hudi hive table contents does not match contents input data. \");\n+    }\n+\n+    // if delete input data is enabled, erase input data.\n+    if (config.isDeleteInputData()) {\n+      // clean up input data for current group of writes.\n+      inputPathStr = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/../input/\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "originalPosition": 122}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTI2NzA3MzIz", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-526707323", "createdAt": "2020-11-09T22:30:08Z", "commit": {"oid": "8feb5a0995ba602ca5042a0fb7ed0f68dc251f4b"}, "state": "CHANGES_REQUESTED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "b6c466f6cfc8a1c3852eb80a82a65c2c695f37ec", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/b6c466f6cfc8a1c3852eb80a82a65c2c695f37ec", "committedDate": "2020-11-21T19:21:29Z", "message": "Addressing feedback"}, "afterCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/f91cb6a43c1d6c98d50715fdfef5e9696614033d", "committedDate": "2020-11-21T19:34:34Z", "message": "Addressing feedback"}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bb66e344ded7f737da619f08f23efce9e3409fa0", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/bb66e344ded7f737da619f08f23efce9e3409fa0", "committedDate": "2020-11-21T19:58:55Z", "message": "Addressing feedback"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/f91cb6a43c1d6c98d50715fdfef5e9696614033d", "committedDate": "2020-11-21T19:34:34Z", "message": "Addressing feedback"}, "afterCommit": {"oid": "bb66e344ded7f737da619f08f23efce9e3409fa0", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/bb66e344ded7f737da619f08f23efce9e3409fa0", "committedDate": "2020-11-21T19:58:55Z", "message": "Addressing feedback"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM2MDAzNjU3", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-536003657", "createdAt": "2020-11-21T19:36:10Z", "commit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "state": "COMMENTED", "comments": {"totalCount": 12, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQxOTozNjoxMFrOH3w26Q==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMS0yMVQyMDowMTowMVrOH3xAZg==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDIxNw==", "bodyText": "I haven't fixed these dags yet for long running test-suite. Once we have consensus that things are looking good, I will update all dags. Do check unit test dags under resources dir in hudi-integ-test module for updated version.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234217", "createdAt": "2020-11-21T19:36:10Z", "author": {"login": "nsivabalan"}, "path": "docker/demo/config/test-suite/cow-per-round-mixed-validate.yaml", "diffHunk": "@@ -0,0 +1,65 @@\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#      http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+\n+first_insert:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 17}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDM2MA==", "bodyText": "as per our discussion, I have added this new field from within the code. So essentially this field will be appended to both source schema and target schema and will be used for source ordering. batch_id is used as values.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234360", "createdAt": "2020-11-21T19:37:31Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/README.md", "diffHunk": "@@ -214,7 +216,7 @@ spark-submit \\\n --conf spark.sql.catalogImplementation=hive \\\n --class org.apache.hudi.integ.testsuite.HoodieTestSuiteJob \\\n /opt/hudi-integ-test-bundle-0.6.1-SNAPSHOT.jar \\\n---source-ordering-field timestamp \\\n+--source-ordering-field test_suite_source_ordering_field \\", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 16}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDQxOA==", "bodyText": "high level config param parsing.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234418", "createdAt": "2020-11-21T19:38:19Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/DagUtils.java", "diffHunk": "@@ -62,15 +71,38 @@ public static WorkflowDag convertYamlPathToDag(FileSystem fs, String path) throw\n    * Converts a YAML representation to {@link WorkflowDag}.\n    */\n   public static WorkflowDag convertYamlToDag(String yaml) throws IOException {\n+    int dagRounds = DEFAULT_DAG_ROUNDS;\n+    int intermittentDelayMins = DEFAULT_INTERMITTENT_DELAY_MINS;\n+    String dagName = DEFAULT_DAG_NAME;\n     Map<String, DagNode> allNodes = new HashMap<>();\n     final ObjectMapper yamlReader = new ObjectMapper(new YAMLFactory());\n     final JsonNode jsonNode = yamlReader.readTree(yaml);\n     Iterator<Entry<String, JsonNode>> itr = jsonNode.fields();\n     while (itr.hasNext()) {\n       Entry<String, JsonNode> dagNode = itr.next();\n-      allNodes.put(dagNode.getKey(), convertJsonToDagNode(allNodes, dagNode.getKey(), dagNode.getValue()));\n+      String key = dagNode.getKey();\n+      switch (key) {\n+        case DAG_NAME:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 32}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDQ1Ng==", "bodyText": "as agreed, all node contents go into \"dag_content\"", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234456", "createdAt": "2020-11-21T19:38:45Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/DagUtils.java", "diffHunk": "@@ -62,15 +71,38 @@ public static WorkflowDag convertYamlPathToDag(FileSystem fs, String path) throw\n    * Converts a YAML representation to {@link WorkflowDag}.\n    */\n   public static WorkflowDag convertYamlToDag(String yaml) throws IOException {\n+    int dagRounds = DEFAULT_DAG_ROUNDS;\n+    int intermittentDelayMins = DEFAULT_INTERMITTENT_DELAY_MINS;\n+    String dagName = DEFAULT_DAG_NAME;\n     Map<String, DagNode> allNodes = new HashMap<>();\n     final ObjectMapper yamlReader = new ObjectMapper(new YAMLFactory());\n     final JsonNode jsonNode = yamlReader.readTree(yaml);\n     Iterator<Entry<String, JsonNode>> itr = jsonNode.fields();\n     while (itr.hasNext()) {\n       Entry<String, JsonNode> dagNode = itr.next();\n-      allNodes.put(dagNode.getKey(), convertJsonToDagNode(allNodes, dagNode.getKey(), dagNode.getValue()));\n+      String key = dagNode.getKey();\n+      switch (key) {\n+        case DAG_NAME:\n+          dagName = dagNode.getValue().asText();\n+          break;\n+        case DAG_ROUNDS:\n+          dagRounds = dagNode.getValue().asInt();\n+          break;\n+        case DAG_INTERMITTENT_DELAY_MINS:\n+          intermittentDelayMins = dagNode.getValue().asInt();\n+          break;\n+        case DAG_CONTENT:", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDYzMA==", "bodyText": "may I know where or how to fetch the record key and partition path field. I don't see any thing exposed in deltastreamer config. as of now, I am hardcoding it here.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234630", "createdAt": "2020-11-21T19:40:14Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+import org.apache.hudi.integ.testsuite.schema.SchemaUtils;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    // todo: Fix partitioning schemes. For now, assumes data based partitioning.\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().inputBasePath;\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    // todo: fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.\n+    Dataset<Row> inputDf = session.read().format(\"avro\").load(inputPath);\n+    ExpressionEncoder encoder = getEncoder(inputDf.schema());\n+    Dataset<Row> inputSnapshotDf = inputDf.groupByKey(\n+        (MapFunction<Row, String>) value -> value.getAs(\"timestamp\") + \"+\" + value.getAs(\"_row_key\"), Encoders.STRING())", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 86}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDc2MQ==", "bodyText": "I didn't make a whole lot of change from last time. I exposed the global params in workflowDag and using it wherever required. like rounds, delay etc. Felt this is simple and achieves our goal.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234761", "createdAt": "2020-11-21T19:41:38Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/scheduler/DagScheduler.java", "diffHunk": "@@ -77,33 +79,47 @@ public void schedule() throws Exception {\n    * Method to start executing the nodes in workflow DAGs.\n    *\n    * @param service ExecutorService\n-   * @param nodes Nodes to be executed\n+   * @param workflowDag instance of workflow dag that needs to be executed\n    * @throws Exception will be thrown if ant error occurred\n    */\n-  private void execute(ExecutorService service, List<DagNode> nodes) throws Exception {\n+  private void execute(ExecutorService service, WorkflowDag workflowDag) throws Exception {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 41}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNDk2MA==", "bodyText": "Added this schemaProvider to append the source ordering field to source and target schema.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528234960", "createdAt": "2020-11-21T19:44:20Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/schema/TestSuiteFileBasedSchemaProvider.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.schema;\n+\n+import org.apache.hudi.common.config.TypedProperties;\n+import org.apache.hudi.integ.testsuite.dag.WriterContext;\n+import org.apache.hudi.utilities.schema.FilebasedSchemaProvider;\n+\n+import org.apache.avro.Schema;\n+import org.apache.avro.Schema.Field;\n+import org.apache.avro.Schema.Type;\n+import org.apache.log4j.LogManager;\n+import org.apache.log4j.Logger;\n+import org.apache.spark.api.java.JavaSparkContext;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class TestSuiteFileBasedSchemaProvider extends FilebasedSchemaProvider {", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNTAyMA==", "bodyText": "this is where the source ordering field is set.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528235020", "createdAt": "2020-11-21T19:44:44Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/writer/DFSDeltaWriterAdapter.java", "diffHunk": "@@ -30,22 +32,29 @@\n  */\n public class DFSDeltaWriterAdapter implements DeltaWriterAdapter<GenericRecord> {\n \n-  private DeltaInputWriter deltaInputGenerator;\n+  private DeltaInputWriter deltaInputWriter;\n   private List<DeltaWriteStats> metrics = new ArrayList<>();\n+  private int preCombineFieldVal = 0;\n+\n+  public DFSDeltaWriterAdapter(DeltaInputWriter<GenericRecord> deltaInputWriter, int preCombineFieldVal) {\n+    this.deltaInputWriter = deltaInputWriter;\n+    this.preCombineFieldVal = preCombineFieldVal;\n+  }\n \n-  public DFSDeltaWriterAdapter(DeltaInputWriter<GenericRecord> deltaInputGenerator) {\n-    this.deltaInputGenerator = deltaInputGenerator;\n+  public DFSDeltaWriterAdapter(DeltaInputWriter<GenericRecord> deltaInputWriter) {\n+    this.deltaInputWriter = deltaInputWriter;\n   }\n \n   @Override\n   public List<DeltaWriteStats> write(Iterator<GenericRecord> input) throws IOException {\n     while (input.hasNext()) {\n       GenericRecord next = input.next();\n-      if (this.deltaInputGenerator.canWrite()) {\n-        this.deltaInputGenerator.writeData(next);\n-      } else if (input.hasNext()) {\n+      next.put(SchemaUtils.SOURCE_ORDERING_FIELD, preCombineFieldVal);", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 36}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNTEyOA==", "bodyText": "Here is the example of how the dag looks like w/ global params. I have tested this dag for few rounds of validation.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528235128", "createdAt": "2020-11-21T19:45:38Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/test/resources/unit-test-cow-dag.yaml", "diffHunk": "@@ -13,58 +13,62 @@\n # WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n # See the License for the specific language governing permissions and\n # limitations under the License.\n-first_insert:\n-  config:\n-    record_size: 70000\n-    num_partitions_insert: 1\n-    repeat_count: 2\n-    num_records_insert: 100\n-  type: InsertNode\n-  deps: none\n-second_insert:\n-  config:\n-    record_size: 70000\n-    num_partitions_insert: 1\n-    repeat_count: 1\n-    num_records_insert: 100\n-  type: InsertNode\n-  deps: first_insert\n-first_rollback:\n-  config:\n-  deps: second_insert\n-  type: RollbackNode\n-third_insert:\n-  config:\n-    record_size: 70000\n-    num_partitions_insert: 1\n-    repeat_count: 1\n-    num_records_insert: 100\n-  type: InsertNode\n-  deps: first_rollback\n-first_upsert:\n-  config:\n-    record_size: 70000\n-    num_partitions_upsert: 1\n-    repeat_count: 1\n-    num_records_upsert: 100\n-  type: UpsertNode\n-  deps: third_insert\n-first_hive_sync:\n-  config:\n-    queue_name: \"adhoc\"\n-    engine: \"mr\"\n-  type: HiveSyncNode\n-  deps: first_upsert\n-first_hive_query:\n-  config:\n-    hive_props:\n-      prop2: \"set spark.yarn.queue=\"\n-      prop3: \"set hive.strict.checks.large.query=false\"\n-      prop4: \"set hive.stats.autogather=false\"\n-    hive_queries:\n-      query1: \"select count(*) from testdb1.table1\"\n-      result1: 300\n-      query2: \"select count(*) from testdb1.table1 group   by `_row_key` having count(*) > 1\"\n-      result2: 0\n-  type: HiveQueryNode\n-  deps: first_hive_sync\n\\ No newline at end of file\n+dag_name: unit-test-cow-dag", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 60}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNTIwMA==", "bodyText": "since I am introducing a test schema provider to append source ordering field, I had to make this protected since the test schema provider extends from this.", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528235200", "createdAt": "2020-11-21T19:46:25Z", "author": {"login": "nsivabalan"}, "path": "hudi-utilities/src/main/java/org/apache/hudi/utilities/schema/FilebasedSchemaProvider.java", "diffHunk": "@@ -46,9 +46,9 @@\n \n   private final FileSystem fs;\n \n-  private final Schema sourceSchema;\n+  protected Schema sourceSchema;", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "f91cb6a43c1d6c98d50715fdfef5e9696614033d"}, "originalPosition": 5}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNjYwNQ==", "bodyText": "is this the right way to fetch record key and partition path field ?", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528236605", "createdAt": "2020-11-21T20:00:30Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+import org.apache.hudi.integ.testsuite.schema.SchemaUtils;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    // todo: Fix partitioning schemes. For now, assumes data based partitioning.\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().inputBasePath;\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    String recordKeyField = context.getWriterContext().getProps().getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY());", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb66e344ded7f737da619f08f23efce9e3409fa0"}, "originalPosition": 82}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODIzNjY0Ng==", "bodyText": "again, couldn't find a better way to fetch db and table name. LMK if there are other better ways", "url": "https://github.com/apache/hudi/pull/2168#discussion_r528236646", "createdAt": "2020-11-21T20:01:01Z", "author": {"login": "nsivabalan"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/nodes/ValidateDatasetNode.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.hudi.integ.testsuite.dag.nodes;\n+\n+import org.apache.hudi.DataSourceWriteOptions;\n+import org.apache.hudi.common.model.HoodieRecord;\n+import org.apache.hudi.integ.testsuite.configuration.DeltaConfig.Config;\n+import org.apache.hudi.integ.testsuite.dag.ExecutionContext;\n+import org.apache.hudi.integ.testsuite.schema.SchemaUtils;\n+\n+import org.apache.hadoop.fs.FileStatus;\n+import org.apache.hadoop.fs.FileSystem;\n+import org.apache.hadoop.fs.Path;\n+import org.apache.spark.api.java.function.MapFunction;\n+import org.apache.spark.api.java.function.ReduceFunction;\n+import org.apache.spark.sql.Dataset;\n+import org.apache.spark.sql.Encoders;\n+import org.apache.spark.sql.Row;\n+import org.apache.spark.sql.SparkSession;\n+import org.apache.spark.sql.catalyst.analysis.SimpleAnalyzer$;\n+import org.apache.spark.sql.catalyst.encoders.ExpressionEncoder;\n+import org.apache.spark.sql.catalyst.encoders.RowEncoder;\n+import org.apache.spark.sql.catalyst.expressions.Attribute;\n+import org.apache.spark.sql.types.StructType;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.JavaConverters;\n+\n+/**\n+ * This nodes validates contents from input path are in tact with Hudi. This nodes uses spark datasource for comparison purposes. By default no configs are required for this node. But there is an\n+ * optional config \"delete_input_data\" that you can set for this node. If set, once validation completes, contents from inputPath are deleted. This will come in handy for long running test suites.\n+ * README has more details under docker set up for usages of this node.\n+ */\n+public class ValidateDatasetNode extends DagNode<Boolean> {\n+\n+  private static Logger log = LoggerFactory.getLogger(ValidateDatasetNode.class);\n+\n+  public ValidateDatasetNode(Config config) {\n+    this.config = config;\n+  }\n+\n+  @Override\n+  public void execute(ExecutionContext context) throws Exception {\n+\n+    SparkSession session = SparkSession.builder().sparkContext(context.getJsc().sc()).getOrCreate();\n+\n+    // todo: Fix partitioning schemes. For now, assumes data based partitioning.\n+    String inputPath = context.getHoodieTestSuiteWriter().getCfg().inputBasePath + \"/*/*\";\n+    String hudiPath = context.getHoodieTestSuiteWriter().getCfg().targetBasePath + \"/*/*/*\";\n+    log.warn(\"ValidateDataset Node: Input path \" + inputPath + \", hudi path \" + hudiPath);\n+    // listing batches to be validated\n+    String inputPathStr = context.getHoodieTestSuiteWriter().getCfg().inputBasePath;\n+    FileSystem fs = new Path(inputPathStr)\n+        .getFileSystem(context.getHoodieTestSuiteWriter().getConfiguration());\n+    FileStatus[] fileStatuses = fs.listStatus(new Path(inputPathStr));\n+    for (FileStatus fileStatus : fileStatuses) {\n+      log.debug(\"Listing all Micro batches to be validated :: \" + fileStatus.getPath().toString());\n+    }\n+\n+    String recordKeyField = context.getWriterContext().getProps().getString(DataSourceWriteOptions.RECORDKEY_FIELD_OPT_KEY());\n+    String partitionPathField = context.getWriterContext().getProps().getString(DataSourceWriteOptions.PARTITIONPATH_FIELD_OPT_KEY());\n+    // todo: fix hard coded fields from configs.\n+    // read input and resolve insert, updates, etc.\n+    Dataset<Row> inputDf = session.read().format(\"avro\").load(inputPath);\n+    ExpressionEncoder encoder = getEncoder(inputDf.schema());\n+    Dataset<Row> inputSnapshotDf = inputDf.groupByKey(\n+        (MapFunction<Row, String>) value -> partitionPathField + \"+\" + recordKeyField, Encoders.STRING())\n+        .reduceGroups((ReduceFunction<Row>) (v1, v2) -> {\n+          int ts1 = v1.getAs(SchemaUtils.SOURCE_ORDERING_FIELD);\n+          int ts2 = v2.getAs(SchemaUtils.SOURCE_ORDERING_FIELD);\n+          if (ts1 > ts2) {\n+            return v1;\n+          } else {\n+            return v2;\n+          }\n+        })\n+        .map((MapFunction<Tuple2<String, Row>, Row>) value -> value._2, encoder);\n+\n+    // read from hudi and remove meta columns.\n+    Dataset<Row> hudiDf = session.read().format(\"hudi\").load(hudiPath);\n+    Dataset<Row> trimmedDf = hudiDf.drop(HoodieRecord.COMMIT_TIME_METADATA_FIELD).drop(HoodieRecord.COMMIT_SEQNO_METADATA_FIELD).drop(HoodieRecord.RECORD_KEY_METADATA_FIELD)\n+        .drop(HoodieRecord.PARTITION_PATH_METADATA_FIELD).drop(HoodieRecord.FILENAME_METADATA_FIELD);\n+\n+    Dataset<Row> intersectionDf = inputSnapshotDf.intersect(trimmedDf);\n+    // the intersected df should be same as inputDf. if not, there is some mismatch.\n+    if (inputSnapshotDf.except(intersectionDf).count() != 0) {\n+      log.error(\"Data set validation failed. Total count in hudi \" + trimmedDf.count() + \", input df count \" + inputSnapshotDf.count());\n+      throw new AssertionError(\"Hudi contents does not match contents input data. \");\n+    }\n+\n+    String database = context.getWriterContext().getProps().getString(\"hoodie.datasource.hive_sync.database\");\n+    String tableName = context.getWriterContext().getProps().getString(\"hoodie.datasource.hive_sync.table\");", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb66e344ded7f737da619f08f23efce9e3409fa0"}, "originalPosition": 114}]}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ3NjY0ODM5", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-547664839", "createdAt": "2020-12-08T21:55:17Z", "commit": {"oid": "bb66e344ded7f737da619f08f23efce9e3409fa0"}, "state": "COMMENTED", "comments": {"totalCount": 1, "pageInfo": {"startCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMTo1NToxN1rOIB39jw==", "endCursor": "Y3Vyc29yOnYyOpK0MjAyMC0xMi0wOFQyMTo1NToxN1rOIB39jw==", "hasNextPage": false, "hasPreviousPage": false}, "nodes": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODgzNjM2Nw==", "bodyText": "The name can be in caps (TestDagName), no need for camecasing..", "url": "https://github.com/apache/hudi/pull/2168#discussion_r538836367", "createdAt": "2020-12-08T21:55:17Z", "author": {"login": "n3nash"}, "path": "hudi-integ-test/src/main/java/org/apache/hudi/integ/testsuite/dag/DagUtils.java", "diffHunk": "@@ -48,6 +48,15 @@\n  */\n public class DagUtils {\n \n+  public static final String DAG_NAME = \"dag_name\";\n+  public static final String DAG_ROUNDS = \"dag_rounds\";\n+  public static final String DAG_INTERMITTENT_DELAY_MINS = \"dag_intermittent_delay_mins\";\n+  public static final String DAG_CONTENT = \"dag_content\";\n+\n+  public static int DEFAULT_DAG_ROUNDS = 1;\n+  public static int DEFAULT_INTERMITTENT_DELAY_MINS = 10;\n+  public static String DEFAULT_DAG_NAME = \"testDagName\";", "state": "SUBMITTED", "replyTo": null, "originalCommit": {"oid": "bb66e344ded7f737da619f08f23efce9e3409fa0"}, "originalPosition": 11}]}}, {"__typename": "PullRequestCommit", "commit": {"oid": "bc2ff513c06431641c1e14bf4263c2c118b4500e", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/bc2ff513c06431641c1e14bf4263c2c118b4500e", "committedDate": "2020-12-18T07:01:47Z", "message": "Addressing comments"}}, {"__typename": "HeadRefForcePushedEvent", "beforeCommit": {"oid": "e6f76b0f7a7fe8f73f7b1a396cf0a2957965a492", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/e6f76b0f7a7fe8f73f7b1a396cf0a2957965a492", "committedDate": "2020-12-17T23:39:27Z", "message": "Addressing comments"}, "afterCommit": {"oid": "bc2ff513c06431641c1e14bf4263c2c118b4500e", "author": {"user": {"login": "nsivabalan", "name": "Sivabalan Narayanan"}}, "url": "https://github.com/apache/hudi/commit/bc2ff513c06431641c1e14bf4263c2c118b4500e", "committedDate": "2020-12-18T07:01:47Z", "message": "Addressing comments"}}, {"__typename": "PullRequestReview", "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTU4ODgzODM4", "url": "https://github.com/apache/hudi/pull/2168#pullrequestreview-558883838", "createdAt": "2020-12-26T17:27:19Z", "commit": {"oid": "bc2ff513c06431641c1e14bf4263c2c118b4500e"}, "state": "APPROVED", "comments": {"totalCount": 0, "pageInfo": {"startCursor": null, "endCursor": null, "hasNextPage": false, "hasPreviousPage": false}, "nodes": []}}]}}}, "rateLimit": {"limit": 5000, "remaining": 4158, "cost": 1, "resetAt": "2021-10-28T17:48:14Z"}}}